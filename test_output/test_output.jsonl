{"input": "To generate the given HLS codes in C, use the following natural language instructions for specific #pragma values:\n\n1. **Treat the following function as a hardware kernel for acceleration**\n   - Description: Specify the function as a hardware kernel for acceleration\n   - HLS Code: `#pragma ACCEL kernel`\n\n2. **Don't automatically pipeline this loop**\n   - Description: Disable automatic loop pipelining\n   - HLS Code: `#pragma ACCEL PIPELINE \"off\"`\n\n3. **Process this loop in its original, full form without breaking it into smaller chunks**\n   - Description: Set tile factor to 1 to process loop in its original form\n   - HLS Code: `#pragma ACCEL TILE FACTOR=1`\n\n4. **Run the iterations of this loop one after the other, not in parallel**\n   - Description: Set parallel factor to 1 to run loop iterations sequentially\n   - HLS Code: `#pragma ACCEL PARALLEL FACTOR=1`\n\nThese natural language instructions can be used to generate the HLS codes for the given C function.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1 * i;\n        int j_col = j + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_col][j] - ex[i][j] + ey[i][j_col] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": " The following is the HLS code generated by ACCEL.\n\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "3": " The generated kernel can be compiled and run on ALTERA FPGA board.\n", "4": "\n#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{7}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To generate the given HLS codes:\n\n- Apply automatic pipeline optimization to the loop.\n- Set the tile factor to 'auto' so that the loop is processed in its original, full form without breaking it into smaller chunks.\n- Set the parallel factor to 'auto{2}' for the outer loop and 'auto{1}' for the first inner loop, and 'auto{8}' for the second inner loop.\n- Treat the function 'kernel_jacobi_1d' as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n \n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n \n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n \n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n \n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n \n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To generate the given HLS codes, apply the following natural language instructions:\n\n1. Use automatic pipelining for the loop.\n2. Apply tiling with an automatic factor of 1 to the loop.\n3. Parallelize the loop with an automatic factor of 2.\n4. Apply parallelization with an automatic factor of 2 to the inner loop.\n5. Further parallelize the loop with an automatic factor of 10.\n\nThese instructions correspond to the given HLS pragmas in the C code.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L4}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{_auto_pipeline_0}\n  \n#pragma ACCEL TILE FACTOR=auto{_auto_tile_0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{_auto_parallel_0}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PIPELINE auto{_auto_pipeline_1}\n    \n#pragma ACCEL TILE FACTOR=auto{_auto_tile_1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{_auto_parallel_1}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L2}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{10}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{25}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 3 1;\n        B[i] = 0.33333 * (A[i] + A[i - 1] + A[i + 1]);\n      }\n    }\n    \n#pragma endscop\n//#pragma endscop\n}\n"}}
{"input": "To generate the given HLS codes in C, utilize the following concise natural language instructions for specific #pragma values:\n\n- To turn off automatic loop pipelining: \"Disable automatic loop pipelining\"\n- To set the tile factor to 1 for original loop processing: \"Use a tile factor of 1 for loop processing\"\n- To run loop iterations in parallel with a factor of 2: \"Execute loop iterations in parallel with a factor of 2\"\n- To designate the function as a hardware acceleration kernel: \"Designate the following function as a hardware kernel for acceleration\"\n\nOnce implemented with these instructions in mind, the HLS codes when written in C, will execute the desired functionalities.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L8}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "1": "\n\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": "\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_up = i + 1;\n        int j_up = j + 1;\n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7_0}\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_up][j] - ex[i][j]) - 0.7 * (ey[i][j_up] - ey[i][j]) + 1.0 * (tz[i][j] - tz[i][j_up]);\n      }\n    }\n  }\n}\n"}}
{"input": "Generate HLS code with the following natural language instruction:\n\"Mark this function as a hardware kernel for acceleration, pipeline the outer loop automatically, tile the loop with a factor of 1 automatically, and parallelize the loops with a factor of 2 and 6 respectively.\"", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 38; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 3{\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n  }\n//#pragma endscop\n}\n2; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (i = 1; i < 119; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 119; i++) ", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction=D FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 3B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n  }\n//#pragma endscop\n}\n2; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (i = 1; i < 119; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (i = 1; i < 119; i++) {\n      "}}
{"input": "To generate the given HLS codes in C, use the following pragma values:\n\n1. Treat the following function as a hardware kernel for acceleration: `#pragma ACCEL kernel`\n\n2. Don't automatically pipeline this loop: `#pragma ACCEL PIPELINE \"off\"`\n\n3. Process this loop in its original, full form without breaking it into smaller chunks: `#pragma ACCEL TILE FACTOR=1`\n\n4. Run the iterations of this loop one after the other, not in parallel: `#pragma ACCEL PARALLEL FACTOR=1`", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n5. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PARALLEL FACTOR=auto{1}`\n\n6. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PIPELINE auto{off}`\n\n7. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}`\n\n8. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L2}`\n\n9. Do not apply any automatic parallelization for this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L2}`\n\n10. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}`\n\n11. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L3}`\n\n12. Do not apply any automatic parallelization for this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L3}`\n\n13. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}`\n\n14. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L4}`\n\n15. Do not apply any automatic parallelization for this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L4}`\n\n16. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}`\n\n17. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L5}`\n\n18. Do not apply any automatic parallelization for this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L5}`\n\n19. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}`\n\n20. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L6}`\n\n21. Do not apply any automatic parallelization for this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L6}`\n\n22. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}`\n\n23. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L7}`\n\n24. Do not apply any automatic parallelization for this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L7}`\n\n25. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}`\n\n26. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L8}`\n\n27. Do not apply any automatic parallelization for this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L8}`\n\n28. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}`\n\n29. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L9}`\n\n30. Do not apply any automatic parallelization for this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L9}`\n\n31. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L10}`\n\n32. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L10}`\n\n33. Do not apply any automatic parallelization for this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L10}`\n\n34. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L11}`\n\n35. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L11}`\n\n36. Do not apply any automatic parallelization for this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L11}`\n\n37. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L12}`\n\n38. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L12}`\n\n39. Do not apply any automatic parallelization for this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L12}`\n\n40. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L13}`\n\n41. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L13}`\n\n42. Do not apply any automatic parallelization for this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L13}`\n\n43. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L14}`\n\n44. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L14}`\n\n45. Do not apply any automatic parallelization for this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L14}`\n\n46. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L15}`\n\n47. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L15}`\n\n48. Do not apply any automatic parallelization for this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L15}`\n\n49. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L16}`\n\n50. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L16}`\n\n51. Do not apply any automatic parallelization for this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L16}`\n\n52. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L17}`\n\n53. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L17}`\n\n54. Do not apply any automatic parallelization for this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L17}`\n\n55. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L18}`\n\n56. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L18}`\n\n57. Do not apply any automatic parallelization for this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L18}`\n\n58. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L19}`\n\n59. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L19}`\n\n60. Do not apply any automatic parallelization for this loop: `#pragma", "1": "\n\n5. Don't automatically distribute this loop: `#pragma ACCEL DISTRIBUTE FACTOR=1`\n\n6. Do not target a particular device. The default target is the CPU:\n```\n #pragma ACCEL device\n\n```\n", "2": "\n\n5. Automatically pick loop transformation: \n\n   #pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n\n6. Automatically pick loop transformation: \n\n   #pragma ACCEL PIPELINE auto{__PIPE__L1}\n\n7. Automatically pick arithmetics transformation: \n\n   #pragma ACCEL ARITHMETIC auto{__ARITH__L2}\n\n8. Automatically pick arithmetics transformation: \n\n   #pragma ACCEL ARITHMETIC auto{__ARITH__L3}\n\n9. Automatically pick arithmetics transformation: \n\n   #pragma ACCEL ARITHMETIC auto{__ARITH__P0}\n\n10. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P1}\n\n11. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P2}\n\n12. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P3}\n\n13. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P4}\n\n14. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P5}\n\n15. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P6}\n\n16. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P7}\n\n17. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P8}\n\n18. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P9}\n\n19. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P10}\n\n20. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P11}\n\n21. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P12}\n\n22. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P13}\n\n23. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P14}\n\n24. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P15}\n\n25. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P16}\n\n26. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P17}\n\n27. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P18}\n\n28. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P19}\n\n29. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P20}\n\n30. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P21}\n\n31. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P22}\n\n32. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P23}\n\n33. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P24}\n\n34. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P25}\n\n35. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P26}\n\n36. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P27}\n\n37. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P28}\n\n38. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P29}\n\n39. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P30}\n\n40. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P31}\n\n41. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P32}\n\n42. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P33}\n\n43. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P34}\n\n44. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P35}\n\n45. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P36}\n\n46. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P37}\n\n47. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P38}\n\n48. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P39}\n\n49. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P40}\n\n50. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P41}\n\n51. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P42}\n\n52. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P43}\n\n53. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P44}\n\n54. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P45}\n\n55. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P46}\n\n56. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P47}\n\n57. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P48}\n\n58. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P49}\n\n59. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P50}\n\n60. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__", "3": "\n\n5. Do not pipeline the loop below: #pragma ACCEL PIPELINE auto{off}\n  \n6. Do not parallelize the loop below: #pragma ACCEL PARALLEL auto{1}\n  \n7. #pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n8. #pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n9. #pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (tiled_index = 0; tiled_index < 8; tiled_index++) {\n    int _in_j = 0;\n    int _in_j_col = (((int )tiled_index) * 64) + 1;\n    int _in_j_row = 1;\n    int _out_j = 0;\n    int _out_j_col = (((int )tiled_index) * 64) + 1;\n    int _out_j_row = 1;\n    for (j_col = 1; j_col <= 60; j_col += 64) {\n      if (j_col + 64 - 1 < 60) {\n        _in_j_col = j_col + 64 - 1;\n      }\n      else {\n        _in_j_col = 60;\n      }\n      for (j_row = 1; j_row <= 60; j_row += 64) {\n        if (j_row + 64 - 1 < 60) {\n          _in_j_row = j_row + 64 - 1;\n        }\n        else {\n          _in_j_row = 60;\n        }\n//#pragma ACCEL PIPELINE auto{off}\n        for (in_j = 0; in_j <= 79; in_j++) {\n          _in = in[in_j][_in_j_row][_in_j_col];\n//#pragma ACCEL PARALLEL reduction=out FACTOR=auto{__PARA__L2}\n          for (out_j = 0; out_j <= 79; out_j++) {\n            out[out_j][_out_j_row][_out_j_col] += _in * A[out_j][in_j];\n          }\n        }\n//#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      }\n//#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    }\n//#pragma ACCEL PIPELINE auto{__PIPE__L1}\n  }\n//#pragma ACCEL PIPELINE auto{off}\n\n  }\n", "4": "\n\n5. Don't automatically distribute this loop: `#pragma ACCEL DISTRIBUTE FACTOR=1`\n\n6. Don't automatically parallelize this loop: `#pragma ACCEL PARALLEL FACTOR=auto{1}`\n\n7. Don't automatically parallelize this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}`\n//#pragma ACCEL PIPELINE auto{flatten}\n\n//#pragma ACCEL TILE FACTOR=auto{4}\n\n//#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n/* Configurations */\n#define TILE_FACTOR 4\n#define PARA_L2 1\n#define PARA_L1 16\n#define PARA_L0 1\n#define PARA_INPUT_L 1\n#define PARA_OUTPUT_L 1\n\n#include <math.h>\n#include <stdio.h>\n#ifdef _OPENMP\n#include <omp.h>\n#endif\n\nstruct lp_struct_t {\n  double A[120][120];\n  double x[120];\n  double b[120];\n  double b_orig[120];\n  double b_error[120];\n};\n\nvoid kernel_gemm(double m1[120][120],double m2[120][120],double prod[120][120])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 120; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 120; j++) {\n      lp_1:\n      double sum = (double )0;\n      \n#pragma ACCEL PARALLEL reduction=sum FACTOR=auto{__PARA__L2}\n      for (k = 0; k < 120; k++) {\n        lp_2:\n        sum += m1[i][k] * m2[k][j];\n      }\n      prod[i][j] = sum;\n    }\n  }\n//#pragma endscop\n}\n\nvoid kernel_gemm_orig(double m1[120][120],double m2[120][120],double prod[120][120])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 120; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 120; j++) {\n      lp_3:\n      double sum = (double )0;\n      \n#pragma ACCEL PARALLEL reduction=sum FACTOR=auto{__PARA__L0}\n      for (k = 0; k < 120; k++) {\n        lp_4:\n        sum += m1[i][k] * m2[k][j];\n      }\n      prod[i][j] = sum;\n    }\n  }\n//#pragma endscop\n}\n\nint main(int argc,char **argv)\n{\n  double (*A)[120][120]) = ((double (*)[120][120])((double *)malloc(480000 * sizeof(double ))));\n  double (*x)[120][120]) = ((double (*)[120][120])((double *)malloc(480000 * sizeof(double ))));\n  double (*b)[120]) = ((double (*)[120])((double *)malloc(120 * sizeof(double ))));\n  double (*b_orig)[120]) = ((double (*)[120])((double *)malloc(120 * sizeof(double ))));\n  double (*b_error)[120]) = ((double (*)[120])((double *)malloc(120 * sizeof(double ))));\n  double _in_A[120][120];\n  double _in_x[120][120];\n  double _in_b[120];\n  double _out_b[120];\n  double _out_b_orig[120];\n  double _out_b_error[120];\n  double _result;\n  struct lp_struct_t _lp;\n  int i;\n  int j;\n  int k;\n//#pragma ACCEL kernel\n\n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  kernel_gemm(_in_A,_in_x,_out_b);\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n  kernel_gemm_orig(_in_A,_in_x,_out_b_orig);\n//Section0:\n//  Original from: gemm.c:30\n//  A[i][k] * x[k][j] => sum[i][j]\n  \n#pragma ACCEL PIPELINE auto{off}\n  for (i = 0; i < 120; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n    for (j = 0; j < 120; j++) {\n      sum:\n      _lp.b[i] = 0.0;\n      for (k = 0; k < 120; k++) {\n        _lp.b[i] += _lp.A[i][k] * _lp.x[k][j];\n      }\n      _lp.b_error[i] = _lp.b[i] - _lp.b_orig[i];\n    }\n  }\n//Section1:\n//  Original from: gemm.c:44\n//  A[i][k] * x[k][j] => sum[i][j]\n//  Function: gemm\n//  Args:\n//  Return: double\n//  Requirements:\n//    All data must be aligned.\n//    A and x must be private.\n//    sum must be local.\n//    b must be local.\n//    b_error must be reduction.\n//    depend(2) sum -> b\n//    depend(2) b -> b_error\n//    depend(1) A => sum\n//    depend(1) x => sum\n//    gemm_orig\n//    \n//#pragma ACCEL PIPELINE auto{flatten}\n//#pragma ACCEL TILE FACTOR=auto{4}\n//#pragma ACCEL PARALLEL FACTOR=auto{1}\n//  for (i = 0; i < 120; i++) {\n//    \n//#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n//    for (j = 0; j < 120; j++) {\n//      sum:\n//      double sum = (double )0;\n//      \n//#pragma ACCEL PARALLEL reduction=sum FACTOR=auto{__PARA__L3}\n//      for (k = 0; k < 120; k++) {\n//        double _in_val = _in_A[i][k];\n//        double _in_ptr = _in_x[k][j];\n//        sum += _in_val * _in_ptr;\n//      }\n//      _out_b[i] = sum;"}}
{"input": "To generate the given HLS codes, use the following natural language instructions:\n\n1. Mark the function as a hardware kernel for acceleration.\n   Use: 'Treat the following function as a hardware kernel for acceleration'\n\n2. Don't automatically pipeline the outer loop.\n   Use: '#pragma ACCEL PIPELINE \"off\"'\n\n3. Ensure the loop is processed in its original, full form without breaking it into smaller chunks.\n   Use: '#pragma ACCEL TILE FACTOR=1'\n\n4. Run the iterations of the outer loop one after the other, not in parallel.\n   Use: '#pragma ACCEL PARALLEL FACTOR=1'\n\n5. Optionally, specify the auto factor value for the pipeline, tile, and parallel pragma directives.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L0}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L0}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L1}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L1}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L2}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L2}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L3}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L3}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L4}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L4}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L5}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L5}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L6}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L6}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L7}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L7}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L8}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L8}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L9}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L9}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L10}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L10}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L10}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L11}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L11}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L11}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L12}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L12}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L12}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L13}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L13}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L13}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L14}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L14}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L14}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L15}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L15}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L15}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L16}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L16}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L16}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L17}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L17}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L17}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L18}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L18}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L18}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L19}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L19}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L19}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L20}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L20}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L20}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L21}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L21}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L21}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L22}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L22}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L22}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L23}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L23}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L23}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L24}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L24}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L24}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L25}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L25}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L25}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L26}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L26}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L26", "1": "\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L0}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L0}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L1}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L1}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L2}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L2}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L3}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L3}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L4}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L4}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L5}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L5}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L6}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L6}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L7}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L7}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L8}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L8}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L9}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L9}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L10}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L10}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L10}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L11}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L11}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L11}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L12}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L12}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L12}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L13}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L13}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L13}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L14}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L14}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L14}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L15}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L15}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L15}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L16}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L16}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L16}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L17}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L17}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L17}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L18}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L18}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L18}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L19}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L19}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L19}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L20}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L20}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L20}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L21}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L21}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L21}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L22}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L22}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L22}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L23}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L23}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L23}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L24}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L24}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L24}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L25}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L25}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L25}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L26}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L26}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L26", "2": "\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L0}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L0}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L1}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L1}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L2}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L2}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L3}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L3}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L4}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L4}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L5}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L5}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L6}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L6}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L7}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L7}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L8}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L8}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L9}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L9}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L10}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L10}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L10}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L11}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L11}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L11}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L12}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L12}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L12}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L13}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L13}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L13}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L14}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L14}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L14}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L15}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L15}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L15}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L16}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L16}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L16}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L17}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L17}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L17}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L18}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L18}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L18}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L19}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L19}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L19}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L20}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L20}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L20}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L21}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L21}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L21}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L22}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L22}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L22}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L23}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L23}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L23}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L24}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L24}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L24}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L25}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L25}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L25}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L26}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L26}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L26", "3": "\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L0}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L0}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L2}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L2}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L3}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L3}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L4}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L4}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L5}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L5}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L6}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L6}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L7}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L7}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L8}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L8}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L9}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L9}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L10}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L10}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L10}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L11}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L11}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L11}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L12}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L12}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L12}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L13}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L13}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L13}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L14}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L14}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L14}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L15}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L15}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L15}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L16}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L16}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L16}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L17}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L17}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L17}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L18}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L18}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L18}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L19}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L19}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L19}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L20}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L20}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L20}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L21}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L21}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L21}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L22}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L22}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L22}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L23}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L23}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L23}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L24}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L24}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L24}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L25}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L25}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L25}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L26}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L26}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L26}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L27}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L27}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__", "4": "\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L0}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L0}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L2}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L2}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L3}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L3}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L4}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L4}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L5}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L5}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L6}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L6}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L7}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L7}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L8}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L8}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L9}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L9}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L10}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L10}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L10}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L11}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L11}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L11}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L12}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L12}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L12}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L13}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L13}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L13}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L14}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L14}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L14}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L15}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L15}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L15}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L16}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L16}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L16}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L17}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L17}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L17}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L18}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L18}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L18}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L19}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L19}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L19}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L20}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L20}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L20}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L21}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L21}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L21}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L22}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L22}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L22}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L23}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L23}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L23}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L24}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L24}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L24}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L25}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L25}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L25}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L26}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L26}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L26}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L27}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L27}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__"}}
{"input": "Process the kernel loop in its original, full form without breaking it into smaller chunks. Then, don't automatically pipeline this loop. Run the iterations of this loop one after the other, not in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 0 + 1L * jump_ey;\n        int _in_i = 0 + 1L * jump_ex;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": " \n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{__PARA__L2}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 30; t++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1;\n        int j_col = -1;\n        double hz_col = 0.0;\n        i_col = 200 - 1 - i;\n        j_col = 240 - 1 - j;\n        hz_col = hz[i_col][j_col];\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_col][j_col + 1] - ex[i_col][j_col] + ey[i_col + 1][j_col] - ey[i_col][j_col]);\n      }\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes in C, use the following natural language instructions:\n\n1. Treat the following function as a hardware kernel for acceleration.\n2. Don't automatically pipeline this loop and flatten it.\n3. Process this loop in its original, full form without breaking it into smaller chunks automatically.\n4. Run the iterations of this loop one after the other, not in parallel with a factor of 2.\n5. Run the iterations of this loop in parallel with a factor of 16.\n6. Run the iterations of this loop one after the other, not in parallel with a factor of 1.\n\nThe corresponding #pragma values are:\n1. #pragma ACCEL kernel\n2. #pragma ACCEL PIPELINE auto{flatten}\n3. #pragma ACCEL TILE FACTOR=auto{1}\n4. #pragma ACCEL PARALLEL FACTOR=auto{2}\n5. #pragma ACCEL PARALLEL FACTOR=auto{16}\n6. #pragma ACCEL PARALLEL FACTOR=auto{1}", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "1": "\n\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_0 = i;\n        int j_0 = j;\n        \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n        hz[i_0][j_0] = hz[i_0][j_0] - 0.7 * (ex[i_0][j_0 + 1] - ex[i_0][j_0] + ey[i_0 + 1][j_0] - ey[i_0][j_0]);\n      }\n    }\n  }\n}\n", "2": "\n\n\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1;\n        int j_col = -1;\n        double dzi = (hz[i][j] - hz[i][j + 1]);\n        double dxe = (ex[i][j] - ex[i][j + 1]);\n        double dyi = (ey[i][j] - ey[i + 1][j]);\n        hz[i][j] = hz[i][j] + 0.7 * dzi + ((*(fict_ptr + j)) * (ex[i][j] - 2.0 * ey[i][j] + hz[i][j + 1]) - 0.7 * ((ey[i][j + 1] - ey[i + 1][j + 1]) * dxi + (ex[i + 1][j] - ex[i + 1][j + 1]) * dyi));\n        ex[i][j] = ex[i][j] + 0.7 * dxi + dyi;\n        ey[i][j] = ey[i][j] + 0.7 * dyi + dzi;\n      }\n    }\n  }\n}\n", "4": "\n \n#include <math.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/time.h>\n#include <cutil_inline.h>\n \n#define N 128\n#define M 128\n#define K 128\n#define double float\n// A is NxM\ndouble A[N][M];\n// B is MxK\ndouble B[M][K];\n// C is NxK\ndouble C[N][K];\n// Threads per block\n#define BLOCK_SIZE 16\n// Total number of threads\n#define NUM_THREADS 256\n \ndouble mul(double A,double B){\n  return A * B;\n}\n \nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[64][64],double A[64][64],double B[64][64])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* Standardize from: for(i = 0;i < 64;++i) {...} */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  for (i = 0; i < 64; i++) {\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (j = 0; j < 64; j++) {\n      C[i][j] *= beta;\n    }\n  }\n/* Standardize from: for(i = 0;i < 64;++i) {...} */\n  \n#pragma ACCEL PIPELINE auto{}\n  for (i = 0; i < 64; i++) {\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (k = 0; k < 64; k++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j < 64; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n/* Standardize from: for(i = 0;i < 64;++i) {...} */\n  \n#pragma ACCEL PIPELINE auto{off}\n  for (i = 0; i < 64; i++) {\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (j = 0; j < 64; j++) {\n      C[i][j] += C[i][j];\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To generate the given HLS codes in C, you should use the following natural language instructions for the specific #pragma values:\n\n1. For the function `kernel_jacobi_1d`:\n    - Treat the following function as a hardware kernel for acceleration.\n\n2. For the first loop:\n    - Don't automatically pipeline this loop.\n\n3. For tiling:\n    - Process this loop in its original, full form without breaking it into smaller chunks.\n\n4. For parallelization with a factor of 2:\n    - Run the iterations of this loop in parallel with a parallel factor of 2.\n\n5. For the inner loop (first usage):\n    - Run the iterations of this loop one after the other, not in parallel.\n\n6. For the inner loop (second usage):\n    - Run the iterations of this loop in parallel with a parallel factor of 8.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n7. For the function `kernel_jacobi_1d`:\n    - Transform the source file to apply the transforms.\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n\n7. For the function `kernel_jacobi_1d`:\n    - Transform the auto-pipeline transforms: off\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n\n7. For the function `kernel_jacobi_1d`:\n    - Transform the source file to a new file.\n    - Use the automatic kernel processor to implement the kernel.\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n\n7. For the second loop:\n    - Don't automatically pipeline this loop.\n\n8. For tiling:\n    - Process this loop in its original, full form without breaking it into smaller chunks.\n\n9. For parallelization with a factor of 2:\n    - Run the iterations of this loop in parallel with a parallel factor of 2.\n\n10. For the inner loop (first usage):\n    - Run the iterations of this loop one after the other, not in parallel.\n\n11. For the inner loop (second usage):\n    - Run the iterations of this loop in parallel with a parallel factor of 2.\n\n12. For the third loop:\n    - Don't automatically pipeline this loop.\n\n13. For tiling:\n    - Process this loop in its original, full form without breaking it into smaller chunks.\n\n14. For parallelization with a factor of 2:\n    - Run the iterations of this loop in parallel with a parallel factor of 2.\n\n15. For the fourth loop:\n    - Don't automatically pipeline this loop.\n\n16. For tiling:\n    - Process this loop in full form with a tile size of 128.\n\n17. For parallelization with a factor of 2:\n    - Run the iterations of this loop in parallel with a parallel factor of 2.\n\n18. For the fifth loop:\n    - Don't automatically pipeline this loop.\n\n19. For tiling:\n    - Process this loop in full form with a tile size of 4.\n\n20. For parallelization with a auto-parallel factor:\n    - Automatically parallelize this loop with a parallel factor of 2.\n\n21. For the sixth loop:\n    - Don't automatically pipeline this loop.\n\n22. For tiling:\n    - Process this loop in full form with a tile size of 4.\n\n23. For parallelization with a auto-parallel factor:\n    - Automatically parallelize this loop with a parallel factor of 2.\n\n24. For the seventh loop:\n    - Don't automatically pipeline this loop.\n\n25. For tiling:\n    - Process this loop in full form with a tile size of 4.\n\n26. For parallelization with a auto-parallel factor:\n    - Automatically parallelize this loop with a parallel factor of 2.\n\n27. For the eighth loop:\n    - Don't automatically pipeline this loop.\n\n28. For tiling:\n    - Process this loop in full form with a tile size of 4.\n\n29. For parallelization with a auto-parallel factor:\n    - Automatically parallelize this loop with a parallel factor of 2.\n\n30. For the ninth loop:\n    - Don't automatically pipeline this loop.\n\n31. For tiling:\n    - Process this loop in full form with a tile size of 4.\n\n32. For parallelization with a auto-parallel factor:\n    - Automatically parallelize this loop with a parallel factor of 2.\n\n33. For the function `kernel_jacobi_1d`:\n    - Automatically pipeline this kernel.\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n\n7. For the function `kernel_jacobi_1d`:\n    - Transform this kernel from a sequential kernel to a data-parallel kernel.\n\n8. For the second loop:\n    - Automatically pipeline this loop.\n\n9. For the first loop:\n    - Partition L1:complete\n\n10. For the first loop:\n    - Parallelize sequentially\n\n11. For the second loop:\n    - Parallelize with B4 (4)\n\n12. For the first loop:\n    - Parallelize with FACTOR=auto{1}\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To generate the given HLS codes in C, you can use the following concise natural language instruction for the process and pragma values:\n\n\"Designate the following function as a hardware kernel for acceleration\" - this describes the pragma value '#pragma ACCEL kernel'\n\n\"Automatically pipeline this loop without flattening\" - this maps to the pragma value '#pragma ACCEL PIPELINE auto{flatten}'\n\n\"Set the tile factor for loop tiling to be automatically determined as 1\" - this corresponds to the pragma value '#pragma ACCEL TILE FACTOR=auto{1}'\n\n\"Run the iterations of the following loops in parallel with a factor to be automatically determined as 2\" - for both loops, the pragma value is '#pragma ACCEL PARALLEL FACTOR=auto{2}'\n\nFor the provided code snippet, using these natural language instructions will generate the corresponding HLS codes in C with the specified pragma values.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 119; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 119; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 119; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 119; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "Apply pipeline optimization to the outer loop, disable automatic pipelining for the middle loop, and flatten the inner loop for parallelization using suitable HLS pragma directives.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 90; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n//#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 90; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = A[i][j] - 0.5 * (A[i][j] - A[i][j - 1]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n// Xilinx XRT kernel\n#pragma ACCEL kernel\n\nvoid kernel_2mm(double m1[4096],double m2[4096],double m3[4096],double prod[32768])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (i = 0; i < 32; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    for (j = 0; j < 32; j++) {\n      m3[i * 32 + j] = ((double )0);\n      for (k = 0; k < 32; k++) {\n        m3[i * 32 + j] += m1[i * 32 + k] * m2[k * 32 + j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n  for (i = 0; i < 32; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    for (j = 0; j < 32; j++) {\n      double sum = (double )0;\n      for (k = 0; k < 32; k++) {\n        sum += m1[i * 32 + k] * m3[k * 32 + j];\n      }\n      prod[i * 32 + j] = sum;\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n// This version has been generated by the AutoPipemizer tool.\n// The original code is: #pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PARALLEL reduction=E FACTOR=auto{2}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PARALLEL reduction=F FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[k][i] * D[k][j];\n      }\n    }\n  }\n/* G */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PARALLEL reduction=G FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "Process the loop in its original, full form without breaking it into smaller chunks. Treat the loop iterations as if they are a pipeline, automatically determining the optimal settings. Run two iterations of this loop in parallel. Within this loop, process 24 iterations in parallel, and then process the remaining iterations two at a time in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{24}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL reduction=u FACTOR=auto{__PARA__L2}\n    for (i = 1; i < 39; i++) {\n      b = 0.16666666666666666666666666L * f(i - 1);\n      u[i] = u[i] + su[i] * (h * (p[i] - b - u[i] - q[i]));\n    }\n    \n#pragma ACCEL PARALLEL reduction=q FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 39; i++) {\n      q[i] = g[i] * u[i + 1] + h * (p[i] - q[i]);\n    }\n  }\n}\n", "1": "\n #pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL reduction=u FACTOR=auto{__PARA__L2}\n    for (i = 1; i < 92; i++) {\n      b = sin(a);\n      u[i] = u[i] + b * v[i] + p[i];\n    }\n    \n#pragma ACCEL PARALLEL reduction=v FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 92; i++) {\n      b = u[i] - v[i];\n      y = i * (i - 1) * (i - 2);\n      v[i] = v[i] + b * a * y;\n    }\n    \n#pragma ACCEL PARALLEL reduction=p FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 92; i++) {\n      d = 1.0 + a * (y - v[i]) - b * u[i];\n      p[i] = d * p[i];\n    }\n  }\n}\n", "2": "\n #pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 1; i < 39; i++) {\n      b[i] = 0.0;\n      s[i] = 0.0;\n      q[i] = 0.0;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 0; i < 39; i++) {\n      y = _in_[i];\n      s[i] = y;\n      for (j = 1; j <= 39; j++) {\n        b[j] += y * d[i * 39 + j];\n      }\n      q[i] = b[i] / b[i * 39 + i];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n    for (i = 0; i < 39; i++) {\n      y = s[i];\n      q_1m_1 = q[i - 1];\n      x = y - q[i] * (b[i] - (q_1m_1) * b[i - 1]);\n      d[i] = x;\n    }\n  }\n}\n", "3": "\n #pragma ACCEL PIPELINE auto{__PIPE__L0}\n \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n for (t = 0; t < 40; t++) {\n  tmp = dt * DX;\n \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 1; i < 39; i++) {\n    sb = s[0] - e[i];\n    bb = b[i] - 2 * a[i] + a[0];\n    aa = a[i] - a[0];\n    cc = e[i] - d[i] - aa * dp[i] / dx;\n    dd = d[i] - d[0] - aa / dx * (fp[i] - fp[0] - sb * (d[0] - b[0]) / bb);\n    cp[i] = cp[i] - dd * cc / (bb * dd + eps);\n    dp[i] = dd + cc * cp[i] / dd;\n    fp[i] = fp[i] + cc * dp[i] / dd + sb * cp[i];\n    d[i] = d[i] + g[i] * tmp;\n    g[i] = g[i] + aa * tmp;\n    a[i] = a[i] + dp[i] * tmp;\n    b[i] = b[i] + cp[i] * tmp;\n    e[i] = e[i] + dd * tmp;\n  }\n  d[0] = 1.0;\n  e[0] = 0.0;\n  f[0] = 0.0;\n  g[0] = 0.0;\n  a[0] = 1.0;\n  b[0] = 0.0;\n}\n", "4": "\n #pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n  for (tj = 1;tj < 42;tj++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (tk = 1;tk < 42;tk++) {\n      \n#pragma ACCEL PARALLEL reduction=tmp2 FACTOR=auto{__PARA__L4}\n      for (i = 1;i < 240;i++) {\n        bv = dt * (xr[i] - x[tj]);\n        bw = dt * (xr[i] - x[tk]);\n        tmp2 = bv * bw;\n        a = A[i][j][tk] + A[i][j][tj];\n        tmp1 = A[i][j][tk] * bw + A[i][j][tj] * bv;\n        C[i][j] += tmp2 * a;\n        D[i][j] += tmp2 * tmp1;\n        F[i][j] += tmp1 * bv;\n        G[i][j] += tmp1 * bw;\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{24}\n    for (i = 1;i < 240;i++) {\n      b = B[i][j];\n      tmp1 = B[i][j] * F[i][j];\n      e = E[i][j] + G[i][j];\n      f = F[i][j] + B[i][j] * G[i][j];\n      \n#pragma ACCEL PARALLEL reduction=C[i][j] FACTOR=auto{__PARA__L5}\n      for (ii = 1;ii < 240;ii++) {\n        C[i][j] += B[i][ii] * E[i][ii];\n      }\n      D[i][j] = D[i][j] + tmp1 + e;\n      C[i][j] = C[i][j] + b * e;\n      F[i][j] = F[i][j] * b;\n      G[i][j] = G[i][j] * b;\n      E[i][j] = b * e;\n      B[i][j] = b * f;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n  for (i = 1;i < 240;i++) {\n    for (j = 1;j < 240;j++) {\n      q[i][j] = ((double )0);\n    }\n  }\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n  for (i = 1;i < 240;i++) {\n    for (j = 1;j < 240;j++) {\n      P[i][j] = C[i][j] - D[i][j];\n      Q[i][j] = P[i][j] / ((double )(2.0 * 41));\n      r[i][j] = Q[i][j] - G[i][j];\n      s[i][j] = F[i][j] - B[i][j] * r[i][j];\n      double _tmp_ = s[i][j];\n      for (k = 1;k < 240;k++) {\n        q[i][k] += _tmp_ * B[k][j];\n      }\n    }\n    double _tmp_ = 1.0e-4;\n    for (k = 1;k < 240;k++) {\n      q[i][k] = q[i][k] * _tmp_;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L8}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n  for (i = 1;i < 240;i++) {\n    for (j = 1;j < 240;j++) {\n      xr[i] += (( q[i][j] + r[i][j]) * x[j]);\n    }\n  }\n}\n"}}
{"input": "Define a hardware kernel for acceleration. Use parallel and pipeline optimizations for the nested loops. Ensure the outer loop runs in full form without breaking into smaller chunks, and the inner loops process iterations one after another, not in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{__PARA__L2}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction=D FACTOR=auto{__PARA__L3}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{2}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 0 + 1L * 2L * 7L;\n        int _in_i = 0 + 1L * 2L * 7L;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int ii = i + 1;\n        int jj = j + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes written in C, use the following natural language instruction for the specific #pragma values:\n\n1. To automatically pipeline the loop:\n   Use: \"Automatically pipeline this loop\"\n   Code: `#pragma ACCEL PIPELINE auto{}`\n\n2. To tile the loop with a factor determined automatically:\n   Use: \"Automatically determine the tiling factor for this loop\"\n   Code: `#pragma ACCEL TILE FACTOR=auto{1}`\n\n3. To run iterations of the loop in parallel with an automatically determined factor:\n   Use: \"Automatically determine the parallelization factor for this loop\"\n   Code: `#pragma ACCEL PARALLEL FACTOR=auto{2}`\n\n4. To set a specific parallelization factor for the inner loop:\n   Use: \"Set the parallelization factor for the inner loop to 15\"\n   Code: `#pragma ACCEL PARALLEL FACTOR=auto{15}`\n\n5. To set a specific parallelization factor for another inner loop:\n   Use: \"Set the parallelization factor for the inner loop to 3\"\n   Code: `#pragma ACCEL PARALLEL FACTOR=auto{3}`\n\nBy following these natural language instructions, the given HLS codes can be generated in C with the appropriate #pragma values.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L8}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L8}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L8}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "Process the iterations of the following loop in parallel, utilizing automatic factor calculation.\nDon't automatically pipeline this loop.\nProcess this loop in its original, full form without breaking it into smaller chunks.\nRun the iterations of this loop one after the other, not in parallel. Also, treat the following function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1 * i;\n        int j_col = j + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_col][j] - ex[i][j_col]) - 0.7 * (ey[i][j_col] - ey[i_col][j]);\n      }\n    }\n  }\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_gemver(int n,double alpha,double beta,double A[120][120],double u1[120],double v1[120],double u2[120],double v2[120],double w[120],double x[120],double y[120],double z[120])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 120; i++) {\n    x[i] = ((double )0);\n    y[i] = 0.0;\n    z[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 120; i++) {\n    double tmp_x = 0.0;\n    double tmp_y = 0.0;\n    double tmp_z = 0.0;\n    double u_entry = u1[i];\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 120; j++) {\n      double A_entry = A[i][j];\n      double v_entry = v1[j];\n      tmp_x += A_entry * v_entry;\n      tmp_y += A_entry * u_entry;\n      tmp_z += A_entry * v_entry * u_entry;\n    }\n    x[i] = alpha * tmp_x;\n    y[i] = alpha * tmp_y;\n    z[i] = beta * tmp_z + y[i];\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 120; i++) {\n    double tmp_x = ((double )0);\n    double tmp_y = ((double )0);\n    double u_entry = u2[i];\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 120; j++) {\n      double A_entry = A[j][i];\n      double v_entry = v2[j];\n      tmp_x += A_entry * v_entry;\n      tmp_y += A_entry * u_entry;\n    }\n    x[i] += tmp_x;\n    y[i] += alpha * 2.0 * u_entry * v2[i] + tmp_y;\n  }\n}\n"}}
{"input": "To generate the following HLS codes in C:\n```c\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps, int n, double A[120], double B[120])\n{\n  int t;\n  int i;\n#pragma ACCEL PIPELINE auto{flatten}\n#pragma ACCEL TILE FACTOR=auto{1}\n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n}\n```\n\nYou can use the following concise natural language instructions for each #pragma directive:\n\n1. \"Treat the following function as a hardware kernel for acceleration\"\n   - `#pragma ACCEL kernel`\n\n2. \"Don't automatically pipeline this loop, maintain original structure\"\n   - `#pragma ACCEL PIPELINE auto{flatten}` \n\n3. \"Process this loop in its original, full form without breaking it into smaller chunks\"\n   - `#pragma ACCEL TILE FACTOR=auto{1}`\n\n4. \"Run the iterations of this loop in parallel with the specified factor\"\n   - `#pragma ACCEL PARALLEL FACTOR=auto{2}` for the outer loop\n   - `#pragma ACCEL PARALLEL FACTOR=auto{15}` for the first inner loop\n   - `#pragma ACCEL PARALLEL FACTOR=auto{1}` for the second inner loop", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n5. \"Automatic parallelization enabled\"\n  ", "1": "\n\n5. \"Automatic parallelization enabled\"\n   - ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n\n6. \"Automatic tiling enabled\"\n   - ACCEL TILE FACTOR=auto{__TILE__L0}\n\n", "2": "\n\n5. \"Transform this for loop into a parallelized reduction loop\"\n   - `#pragma ACCEL PIPELINE auto{off}`\n   - `#pragma ACCEL TILE FACTOR=auto{1}`\n   - `#pragma ACCEL PARALLEL FACTOR=auto{15} reduction=A`\n", "3": "\n\n5. \"Set the target region array A to have a parallel storage\"\n   - `#pragma ACCEL PARALLEL FACTOR=auto{1} PARALLEL_FACTOR=A`\n\n6. \"Set the target region array B to have a parallel storage\"\n   - `#pragma ACCEL PARALLEL FACTOR=auto{1} PARALLEL_FACTOR=B`\n", "4": "\n\n5. \"Use the following space-time transform for the outer-most loop\"\n   - `#pragma ACCEL PIPELINE auto{__PIPE__L1}`\n   - `#pragma ACCEL TILE FACTOR=auto{__TILE__L1}`\n   - `#pragma ACCEL REGISTER FACTOR=auto{__REGISTER__L1}`\n  \n6. \"Use the following space-time transform for the middle-most loop\"\n   - `#pragma ACCEL PIPELINE auto{__PIPE__L2}`\n   - `#pragma ACCEL TILE FACTOR=auto{__TILE__L2}`\n   - `#pragma ACCEL REGISTER FACTOR=auto{__REGISTER__L2}`\n  \n7. \"Use the following space-time transform for the inner-most loop\"\n   - `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}`\n  \n8. \"Use the following space-time transform for the inner-most loop\"\n   - `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}`\n  \n"}}
{"input": "Process the following function as a hardware kernel for acceleration.\nEnsure the loop iterations run in parallel, each with an auto-determined factor.\nDisable automatic loop pipelining.\nSet the loop tiling factor to be determined automatically.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "1": "\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1*i;\n        int j_col = j + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_col][j] - ex[i][j_col]) - 0.7 * (ey[i][j_col] - ey[i_col][j]);\n      }\n    }\n  }\n}\n", "2": "\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int s = i * 240 + j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 0 + 1L * 240L;\n        int _in_i = 0 + 1L * 200L;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes in C, use the following natural language instruction:\n\n\"Designate the following function as a hardware kernel for acceleration. Sequentially process the iterations of the outer loop, and parallelize the inner loop with a factor of 15. Automatically pipeline the loops and use a tiling factor of 1. Additionally, parallelize the second inner loop with a factor of 1.\"\n\nThis instruction encompasses the use of the following #pragma values:\n- '#pragma ACCEL kernel' to designate the function as a hardware kernel\n- '#pragma ACCEL PIPELINE auto{flatten}' to automatically pipeline the loops\n- '#pragma ACCEL TILE FACTOR=auto{1}' to apply a tiling factor of 1\n- '#pragma ACCEL PARALLEL FACTOR=auto{2}' to parallelize the outer loop\n- '#pragma ACCEL PARALLEL FACTOR=auto{15}' to parallelize the first inner loop with a factor of 15\n- '#pragma ACCEL PARALLEL FACTOR=auto{1}' to parallelize the second inner loop with a factor of 1", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n\n#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n\n#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction=D FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To generate the given C code with HLS pragmas, you should follow the natural language instructions below:\n\n- Apply automatic pipelining to the loop: '#pragma ACCEL PIPELINE auto{}'\n- Tile the loop with a factor determined automatically: '#pragma ACCEL TILE FACTOR=auto{1}'\n- Parallelize the loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{2}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{3}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{10}'", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}'\n\n #pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{_1}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L2}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L4}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L5}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L6}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": "\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'", "3": "\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}'\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}'\n- Parallelize this nested loop with a factor of 2: '#pragma ACCEL PARALLEL FACTOR=auto{2}'\n \n#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "Process the iterations of the first loop in parallel with a factor determined automatically, then disable automatic pipelining for this loop, and finally, process the second nested loop in parallel with a factor determined automatically and with a reduction performed in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": " The default value for the _P_LIB_DYNAMIC_ scheduled pipeline is auto{__PIPE__L2}\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "1": "  \\p2 #pragma ACCEL PIPELINE auto{off}\n \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  for (j = 1; j < 120; j++) {\n     dj = ((double )j) - 1.0;\n     tmpj = 0.0;\n     tij = 0.0;\n     si = 0.0;\n     qmc = ((double )((double )4.0 * M_PI));\n     _in_14:\n    for (i = 1; i < 120; i++) {\n      d = ((double )i) - 1.0;\n      e = dj / d;\n      e2 = e * e;\n      u = e2;\n      u = u * u;\n      u = u * u;\n      u = u * u;\n      u = u * u;\n      u = u * u;\n      u = u * u;\n      force = u * (e * (3.0 * sqrt(e) ) + 1.0) ;\n      phi = qmc / (sqrt(d * d_jm1) * (d + d_jm1) );\n      tmp = A[i] * B[j];\n      si += tmp;\n      tij += force * phi * tmp;\n    }\n     tmpj = si * D[j];\n     A[j] = tmpj + tij;\n  }\n}\n", "2": " This option will create 4 computation threads.\n #pragma ACCEL PIPELINE auto{off}\n\n#pragma ACCEL TILE FACTOR=auto{1}\n  for (tj = 0;tj < 40;tj++) {\n     tmp = 0.0;\n     sim = 0.0;\n     SUM_SIM: for (jt = 0;jt < 40;jt++) {\n        if (tj == jt) {\n          continue;\n        }\n        delta_ij = space[tj] - space[jt];\n        SIMM_IJ: for (i = 0;i < 30;i++) {\n          SIMM_J = 30 + 0;\n          if (i == SIMM_J) {\n            goto SIMM_J_END;\n          }\n          delta_si = li[i] - space[jt];\n          simi = 0.0;\n          SIMI_IJ: for (j = 0;j < 30;j++) {\n            if (i == j) {\n              continue;\n            }\n            delta_sj = lj[j] - space[jt];\n            inner_simi = (delta_ij * delta_si) + (delta_sj * delta_sj);\n            simi += exp(inner_simi);\n          }\n//#pragma ACCEL PARALLEL reduction=simi FACTOR=auto{__PARA__L2}\n\t  for (j = 0; j < 30; j++) {\n            delta_sj = lj[j] - space[jt];\n            inner_simi = (delta_ij * delta_si) + (delta_sj * delta_sj);\n            simi += exp(inner_simi);\n          }\n        SIMM_J = 30 + 1;\n        SIMM_J_END:;\n        }\n        simj = 0.0;\n        SUM_SIMJ: for (j = 0;j < 30;j++) {\n          delta_sj = lj[j] - space[tj];\n          inner_simj = (delta_ij * delta_sj) + (delta_si * delta_sj);\n          simj += exp(inner_simj);\n        }\n//#pragma ACCEL PARALLEL reduction=simj FACTOR=auto{__PARA__L3}\n\tfor (j = 0; j < 30; j++) {\n          delta_sj = lj[j] - space[tj];\n          inner_simj = (delta_ij * delta_sj) + (delta_si * delta_sj);\n          simj += exp(inner_simj);\n        }\n        sim = simi * simj;\n        tmp += sim;\n      }\n      lspace[tj] = space[tj] + (a * (log(tmp) - sim));\n    }\n    tj = 39 + 0;\n    tj_end = 39 + 1;\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (tj = 39 + 0;tj < 39 + 1;tj++) {\n    space[tj] = lspace[tj];\n  }\n}\n", "3": " The default value for the _P_AFFINITY keyword is AUTO.\n #pragma ACCEL PIPELINE auto{__PIPE__L2}\n \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n for (j = 1; j < 120; j++) {\n  tmp = 1.0 / (1.0)...\n      + 2.0;\n  \n#pragma ACCEL PARALLEL reduction=u FACTOR=auto{__PARA__L5}\n  for (i = 1; i < 90; i++) {\n    u[i] = u[i] + 1.0 / (1.0)...\n        * (v[i] + v[i + 1] + v[i + 2] - u[i] - u[i + 1] - u[i + 2]);\n  }\n  v[1] = STENCIL_120(u);\n }\n// Matrix multiplication A*B\n      fori = 0;\n      forj = 0;\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 1; i < 39; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (j = 1; j < 39; j++) {\n      A[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (k = 1; k < 39; k++) {\n        A[i][j] += B[i][k] * C[k][j];\n      }\n    }\n  }\n}\n \nint main() {\n   int i;\n   int j;\n   int k;\n   int k_col;\n   int i_row;\n   int j_col;\n   double tmp;\n   double mul1;\n   double mul2;\n   double _in_A[39][39];\n   double _in_B[39][39];\n   double _in_C[39][39];\n   double _out_AR[39][39];\n   double _out_BR[39][39];\n   double _out_CR[39][39];\n   double _out_Q[39][39];\n   double _out_P[39][39];\n   double _out_S[39][39];\n   double _out_R[39][39];\n   double _out_Q1[39][39];\n   double _out_P1[39][39];\n   double _out_S1[39][39];\n   double _out_R1[39][39];\n   double _in_A_tmp_buf[39][39] = {({ 0 }) tmp_buf[j_col];\n      }\n      #pragma ACCEL PIPELINE auto{__PIPE__L3}\n      #pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n      #pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j_col = 1; j_col < 39 - 2; j_col++) {\n        mul1 = _in_A[i][j_col + 1] * _in_B[j_col + 1][j];\n        mul2 = _in_A[i][j_col + 2] * _in_B[j_col + 2][j];\n        _out_AR[i][j] = _out_AR[i][j] - mul1 * _in_C[j_col + 1][j];\n        _out_BR[i][j] = _out_BR[i][j] - mul1 * _in_C[j_col + 2][j];\n        _out_CR[i][j] = _out_CR[i][j] - mul2 * _in_C[j_col + 2][j];\n        _out_Q[i][j] = _out_Q[i][j] - mul1 * _out_P[j_col + 1][j];\n        _out_P[i][j] = _out_P[i][j] - mul1 * _out_S[j_col + 1][j];\n        _out_S[i][j] = _out_S[i][j] - mul1 * _out_R[j_col + 1][j];\n        _out_R[i][j] = _out_R[i][j] - mul2 * _out_S[j_col + 2][j];\n        tmp = 1.0 / (1.0)...\n            - mul1.\n            * mul1.\n            - mul2.\n            * mul2.\n            + 2.0.\n            * _in_A[i][j_col].\n            * _in_B[j_col][j];\n        _out_Q1[i][j] = tmp * _out_Q[i][j];\n        _out_P1[i][j] = tmp * _out_P[i][j];\n        _out_S1[i][j] = tmp * _out_S[i][j];\n        _out_R1[i][j] = tmp * _out_R[i][j];\n      }\n    }\n  }\n//data consistency check\n   fori = 0;\n   forj = 0;\n  for (i = 1; i < 39; i++) {\n    for (j = 1; j < 39; j++) {\n      tmp = 0.0;\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k_col = 1; k_col < 39; k_col++) {\n        tmp += _out_A[i][k_col] * _out_B[k_col][j];\n      }\n      if (fabs(tmp - _out_Q[i][j]) > 1e-5) {\n        assert(0);\n      }\n    }\n  }\n   fori = 0;\n   forj = 0;\n  for (i = 1; i < 39; i++) {\n    for (j = 1; j < 39; j++) {\n      tmp = 0.0;\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L13}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L13}\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L13}\n      for (i_row = 1; i_row < 39; i_row++) {\n        tmp += _out_A[i_row][i] * _out_P[i_row][j];\n      }\n      if (fabs(tmp - _out_P[i][j]) > 1e-5) {\n        assert(0);\n      }\n    }\n  }\n   fori = 0;\n   forj = 0;\n  for (i = 1; i < 39; i++) {\n    for (j = 1; j < 39; j++) {\n      tmp = 0.0;\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L14}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L14}\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L14}\n      for (i_row = 1; i_row < 39; i_row++) {\n        tmp += _out_A[i_row][i] * _out_S[i_row][j];\n      }\n", "4": " The default value for the 'parallel' switch is auto{2}.\n #pragma ACCEL PIPELINE auto{off}\n \n#pragma ACCEL TILE FACTOR=auto{1}\n \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 32; t++) {\n     dt = ((double )t) * 2.0;\n     tmp = 0.0;\n     dv = 0.0;\n     zero = 0.0;\n     rho = 0.0;\n     for (i = 1; i <= 30; i++) {\n        tmp += pow(f[i],2);\n        l[i] = 2.0 * M_PI * y[i] * f[i];\n        r[i] = 2.0 * M_PI * z[i] * f[i];\n     }\n     for (j = 1; j <= 30; j++) {\n        if (j != 1) {\n           u[j] = u[j] - b / tmp * (f[j] * g[j - 1] - f[j - 1] * g[j]);\n        }\n        b = s[j] - 2.0 * M_PI * (((double )(pow(sp[j],2) * u[j] * u[j] / (4.0 * M_PI * M_PI) - y[j] * u[j] * (g[j] - u[j]) / (2.0 * M_PI ) - z[j] * u[j] * (f[j] - 1.0) / (4.0 * M_PI))) + y[j] * y[j] / (4.0 * M_PI ) + z[j] * z[j] / (4.0 * M_PI )) - a / tmp * (g[j] - u[j]);\n        a = a - b / tmp * (g[j] - u[j]);\n        dv += f[j] * (y[j] * u[j]) - g[j] * (z[j] * u[j]);\n        zero = g[j] - (((double )(sp[j] * u[j] * u[j] / (4.0 * M_PI) - y[j] * u[j])) / a);\n        rho += f[j] * ((y[j] * u[j]) * (y[j] * u[j]) / (4.0 * M_PI ) + (z[j] * u[j]) * (z[j] * u[j]) / (4.0 * M_PI ) - (y[j] * zero) / a);\n     }\n     r[31] = 0.0;\n     l[31] = 0.0;\n     for (i = 30; i >= 1; i--) {\n        l[i] = l[i] - b / tmp * (f[i] * g[i + 1] - f[i + 1] * g[i]);\n        r[i] = r[i] - a / tmp * (g[i] - u[i]);\n     }\n     for (i = 1; i <= 30; i++) {\n        s[i] = M_PI * (2.0 * (f[i] * u[i] - g[i]) - dv / a);\n        w[i] = y[i] * u[i] - s[i];\n        v[i] = z[i] * u[i] - (f[i] - 1.0) * s[i];\n     }\n     for (i = 1; i <= 30; i++) {\n       g[i] = 2.0 * M_PI * y[i] * f[i] * u[i] / a;\n       f[i] = ((f[i] * u[i]) * (g[i] - u[i]) - (y[i] * u[i]) * rho) / (g[i] - 2.0 * l[i] - r[i]);\n    }\n    f[31] = 1.0 - dv / a;\n    g[31] = 0.0;\n  }\n}\n"}}
{"input": "Process this loop in its original, full form without breaking it into smaller chunks\n#pragma ACCEL PIPELINE auto{off}\n\nDivide the loop into smaller chunks with a factor of 1 along the specified dimension\n#pragma ACCEL TILE FACTOR=auto{1}\n\nRun the iterations of this loop in parallel with a factor of 2\n#pragma ACCEL PARALLEL FACTOR=auto{2}\n\nTreat the following function as a hardware kernel for acceleration\n#pragma ACCEL kernel", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 2L * j;\n        int _in_i = 2L * i;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "1": "\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 2L * j;\n        int _in_i = 2L * i;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": "\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": "\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1 * i + 240 - 1;\n        int j_col = -1 * j + 240 - 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n"}}
{"input": "Process the following nested loops with tiling, automatically determine the tile factor for the outermost loop and use a tile factor of 8 for the middle loop. Pipeline the loops automatically, except for the innermost loop, which should be pipelined with a flatten option.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{8}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    for (j = 0; j < 220; j++) {\n      double temp = alpha * B[i][j];\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L5}\n      for (k = 0; k < 200; k++) {\n        C[i][j] += temp * A[i][k];\n      }\n    }\n  }\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 30; t++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 120 - 1; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int orig_A[4096],int sol[4096],int filter[9])\n{\n  int r;\n  int c;\n  int r0;\n  int r1;\n  int r2;\n  int r3;\n  int r4;\n  int r5;\n  int r6;\n  int r7\n  int c0;\n  int c1;\n  int c2;\n  int c3\n  int c4;\n  int c5;\n  int c6;\n  int c7\n  int flnr;\n  int flnc;\n  int temp;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  loop_r:\n  for (r = 0; r < 32; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    loop_rc0:\n    for (rc0 = 4 * r + 0; rc0 < 4 * r + 3; rc0++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      loop_c0:\n      for (c0 = 4 * r + 0; c0 < 4 * r + 3; c0 += 8) {\n        temp = orig_A[rc0 * 32 + c0];\n        loop_flnr:\n        for (flnr = 0; flnr < 3; flnr++) {\n          loop_flnc:\n          for (flnc = 0; flnc < 3; flnc++) {\n            temp += filter[flnr * 3 + flnc] * orig_A[(r0 + flnr) * 32 + c0 + flnc];\n          }\n        }\n        sol[rc0 * 32 + c0] = temp;\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    loop_rc1:\n    for (rc1 = 4 * r + 1; rc1 < 4 * r + 3; rc1++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n      loop_c1:\n      for (c1 = 4 * r + 1; c1 < 4 * r + 3; c1 += 8) {\n        temp = orig_A[rc1 * 32 + c1];\n        loop_flnr_1:\n        for (flnr = 0; flnr < 3; flnr++) {\n          loop_flnc_1:\n          for (flnc = 0; flnc < 3; flnc++) {\n            temp += filter[flnr * 3 + flnc] * orig_A[(r1 + flnr) * 32 + c1 + flnc];\n          }\n        }\n        sol[rc1 * 32 + c1] = temp;\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n    loop_rc2:\n    for (rc2 = 4 * r + 2; rc2 < 4 * r + 3; rc2++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n      loop_c2:\n      for (c2 = 4 * r + 2; c2 < 4 * r + 3; c2 += 8) {\n        temp = orig_A[rc2 * 32 + c2];\n        loop_flnr_2:\n        for (flnr = 0; flnr < 3; flnr++) {\n          loop_flnc_2:\n          for (flnc = 0; flnc < 3; flnc++) {\n            temp += filter[flnr * 3 + flnc] * orig_A[(r2 + flnr) * 32 + c2 + flnc];\n          }\n        }\n        sol[rc2 * 32 + c2] = temp;\n      }\n    }\n  }\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int orig_A[25][20],int sol[25][20],int filter[3][3])\n{\n  int i;\n  int j;\n  int k;\n  int l;\n  int i0;\n  int j0;\n  int tmp;\n  int tmp_row;\n  int tmp_col;\n  int mul;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  loopj:\n  for (j = 2; j < 18; j++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    loopi:\n    for (i = 2; i < 18; i++) {\n      tmp_row = ((int )0);\n      \n#pragma ACCEL PIPELINE auto{off}\n      loopk:\n      for (k = 0; k < 3; k++) {\n        tmp_col = ((int )0);\n        \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n        loopl:\n        for (l = 0; l < 3; l++) {\n          i0 = i - 1 + k;\n          j0 = j - 1 + l;\n          mul = filter[k][l] * orig_A[i0][j0];\n          tmp_col += mul;\n        }\n        tmp_row += tmp_col;\n      }\n      sol[i][j] = tmp_row;\n      tmp = orig_A[i][j];\n      aj < 20; j++) {\n    orig_A[i][j] = ((int )1);\n  }\n}\n}\ndd = (tmp_row - tmp);\n      mul = (seidel_coeff * add);\n      if (mul < ((int )0)) {\n        mul = -mul;\n      }\n      if (mul < ((int )1e-2)) {\n        mul = ((int )1e-2);\n      }\n      if (mul > ((int )1e2)) {\n        mul = ((int )1e2);\n      }\n      mul = mul * orig_A[i][j];\n      if (mul > ((int )(18 * 20))) {\n        mul = ((int )(18 * 20));\n      }\n      if (mul < ((int )(-18 * 20))) {\n        mul = ((int )(-18 * 20));\n      }\n      orig_A[i][j] = tmp + mul;\n    }\n  }\n}\nvoid kernel_seidel_2d_init(int orig_A[25][20],int filter[3][3])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 25; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (j = 0; j < 20; j++) {\n      orig_A[i][j] = (i * j + 1) + 1;\n    }\n  }\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n  for (i = 0; i < 3; i++) {\n    for (j = 0; j < 3; j++) {\n      filter[i][j] = 1;\n    }\n  }\n}\nvoid kernel_seidel_2d_exit(int sol[25][20])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 2; i < 25 - 2; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (j = 2; j < 20 - 2; j++) {\n      sol[i][j] = ((long )((double )sol[i][j] * sqrt(((double )((int )1)) / ((double )seidel_coeff)))) + ((long )((double )((int )18) * sqrt(((double )((int )1)) / ((double )seidel_coeff)))) + ((long )(orig_A[i][j])) - ((long )(sol[i - 2L][j - 2L])) - ((long )(sol[i - 2L][j])) - ((long )(sol[i][j - 2L])) - ((long )(sol[i - 2L][j + 2L])) - ((long )(sol[i + 2L][j - 2L])) - ((long )(sol[i + 2L][j])) - ((long )(sol[i][j + 2L]));\n    }\n  }\n}\nint main()\n{\n  int orig_A[25][20] = {{1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}};\n  int sol[25][20] = {{0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}};\n  int filter[3][3] = {{1, 1, 1}, {1, -7, 1}, {1, 1, 1}};\n  \n#pragma ACCEL kernel\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  kernel_seidel_2d(orig_A,sol,filter);\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n  kernel_seidel_2d_exit(sol);\n}\n \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n\nvoid kernel_seidel_2d(int orig_A[25][20],int sol[25][20],int filter[3][3])\n{\n  int i;\n  int j;\n  int k;\n  int l;\n  int i0;\n  int j0;\n  int tmp;\n  int tmp_row;\n  int tmp_col;\n  int mul;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  loopj:\n  for (j = 2; j < 18; j++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    loopi:\n    for (i = 2; i < 18; i++) {\n      tmp_row = ((int )0);\n      \n#pragma ACCEL PIPELINE auto{off}\n      loopk:\n      for (k = 0; k < 3; k++) {\n        tmp_col = ((int )0);\n        \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n        loopl:\n        for (l = 0; l < 3; l++) {\n          i0 = i - 1 + k;\n          j0 = j - 1 + l;\n          mul = filter[k][l] * orig_A[i0][j0];\n          tmp_col += mul;\n        }\n        tmp_row += tmp_col"}}
{"input": "To generate the given HLS codes in C, follow the natural language instructions provided below:\n\n1. Mark the following function as a hardware kernel for acceleration.\n   Use: 'Treat the following function as a hardware kernel for acceleration'.\n\n2. Don't automatically pipeline the loop.\n   Use: '#pragma ACCEL PIPELINE \"off\"'\n\n3. Process this loop in its original, full form without breaking it into smaller chunks.\n   Use: '#pragma ACCEL TILE FACTOR=1'\n\n4. Run the iterations of this loop one after the other, not in parallel.\n   Use: '#pragma ACCEL PARALLEL FACTOR=1'\n\n5. Auto-pipeline the loop with default settings.\n   Use: '#pragma ACCEL PIPELINE auto{}'\n\n6. Set the tiling factor of the loop to be determined automatically.\n   Use: '#pragma ACCEL TILE FACTOR=auto{1}'\n\n7. Set the parallelization factor of the loop to be determined automatically, with a default factor of 2.\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{2}'\n\n8. Set the parallelization factor of the loop to be determined automatically, with a specific factor of 16.\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{16}'\n\n9. Set the parallelization factor of the loop to be determined automatically, with a specific factor of 3.\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{3}'\n\nBy following these natural language instructions, you can generate the given HLS codes in C.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L8}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 2 * j;\n        int _in_i = 2 * i;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][_in_j + 1] - ex[i][_in_j] + ey[ _in_i + 1][j] - ey[ _in_i][j]);\n      }\n    }\n  }\n}\n", "2": "\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 2L * (j + 1) - 1 - 1;\n        int _in_i = 2L * (i + 1) - 1 - 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i % 100);\n        int i_row = 2L * (i / 100);\n        int j_col = 2L * (j % 100);\n        int j_row = 2L * (j / 100);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_row][j_col] - ex[i_row][j_col + 1] + ey[j_row][i_col] - ey[j_row + 1][i_col]);\n      }\n    }\n  }\n}\n", "4": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes in C, use the following natural language instruction:\n\n\"Annotate the function as a hardware kernel for acceleration, and for the loop iterations:\n- Enable automatic loop pipelining\n- Use an automatic tile factor of 1\n- Parallelize the outer loop with a factor of 2, and the inner loops with factors of 3 and 1 respectively.\"", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        double sum_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=sum_tmp FACTOR=auto{__PARA__L3}\n\tfor (s = 0; s < 30; s++) {\n          sum_tmp += A[r][q][s] * C4[s][p];\n        }\n\tsum[p] = sum_tmp;\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        z_pe[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 1; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n      for (j = 1; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ey[i + 1][j] - ey[i][j] + ex[i][j + 1] - ex[i][j]);\n      }\n    }\n  }\n}\n"}}
{"input": "To optimize the given C code for hardware acceleration, you should use the following HLS pragmas:\n\n1. Use `#pragma ACCEL PIPELINE off` to prevent automatic pipelining of the loop.\n\n2. Use `#pragma ACCEL TILE FACTOR=1` to process the loop in its original, full form without breaking it into smaller chunks.\n\n3. Use `#pragma ACCEL PARALLEL FACTOR=2` to execute iterations of the loop in parallel with a factor of 2.\n\n4. Finally, declare the function as a hardware kernel for acceleration using `#pragma ACCEL kernel`.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{24}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 2L * (j + 1) - 1 - 1;\n        int _in_i = 2L * (i + 1) - 1 - 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "1": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 2L * (j + 1) - 1 - 1;\n        int _in_i = 2L * (i + 1) - 1 - 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_low = i - 1;\n        int i_high = i + 1;\n        int j_low = j - 1;\n        int j_high = j + 1;\n        double out = ((double )0);\n        double ex0 = ex[i][j];\n        double ey0 = ey[i][j];\n        double hz0 = hz[i][j];\n        double _in_j = ey[i_low][j_high];\n        double _in_j_1 = ey[i_low][j];\n        double _in_j_2 = ey[i_low][j_low];\n        double _in_j_3 = ey[i][j_high];\n        double _in_0 = ex[i_high][j_low];\n        double _in_1 = ex[i_high][j];\n        double _in_2 = ex[i_high][j_high];\n        double _in_3 = hz[i_low][j_low];\n        double _in_4 = hz[i_low][j];\n        double _in_5 = hz[i_low][j_high];\n        double _in_6 = hz[i][j_low];\n        double _in_7 = hz[i][j_high];\n        double _in_8 = hz[i_high][j_low];\n        double _in_9 = hz[i_high][j_high];\n        out += ((_in_j - ey0) * ((_in_0 - ex0) / (_in_3 - _in_4))) + ((_in_j_1 - ey0) * ((_in_1 - ex0) / (_in_5 - _in_4)));\n        out += ((_in_j_2 - ey0) * ((_in_2 - ex0) / (_in_7 - _in_4)));\n        out += ((_in_j_3 - ey0) * ((_in_1 - ex0) / (_in_5 - _in_6)));\n        ey[i][j] = out;\n        hz[i][j] = ex0 - 0.5 * (ex[i][j] - ex[i][j]) + 0.5 * (ey[i][j] - ey0) + 0.5 * (hz[i][j] - hz0) + 0.5 * (_in_8 - hz0);\n      }\n    }\n  }\n}\n", "4": "\n\n#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DX_2;\n  double DY_2;\n  double DX_4;\n  double DY_4;\n  double DX_6;\n  double DY_6;\n  double DX_8;\n  double DY_8;\n  double NDX;\n  double NDY;\n  double tmp;\n  double mul1;\n  double mul2;\n  double mul3;\n  double mul4;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  DX = 1.0 / ((double )60);\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  DY = 1.0 / ((double )60);\n  DX_2 = DX * DX;\n  DY_2 = DY * DY;\n  DX_4 = DX_2 * DX_2;\n  DY_4 = DY_2 * DY_2;\n  DX_6 = DX_4 * DX_2;\n  DY_6 = DY_4 * DY_2;\n  DX_8 = DX_6 * DX_2;\n  DY_8 = DY_6 * DY_2;\n  NDX = -1.0 * DX;\n  NDY = -1.0 * DY;\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 39; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      mul1 = DX_2 * ((double )((int )((++tmp))));\n      mul2 = DY * ((double )(60 - 1));\n      a = u[0][i] - DT * ((((u[0][i] - u[0][(i - 1)] ) + (u[0][(i + 1)] - u[0][i])) * DX_2 ) + ((v[0][i] - v[0][(i - 1)]) * (DY2 ) + ((u[0][(i + 1)] - (double )2.0f * u[0][i] + u[0][(i - 1)]) * DY ) ));\n      b = v[0][i] - DT * ((((v[0][i] - v[0][(i - 1)]) + (v[0][(i + 1)] - v[0][i])) * DX_2 ) + (((q[i] - q[((i - 1) + 1)]) * DY_2 ) + (v[0][(i + 1)] - (double )2.0f * v[0][i] + v[0][(i - 1)]) * DY ) );\n      c = p[i][0] - DT * ( - 1.0 * (a) * (d) + (b) * ((double )((int )((++tmp)))) );\n      d = p[i][60 - 1] - DT * ( - 1.0 * (a) * (c) - 1.0 * (b) * NDX );\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 1; j < 59; j++) {\n        mul3 = mul1 * ((double )((int )((++tmp))));\n        mul4 = mul2 * ((double )((int )((++tmp))));\n        e = u[j][i] - DT * ((((u[j][i] - u[j][(i - 1)]) + (u[j][(i + 1)] - u[j][i])) * DX_2 ) + ((v[j][i] - v[j][(i - 1)]) * (DY2 ) + ((u[j][(i + 1)] - (double )2.0f * u[j][i] + u[j][(i - 1)]) * DY ) ));\n        f = v[j][i] - DT * ((((v[j][i] - v[j][(i - 1)]) + (v[j][(i + 1)] - v[j][i])) * DX_2 ) + (((q[i] - q[((j - 1) + 1) * 60]) * DY_2 ) + (v[j][(i + 1)] - (double )2.0f * v[j][i] + v[j][(i - 1)]) * DY ) ));\n        p[j][i] = p[j][i] - DT * (a * (p[j][i] - p[j][(i - 1)]) - b * (p[j][i] - p[j][(i + 1)]) + d * (e - p[j][(i - 1)]) - c * (f - p[j][(i + 1)]));\n      }\n      p[0][i] = 0.0;\n      p[60 - 1][i] = 0.0;\n      u[0][i] = 0.0;\n      v[0][i] = 0.0;\n      q[i] = 0.0;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 1; i < 59; i++) {\n      mul1 = DY_2 * ((double )((int )((++tmp))));\n      mul2 = DX * ((double )(60 - 1));\n      a = u[i][0] - DT * ((((u[i][0] - u[i][(0 - 1)]) + (u[i][(1 + 0)] - u[i][0])) * DY_2 ) + ((v[i][0] - v[i][(0 - 1)]) * (DX2 ) + ((u[i][(1 + 0)] - (double )2.0f * u[i][0] + u[i][(0 - 1)]) * DX ) ));\n      b = v[i][0] - DT * ((((v[i][0] - v[i][(0 - 1)]) + (v[i][(1 + 0)] - v[i][0])) * DY_2 ) + (((p[i][(1 + 0)] - p[i][((0 - 1) + 1)]) * DX_2 ) + (v[i][(1 + 0)] - (double )2.0f * v[i][0] + v[i][(0 - 1)]) * DX ) );\n      c = p[i][0] - DT * ( - 1.0"}}
{"input": "To generate the given HLS codes in C:\n\n1. Activate kernel acceleration for the function 'kernel_jacobi_1d'.\n2. Deactivate automatic loop pipelining for all loops in the function.\n3. Set the loop tiling factor to 1 for maximum performance.\n4. Set the loop parallelization factor for the outer loop to 2, and for the inner loops to 3 and 12 respectively.\n\nThis set of natural language instructions describes how to use specific #pragma values for HLS code generation.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "2": " \n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n"}}
{"input": "Generate HLS code for the given C code: \n\nUse the following pragma directives:\n1. Mark the function as a hardware kernel for acceleration: `#pragma ACCEL kernel`\n2. Turn off automatic pipelining for the outer two loops: `#pragma ACCEL PIPELINE auto{off}`\n3. Process the outer loops in their original, full form without breaking them into smaller chunks: `#pragma ACCEL TILE FACTOR=auto{1}`\n4. Apply automatic pipelining for the innermost loop: `#pragma ACCEL PIPELINE auto{}`\n5. Divide the innermost loop into chunks of 4 for tiling: `#pragma ACCEL TILE FACTOR=auto{4}`", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{}\n      \n#pragma ACCEL TILE FACTOR=auto{4}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n #pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j;\n        int _in_i;\n        _in_j = j + 1;\n        _in_i = i + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": "\n\n\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{32}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n\n\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n\n**/\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "Process the following function as a hardware kernel for acceleration. Don't automatically pipeline the loops. Process the loops in their original, full form without breaking them into smaller chunks. Run the iterations of the loops one after the other, not in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{}\n      \n#pragma ACCEL TILE FACTOR=auto{8}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1*i;\n        int j_col = j + 1;\n        hz[i_col][j_col] = hz[i_col][j_col] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[j + 1][i] - ey[j][i]);\n      }\n    }\n  }\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 0 + 1L * jump;\n        int _in_i = 0 + 1L * tile;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i % 10L);\n        int j_col = 2L * (j % 10L);\n        hz[i][j] = hz[i][j] - 0.25 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]) + _fict_[i_col * (240) + j_col];\n      }\n    }\n  }\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = -mul2 / 2.0;\n  c = 1.0 + a + mul1;\n  d = 1.0 + mul2;\n  e = a * DX * DX;\n  f = b * DY * DY;\n// Section A\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 39; t++) {\n// Loop u_scope{0}\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n    }\n// Loop u_scope{1}\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        u[i][j] =  - (((u[i - 1][j]) * a) + ((v[i][j - 1]) * b) + b1);\n      }\n    }\n// Loop u_scope{2}\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        v[i][j] =  - (((u[i][j - 1]) * e) + ((v[i - 1][j]) * f) + b2);\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To generate the given HLS codes in C, use the following natural language instructions and corresponding #pragma values:\n\n1. **Process this loop without automatic pipelining**: \n   - Describe: Ensure manual control over loop pipelining\n   - Pragma: `#pragma ACCEL PIPELINE \"off\"`\n\n2. **Keep the loop in its original, full form without breaking it into smaller chunks**:\n   - Describe: Set loop tiling factor to 1\n   - Pragma: `#pragma ACCEL TILE FACTOR=1`\n\n3. **Run the iterations of this loop one after the other, not in parallel**:\n   - Describe: Set loop parallelization factor to 1\n   - Pragma: `#pragma ACCEL PARALLEL FACTOR=1`\n\n4. **Treat the following function as a hardware kernel for acceleration**:\n   - Describe: Mark the function as a hardware accelerator\n   - Pragma: `#pragma ACCEL kernel`", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n/* Matrix multiplication */\n  \n#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "1": "\n\n/* Matrix multiplication */\n \nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "2": "\n\n/* Evaluate the first 500 members of the series: \n * 1 + 1/1! + 1/2! + 1/3! + ... + 1/k!\n */\n #pragma ACCEL kernel\n\nvoid bbgemm(double nx,double ny,double nz,double alpha,double beta,double ex[40][50],double ey[50][60],double eze[40][60],double sz[40][50])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (k = 0; k < 60; k++) {\n      eze[i][k] = 0.0;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (j = 0; j < 50; j++) {\n      \n#pragma ACCEL PARALLEL reduction=sz FACTOR=auto{__PARA__L3}\n      for (k = 0; k < 60; k++) {\n        sz[i][j] += alpha * ey[j][k] * eze[i][k];\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (k = 0; k < 50; k++) {\n      \n#pragma ACCEL PARALLEL reduction=ex FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 60; j++) {\n        ex[i][k] += beta * nz * ey[k][j] * sz[i][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n\n/* Eigendecomp: Eigendecomposition of a symmetric matrix.\n *\n * [V,D] = Eigendecomp(A) computes the eigendecomposition of a square matrix\n *   A. V is a matrix whose columns are the eigenvectors of A. D is a\n *   diagonal matrix whose elements are the corresponding eigenvalues of A.\n */\n #pragma ACCEL kernel\n\nvoid kernel_eigendecomp(int m,double A[40][40],double D[40],double V[40][40])\n{\n  int i;\n  int j;\n  int k;\n  int l;\n  double b;\n  double r;\n  double f;\n  double t;\n  double b1;\n  double max;\n  double mul;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  triagloop:\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    eigtkloop:\n    for (k = i; k < 40; k++) {\n      b = A[k][i];\n      r = sqrt((((A[k][i] * A[k][i]) + (A[i][i] * A[i][i])) - (A[k][i] * A[i][k])));\n      if (k == i) {\n        if (b > 0.0) {\n          r = -r;\n        }\n        D[i] = A[i][i] + r;\n      }\n      else {\n        if (b >= 0.0) {\n          f = 1.0 / (2.0 * b);\n          t = f * ((A[i][i] - A[k][k]) + r);\n        }\n        else {\n          f = -1.0 / (2.0 * b);\n          t = f * ((A[i][i] - A[k][k]) - r);\n        }\n        D[k] = b + t;\n        mul = f * A[i][k];\n        eigtvlloop:\n        for (j = i; j < 40; j++) {\n          A[k][j] = A[k][j] - mul * A[i][j];\n        }\n        eigtvecloop:\n        for (j = i; j < 40; j++) {\n          b1 = A[j][i];\n          A[j][i] = A[j][k] - mul * A[j][k];\n          A[j][k] = b1;\n        }\n      }\n      max = -3.141592653589793e+0;\n      eigtvec2loop:\n      for (l = 0; l < 40; l++) {\n        if (l != i && l != k) {\n          if (A[l][i] > max) {\n            max = A[l][i];\n          }\n        }\n      }\n      vcolloop:\n      for (l = 0; l < 40; l++) {\n        if (l != i && l != k) {\n          if (A[l][i] >= max * 0.0001) {\n            mul = A[l][i] / (A[l][i] - max);\n            V[l][i] = mul * V[l][i] - V[l][k];\n          }\n        }\n      }\n    }\n  }\n}\n", "4": "\n\n/* DGEMM  Performs one of the matrix-matrix operations\n  C := alpha*A*B + beta*C,\n  where alpha and beta are scalars, A is a general rectangular matrix\n  and B and C are general rectangular matrices.\n  \n  Arguments\n  =========\n  \n  TRANSA - CHARACTER*1.\n           On entry, TRANSA specifies the form of op( A ) to be used in\n           the matrix multiplication as follows:\n               \n   TRANSA = 'N' or 'N'   A is transposed, but not conjugated.\n  \n   TRANSA = 'C' or 'C'   A is conjugated and transposed.\n   \n   TRANSA is a  blas character variable\n   \n   TRANSB - CHARACTER*1.\n           On entry, TRANSB specifies the form of op( B ) to be used in\n           the matrix multiplication as follows:\n               \n   TRANSB = 'N' or 'N'   B is transposed, but not conjugated.\n  \n   TRANSB = 'C' or 'C'   B is conjugated and transposed.\n   \n   TRANSB is a  blas character variable\n   \n   M      - INTEGER.\n           On entry,  M  specifies  the number  of rows  of  the  matrix\n           op( A )  and of the  matrix  C.  M  must  be at least  zero.\n           Unchanged on exit.\n   \n   N      - INTEGER.\n           On entry,  N  specifies the number  of columns of the matrix\n           op( A ) and the number of columns of the matrix  C. N must be\n           at least zero.\n           Unchanged on exit.\n   \n   K      - INTEGER.\n           On entry,  K  specifies  the number of columns of the matrix\n           op( B ) and the number of rows of the matrix op( A ). K must\n           be at least  zero.\n           Unchanged on exit.\n   \n   ALPHA  - DOUBLE PRECISION.\n           On entry, ALPHA specifies the scalar alpha.\n           Unchanged on exit.\n   \n   A      - DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is\n           k  when  TRANSA = 'N' or 'n',  and is  m  otherwise.\n           Before entry with  TRANSA = 'N' or 'n',  the leading  m by k\n           part of the array  A  must contain the matrix  A,  otherwise\n           the leading  k by m  part of the array  A  must contain  the\n           matrix A.\n           Unchanged on exit.\n   \n   LDA    - INTEGER.\n           On entry, LDA specifies the first dimension of A as declared\n           in the calling (sub) program. When  TRANSA = 'N' or 'n' then\n           LDA must be at least  max( 1, m ), otherwise  LDA must be at\n           least  max( 1, k ).\n           Unchanged on exit.\n   \n   B      - DOUBLE PRECISION array of DIMENSION ( LDB, kb ), where kb is\n           n  when  TRANSB = 'N' or 'n',  and is  k  otherwise.\n           Before entry with  TRANSB = 'N' or 'n',  the leading  k by n\n           part of the array  B  must contain the matrix  B,  otherwise\n           the leading  n by k  part of the array  B  must contain  the\n           matrix B.\n           Unchanged on exit.\n   \n   LDB    - INTEGER.\n           On entry, LDB specifies the first dimension of B as declared\n           in the calling (sub) program. When  TRANSB = 'N' or 'n' then\n           LDB must be at least  max( 1, k ), otherwise  LDB must be at\n           least  max( 1, n ).\n           Unchanged on exit.\n   \n   BETA   - DOUBLE PRECISION.\n           On entry,  BETA  specifies the scalar  beta.  When  BETA  is\n           supplied as zero then C need not be set on input.\n           Unchanged on exit.\n   \n   C      - DOUBLE PRECISION array of DIMENSION ( LDC, n ).\n           Before entry, the leading  m by n  part of the array  C must\n           contain the matrix  C,  except when  beta  is zero, in which\n           case C need not be set on entry.\n           On exit, the array  C  is overwritten by the  m by n  matrix\n           ( alpha*op( A )*op( B ) + beta*C ).\n   \n   LDC    - INTEGER.\n           On entry, LDC specifies the first dimension of C as declared\n           in the calling (sub) program. LDC must be at least\n           max( 1, m ).\n           Unchanged on exit.\n   \n   Further Details\n   ===============\n   \n   Level 3 Blas routine.   \n   \n   -- Written on 8-February-1989.   \n   Jack Dongarra, Argonne National Laboratory.   \n   Iain Duff, AERE Harwell.   \n   Jeremy Du Croz, Numerical Algorithms Group Ltd.   \n   Sven Hammarling, Numerical Algorithms Group Ltd.   \n   \n   -- Modified 8-Nov-93 to set CL3JUMP = .TRUE. if SCALEA = SCALEB = 1.   \n   --   SJH, 1993-10.   \n   ----------------------------------------------------------------------- */\n   /* Table of constant values */\n   \n   static doublecomplex c_b1 = {0.0,0.0} ;\n   static doublecomplex c_b2 = {1.0,0.0} ;\n   static double alpha = 1.0;\n   static double beta = 1.0;\n   \n#include \"dgemm.h\"\n   /* System generated locals */\n   int a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2;\n   double d__1;\n   \n   /* Local variables */\n   static int k, m1, n1, n2, n1b, n2b;\n   static double beta1;\n   static double s1, s2, t1, t2;\n   static double a11, a12, a21, a22, b11, b12, b21, b22;\n   static double tmp;\n   static doublecomplex z__1;\n   static double r1, d12;\n   static double d22;\n   static double r2, d21;\n   static double t128;\n   static double s228;\n   static double t228;\n   static double s216;\n   static double d11;\n   static double s116;\n   static double s128;\n   static double s12;\n   static double s22;\n   static double s16;\n   static double s26;\n   static double s18;\n   static double s28;\n   static double s61;\n   static double s62;\n   static double s64;\n   static double s68;\n   static double s82;\n   static double s86;\n   static double s88;\n   static double s112;\n   static double s1168;\n   static double s1282;\n   static double s1286;\n   static double s144;\n   static double s1472;\n   static double s1632;\n   static double s168;\n   static double s1824;\n   static double s1872;\n   static double s192;\n   static double s1984;\n   static double s2048;\n   static double s2112;\n   static double s2144;\n   static double s2176;\n   static double s2224;\n   static double s2256;\n   static double s2288;\n   static double s2352;\n   static double s2400;\n   static double s2464;\n   static double s2528;\n   static double s254"}}
{"input": "To generate the given HLS codes written in C, use the following natural language instructions for the specific #pragma values:\n\n1. For the outer loop, automatically pipeline the loop without flattening it: \n   ```\n   #pragma ACCEL PIPELINE auto{flatten}\n   ```\n\n2. Tile the loop with a factor automatically determined to be 1: \n   ```\n   #pragma ACCEL TILE FACTOR=auto{1}\n   ```\n\n3. Parallelize the outer loop with a factor automatically determined to be 2: \n   ```\n   #pragma ACCEL PARALLEL FACTOR=auto{2}\n   ```\n\n4. Parallelize the inner loop with a factor automatically determined to be 20: \n   ```\n   #pragma ACCEL PARALLEL FACTOR=auto{20}\n   ```\n\n5. Parallelize another inner loop with a factor automatically determined to be 1: \n   ```\n   #pragma ACCEL PARALLEL FACTOR=auto{1}\n   ```\n\nAdditionally, treat the `kernel_jacobi_1d` function as a hardware kernel for acceleration:\n```\n#pragma ACCEL kernel\n```", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n", "1": "\n\n### **Auto-tuned Kernel**\n\n```\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n```\n", "2": "\n\nHere is the original code:\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n\n### Generated Code\n     #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n\n### **Testing**\n\nTheoritical kernel execution time:\n```\n <<KERNEL_SCORE>> \n```\n\nMeasured kernel execution time:\n"}}
{"input": "To generate the given HLS codes in C, use the following high-level synthesis (HLS) pragmas:\n\n1. Treat the following function as a hardware kernel for acceleration\n   - Natural language instruction: \"Designate this function as a hardware kernel\"\n   - HLS pragma: #pragma ACCEL kernel\n\n2. Don't automatically pipeline this loop\n   - Natural language instruction: \"Do not automatically pipeline this loop\"\n   - HLS pragma: #pragma ACCEL PIPELINE \"off\"\n\n3. Process this loop in its original, full form without breaking it into smaller chunks\n   - Natural language instruction: \"Process this loop with a tile factor of 1\"\n   - HLS pragma: #pragma ACCEL TILE FACTOR=1\n\n4. Run the iterations of this loop one after the other, not in parallel\n   - Natural language instruction: \"Execute this loop sequentially, without parallelization\"\n   - HLS pragma: #pragma ACCEL PARALLEL FACTOR=1\n\nFor the placeholders \"auto\", \"__PARA__L0\", \"__PARA__L4\", \"__PARA__L1\", \"__PARA__L5\", \"__PARA__L2\", \"__PIPE__L3\", \"__TILE__L3\", \"__PIPE__L7\", and \"__PARA__L7_0\", the specific values for these placeholders should be determined based on the specific design and optimization goals. These values need to be chosen based on the particular characteristics and requirements of the target hardware architecture.", "output": "#include <math.h>\n#pragma ACCEL kernel\n\nvoid kernel_correlation(double float_n,double data[100][80],double corr[80][80],double mean[80],double stddev[80])\n{\n  int i;\n  int j;\n  int k;\n  double eps = 0.1;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n  for (j = 0; j < 80; j++) {\n    mean[j] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 100; i++) {\n      mean[j] += data[i][j];\n    }\n    mean[j] /= float_n;\n  }\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n  for (j = 0; j < 80; j++) {\n    stddev[j] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 0; i < 100; i++) {\n      stddev[j] += pow(data[i][j] - mean[j],(double )2);\n    }\n    stddev[j] /= float_n;\n    stddev[j] = sqrt(stddev[j]);\n/* The following in an inelegant but usual way to handle\n         near-zero std. dev. values, which below would cause a zero-\n         divide. */\n    stddev[j] = (stddev[j] <= eps?1.0 : stddev[j]);\n  }\n/* Center and reduce the column vectors. */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (i = 0; i < 100; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (j = 0; j < 80; j++) {\n      data[i][j] -= mean[j];\n      data[i][j] /= sqrt(float_n) * stddev[j];\n    }\n  }\n/* Calculate the m * m correlation matrix. */\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 80 - 1; i++) {\n    corr[i][i] = 1.0;\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L7}\n    for (j = i + 1; j < 80; j++) {\n      corr[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7_0}\n      for (k = 0; k < 100; k++) {\n        corr[i][j] += data[k][i] * data[k][j];\n      }\n      corr[j][i] = corr[i][j];\n    }\n  }\n  corr[80 - 1][80 - 1] = 1.0;\n}\n", "predicted": {"0": "\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "1": " The optimizer will automatically select the fastest implementations based on hardware characteristics and targeted issues.\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_0}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[j];\n    }\n    \n#pragma ACCEL PIPELINE auto{off_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1_1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_1}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1_1_0}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1_2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_2}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1_2_0}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1_3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_3}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1_3_0}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": " A list of general placeholder values is provided below. These values are only guidelines and these placeholder values should be interpreted based on the target architecture.\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[j];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L7}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L7}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7_0}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 2L * j;\n        int _in_i = 2L * i;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": " The optimizer will automatically evaluate the impact of these options for the selected target hardware and populate the above pragmas with optimal values.\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L7}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L7}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7_0}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_up = i + 1;\n        int j_right = j + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_up][j] - ex[i][j]) - 0.7 * (ey[i][j_right] - ey[i][j]) + 1.0 * q[i][j];\n      }\n    }\n  }\n}\n", "4": " A list of common placeholder values and their possible values can be found in the section \"Common AutoTiler Pragmas\" of the AutoTiler User Guide.\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n"}}
{"input": "Process the loop iterations in parallel with an automatically determined factor, treat the following function as a hardware kernel for acceleration. For the loop that initializes array 's' with 0 values, do not automatically pipeline the loop. For the nested loop that performs matrix multiplication and reductions, process it in its original, full form without breaking it into smaller chunks.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L4}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{1}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=s FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        s[k] += alpha * A[i][k] * B[k][j];\n      }\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += s[k];\n      }\n    }\n  }\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=A FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        A[i][k]:\n        C[i][j] += alpha * B[k][j] * A[i][k];\n      }\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes, use the following comprehensive but concise natural language instruction:\n\n\"Designate the following function as a hardware kernel for acceleration, and automatically pipeline the loop. Then, process the loop in its original, full form without breaking it into smaller chunks, and run the iterations of this loop in parallel with a factor of 2. Within the loop, also run certain iterations in further parallel with a factor of 3 and 10.\"\n\nThis instruction covers the use of the following #pragma values:\n1. '#pragma ACCEL kernel' to designate the function as a hardware kernel for acceleration\n2. '#pragma ACCEL PIPELINE auto{}' to automatically pipeline the loop\n3. '#pragma ACCEL TILE FACTOR=auto{1}' to process the loop in its original, full form without breaking it into smaller chunks\n4. '#pragma ACCEL PARALLEL FACTOR=auto{2}' to run the iterations of the loop in parallel with a factor of 2\n5. '#pragma ACCEL PARALLEL FACTOR=auto{3}' and '#pragma ACCEL PARALLEL FACTOR=auto{10}' to run specific iterations within the loop in further parallel with factors of 3 and 10, respectively.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n\n** kernel \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_up = i + 1;\n        int j_up = j + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": "\n\n *\n * File path:\n *\tautotune_blas_gemm.c\n *\n * Tool:\n *\tAUTOPILOT\n *\n * Descriptions:\n *\tdouble gemm(double m1[4096],double m2[4096],double prod[4096])\n *\n */\n\n#pragma ACCEL kernel\n\nvoid gemm(double m1[4096],double m2[4096],double prod[4096])\n{\n  int i;\n  int j;\n  int k;\n  int k_col;\n  int i_col;\n  double mult;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  outer:\n  for (i = 0; i < 64; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    middle:\n    for (j = 0; j < 64; j++) {\n      i_col = i * 64;\n      double sum = (double )0;\n      \n#pragma ACCEL PARALLEL reduction=sum FACTOR=auto{10}\n      inner:\n      for (k = 0; k < 64; k++) {\n        k_col = k * 64;\n        mult = m1[i_col + k] * m2[k_col + j];\n        sum += mult;\n      }\n      prod[i_col + j] = sum;\n    }\n  }\n}\n", "3": "\n\n**Note**: This example references a BLAS library. BLAS is an external library and is not provided by ARM.\n\n#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{_in_4}\n  \n#pragma ACCEL TILE FACTOR=auto{16}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (j = 0; j < 220; j++) {\n      double tmp = A[i][0] * B[0][j];\n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (k = 1; k < 200; k++) {\n        tmp += A[i][k] * B[k][j];\n      }\n      C[i][j] += alpha * tmp;\n    }\n  }\n}\n", "4": "\n\n *\n * File loop_row.c: \n * \n * Code based on previous loop_row.c version, Apr 14 2006 10:04:51\n * \n * \n * \n * PARAMS:\n *  I = 240 \n *  J = 280 \n *  TMP = 240 \n *  N = 40 \n *  NC = 40 \n *  NR = 20 \n *  NQ = 240 \n *  PQ = 16 \n *  P = 2 \n *  Q = 2 \n */\n #include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/time.h>\n#include <unistd.h>\n#include <stdbool.h>\n#include \"../benchmarks.h\"\n\n#include \"bench_main.h\"\n\n\ndouble kernel_doitgen(double A[240][280], double C4[40][40], double sum[40])\n{\n  int i;\n  int p;\n  int q;\n  int j;\n  int p_col;\n  int q_col;\n  double mult;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  loop_p:\n  for (i = 0; i < 240; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    loop_q:\n    for (j = 0; j < 280; j++) {\n      sum[i] = 0.0;\n      loop_p_col:\n      for (p = 0; p < 20; p++) {\n        p_col = i * 20 + p;\n        loop_q_col:\n        for (q = 0; q < 240; q++) {\n          q_col = j * 240 + q;\n          mult = A[p_col][q_col] * A[q_col][j];\n          sum[i] = sum[i] + mult;\n        }\n      }\n      A[i][j] = sum[i] + C4[i][j];\n    }\n  }\n}\n\n\ndouble kernel_dotprod(double A[240][280], double B[240][280], double C[240][280])\n{\n  int i;\n  int j;\n  int k;\n  int k_col;\n  int i_col;\n  double mult;\n  double sum;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  loop_i:\n  for (i = 0; i < 240; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    loop_j:\n    for (j = 0; j < 280; j++) {\n      i_col = i * 240;\n      sum = 0.0;\n      loop_k:\n      for (k = 0; k < 20; k++) {\n        k_col = i * 20 + k;\n        mult = A[k_col][j] * B[i_col + k];\n        sum = sum + mult;\n      }\n      C[i_col + j] = sum;\n    }\n  }\n}\n\n\ndouble kernel_triad(double A[240][280], double B[240][280], double C[240][280])\n{\n  int i;\n  int j;\n  int k;\n  int k_col;\n  int i_col;\n  double mult_1;\n  double mult_2;\n  double add;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  loop_i:\n  for (i = 0; i < 240; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    loop_j:\n    for (j = 0; j < 280; j++) {\n      i_col = i * 240;\n      loop_k:\n      for (k = 0; k < 20; k++) {\n        k_col = i * 20 + k;\n        mult_1 = B[k_col][j] * A[k_col][j];\n        loop_k_col:\n        for (k_col = i * 20; k_col < (i * 20 + 20); k_col++) {\n          mult_2 = B[i_col + k][k_col] * A[k_col][j];\n          add = mult_1 + mult_2;\n          C[i_col + k_col] = C[i_col + k_col] + add;\n        }\n      }\n    }\n  }\n}\n\n\nint main(int argc,char **argv) {\n  double A[240][280];\n  double B[240][280];\n  double C[240][280];\n  double D[240][280];\n  double C4[40][40];\n  double sum[40];\n  double rA[20][240][280];\n  double rB[20][240][280];\n  double rC[20][40][280];\n  double rD[20][240][280];\n  double res[40][240][280];\n  double tmp[40][280];\n  double tmp_1[240][280];\n  double tmp_2[240][280];\n  double tmp_3[40][280];\n  double res_1[40][240][280];\n  double exp[40][240][280];\n  double check[40][240][280];\n  double e;\n  int i;\n  int j;\n  int k;\n  \n#pragma ACCEL kernel\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  init_kernel:\n  for (i = 0; i < 240; i++) {\n    init_kernel_0:\n    for (j = 0; j < 280; j++) {\n      A[i][j] = (double )0;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n  init_kernel_1:\n  for (i = 0; i < 240; i++) {\n    init_kernel_2:\n    for (j = 0; j < 280; j++) {\n      B[i][j] = (double )0;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n  init_kernel_3:\n  for (i = 0; i < 240; i++) {\n    init_kernel_4:\n    for (j = 0; j < 280; j++) {\n      C[i][j] = (double )0;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n  init_kernel_"}}
{"input": "Process the entire loop in its original, full form without breaking it into smaller chunks, run the iterations of this loop in parallel with automatic factor determination, and avoid automatically pipelining this loop. Treat the following function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 0 + 1L;\n        int _in_i = ((int )i) + 1L;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 0 + 1L;\n        int _in_i = ((int ) i) + 1L;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 0 + 1L;\n        int _in_i = ((int )i) + 1L;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1;\n        int j_col = -1;\n        double dxy = 0.0;\n        double ex_x = 0.0;\n        double ey_y = 0.0;\n        double hz_x = 0.0;\n        double hz_y = 0.0;\n        double _in_0 = ex[i][j];\n        hz_x = ex[i][j + 1] - _in_0;\n        dxy = ey[i][j] - _fict_[t];\n        ex_x = dxy * ((hz[i][j + 1] - hz[i][j]) / (hz[i][j + 1] - hz[i][j]));\n        ey_y = dxy * ((hz[i + 1][j] - hz[i][j]) / (hz[i + 1][j] - hz[i][j]));\n        hz_y = -1.0 * (ex_x + ey_y);\n        dxy = hz[i][j] + hz_x + hz_y;\n        hz[i][j] = dxy;\n        ex[i][j + 1] = _in_0 + ex_x;\n        ey[i + 1][j] = _fict_[t] + ey_y;\n      }\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes in C, you would use the following natural language instruction:\n\n\"Mark the following function as a hardware kernel for acceleration and then specify specific optimizations for loops, such as: run the iterations of the loop one after the other, not in parallel; don't automatically pipeline this loop; and process this loop in its original, full form without breaking it into smaller chunks. Also, parallelize the following loop with a factor of 'auto'.\"\n\nThis comprehensive instruction covers the pragma values used in the provided HLS codes.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L8}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1 * i + 120;\n        int j_col = -1 * j + 120;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": " The following is the C version of the kernel for the target function:\n #pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": " The following table describes the corresponding pragma values for the natural language instruction:\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DX_2;\n  double DY_2;\n  double DX_4;\n  double DY_4;\n  double DX_6;\n  double DY_6;\n  double C1;\n  double C2;\n  double C1_2;\n  double C1_4;\n  double C1_6;\n  double N1;\n  double N2;\n  double N3;\n  double N4;\n  double N5;\n  double N6;\n  double M1;\n  double M2;\n  double M3;\n  double M4;\n  double M5;\n  double M6;\n  double tmp;\n  double mul1;\n  double mul2;\n  double mul3;\n  double mul4;\n  double mul5;\n  double mul6;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DX_2 = DX * 2.0;\n  DY_2 = DY * 2.0;\n  DX_4 = DX_2 * DX_2;\n  DY_4 = DY_2 * DY_2;\n  DX_6 = DX_4 * DX_2;\n  DY_6 = DY_4 * DY_2;\n  C1 = 3.0 * (DX_2 * DY_2) - DX_4 * DY_2;\n  C2 = 3.0 * (DX_2 * DY_4) - DX_4 * DY_4;\n  C1_2 = C1 * 2.0;\n  C1_4 = C1 * 4.0;\n  C1_6 = C1 * 6.0;\n  N1 = -1.0 / (DX_2 * DY);\n  N2 = 1.0 / (2.0 * DX_2 * DY);\n  N3 = -1.0 / (2.0 * DX_4 * DY);\n  N4 = 1.0 / (4.0 * DX_4 * DY);\n  N5 = -1.0 / (2.0 * DX_6 * DY);\n  N6 = 1.0 / (6.0 * DX_6 * DY);\n  M1 = 1.0 / (2.0 * DX_2 * DY_2);\n  M2 = -1.0 / (2.0 * DX * DY_2);\n  M3 = 1.0 / (2.0 * DX_2 * DY_4);\n  M4 = 1.0 / (4.0 * DX_4 * DY_2);\n  M5 = -1.0 / (2.0 * DX_4 * DY_4);\n  M6 = 1.0 / (4.0 * DX_6 * DY_2);\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 39; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      DX_2 = DX * ((double )(60 - 2 * 1));\n      DY_2 = DY * ((double )(60 - 2 * 1));\n      DX_4 = DX_2 * DX_2;\n      DY_4 = DY_2 * DY_2;\n      DX_6 = DX_4 * DX_2;\n      DY_6 = DY_4 * DY_2;\n      C1 = 3.0 * (DX_2 * DY_2) - DX_4 * DY_2;\n      C2 = 3.0 * (DX_2 * DY_4) - DX_4 * DY_4;\n      C1_2 = C1 * ((double )2);\n      C1_4 = C1 * ((double )4);\n      C1_6 = C1 * ((double )6);\n      N1 = -1.0 / (((double )2) * DX_2 * DY);\n      N2 = 1.0 / (((double )2) * DX_2 * DY);\n      N3 = -1.0 / (((double )4) * DX_4 * DY);\n      N4 = 1.0 / (((double )4) * DX_4 * DY);\n      N5 = -1.0 / (((double )6) * DX_6 * DY);\n      N6 = 1.0 / (((double )6) * DX_6 * DY);\n      M1 = 1.0 / (((double )2) * DX_2 * DY_2);\n      M2 = -1.0 / (((double )2) * DX * DY_2);\n      M3 = 1.0 / (((double )2) * DX_2 * DY_4);\n      M4 = 1.0 / (((double )4) * DX_4 * DY_2);\n      M5 = -1.0 / (((double )4) * DX_4 * DY_4);\n      M6 = 1.0 / (((double )4) * DX_6 * DY_2);\n      a = ((((N1 * (S2(i + 1, j) - S2(i - 1, j)) - N4 * (S4(i + 1, j) - S4(i - 1, j))) - N5 * (S6(i + 1, j) - S6(i - 1, j))) - N6 * (S8(i + 1, j) - S8(i - 1, j))) - (M2 * u2(i, j + 1) - M2 * u2(i, j - 1)));\n      b = ((((N2 * (S2(i + 1, j + 1) - S2(i - 1, j + 1)) - N4 * (S4(i + 1, j + 1) - S4(i - 1, j + 1))) - N5 * (S6(i + 1, j + 1) - S6(i - 1, j + 1))) - N6 * (S8(i + 1, j + 1) - S8(i - 1, j + 1))) - (M3 * u2(i, j + 2) - M3 * u2(i, j - 2)));\n      c = ((((N3 * (S2(i + 2, j) - S2(i - 2, j)) - N4 * (S4(i + 2, j) - S4(i - 2, j))) - N5 * (S6(i + 2, j) - S6(i - 2, j))) - N6 * (S8(i + 2, j) - S8(i - 2, j))) - (M4 * u2(i, j + 1) - M4 * u2(i, j - 1)));\n      d = ((((N1 * (S4(i + 1, j) - S4(i - 1, j)) - N3 * (S6(i + 1, j) - S6(i - 1, j))) - N5 * (S8(i + 1, j) - S8(i - 1"}}
{"input": "To generate the given HLS code in C, use the following natural language instruction:\n\n- \"Designate the following function as a hardware kernel for acceleration\"\n- \"For the outer loop, automatically pipeline the processing\"\n- \"Break the outer loop into smaller chunks in a way that best suits the target platform\"\n- \"For the middle loop, turn off automatic pipelining\"\n- \"Process the middle loop in its original, full form without breaking it into smaller chunks\"\n- \"For the innermost loop, flatten the loop for parallel processing\"\n- \"Process the innermost loop in its original, full form without breaking it into smaller chunks\"", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction=D FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n\n#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "2": "\n- \"For the kernel, exploit multistage parallelism\"\n- \"For the kernel, exploit task parallelism\"\n- \"For the kernel, exploit work-group parallelism\"\n\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n- \"For the outer loop, automatically parallelize the processing\"\n- \"Set the number of kernel threads to 16\"\n- \"For the middle loop, automatically parallelize the processing\"\n- \"Set the number of kernel threads to 1\"\n- \"For the innermost loop, automatically parallelize the processing\"\n- \"Set the number of kernel threads to 8\"\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "\n- \"For the inner loop, manually pipeline the processing\"\n- \"Manually unroll the inner loop by a factor of 4\"\n- \"For the outer loop, manually parallelize the processing\"\n- \"Manually parallelize the outer loop by a factor of 8\"\n- \"For the middle loop, manually parallelize the processing\"\n- \"Manually parallelize the middle loop by a factor of 2\"\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _row = i * 240 + j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n"}}
{"input": "Process the calculations in the kernel function in parallel and treat the function as a hardware kernel for acceleration. The first loop should be parallelized with a parallel factor calculated automatically and the loop body processed without automatic pipelining. Use a tiling factor calculated automatically for the second loop and parallelize it with a factor calculated automatically, then add a reduction clause to the inner loop with a parallel factor calculated automatically.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n"}}
{"input": "Process the loop in its original, full form without breaking it into smaller chunks and don't automatically pipeline this loop, run the iterations of this loop one after the other, not in parallel. Treat the following function as a hardware kernel for acceleration.\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": " #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 0 + 1L;\n        int _in_i = ((int )i) + 1L;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "1": " #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 0 + 1L;\n        int _in_i = ((int )i) + 1L;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": " #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        z_diff[0] = hz[i][j] - hz[i][j + 1];\n        z_diff[1] = hz[i][j + 1] - hz[i + 1][j + 1];\n        z_diff[2] = hz[i + 1][j + 1] - hz[i + 1][j];\n        ex[i][j] += 0.7071 * (sig_ex * (z_diff[0] - z_diff[1]) + nx * (ey[i][j + 1] - ey[i][j]));\n        ey[i][j] += 0.7071 * (sig_ey * (z_diff[1] - z_diff[2]) + ny * (ex[i + 1][j] - ex[i][j]));\n        hz[i][j] += 0.7071 * (sig_hz * (z_diff[0] - z_diff[2]) + nz * (ex[i][j + 1] - ex[i][j]) + (ex[i][j + 1] - ex[i][j]) * (ey[i + 1][j] - ey[i][j]));\n      }\n    }\n  }\n}\n", "3": " #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1;\n        int j_col = -1;\n        double dxy_x = 0.0;\n        double dxy_y = 0.0;\n        double ex_x = 0.0;\n        double ex_y = 0.0;\n        double ey_x = 0.0;\n        double ey_y = 0.0;\n        double hz_x = 0.0;\n        double hz_y = 0.0;\n        double _in_1 = 0.0;\n        double _in_2 = 0.0;\n        double _in_3 = 0.0;\n        double _in_4 = 0.0;\n        double _in_5 = 0.0;\n        double _in_6 = 0.0;\n        double _in_7 = 0.0;\n        double _in_8 = 0.0;\n        i_col = 1 + i;\n        j_col = 1 + j;\n        dxy_x = (((double )ex[i_col][j]) - ((double )ex[i][j])) / (((double )(i + 1)) - ((double )i));\n        dxy_y = (((double )ey[i][j_col]) - ((double )ey[i][j])) / (((double )(j_col + 1)) - ((double )(j)));\n        ex_x = dxy_x - ey[i][j] * dxy_y;\n        ex_y = ey[i_col][j] * dxy_x - dxy_y;\n        ey_x = dxy_x + ey[i][j] * dxy_y;\n        ey_y = ((double )-1.0) * dxy_x - ex[i][j] * dxy_y;\n        hz_x = dxy_x - 0.5 * (hz[i_col][j] - hz[i][j]);\n        hz_y = dxy_y - 0.5 * (hz[i][j_col] - hz[i][j]);\n        _in_1 = ex[i][j] + ex_x;\n        _in_2 = ey[i][j] + ex_y;\n        _in_3 = hz[i][j] + hz_x;\n        _in_4 = _in_2 + ey_x;\n        _in_5 = ey[i][j_col] + ey_y;\n        _in_6 = hz[i][j_col] + hz_y;\n        _in_7 = _in_1 * _in_4;\n        _in_8 = _in_3 * _in_5;\n        ex[i][j] = _in_7;\n        ey[i][j] = _in_8;\n        hz[i][j] = _in_6;\n      }\n    }\n  }\n}\n", "4": " #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1;\n        int j_col = -1;\n        double dxy = 0.0;\n        double ex_x = 0.0;\n        double ey_y = 0.0;\n        double hz_x = 0.0;\n        double hz_y = 0.0;\n        double _in_0 = ex[i][j];\n        data_t ex_0 = _in_0;\n        data_t ey_x = diff_coef->ey[i][j] * ex_0;\n        data_t hz_x_x = diff_coef->hz[i][j] * ex_x;\n        data_t ey_y_x = diff_coef->ey[i][j] * ey_x;\n        data_t hz_x_x_x = diff_coef->hz[i][j] * hz_x_x;\n        data_t tmp = ey[i][j + 1];\n        data_t hz_y_x = diff_coef->hz[i][j] * ey_y_x;\n        data_t tmp_x = ey[i + 1][j];\n        data_t del_x = tmp_x - tmp;\n        data_t _in_1 = del_x;\n        data_t ey_y_x_x = _in_1 * ey_y_x;\n        data_t _in_2 = hz[i][j];\n        data_t hz_z_x = _in_2 * hz_x_x;\n        data_t _in_3 = tmp;\n        data_t hz_z_x_x = _in_3 * hz_x_x_x;\n        data_t dxy_x = ey_y_x_x + hz_z_x_x;\n        data_t _in_4 = hz[i + 1][j];\n        data_t hz_z_y = _in_4 * hz_y_x;\n        data_t _in_5 = tmp;\n        data_t hz_z_y_x = _in_5 * hz_y_x_x;\n        data_t dxy_y = hz_z_y + hz_z_y_x;\n        data_t n = -1.0;\n        data_t dt = 1.0;\n        data_t dx = 1.0;\n        data_t dy = 1.0;\n        data_t dzt = dt * dx * dy;\n        data_t dxy_dt = dxy * dt;\n        data_t dxy_dx = dxy_x * dx;\n        data_t dxy_dy = dxy_y * dy;\n        data_t six_dx2 = 6.0 * (dx * dx);\n        data_t six_dy2 = 6.0 * (dy * dy);\n        data_t five_dz2 = 5.0 * (dzt * dzt);\n        data_t five_dx2_dt2 = 2.0 * (five_dx2 * (dt * dt));\n        data_t five_dy2_dt2 = 2.0 * (five_dy2 * (dt * dt));\n        data_t four_dz2_dt2 = 2.0 * (four_dz2 * (dt * dt));\n        data_t five_dx_dt = 5.0 * (dx * (dt));\n        data_t five_dy_dt = 5.0 * (dy * (dt));\n        data_t four_dz_dt = 4.0 * (dzt * (dt));\n        data_t four_dx2_dy2 = four_dx2 * four_dy2;\n        data_t four_dx2_dz2 = four_dx2 * four_dz2;\n        data_t four_dy2_dz2 = four_dy2 * four_dz2;\n        data_t four_dx_dt2 = 4.0 * (dx * (dt * dt));\n        data_t four_dy_dt2 = 4.0 * (dy * (dt * dt));\n        data_t four_dz_dt2 = 4.0 * (dzt * (dt * dt));\n        data_t p = ((((six_dx2 * ey_y + six_dy2 * ex_x) + hz_x_x) + hz_y_y) - (dxy_dt + (n * dzt)));\n        data_t q = ((((six_dx2 * ey_x + six_dy2 * ex_y) + hz_x_y) + hz_y_x) - (dxy_dx + (n * dzt)));\n        data_t r = (((four_dx2_dt2 * ey_y + four_dy2_dt2 * ex_x) + four_dz2_dt2 * ex_ex_x) + (((four_dx2_dy2 * ey_y + four_dy2_dx2 * ex_x) + four_dz2_dx2 * ex_ey_x) + hz_x_x) - (dxy_dx * dxy_dt + (n * (four_dz2_dx2 * ex_x + four_dx2_dz2 * ey_x + two_dz_dt * (ex_x * ex_x + ey_x * ey_"}}
{"input": "To generate the HLS codes written in C, use the following comprehensive but very concise natural language instructions for the specific #pragma values:\n\n- Treat the following function as a hardware kernel for acceleration\n  - describe: `#pragma ACCEL kernel`\n\n- Don't automatically pipeline this loop\n  - describe: `#pragma ACCEL PIPELINE \"off\"`\n\n- Process this loop in its original, full form without breaking it into smaller chunks\n  - describe: `#pragma ACCEL TILE FACTOR=1`\n\n- Run the iterations of this loop one after the other, not in parallel\n  - describe: `#pragma ACCEL PARALLEL FACTOR=1`\n\nThese instructions correspond to the HLS codes and their respective #pragma values in the given C code.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction=D FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 2 * j;\n        int _in_i = 2 * i;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][_in_j + 1] - ex[i][_in_j] + ey[ _in_i + 1][j] - ey[ _in_i][j]);\n      }\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS code in C, you should:\n1. Treat the following function as a hardware kernel for acceleration.\n2. Don't automatically pipeline the loops.\n3. Process the loops with their original, full form without breaking them into smaller chunks.\n4. Run the iterations of the loops one after the other, not in parallel.\n\nThe natural language instructions for the pragma values are as follows:\n- '#pragma ACCEL kernel': Treat the following function as a hardware kernel for acceleration.\n- '#pragma ACCEL PIPELINE auto{off}': Don't automatically pipeline the loops.\n- '#pragma ACCEL TILE FACTOR=auto{1}': Process the loops with their original, full form without breaking them into smaller chunks.\n- '#pragma ACCEL PARALLEL FACTOR=auto{2}': Run the iterations of the loops one after the other, not in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2_0}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{off_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1_1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2_1}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2_1_0}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1_2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2_2}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2_2_0}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1_3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2_3}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2_3_0}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 2*(j + 1) - 1 - 0;\n        int _in_i = 2*(i + 1) - 1 - 0;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": "\n \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 2L * (j + 1) - 1 - 1;\n        int _in_i = 2L * (i + 1) - 1 - 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": "\n  \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_up = i + 1;\n        int j_up = j + 1;\n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7_0}\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_up][j] - ex[i][j]) - 0.7 * (ey[i][j_up] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "\n\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n"}}
{"input": "Process the first loop in parallel with a factor of 1, then pipeline the loop, and finally, process the second loop in parallel with a factor of 1 and utilize reduction for the inner loop.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 30; t++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 120 - 1; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL PIPELINE auto{off}\n\n#pragma ACCEL TILE FACTOR=auto{1}\n  for (j = 1; j < 128; j++) {\n    tmp = _in[j];\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 256; i++) {\n      double col_j = _in[i * 128 + j];\n      \n      _out[i * 128 + j] = (tmp + col_j);\n    }\n  }\n}\n", "2": " \n #pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (tj = 1; tj <= 20; tj++) {\n    tmp2 = 0.0;\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (ti = 1; ti <= 40; ti++) {\n      tmp2 += A[tj][ti] * x[ti];\n    }\n    y[tj] = 0.0;\n    sum = 0.0;\n    \n#pragma ACCEL PARALLEL reduction=sum FACTOR=auto{__PARA__L3}\n    for (ti = 1; ti <= 40; ti++) {\n      sum += B[tj][ti] * A[tj][ti];\n      y[tj] += pow(B[tj][ti],2) * x[ti] + sum;\n    }\n  }\n}\n", "3": "\n #pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n  for (j = 1; j <= 32; j++) {\n/* Standardize from: for(k = 1...\n     Standardize to: for(k = 1...\n     #pragma ACCEL PIPELINE auto{__PIPE__L1}\n     for (k = 1; k <= 32; k++) {\n      e = a[j] - b[k];\n      d = c[j] - d[k];\n      product = e * d;\n      f[k] += product;\n      g[j] += e * f[k];\n      h[k] += d * f[k];\n     }\n     */\n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n     for (k = 1; k <= 32; k++) {\n      e = a[j] - b[k];\n      d = c[j] - d[k];\n      product = e * d;\n      f[k] += product;\n      g[j] += e * f[k];\n      h[k] += d * f[k];\n     }\n    }\n   }\n  }\n  ttmp = ((double )0);\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (k = 1; k <= 32; k++) {\n    ttmp += ((double )h[k]);\n  }\n  \n#pragma ACCEL ENDASSEMBLY\n}\n", "4": "\n #pragma ACCEL PIPELINE auto{off}\n\n#pragma ACCEL TILE FACTOR=auto{1}\n  for (tile_i = 0; tile_i < 8; tile_i++) {\n    L1 = 0.0;\n    L2 = 0.0;\n    L3 = 0.0;\n    L4 = 0.0;\n    prefetch_array_q_2(tile_i,q_2);\n\n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n\n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 400; i++) {\n      L1 += (q_2[i] - p_2[i]) * (q_2[i] - p_2[i]);\n      L2 += (q_2[i] - p_1[i]) * (q_2[i] - p_1[i]);\n      L3 += (q_2[i] - p_0[i]) * (q_2[i] - p_0[i]);\n      L4 += (q_2[i] - p_1[i]) * (q_2[i] - p_0[i]);\n    }\n  }\n\n  E_2 = L1 + L2;\n  SSE = L3 + L4;\n//SSE_original = fabs(SSE_original);\n\n  *E = E_2;\n  *SSE_in = SSE;\n  return;\n}\n"}}
{"input": "To generate the given HLS codes in C, apply the following comprehensive natural language instructions:\n\n1. Treat the following function as a hardware kernel for acceleration.\n\n2. Don't automatically pipeline the outermost loop.\n\n3. Process the outermost loop in its original, full form without breaking it into smaller chunks.\n\n4. Automatically pipeline the middle loop.\n\n5. Process the middle loop in its original, full form without breaking it into smaller chunks.\n\n6. Automatically pipeline the innermost loop.\n\n7. Process the innermost loop in its original, full form without breaking it into smaller chunks.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5_0}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{off_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1_1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5_1}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5_1_0}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1_2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5_2}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5_2_0}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1_3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5_3}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5_3_0}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": "\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L50}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L51}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L52}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_up = i + 1;\n        int j_up = j + 1;\n#pragma ACCEL PARAM INDEX=__INDEX__L8\n        hz[i][j] = 0.25 * (ex[i][j] - ex[i_up][j]) * (ey[i][j] - ey[i][j_up]) + ey[i][j_up] - ey[i_up][j_up];\n      }\n    }\n  }\n}\n"}}
{"input": "Process the following function as a hardware kernel for acceleration. Run the iterations of the first loop one after the other, not in parallel. Don't automatically pipeline the second loop. Process the second loop in its original, full form without breaking it into smaller chunks. Run the iterations of the third loop and the inner loop one after the other, not in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": " Don't automatically pipeline the third loop. Pipeline the fourth loop with off\n//#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n}\n", "1": " Don't automatically pipeline the third loop. Pipeline the fourth loop with off\npragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[i - 1][j] + A[i - 1][j - 1] + A[i - 1][1 + j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[i - 1][j] + B[i - 1][j - 1] + B[i - 1][1 + j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": " Pipeline the third loop.\n #pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": " Don't automatically pipeline the third loop. Pipeline the fourth loop.\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 3{\n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (j = 1; j < 89; j++) {\n      B[i][j] = 0.33333 * (A[i][j - 1] + A[i][j] + A[i][j + 1]);\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n  for (t = 0; t < 390; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 1; i < 89; i++) {\n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.33333 * (B[i][j - 1] + B[i][j] + B[i][j + 1]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": " Don't automatically pipeline the third loop.\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n  for (t = 0; t < 3B[i - 1][j]) + A[i][j - 1] + A[i][j + 1]) - B[i][j]) / 4.0;\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = A[i][j];\n      }\n    }\n    \n#pragma endscop\n}\n"}}
{"input": "Process the nested loops in their original form, without breaking them into smaller chunks, and run the iterations of the loops one after the other, not in parallel. Additionally, treat the 'kernel_doitgen' function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{2}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(int A[25][20][30],int B[25][20][30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        B[r][q][p] = ((long )0);\n      }\n    }\n    for (s = 0; s < 30; s++) {\n      for (q = 0; q < 20; q++) {\n        for (p = 0; p < 30; p++) {\n          if (p < s) {\n            B[r][q][p] += A[r][q][s] * B[r][q][s];\n          }\n        }\n      }\n    }\n    for (s = 0; s < 30; s++) {\n      for (q = 0; q < 20; q++) {\n        for (p = 0; p < 30; p++) {\n          if (s < p) {\n            B[r][q][p] += A[r][q][s] * B[r][q][s];\n          }\n        }\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(int A[25][20][30],int B[25][20][30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        B[r][q][p] = ((long )0);\n      }\n    }\n    for (s = 0; s < 30; s++) {\n      for (q = 0; q < 20; q++) {\n        for (p = 0; p < 30; p++) {\n          if (p < s) {\n            B[r][q][p] += A[r][q][s] * B[r][q][s];\n          }\n        }\n      }\n    }\n    for (s = 0; s < 30; s++) {\n      for (q = 0; q < 20; q++) {\n        for (p = 0; p < 30; p++) {\n          if (p == s) {\n            B[r][q][p] = A[r][q][s];\n          }\n        }\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(int A[25][20][30],int B[25][20][30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        B[r][q][p] = A[r][q][p];\n      }\n    }\n    for (s = 0; s < 30; s++) {\n      for (q = 0; q < 20; q++) {\n        int _in_val = A[r][q][s];\n        B[r][q][s] = _in_val * ((_in_val > 0.0) ? 1.0 : -1.0);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(int A[25][20][30],int C4[30][28][20])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = ((long )r) * (((long )q) * (((long )p) * 2));\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n      for (p = 0; p < 30; p++) {\n        \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n        for (i = 1; i < 5; i++) {\n          s = r + 2;\n          t = q + 2;\n#pragma ACCEL PARALLEL reduction=C4 FACTOR=auto{__PARA__L6}\n          for (j = 0; j < 4; j++) {\n            C4[p][s + j][t] += A[r][q][p + j] * ((long )i) * 2;\n          }\n        }\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][25])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = ((double )0);\n      }\n    }\n    for (p = 0; p < 30; p++) {\n      A[r][14][p] = 4.0;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n      for (p = 0; p < 30; p++) {\n        for (s = 0; s < 25; s++) {\n          A[s][q][p] += ((double )4) * A[r][q][p] * A[s][r][p];\n        }\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      for (p = 0; p < 30; p++) {\n        C4[p][r] = A[r][q][p];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To generate the given HLS code in C, use the following natural language instructions:\n\n1. Treat the following function as a hardware kernel for acceleration.\n2. Don't automatically pipeline this loop.\n3. Process this loop in its original, full form without breaking it into smaller chunks.\n4. Run the iterations of this loop one after the other, not in parallel.\n\nApply these instructions to the respective pragma values in the code.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2_0}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{off_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1_1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2_1}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2_1_0}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1_2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2_2}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2_2_0}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1_3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2_3}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2_3_0}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "3": "\n  \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _row = i * 240 + j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n"}}
{"input": "Process the loop in its original, full form without breaking it into smaller chunks, and do not automatically pipeline it. Also, treat the following function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{2}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "  \n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "  \n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "2": "  \n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 0 + 1L * j;\n        int _in_i = 0 + 1L * i;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": " #pragma ACCEL kernel\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "  \n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        double  _val_27 = 0.0;\n        double  _val_28 = 0.0;\n        double  _val_29 = 0.0;\n        double  _val_30 = 0.0;\n        double  _val_31 = 0.0;\n        double  _val_32 = 0.0;\n        double  _val_33 = 0.0;\n        double  _val_34 = 0.0;\n        double  _val_35 = 0.0;\n\t_val_27 = ex[i][j + 1] - ex[i][j];\n\t_val_28 = ey[i + 1][j] - ey[i][j];\n\t_val_29 = hz[i][j + 1] - hz[i][j];\n\t_val_30 = ex[i + 1][j + 1] - ex[i + 1][j];\n\t_val_31 = ey[i + 1][j + 1] - ey[i + 1][j];\n\t_val_32 = hz[i + 1][j + 1] - hz[i + 1][j];\n\t_val_33 = hz[i + 1][j] - hz[i + 1][j];\n\t_val_34 = hz[i][j] - hz[i][j + 1];\n\t_val_35 = _val_29 + _val_33;\n        ey[i][j] = _val_31 + (_val_28 * _val_35);\n        _ecm[i][j] = _val_32 - (_val_27 * _val_34 + _val_28 * _val_35);\n        ex[i][j] = _val_30 + (_val_27 * _val_34 + _val_29 * _val_35);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n      for (j = 0; j < 240; j++) {\n        hz[i][j] = _ecm[i][j];\n      }\n    }\n  }\n}\n"}}
{"input": "Process the loop with the original code as a hardware kernel for acceleration and automatically parallelize and pipeline the loop while leveraging reduction for parallelization. Use the pragma '#pragma ACCEL kernel' to mark the function as a hardware kernel, '#pragma ACCEL PARALLEL FACTOR=auto{1}' to automatically parallelize the loop, '#pragma ACCEL PIPELINE auto{flatten}' to automatically pipeline the loop, and '#pragma ACCEL PARALLEL reduction FACTOR=auto{1}' to automatically leverage reduction for parallelization.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[410][390],double s[390],double q[410],double p[390],double r[410])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 390; i++) {\n    s[i] = ((double )0);\n    q[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 410; i++) {\n    q[0] += r[i] * A[i][0];\n    s[0] += r[i] * A[i][0];\n  }\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 390; i++) {\n    p[i] = q[i] / s[0];\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 410; i++) {\n    q[0] = 0.0;\n    for (j = 0; j < 390; j++) {\n      q[j] += r[i] * A[i][j];\n      p[j] = q[j] / s[0];\n      s[0] += r[i] * A[i][j] * p[j];\n    }\n  }\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  for (i = 0; i < 116; i++) \n    s[i] = ((double )0);\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    r[i] = 0.0;\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    p[i] = s[i] - q[115];\n  }\n//#pragma endscop\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[410][390],double s[390],double q[410],double p[390],double r[410])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 390; i++) {\n    s[i] = ((double )0);\n    q[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 410; i++) {\n    q[0] += r[i] * A[i][0];\n    s[0] += r[i] * A[i][0];\n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 1; j < 390; j++) {\n      q[j] += r[i] * A[i][j];\n      s[j] += A[i][j] * p[j];\n    }\n    for (j = 0; j < 390; j++) {\n      A[i][j] = A[i][j] - q[j] / ((double )2) - s[j] / ((double )2);\n    }\n    s[0] = sqrt(sqrt(((q[0] + s[0]) * 491304)) + ((double )1));\n    for (j = 1; j < 390; j++) {\n      s[j] = A[i][j] * A[i][j] / s[0];\n    }\n  }\n}\n"}}
{"input": "For the given C code, the comprehensive but very concise natural language instruction would be:\n\n\"Process this function as a hardware kernel for acceleration, turn off automatic pipelining on the loop, set the tile factor to 1, and run the loops in parallel with a factor of 2 and 3 respectively.\"\n\nThis would correspond to the following #pragma directives:\n```c\n#pragma ACCEL kernel\n#pragma ACCEL PIPELINE auto{off}\n#pragma ACCEL TILE FACTOR=auto{1}\n#pragma ACCEL PARALLEL FACTOR=auto{2}\n#pragma ACCEL PARALLEL FACTOR=auto{3}\n```", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n", "1": "\n", "2": "\n\n### **Kernel**: \n#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\nThe application code is:\n #include <stdio.h>\n#include <sys/time.h>\n#include <assert.h>\n#include <math.h>\n#include <omp.h>\n#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n  }\n  for (i = 0; i < 60; i++) {\n    for (k = 0; k < 80; k++) {\n      temp[i][k] = A[i][k] * alpha;\n    }\n  }\n  for (i = 0; i < 60; i++) {\n    for (j = 0; j < 70; j++) {\n      C[i][j] += temp[i][0][0] * B[0][j];\n    }\n  }\n//#pragma ACCEL PIPELINE auto{__PIPE__L2}\n//#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n//#pragma ACCEL PARALLEL FACTOR=auto{3}\n  for (i = 0; i < 60; i++) {\n    for (j = 0; j < 70; j++) {\n      double sum = (double )0;\n      for (k = 0; k < 80; k++) {\n        sum += A[i][k] * B[k][j];\n      }\n      C[i][j] = sum;\n    }\n  }\n}\n", "4": "\n\n# Parallel Sparse Matrix-Vector Multiplication (PSVM)\n\nThis example computes an approximation of the function y = Axapprox, where A is a m x n sparse matrix in the CSR format, x is a n x 1 dense vector, and y is a m x 1 dense vector. The matrix A is approximated by a subset of its nonzero elements specified by the vector S. The subset is chosen such that the number of nonzero elements in the new matrix is less than a specified threshold. The approximation error is computed as follows:\n```\ne = y - Axapprox\nae = y - Ax\n```\nwhere xapprox is the computed approximation.\n\n## Authors:\n\n- [Alessandro Iadarola](https://github.com/alessandro-iadarola)\n\n## Build and Run Instructions\n\nTo build and run the application, execute the following steps:\n\n1. Build the program using the following `make` command:\n\n```bash\n    make\n```\n\n2. Run the program using the following command:\n\n```bash\n    make run\n```\n\n3. You will see the following output:\n\n```bash\n========= Program result =========\n\nOptimal threshold = 2\nError = 0.43773444099999999898\nTime = 0.169614\n```\n\n### Input\n\nThe input consists of two files:\n\n* `A.csr` is the sparse matrix in the CSR (Compressed Sparse Row) format.\n* `S.csr` is the list of nonzero elements in the matrix A that will be used to compute the approximation y.\n\n### Data\n\nThe sparse matrix A and the vector x are stored in a text file. Each row of the matrix contains the indices of the elements of the row in the text file. The row indices are stored first, then the column indices and finally the values of the nonzero elements. The vector x is also stored in a text file. The elements of x are also stored in a text file. The files are in Matlab (.mat) format.\n\n### License\n\nThis example is released under the [3-Clause BSD License](https://github.com/intel/"}}
{"input": "Process the following function as a hardware kernel for acceleration. For the loops inside this function, do not automatically pipeline them, and process them in their original, full form without breaking them into smaller chunks. However, run the iterations of each loop one after the other, not in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_0}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[j];\n    }\n    \n#pragma ACCEL PIPELINE auto{off_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1_1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_1}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1_1_0}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1_2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_2}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1_2_0}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1_3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_3}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1_3_0}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": " \n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 0 + 1L * 240L;\n        int _in_i = 0 + 1L * 200L;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": " \n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 240;\n        int _in_i = 200;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": " Automatically flatten the following function.\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1*i;\n        int j_col = j + 1;\n        hz[i_col][j_col] = hz[i_col][j_col] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes in C, use the following comprehensive but very concise natural language instructions:\n\n- Treat the following function as a hardware kernel for acceleration: `#pragma ACCEL kernel`\n- Don't automatically pipeline this loop: `#pragma ACCEL PIPELINE \"off\"`\n- Process this loop in its original, full form without breaking it into smaller chunks: `#pragma ACCEL TILE FACTOR=1`\n- Run the iterations of this loop one after the other, not in parallel: `#pragma ACCEL PARALLEL FACTOR=1`", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n- Don't automatically parallelize this loop: `#pragma ACCEL PARALLEL FACTOR=auto{1} PIPELINE auto{off}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L2}`\n- Don't automatically parallelize this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L2}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L3}`\n- Don't automatically parallelize this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L3}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L4}`\n- Don't automatically parallelize this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L4}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L5}`\n- Don't automatically parallelize this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L5}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L6}`\n- Don't automatically parallelize this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L6}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L7}`\n- Don't automatically parallelize this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L7}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L8}`\n- Don't automatically parallelize this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L8}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L9}`\n- Don't automatically parallelize this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L9}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L10}`\n- Don't automatically parallelize this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L10}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L10}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L11}`\n- Don't automatically parallelize this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L11}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L11}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L12}`\n- Don't automatically parallelize this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L12}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L12}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L13}`\n- Don't automatically parallelize this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L13}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L13}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L14}`\n- Don't automatically parallelize this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L14}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L14}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L15}`\n- Don't automatically parallelize this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L15}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L15}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L16}`\n- Don't automatically parallelize this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L16}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L16}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L17}`\n- Don't automatically parallelize this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L17}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L17}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L18}`\n- Don't automatically parallelize this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L18}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L18}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L19}`\n- Don't automatically parallelize this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L19}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L19}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L20}`\n- Don't automatically parallelize this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L20}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L20}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L21}`\n- Don't automatically parallelize this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L21}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L21}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L22}`\n- Don't automatically parallelize this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L22}`\n- Don't automatically parallelize this loop: `#", "1": "\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{1}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L10}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L11}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L12}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L13}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L14}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L15}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L16}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L17}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L18}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L19}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L20}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L21}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L22}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L23}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L24}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L25}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L26}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L27}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L28}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L29}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L30}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L31}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L32}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L33}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L34}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L35}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L36}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L37}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L38}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L39}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L40}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L41}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L42}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L43}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L44}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L45}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L46}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L47}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L48}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L49}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L50}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L51}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L52}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L53}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L54}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L55}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L56}`\n- Do not distribute the iterations of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L57}`\n- Do not distribute the iterations of this", "2": "\n- Don't automatically distribute this loop: `#pragma ACCEL DISTRIBUTE FACTOR=1`\n- Don't automatically parallelize this loop: `#pragma ACCEL PARALLEL FACTOR=auto{1}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PARALLEL FACTOR=auto{16}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PARALLEL FACTOR=auto{2}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PARALLEL FACTOR=auto{8}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L2}`\n- Don't automatically parallelize this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L2}`\n- Don't automatically parallelize this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L3}`\n- Don't automatically parallelize this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L3}`\n\n#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n- Do not automatically flatten this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}`\n- Do not automatically distribute this loop: `#pragma ACCEL DISTRIBUTE FACTOR=auto{__PARA__L2}`\n- Do not automatically parallelize this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n  PARALLEL FACTOR=auto{__PARA__L3_0}`\n\n#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "4": "\n- Do not compile the loop below into a parallelized loop due to: DATA DEPENDENCE\n  - View EID 0 of auto pipeline 0 as:\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n\nfor (i = 1; i < 99; i++) {\n  y[i] = 0.0;\n  x[i] = 0.0;\n  s[i] = 0.0;\n  r[i] = 1.0 / (double )i;\n  p[i] = 1.0 / (double )((int )sqrt((double )i));\n  q[i] = 1.0 / (double )((int )sqrt((double )(i + 1)));\n  for (j = 1; j < 99; j++) {\n    y[i] += r[j] * f(p[j] * (x[j] - x[i]) + x[i]);\n    s[i] += r[j] * f(p[j] * (y[j] - y[i]) + y[i]);\n  }\n  q_tmp = q[i];\n  x[i] -= s[i] / (y[i] + q_tmp * s[i]);\n  y[i] -= q_tmp * s[i];\n}\n\n  #pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n\nfor (i = 1; i < 99; i++) {\n  e[i] = (y[i] - s[i]) / (q[i] * s[i]);\n  t[i] = s[i] * (1.0 - pow(2.7182818284590450907938e-01,(- 1.0) * q[i] * e[i]));\n  w[i] = t[i] * f(x[i]);\n}\n\n  #pragma ACCEL PIPELINE auto{__PIPE__L1}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n\nfor (i = 1; i < 99; i++) {\n  for (j = 1; j < 99; j++) {\n    x[j] += e[i] * w[j];\n  }\n}\n"}}
{"input": "Process the \"doitgen\" function as a hardware kernel for acceleration. Pipeline the outer loop, disable automatic pipelining for the middle loop, and flatten the inner loop. Use tiling with a factor of 8 for the outer loop, and a factor of 1 for the middle and inner loops.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        double sum_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=sum_tmp FACTOR=auto{__PARA__L3}\n\tfor (s = 0; s < 30; s++) {\n          sum_tmp += A[r][q][s] * C4[s][p];\n        }\n\tA[r][q][p] = sum_tmp;\n\tsum[p] = sum_tmp;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(int ni,int nj,int nk,int nl,double A[20][22],double B[20][24],double C[24][22],double D[24][30])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  for (i = 0; i < 20; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    for (j = 0; j < 22; j++) {\n      A[i][j] = ((double )0);\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (i = 0; i < 20; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    for (j = 0; j < 24; j++) {\n      B[i][j] = ((double )0);\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (i = 0; i < 24; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    for (j = 0; j < 22; j++) {\n      C[i][j] = ((double )0);\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (i = 0; i < 24; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n    for (j = 0; j < 30; j++) {\n      D[i][j] = ((double )0);\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (i = 0; i < 20; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    for (j = 0; j < 24; j++) {\n      for (k = 0; k < 20; k++) {\n        A[i][j] += B[i][k] * C[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (i = 0; i < 24; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L7}\n    for (j = 0; j < 22; j++) {\n      for (k = 0; k < 20; k++) {\n        D[i][j] += A[k][j] * B[k][i];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(int ni,int nj,int nk,int nl,double A[20][22],double B[20][24],double C[24][22],double D[24][32])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  for (i = 0; i < 20; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    for (j = 0; j < 22; j++) {\n      A[i][j] = ((double )0);\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (i = 0; i < 20; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    for (j = 0; j < 24; j++) {\n      A[i][nj + j] = 0.0;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (i = 0; i < 24; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    for (j = 0; j < 22; j++) {\n      B[i][j] = 0.0;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (i = 0; i < 24; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n    for (j = 0; j < 32; j++) {\n      C[i][j] = 0.0;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (i = 0; i < 20; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    for (j = 0; j < 22; j++) {\n      for (k = 0; k < 20; k++) {\n        A[i][j] += B[k][j] * C[k][i];\n      }\n    }\n  }\n  \n#pragma endscop\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,int nn,double A[200][240],double B[240][280],double C[200][280])\n{\n  int r;\n  int q;\n  int p;\n  int n;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  for (r = 0; r < 200; r++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 240; q++) {\n      A[r][q] = ((double )0);\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 200; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    for (q = 0; q < 280; q++) {\n      C[r][q] = ((double )0);\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    for (p = 0; p < 240; p++) {\n      \n#pragma ACCEL PARALLEL reduction=A FACTOR=auto{__PARA__L4}\n      for (n = 0; n < 200; n++) {\n        A[r][p] += B[n][q] * C[n][q];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[25][30],double B[25][23][30],double D[25][20])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n  int t;\n  int u;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      for (s = 0; s < 30; s++) {\n        A[r][q][s] = ((double )0);\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n      for (p = 0; p < 30; p++) {\n        double sum = 0.0;\n#pragma ACCEL PARALLEL reduction=sum FACTOR=auto{__PARA__L5}\n\tfor (s = 0; s < 23; s++) {\n          sum = sum + B[r][s][p] * D[s][q];\n        }\n\tC4[r][p] = sum;\n\tdouble sum_0 = 0.0;\n#pragma ACCEL PARALLEL reduction=sum_0 FACTOR=auto{__PARA__L6}\n\tfor (s = 0; s < 20; s++) {\n          sum_0 = sum_0 + A[r][s][p] * C4[s][p];\n        }\n\tA[r][q][p] = sum_0;\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "Process the loops in parallel with automatic factor determination to optimize performance\nUse pipeline optimization by automatic flattening to improve throughput\nApply tiling optimization with automatic factor determination\nUtilize parallel reduction for inner loop computation with automatic factor determination", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n  }\n  for (i = 0; i < 60; i++) {\n    for (k = 0; k < 80; k++) {\n      temp[i][k] = A[i][k] * beta;\n    }\n    for (j = 0; j < 70; j++) {\n      for (k = 0; k < 80; k++) {\n        C[i][j] += alpha * temp[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n  }\n  for (i = 0; i < 60; i++) {\n    for (k = 0; k < 80; k++) {\n      temp_x = A[i][k];\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L2}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * temp_x * B[k][j];\n      }\n    }\n  }\n}\n", "2": " to optimize performance\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "3": " to improve performance\n#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[410][390],double s[390],double q[410],double p[390],double r[410])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 390; i++) {\n    s[i] = ((double )0);\n    q[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 410; i++) {\n    q[0] += r[i] * A[i][0];\n    s[0] += r[i] * A[i][0];\n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 1; j < 390; j++) {\n      q[j] += r[i] * A[i][j];\n      s[j] += A[i][j] * p[j];\n    }\n    for (j = 0; j < 390; j++) {\n      A[i][j] = A[i][j] - q[j] * p[i];\n    }\n    for (j = 0; j < 390; j++) {\n      s[j] = s[j] - A[i][j] * p[i];\n    }\n  }\n}\n", "4": "\n //\n //  TwoMM:  This program solves a system of linear\n //  equations of the form: A * X = B\n //\n //  A is an n x n matrix\n //  B is an n x m matrix\n //  X is an n x m matrix\n //\n \n#pragma ACCEL kernel\n\nvoid TwoMM(int n,int m,double A[40][40],double B[40][60],double X[40][60])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 60; j++) {\n      X[i][j] = ((double )0);\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 40; j++) {\n      for (k = 0; k < 60; k++) {\n        X[j][k] += A[i][j] * B[i][k];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "Process the following function as a hardware kernel for acceleration. For the loop within, pipeline it automatically. Then, tile the loop with a factor of 25. Parallelize the loop with a factor of \"auto{__PARA__L0}\", and within that parallel loop, pipeline it off. Then, tile the next loop with a factor of 1, parallelize it with a factor of \"auto{__PARA__L1}\", and within that parallel loop, pipeline it automatically. Then, tile the next loop with a factor of 1, parallelize it with a factor of \"auto{__PARA__L2}\", and within that parallel loop, pipeline it with \"__PIPE__L3\". Finally, parallelize the remaining loop with a factor of 1, and within that loop, pipeline it with \"__PIPE__L7\".", "output": "#include <math.h>\n#pragma ACCEL kernel\n\nvoid kernel_correlation(double float_n,double data[100][80],double corr[80][80],double mean[80],double stddev[80])\n{\n  int i;\n  int j;\n  int k;\n  double eps = 0.1;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{25}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n  for (j = 0; j < 80; j++) {\n    mean[j] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 100; i++) {\n      mean[j] += data[i][j];\n    }\n    mean[j] /= float_n;\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n  for (j = 0; j < 80; j++) {\n    stddev[j] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 0; i < 100; i++) {\n      stddev[j] += pow(data[i][j] - mean[j],(double )2);\n    }\n    stddev[j] /= float_n;\n    stddev[j] = sqrt(stddev[j]);\n/* The following in an inelegant but usual way to handle\n         near-zero std. dev. values, which below would cause a zero-\n         divide. */\n    stddev[j] = (stddev[j] <= eps?1.0 : stddev[j]);\n  }\n/* Center and reduce the column vectors. */\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (i = 0; i < 100; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (j = 0; j < 80; j++) {\n      data[i][j] -= mean[j];\n      data[i][j] /= sqrt(float_n) * stddev[j];\n    }\n  }\n/* Calculate the m * m correlation matrix. */\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 80 - 1; i++) {\n    corr[i][i] = 1.0;\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L7}\n    for (j = i + 1; j < 80; j++) {\n      corr[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7_0}\n      for (k = 0; k < 100; k++) {\n        corr[i][j] += data[k][i] * data[k][j];\n      }\n      corr[j][i] = corr[i][j];\n    }\n  }\n  corr[80 - 1][80 - 1] = 1.0;\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{25}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{25}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[j];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L8}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{25}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{25}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L8}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{25}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L8}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{25}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 30; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 1; i < 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 118; j++) {\n        A[i][j] -= 0.5 * (A[i][j] - A[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L7}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L7}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n    for (i = 1; i < 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 1; j < 118; j++) {\n        A[i][j] -= 0.5 * (A[i][j] - A[i][j + 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 1; i < 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 118; j++) {\n        A[i][j] -= 0.5 * (A[i][j] - A[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "Process the first loop in parallel, automatically determine the parallel factor for optimization. Pipeline the loop automatically using the flatten design. For the second loop, use automatic tiling with a factor of 1. Also, process the second loop in parallel, automatically determining the parallel factor. Apply reduction for the inner parallel loop automatically to optimize. Finally, treat the function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction=D FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "Process the following function as a hardware kernel for acceleration and apply the following directives to the loops:\n1. Disable automatic pipelining for the outermost loop.\n2. Use a tile factor of 1 for both the outermost and the middle loops.\n3. Disable automatic pipelining for the innermost loop, and use a tile factor of 2.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{2}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 240;\n        int _in_i = 200;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": "\n4. Use the following code template for the outermost loop:\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60],double r[60][60],double s[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DX2;\n  double DY2;\n  double DXDY;\n  double C1;\n  double C2;\n  double C3;\n  double C4;\n  double C5;\n  double tmp;\n  double mul1;\n  double mul2;\n  double mul3;\n  double mul4;\n  double mul5;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  DX = 1.0 / ((double )60);\n  \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n  DY = 1.0 / ((double )60);\n  DX2 = DX * DX;\n  DY2 = DY * DY;\n  DXDY = DX2 * DY;\n  C1 = 3.0 * DX2 * DY2;\n  C2 = 3.0 * DX2 - 2.0 * DXDY - DY2;\n  C3 = 3.0 * DXDY - 2.0 * DX2 * DY;\n  C4 = DX2 - DY2;\n  C5 = -2.0 * DX2 * DY;\n//#pragma ACCEL PIPELINE auto{off}\n//#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 39; t++) {\n//#pragma ACCEL PIPELINE auto{off}\n//#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 59; j++) {\n        tmp = C1 * (u[i - 1][j] + u[i + 1][j]) + C2 * (u[i][j - 1] + u[i][j + 1]) + C3 * (u[i][j]) + C4 * (v[i - 1][j] + v[i + 1][j]) + C5 * (v[i][j - 1] + v[i][j + 1]) - DX2 * p[i][j] - DY2 * q[i][j];\n        a = DX * (v[i][j] - v[i - 1][j]) - DY * (u[i][j] - u[i][j - 1]);\n        b = -DX * (v[i + 1][j] - v[i][j]) - DY * (u[i][j + 1] - u[i][j]);\n        c = DX * (v[i][j + 1] - v[i][j]) - DY * (u[i + 1][j] - u[i][j]);\n        d = DX * (u[i][j] - u[i - 1][j]) - DY * (v[i][j] - v[i - 1][j]);\n        e = tmp + C1 * a * d - C2 * b * d - C3 * c * a - C4 * b * c + C5 * (p[i][j] - p[i - 1][j] - q[i][j] + q[i - 1][j]);\n        f = 1.0 / (C2 * d - C1 * b);\n        p[i][j] = f * (C2 * e - C1 * c * d);\n        q[i][j] = f * (c * a - d * b - e);\n        r[i][j] = u[i][j] - DX2 * p[i][j] - DY2 * q[i][j];\n        s[i][j] = v[i][j] - DX * p[i][j] - DY * q[i][j];\n      }\n    }\n//#pragma ACCEL PIPELINE auto{__PIPE__L1}\n  }\n//#pragma endscop\n}\n"}}
{"input": "To generate the following HLS codes in C, you should:\n- Use the pragma #pragma ACCEL kernel to tag the function as a hardware kernel for acceleration.\n- Use #pragma ACCEL PIPELINE auto{} to automatically pipeline the loops.\n- Use #pragma ACCEL TILE FACTOR=8 to break the loop into smaller chunks of size 8.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L0 to run the iterations of the loop in parallel with the specified factor.\n- Use #pragma ACCEL PIPELINE auto{off} to turn off automatic pipelining.\n- Use #pragma ACCEL TILE FACTOR=1 to process the loop in its original, full form without breaking it into smaller chunks.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L1 to run the iterations of the loop in parallel with the specified factor.\n- Use #pragma ACCEL PIPELINE auto{off} to explicitly turn off automatic pipelining.\n- Use #pragma ACCEL TILE FACTOR=1 to process the loop in its original, full form without breaking it into smaller chunks.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L2 to run the iterations of the loop in parallel with the specified factor.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L3} to pipeline the loop with a specific pipeline identifier.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L3 to break the loop into smaller chunks and specify a tile identifier.\n- Use #pragma ACCEL PARALLEL FACTOR=1 to run the iterations of the loop in parallel with a factor of 1.", "output": "#include <math.h>\n#pragma ACCEL kernel\n\nvoid kernel_correlation(double float_n,double data[100][80],double corr[80][80],double mean[80],double stddev[80])\n{\n  int i;\n  int j;\n  int k;\n  double eps = 0.1;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n  for (j = 0; j < 80; j++) {\n    mean[j] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 100; i++) {\n      mean[j] += data[i][j];\n    }\n    mean[j] /= float_n;\n  }\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n  for (j = 0; j < 80; j++) {\n    stddev[j] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 0; i < 100; i++) {\n      stddev[j] += pow(data[i][j] - mean[j],(double )2);\n    }\n    stddev[j] /= float_n;\n    stddev[j] = sqrt(stddev[j]);\n/* The following in an inelegant but usual way to handle\n         near-zero std. dev. values, which below would cause a zero-\n         divide. */\n    stddev[j] = (stddev[j] <= eps?1.0 : stddev[j]);\n  }\n/* Center and reduce the column vectors. */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (i = 0; i < 100; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (j = 0; j < 80; j++) {\n      data[i][j] -= mean[j];\n      data[i][j] /= sqrt(float_n) * stddev[j];\n    }\n  }\n/* Calculate the m * m correlation matrix. */\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 80 - 1; i++) {\n    corr[i][i] = 1.0;\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L7}\n    for (j = i + 1; j < 80; j++) {\n      corr[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7_0}\n      for (k = 0; k < 100; k++) {\n        corr[i][j] += data[k][i] * data[k][j];\n      }\n      corr[j][i] = corr[i][j];\n    }\n  }\n  corr[80 - 1][80 - 1] = 1.0;\n}\n", "predicted": {"0": "\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L5} to pipeline the loop with a specific pipeline identifier.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L5 to break the loop into smaller chunks and specify a tile identifier.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L5 to run the iterations of the loop in parallel with the specified factor.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L6} to pipeline the loop with a specific pipeline identifier.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L6 to break the loop into smaller chunks and specify a tile identifier.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L6 to run the iterations of the loop in parallel with the specified factor.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L7} to pipeline the loop with a specific pipeline identifier.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L7 to break the loop into smaller chunks and specify a tile identifier.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L7 to run the iterations of the loop in parallel with the specified factor.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L8} to pipeline the loop with a specific pipeline identifier.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L8 to break the loop into smaller chunks and specify a tile identifier.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L8 to run the iterations of the loop in parallel with the specified factor.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L9} to pipeline the loop with a specific pipeline identifier.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L9 to break the loop into smaller chunks and specify a tile identifier.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L9 to run the iterations of the loop in parallel with the specified factor.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L10} to pipeline the loop with a specific pipeline identifier.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L10 to break the loop into smaller chunks and specify a tile identifier.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L10 to run the iterations of the loop in parallel with the specified factor.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L11} to pipeline the loop with a specific pipeline identifier.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L11 to break the loop into smaller chunks and specify a tile identifier.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L11 to run the iterations of the loop in parallel with the specified factor.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L12} to pipeline the loop with a specific pipeline identifier.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L12 to break the loop into smaller chunks and specify a tile identifier.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L12 to run the iterations of the loop in parallel with the specified factor.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L13} to pipeline the loop with a specific pipeline identifier.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L13 to break the loop into smaller chunks and specify a tile identifier.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L13 to run the iterations of the loop in parallel with the specified factor.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L14} to pipeline the loop with a specific pipeline identifier.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L14 to break the loop into smaller chunks and specify a tile identifier.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L14 to run the iterations of the loop in parallel with the specified factor.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L15} to pipeline the loop with a specific pipeline identifier.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L15 to break the loop into smaller chunks and specify a tile identifier.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L15 to run the iterations of the loop in parallel with the specified factor.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L16} to pipeline the loop with a specific pipeline identifier.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L16 to break the loop into smaller chunks and specify a tile identifier.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L16 to run the iterations of the loop in parallel with the specified factor.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L17} to pipeline the loop with a specific pipeline identifier.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L17 to break the loop into smaller chunks and specify a tile identifier.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L17 to run the iterations of the loop in parallel with the specified factor.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L18} to pipeline the loop with a specific pipeline identifier.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L18 to break the loop into smaller chunks and specify a tile identifier.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L18 to run the iterations of the loop in parallel with the specified factor.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L19} to pipeline the loop with a specific pipeline identifier.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L19 to break the loop into smaller chunks and specify a tile identifier.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L19 to run the iterations of the loop in parallel with the specified factor.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L20} to pipeline the loop with a specific pipeline identifier.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L20 to break the loop into smaller chunks and specify a tile identifier.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L20 to run the iterations of the loop in parallel with the specified factor.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L21} to pipeline the loop with a specific pipeline identifier.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L21 to break the loop into smaller chunks and specify a tile identifier.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L21 to run the iterations of the loop in parallel with the specified factor.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L22} to pipeline the loop with a specific pipeline identifier.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L22 to break the loop into smaller chunks and specify a tile identifier.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L22 to run the iterations of the loop in parallel with the specified factor.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L23} to pipeline the loop with a specific pipeline identifier.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L23 to break the loop into smaller chunks and specify a tile identifier.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L23 to run the iterations of the loop in parallel with the specified factor.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L24} to pipeline the loop with a specific pipeline identifier.\n- Use #pragma ACCEL TILE FACTOR=__TI", "1": "\n- Use #pragma ACCEL PARAMS FACTOR=__PARAMS__L3 to specify the parameters for the function.\n  \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_in_j = i * 240 + j;\n        int i_next_j = (i + 1) * 240 + j;\n        int i_down_j = (i + 1) * 240 + j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": "\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L4 __PARA__L5 to parallelize the loop with the specified parallelization factors.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L4} to pipeline the loop with the specified pipeline identifier.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L4 to break the loop into smaller chunks and specify a tile identifier.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L6 to run the iterations of the loop in parallel with the specified parallelization factor.\n \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_0 = i;\n        int j_0 = j;\n        hz[i_0][j_0] = hz[i_0][j_0] - 0.7 * (ex[i_0][j_0 + 1] - ex[i_0][j_0] + ey[i_0 + 1][j_0] - ey[i_0][j_0]);\n      }\n    }\n  }\n}\n", "3": "\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L4 FAILEL=__FAILEL__L4 to turn off parallelization in this loop.\n  \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_0 = i;\n        int j_0 = j;\n        \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n        hz[i_0][j_0] = hz[i_0][j_0] - 0.7 * (ex[i_0][j_0 + 1] - ex[i_0][j_0] + ey[i_0 + 1][j_0] - ey[i_0][j_0]);\n      }\n    }\n  }\n}\n", "4": "\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L4 FACTOR=__PARA__L4_0 to parallelize the loop with the specified number of processes.\n \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{24}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{24}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_0 = i;\n        int j_0 = j;\n        \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4_0}\n        for (int t_0 = 0; t_0 < 4; t_0++) {\n          hz[i_0][j_0] = hz[i_0][j_0] - 0.5 * (ex[i_0][j_0 + 1] - ex[i_0][j_0] + ey[i_0 + 1][j_0] - ey[i_0][j_0]);\n        }\n        j_0 = j + 1;\n      }\n      i_0 = i + 1;\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes, use the following concise natural language instructions for each #pragma directive:\n\n1. For the directive '#pragma ACCEL PIPELINE auto{off}', use \"Don't automatically pipeline this loop.\"\n2. For the directive '#pragma ACCEL TILE FACTOR=auto{1}', use \"Process this loop in its original, full form without breaking it into smaller chunks.\"\n3. For the directive '#pragma ACCEL PARALLEL FACTOR=auto{2}', use \"Run the iterations of this loop one after the other, not in parallel.\"\n4. For the directive '#pragma ACCEL PARALLEL FACTOR=auto{3}', use \"Run iterations of this loop in parallel with a factor of 3.\"\n5. For the directive '#pragma ACCEL PARALLEL FACTOR=auto{12}', use \"Run iterations of this loop in parallel with a factor of 12.\"\n\nBy following these natural language instructions, you can organize the HLS codes in C as specified.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "1": "\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 2 * j + 1;\n        int _in_i = 2 * i + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][_in_j] - ex[i][_in_j - 1]) - 0.7 * (ey[i][_in_j] - ey[i][_in_j - 1]);\n      }\n    }\n  }\n}\n", "3": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        double  _tmp_1 = 0.0;\n        double  _tmp_2 = 0.0;\n        double  _tmp_3 = 0.0;\n        double  _tmp_4 = 0.0;\n        double  _tmp_5 = 0.0;\n        double  _tmp_6 = 0.0;\n        double  _tmp_7 = 0.0;\n        double  _tmp_8 = 0.0;\n        double  _tmp_9 = 0.0;\n        double  _tmp_10 = 0.0;\n        double  _tmp_11 = 0.0;\n        double  _tmp_12 = 0.0;\n        double  _tmp_13 = 0.0;\n        double  _tmp_14 = 0.0;\n        double  _tmp_15 = 0.0;\n        double  _tmp_16 = 0.0;\n        double  _tmp_17 = 0.0;\n        double  _tmp_18 = 0.0;\n        double  _tmp_19 = 0.0;\n        double  _tmp_20 = 0.0;\n        _tmp_1 = ex[i][j + 1] - ex[i][j];\n        _tmp_2 = ey[i + 1][j] - ey[i][j];\n        _tmp_3 = hz[i + 1][j] - hz[i][j];\n        _tmp_4 = ex[i + 1][j + 1] - ex[i + 1][j];\n        _tmp_5 = ey[i + 1][j + 1] - ey[i + 1][j];\n        _tmp_6 = hz[i + 1][j + 1] - hz[i + 1][j];\n        _tmp_7 = ex[i][j] - ex[i][j - 1];\n        _tmp_8 = ey[i][j] - ey[i - 1][j];\n        _tmp_9 = hz[i][j] - hz[i - 1][j];\n        _tmp_10 = ex[i - 1][j + 1] - ex[i][j - 1];\n        _tmp_11 = ey[i - 1][j + 1] - ey[i - 1][j];\n        _tmp_12 = hz[i - 1][j + 1] - hz[i - 1][j];\n        _tmp_13 = _tmp_6 + _tmp_9 - _tmp_3;\n        _tmp_14 = _tmp_5 + _tmp_8 - _tmp_2;\n        _tmp_15 = _tmp_1 + _tmp_4 - _tmp_1_;\n        _tmp_16 = _tmp_11 + _tmp_10 - _tmp_7;\n        _tmp_17 = _tmp_14 * _tmp_15;\n        _tmp_18 = _tmp_16 * _tmp_13;\n        _tmp_19 = _tmp_17 - _tmp_18;\n        _tmp_20 = _tmp_19 + _hz[i][j];\n        _fict_[i][j] = _tmp_20;\n        hz[i][j] = _tmp_20;\n      }\n    }\n  }\n}\n", "4": " Note that a double precision type is used for the higher precision required by the formula.\n"}}
{"input": "To generate the given HLS codes written in C, you can use the following natural language instruction:\n\n\"Mark the following function as a hardware kernel for acceleration. Then, for the loops inside the function: run the iterations of the first loop in parallel, pipeline the loop after that, and then break down the third loop into smaller chunks using tiling, and finally, run the innermost loop iterations in parallel with reduction.\"\n\nThis instruction gives a comprehensive but concise overview of the process and the specific #pragma values to use.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n#pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        double sum_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=sum_tmp FACTOR=auto{__PARA__L3}\n\tfor (s = 0; s < 30; s++) {\n          sum_tmp += A[r][q][s] * C4[s][p];\n        }\n\tsum[p] = sum_tmp;\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": " \n#pragma ACCEL kernel\n\nvoid kernel_doit(double A[25][20][30],double C4[25][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        double sum_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=sum_tmp FACTOR=auto{__PARA__L3}\n\tfor (s = 0; s < 30; s++) {\n          sum_tmp += A[r][q][s] * C4[s][p];\n        }\n\tsum[p] = sum_tmp;\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": " \n#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "Perform the following operations on the given C code:\n\n- Treat the function as a hardware kernel for acceleration.\n- Run the iterations of the first loop in parallel.\n- Apply automatic pipeline flattening to the loop.\n- Keep the loop in its original form without breaking it into smaller chunks.\n- Run the iterations of the second loop one after the other, not in parallel, and use reduction for parallel operation.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n #pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[410][390],double s[390],double q[410],double p[390],double r[410])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 390; i++) {\n    s[i] = ((double )0);\n    q[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 410; i++) {\n    q[0] += r[i] * A[i][0];\n    s[0] += r[i] * A[i][0];\n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 1; j < 390; j++) {\n      q[j] += r[i] * A[i][j];\n      s[j] += A[i][j] * p[j];\n    }\n  }\n}\n", "1": "\n\n #pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[410][390],double s[390],double q[410],double p[390],double r[410])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 390; i++) {\n    s[i] = ((double )0);\n    q[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 410; i++) {\n    q[0] += r[i] * A[i][0];\n    s[0] += r[i] * A[i][0];\n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 1; j < 390; j++) {\n      q[j] += r[i] * A[i][j];\n      s[j] += A[i][j] * p[j];\n    }\n  }\n}\n", "2": "\n\n #pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[410][390],double s[390],double q[410],double p[390],double r[410])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n  for (i = 0; i < 390; i++) {\n    s[i] = ((double )0);\n    q[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 410; i++) {\n    q[0] += r[i] * A[i][0];\n    s[0] += r[i] * A[i][0];\n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 1; j < 390; j++) {\n      q[j] += r[i] * A[i][j];\n      s[j] += A[i][j] * p[j];\n    }\n  }\n}\n", "3": "\n\n #pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[410][390],double s[390],double q[410],double p[390],double r[410])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n  for (i = 0; i < 390; i++) {\n    s[i] = ((double )0);\n    q[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n  for (i = 0; i < 410; i++) {\n    q[0] += r[i] * A[i][0];\n    s[0] += r[i] * A[i][0];\n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 1; j < 390; j++) {\n      q[j] += r[i] * A[i][j];\n      s[j] += A[i][j] * p[j];\n    }\n  }\n}\n", "4": "\n\n #pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[410][390],double s[390],double q[410],double p[390],double r[410])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 390; i++) {\n    s[i] = ((double )0);\n    q[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n  for (i = 0; i < 410; i++) {\n    q[0] += r[i] * A[i][0];\n    s[0] += r[i] * A[i][0];\n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 1; j < 390; j++) {\n      q[j] += r[i] * A[i][j];\n      s[j] += A[i][j] * p[j];\n    }\n    for (j = 0; j < 390; j++) {\n      A[i][j] = A[i][j] - q[j] / ((double )((double )(2.0 * 390)) * s[j]);\n    }\n    s[0] = 1.0;\n  }\n}\n"}}
{"input": "To generate the HLS codes written in C, use the following natural language instruction:\n\"Declare the following function as a hardware kernel for acceleration. Then, don't automatically pipeline the loop, process the loop in its original, full form without breaking it into smaller chunks, and run the iterations of this loop one after the other, not in parallel. Set the tile factor and parallel factor as auto for optimization.\"\n\nThese instructions correspond to the following #pragma values:\n- '#pragma ACCEL kernel'\n- '#pragma ACCEL PIPELINE auto{}'\n- '#pragma ACCEL TILE FACTOR=auto{1}'\n- '#pragma ACCEL PARALLEL FACTOR=auto{2}'\n- '#pragma ACCEL PARALLEL FACTOR=auto{10}'\n- '#pragma ACCEL PARALLEL FACTOR=auto{6}'", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (j = 0; j < 220; j++) {\n      double tmp = A[i][0] * B[0][j];\n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (k = 1; k < 200; k++) {\n        tmp += A[i][k] * B[k][j];\n      }\n      C[i][j] += alpha * tmp;\n    }\n  }\n}\n", "1": "\n\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        double  delx =  (double )(ex[i + 1][j + 1] - ex[i][j + 1]);\n        double  dely =  (double )(ey[i + 1][j + 1] - ey[i][j + 1]);\n        double  hz_update =  (double )(ex[i][j + 1] - ex[i + 1][j]) + delx +  (double )(ey[i + 1][j] - ey[i][j]) + dely;\n        hz[i][j] = hz_update;\n      }\n    }\n  }\n}\n", "3": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        double  delta_ex = ex[i][j + 1] - ex[i][j];\n        double  delta_ey = ey[i + 1][j] - ey[i][j];\n        double  delta_hz = hz[i + 1][j] - hz[i][j];\n        double  SI = 1.0 / (1.0 + delta_ex * delta_ex + delta_ey * delta_ey);\n        double  coef = -1.0 * SI * (delta_ex * ey[i][j] + delta_ey * ex[i][j] + delta_hz);\n        ey[i][j] = ey[i][j] + coef * delta_ey;\n        ex[i][j] = ex[i][j] + coef * delta_ex;\n        hz[i][j] = hz[i][j] + coef * delta_hz;\n      }\n    }\n  }\n}\n", "4": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        double  deriv0 = (ey[i][j + 1] - ey[i][j]) / (double )2;\n        double  deriv1 = (ex[i + 1][j] - ex[i][j]) / (double )2;\n        double  int0 = -1.0 * (hz[i][j] - hz[i][j + 1]) / (double )(1e-6);\n        double  int1 = -1.0 * (hz[i + 1][j] - hz[i][j]) / (double )(1e-6);\n        double  tmp = (deriv0 + deriv1) / (double )2;\n        hz[i][j] = tmp - (((int0 + int1) / (double )2) * (dz[i][j]));\n      }\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes in C, use the following natural language instructions for the respective #pragma values:\n\n1. For the function 'kernel_jacobi_1d', mark it as a hardware kernel for acceleration.  \n   Instruction: \"Treat the following function as a hardware kernel for acceleration\"\n\n2. For the loop containing the 't' variable, do not automatically pipeline it.  \n   Instruction: \"Don't automatically pipeline this loop\"\n\n3. For the loop containing the 't' variable, process it in its original, full form without breaking it into smaller chunks.  \n   Instruction: \"Process this loop in its original, full form without breaking it into smaller chunks\"\n\n4. For the loop containing the 't' variable, run the iterations one after the other, not in parallel.  \n   Instruction: \"Run the iterations of this loop one after the other, not in parallel\"\n\n5. For the inner loop containing the 'i' variable, run the iterations in parallel with a factor of 2.  \n   Instruction: \"Run the iterations of this loop in parallel with a factor of 2\"\n\n6. For the inner loop containing the 'i' variable, run the iterations in parallel with a factor of 3.  \n   Instruction: \"Run the iterations of this loop in parallel with a factor of 3\"\n\n7. For the inner loop containing the 'i' variable, run the iterations in parallel with a factor of 10.  \n   Instruction: \"Run the iterations of this loop in parallel with a factor of 10\"", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n8. For the inner loop containing the 'i' variable, distribute the loop across 4 compute nodes.  \n   Instruction: \"Distribute this loop to 4 compute nodes\"\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n\n8. For the inner loop containing the 'i' variable, distribute the loop across 10 compute nodes.  \n   Instruction: \"Distribute this loop across 10 compute nodes\"\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n\n8. For the inner loop containing the 'i' variable, distribute the loop across 4 threads.  \n   Instruction: \"Distribute this loop to 4 threads\"\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n\n8. For the inner loop containing the 'i' variable, distribute the loop across 4 compute units.  \n   Instruction: \"distribute{block}{__PARA__L2}__PARA__L2\"\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n\n8. For the loop containing the 't' variable, break it into smaller chunks of work.  \n   Instruction: \"Break this loop into smaller chunks of work {1, 16}\"\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "Process the following function as a hardware kernel for acceleration, automatically parallelize the outer loop with factor 1, and automatically pipeline the inner loop with the flatten optimization.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[410][390],double s[390],double q[410],double p[390],double r[410])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 390; i++) \n    s[i] = ((double )0);\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 410; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 390; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": " The default input is used.\n #pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[410][390],double s[390],double q[410],double p[390],double r[410])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 390; i++) {\n    s[i] = ((double )0);\n    q[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 410; i++) {\n    q[0] += r[i] * A[i][0];\n    s[0] += r[i] * A[i][0];\n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 1; j < 390; j++) {\n      q[j] += r[i] * A[i][j];\n      s[j] += A[i][j] * p[j];\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes written in C, use the following comprehensive but concise natural language instruction:\n\n- Mark the following function as a hardware kernel for acceleration.\n- Don't automatically pipeline the loops.\n- Process the loops with their original, full form without breaking them into smaller chunks.\n- Run the iterations of the loops one after the other, not in parallel.\n- Turn on automatic parallelization with a factor of 30.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n- ACCEL PIPELINE auto{off}\n \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "1": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i % 100);\n        int j_col = 2L * (j % 120);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": "\n- Don't automatically distribute the code across nodes.\n- Perform the computation sum in float.\n \n#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "3": "\n- Do not enable array reduction.\n- Don't use automatic acceleration.\n\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n- Use an automatic parallelization factor of 2 for the for loop with the static scheduling.\n- Use an automatic parallelization factor of 2 for the for loop with the dynamic scheduling.\n- Use an automatic parallelization factor of 2 for the for loop with the guided scheduling.\n- Use an automatic parallelization factor of 2 for the for loop with the auto scheduling.\n- Use an automatic parallelization factor of 2 for the for loop with the static_auto scheduling.\n- Use an automatic parallelization factor of 2 for the for loop with the guided_auto scheduling.\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int s;\n        double e;\n        double _tmp_26 = 1.0e-5;\n        if ((((i * j) % tmax) == 0)) \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7_0}\n        for (s = 0; s < 100; s++) {\n          e = _fict_[s];\n        }\n        hz[i][j] = e - _tmp_26 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n"}}
{"input": "Process the entire function as a hardware kernel and automatically pipeline the outer loop, tile the loop with a factor of 1 and parallelize the outer loop with a factor of 2 and the inner loops with factors of 30 and 10 respectively.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{30}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "  \\n\");\n  for (t = 0; t < 30; t++) {\n    float suml = 0.0;\n    float sumi = 0.0;\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 40; j++) {\n      \n#pragma ACCEL PARALLEL reduction=suml FACTOR=auto{__PARA__L4}\n      for (i = 0; i < 50; i++) {\n        suml += A[i + j * (50)][t];\n      }\n      \n#pragma ACCEL PARALLEL reduction=sumi FACTOR=auto{__PARA__L5}\n      for (i = 0; i < 50; i++) {\n        sumi += B[i + j * (50)][t] * suml;\n      }\n    }\n    C[t] = sumi;\n  }\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 3i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "  \\n\"\n\t\t\t\" #pragma ACCEL PIPELINE auto{flatten} \\n\"\n\t\t\t\" #pragma ACCEL TILE FACTOR=auto{1} \\n\"\n\t\t\t\" #pragma ACCEL PARALLEL FACTOR=auto{2} \\n\"\n\t\t\t\" #pragma ACCEL PARALLEL FACTOR=auto{30} \\n\"\n\t\t\t\" #pragma ACCEL PARALLEL FACTOR=auto{10} \\n\"\n\t\t\t\"int C0 = 0; \\n\"\n\t\t\t\"int C1 = 0; \\n\"\n\t\t\t\"int trip_A = 128; \\n\"\n\t\t\t\"int trip_B = 128; \\n\"\n\t\t\t\"int _in_A = 0; \\n\"\n\t\t\t\"int _in_B = 0; \\n\"\n\t\t\t\"int _Aarr = 0; \\n\"\n\t\t\t\"int _Barr = 0; \\n\"\n\t\t\t\"int _Carr_0 = 0; \\n\"\n\t\t\t\"int _Carr_1 = 0; \\n\"\n\t\t\t\"int mul = 0; \\n\"\n\t\t\t\"flatten_loop_A: for(int i = 0;i < 128;i++) { \\n\"\n\t\t\t\"  _in_A = A[i]; \\n\"\n\t\t\t\"  _Aarr = _in_A + 1; \\n\"\n\t\t\t\"  flat_loop_B: for(int j = 0;j < 128;j++) { \\n\"\n\t\t\t\"    _in_B = B[j]; \\n\"\n\t\t\t\"    _Barr = _in_B + 1; \\n\"\n\t\t\t\"    _Carr_0 = C[i][_Aarr]; \\n\"\n\t\t\t\"    _Carr_1 = C[i][_Barr]; \\n\"\n\t\t\t\"    C0 = C_row[0] + _Carr_0; \\n\"\n\t\t\t\"    C1 = C_row[1] + _Carr_1; \\n\"\n\t\t\t\"    mul = C0 * C1; \\n\"\n\t\t\t\"    D[j] = D[j] + mul; \\n\"\n\t\t\t\"  } \\n\"\n\t\t\t\"  C_row[0] = C_row[0] + _Carr_0; \\n\"\n\t\t\t\"  C_row[1] = C_row[1] + _Carr_1; \\n\"\n\t\t\t\" } \\n\"\n\t\t\t\"store: for(int i = 0;i < 128;i++) { \\n\"\n\t\t\t\"  E[i] = C_row[0] + C_row[1]; \\n\"\n\t\t\t\"  C_row[0] = E[i]; \\n\"\n\t\t\t\" }\"\n\t\t\t;\n\t\t\tchar* after = \t\t\t\" #pragma ACCEL kernel \\n\"\n\t\t\t\" \\n\"\n\t\t\t\"void kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220]) { \\n\"\n\t\t\t\"  double tmp[200]; \\n\"\n\t\t\t\"  double mul[200];\n//#pragma ACCEL PIPELINE auto{flatten}\n\t\t\t\"  for (int i = 0; i < 200; i++) {\n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n\t\t\t\"    for (int j = 0; j < 220; j++) {\n                   C[i][j] *= beta;\n                }\n\t\t\t\"  }\"\n\t\t\t\"  for (int i = 0; i < 200; i++) {\n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n\t\t\t\"    for (int j = 0; j < 200; j++) {\n                   tmp[i] = A[i][j] * alpha;\n                   mul[i] = tmp[i] * B[j][219];\n\t\t\t\t\tfor (int k = 0; k < 220; k++) {\n                       C[i][j] += mul[j] * B[i][k];\n\t\t\t\t\t}\n                   mul[i] = tmp[i] * B[j][218];\n\t\t\t\t\tfor (int k = 0; k < 220; k++) {\n                       C[i][j] += mul[j] * B[i][k];\n\t\t\t\t\t}\n                   mul[i] = tmp[i] * B[j][217];\n\t\t\t\t\tfor (int k = 0; k < 220; k++) {\n                       C[i][j] += mul[j] * B[i][k];\n\t\t\t\t\t}\n                   mul[i] = tmp[i] * B[j][216];\n\t\t\t\t\tfor (int k = 0; k < 220; k++) {\n                       C[i][j] += mul[j] * B[i][k];\n\t\t\t\t\t}\n                   mul[i] = tmp[i] * B[j][215];\n\t\t\t\t\tfor (int k = 0; k < 220; k++) {\n                       C[i][j] += mul[j] * B[i][k];\n\t\t\t\t\t}\n                   mul[i] = tmp[i] * B[j][214];\n\t\t\t\t\tfor (int k = 0; k < 220; k++) {\n                       C[i][j] += mul[j] * B[i][k];\n\t\t\t\t\t}\n                   mul[i] = tmp[i] * B[j][213];\n\t\t\t\t\tfor (int k = 0; k < 220; k++) {\n                       C[i][j] += mul[j] * B[i][k];\n\t\t\t\t\t}\n                   mul[i] = tmp[i] * B[j][212];\n\t\t\t\t\tfor (int k = 0; k < 220; k++) {\n                       C[i][j] += mul[j] * B[i][k];\n\t\t\t\t\t}\n                   mul[i] = tmp[i] * B[j][211];\n\t\t\t\t\tfor (int k = 0; k < 220; k++) {\n                       C[i][j] += mul[j] * B[i][k];\n\t\t\t\t\t}\n                   mul[i] = tmp[i] * B[j][210];\n\t\t\t\t\tfor (int k = 0; k < 220; k++) {\n                       C[i][j] += mul[j] * B[i][k];\n\t\t\t\t\t}\n                   mul[i] = tmp[i] * B[j][209];\n\t\t\t\t\tfor (int k = 0; k < 220; k++) {\n                       C[i][j] += mul[j] * B[i][k];\n\t\t\t\t\t}\n                   mul[i] = tmp[i] * B[j][208];\n\t\t\t\t\tfor (int k = 0; k < 220; k++) {\n                       C[i][j] += mul[j] * B[i][k];\n\t\t\t\t\t}\n                   mul[i] = tmp[i] * B[j][207];\n\t\t\t\t\tfor (int k = 0; k < 220; k++) {\n                       C[i][j] += mul[j] * B[i][k];\n\t\t\t\t\t}\n                   mul[i] = tmp[i] * B[j][206];\n\t\t\t\t"}}
{"input": "To generate the given HLS codes in C, use the following comprehensive but concise natural language instructions for the specific #pragma values:\n\n1. Treat the following function as a hardware kernel for acceleration:\n   - Use `#pragma ACCEL kernel`\n\n2. Don't automatically pipeline this loop:\n   - Use `#pragma ACCEL PIPELINE \"off\"`\n\n3. Process this loop in its original, full form without breaking it into smaller chunks:\n   - Use `#pragma ACCEL TILE FACTOR=1`\n\n4. Run the iterations of this loop one after the other, not in parallel:\n   - Use `#pragma ACCEL PARALLEL FACTOR=1`\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n5. Automatically parallelize this loop with a total of 16 threads:\n   - Use `#pragma ACCEL PARALLEL FACTOR=auto{16}`\n\n  \n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n5. Use the automatic memory manager:\n   - Use `#pragma ACCEL MEMORY auto{off}`\n\n  \n#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "2": "\n5. Partition the total iteration space for this loop into 160 units (stripes) for scheduling:\n   - Use `#pragma ACCEL PARTITION FACTOR=auto{160}`\n\n  \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[j];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": "\n5. Don't distribute this loop:\n   - Use `#pragma ACCEL PARALLEL FACTOR=auto{1} COMPUTE{AUTO{2}} LAX{}`\n\n6. Don't distribute this loop:\n   - Use `#pragma ACCEL PIPELINE auto{off} COMPUTE{auto{8}} LAX{__PIPE__L2}`\n\n7. Don't distribute this loop:\n   - Use `#pragma ACCEL PIPELINE auto{off} COMPUTE{auto{1}} LAX{__PIPE__L3}`\n\n/* Data and kernel */\n  \n#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "4": "\n5. This loop is parallelized auto-1\n   #pragma ACCEL PIPELINE auto{__PIPE__L4}\n   #pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n   #pragma ACCEL PARALLEL FACTOR=auto{32}\n\tfor (j = 1; j < 32; j++) {\n    tmp = A[i][0] * B[0][j] +A[i][1] * B[1][j] +A[i][2] * B[2][j] +A[i][3] * B[3][j] +A[i][4] * B[4][j];\n    C[i][j] = tmp;\n  }\n\n6. This loop is parallelized auto{__PARA__L2}\n   #pragma ACCEL PIPELINE auto{__PIPE__L2}\n   #pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n   #pragma ACCEL PARALLEL FACTOR=auto{1}\n\tfor (i = 1; i < 20; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 32; j++) {\n      A[i][j] = A[i][j] + 1.0;\n    }\n  }\n\n7. This loop is parallelized auto{__PARA__L1}\n   #pragma ACCEL PIPELINE auto{__PIPE__L1}\n   #pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n   #pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n\tfor (i = 0; i < 20; i++) {\n    B[i][0] = A[i][0] * B[i][0];\n  }\n\n"}}
{"input": "To optimize the given C code with HLS, first, mark the function as a hardware kernel using '#pragma ACCEL kernel'. Then, disable automatic pipelining with '#pragma ACCEL PIPELINE auto{off}'. After that, set the tiling factor to 1 for the outermost loop with '#pragma ACCEL TILE FACTOR=auto{1}'. Inside the nested loops, enable automatic pipelining and set the tiling factor to 4 using '#pragma ACCEL PIPELINE auto{flatten}' and '#pragma ACCEL TILE FACTOR=auto{4}' respectively. Additionally, disable automatic pipelining and set the tiling factor to 1 for the innermost loop using '#pragma ACCEL PIPELINE auto{off}' and '#pragma ACCEL TILE FACTOR=auto{1}'.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 30; t++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 120 - 1; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction=D FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n"}}
{"input": "Process the first loop in parallel considering an optimal factor automatically. Disable automatic pipelining for this section of code. Divide the iterations of the next loop into smaller chunks for acceleration, using an optimal factor. Finally, execute the following loop in parallel, automatically determining the optimal factor for parallelization and including reduction operations. Remember that the entire function should be treated as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": " \n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": " \n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction=D FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_gemver(int n,double alpha,double beta,double A[120][120],double u1[120],double v1[120],double u2[120],double v2[120],double w[120],double x[120],double y[120],double z[120])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n  for (i = 0; i < 120; i++) {\n    x[i] = 0.0;\n    y[i] = 0.0;\n    z[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n  for (i = 0; i < 120; i++) {\n    \n#pragma ACCEL PARALLEL reduction=x FACTOR=auto{__PARA__L2}\n    for (j = 0; j < 120; j++) {\n      x[i] += alpha * A[i][j] * u1[j] * v1[j];\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n  for (i = 0; i < 120; i++) {\n    \n#pragma ACCEL PARALLEL reduction=y FACTOR=auto{__PARA__L4}\n    for (j = 0; j < 120; j++) {\n      y[i] += alpha * A[i][j] * u2[j] * v2[j];\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n  for (i = 0; i < 120; i++) {\n    z[i] = beta * y[i] + x[i];\n  }\n}\n", "3": " \n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "4": " \n #pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][70],double F[50][70],double C[60][80],double D[80][90],double G[40][90])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[k][i] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 90; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To generate the given HLS codes in C, follow these comprehensive but concise natural language instructions:\n- Mark the function as a hardware kernel for acceleration\n- Do not automatically pipeline the loop\n- Process the loop in its original, full form without breaking it into smaller chunks\n- Run the iterations of this loop one after the other, not in parallel\n- Run the iterations of this loop with a parallel factor of 30\n- Run the iterations of this loop with a parallel factor of 10", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 2L * j;\n        int _in_i = 2L * i;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "1": "24\n- Do not automatically distribute the loop\n- Do not automatically transform the loop\n//#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1024}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1;\n        int j_col = -1;\n        double dxy_x = 0.5 * (ex[i + 1][j + 1] - ex[i][j + 1]);\n        double dxy_y = 0.5 * (ey[i + 1][j + 1] - ey[i][j + 1]);\n        double dzz_x = 0.5 * (hz[i + 1][j] - hz[i][j]);\n        double dzz_y = 0.5 * (hz[i][j + 1] - hz[i][j]);\n        double dzz_z = 0.5 * (hz[i][j] - hz[i][j - 1]);\n        double ex_x = dzz_x - dxy_y;\n        double ex_y = dxy_x + dzz_y;\n        double ey_x = dxy_y - dzz_x;\n        double ey_y = dzz_y - dxy_x;\n        double hz_x = dxy_x - ey_y;\n        double hz_y = ey_x - dxy_x;\n        ex[i][j] = ex_x;\n        ey[i][j] = ey_y;\n        hz[i][j] = hz_z + 4.0 * (hz_x + hz_y);\n      }\n    }\n  }\n}\n", "3": "\n- Do not automatically distribute the loop\n- Do not automatically parallelize the loop\n- Do not automatically pipeline the loop\n- Do not automatically parallelize the L2\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_in_j = i + j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "\n \n#pragma ACCEL kernel\n\nvoid kernel_mvt(double x[400],double y[400],double u1[400],double u2[400],double v1[400],double v2[400],int up[400],int vp[400],int nz)\n{\n  int i;\n  int k;\n  double temp;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n  for (i = 0; i < 400; i++) {\n    x[i] = ((double )0);\n    y[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n  for (i = 0; i < 400; i++) {\n    int _in_x2;\n    int _in_x3;\n    _in_x2 = ((int )u1[i]) - 1;\n    _in_x3 = ((int )v1[i]) - 1;\n    for (k = 0; k < 30; k++) {\n      int _in_x4;\n      double _in_x5;\n      double _in_x6;\n      double _in_x7;\n      double _in_x8;\n      double _in_x9;\n      double _in_x10;\n      double _in_x11;\n      double _in_x12;\n      double _in_x13;\n      double _in_x14;\n      double _in_x15;\n      double _in_x16;\n      double _in_x17;\n      double _in_x18;\n      double _in_x19;\n      double _in_x20;\n      double _in_x21;\n      double _in_x22;\n      double _in_x23;\n      double _in_x24;\n      double _in_x25;\n      double _in_x26;\n      double _in_x27;\n      double _in_x28;\n      double _in_x29;\n      double _in_x30;\n      _in_x4 = _in_x2 + ((int )u2[i]) * nz;\n      _in_x5 = x[_in_x4];\n      _in_x6 = y[_in_x4];\n      _in_x7 = ((double )(up[k] - _in_x2));\n      _in_x8 = _in_x7 * _in_x7;\n      _in_x9 = 2.0 * _in_x7 * _in_x6;\n      _in_x10 = _in_x8 * _in4;\n      _in_x11 = _in_x8 * _in5;\n      _in_x12 = 2.0 * _in_x6;\n      _in_x13 = _in_x9 * _in4;\n      _in_x14 = _in_x9 * _in5;\n      _in_x15 = _in_x7 * _in6;\n      _in_x16 = _in_x8 * _in6;\n      _in_x17 = _in_x7 * _in7;\n      _in_x18 = _in_x8 * _in7;\n      _in_x19 = _in_x6 * _in4;\n      _in_x20 = _in_x6 * _in5;\n      _in_x21 = _in_x6 * _in6;\n      _in_x22 = _in_x7 * _in8;\n      _in_x23 = _in_x8 * _in8;\n      _in_x24 = _in_x6 * _in9;\n      _in_x25 = _in_x7 * _in9;\n      _in_x26 = _in_x8 * _in10;\n      _in_x27 = _in_x6 * _in10;\n      _in_x28 = _in_x7 * _in11;\n      _in_x29 = _in_x8 * _in11;\n      _in_x30 = _in_x6 * _in12;\n      temp = _in_x10 + _in_x11 + _in_x12;\n      x[_in_x4] = _in_x5 + _in_x13 + _in_x14 + _in_x15;\n      y[_in_x4] = _in_x6 + _in_x16 + _in_x17 + _in_x18;\n      x[(_in_x4 + _in_x2)] = _in_x5 + _in_x19 + _in_x20 + _in_x21;\n      y[(_in_x4 + _in_x2)] = _in_x6 + _in_x22 + _in_x23 + _in_x24;\n      x[(_in_x4 + _in_x3)] = _in_x5 + _in_x25 + _in_x26 + _in_x27;\n      y[(_in_x4 + _in_x3)] = _in_x6 + _in_x28 + _in_x29 + _in_x30;\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes, use the following comprehensive natural language instruction:\n\n\"Transform the function into a hardware kernel for acceleration. Then, disable automatic pipelining for the loop, set the tiling factor to 1, and ensure parallelism by setting the parallel factor to 2. Within the loop, apply a parallel factor of 30 for the first inner loop and 10 for the second inner loop.\"", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "3": "\n#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] -= 0.5 * (A[i][j] - A[i][j - 1]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n"}}
{"input": "Process the loop in its original, full form without breaking it into smaller chunks. Automatically pipeline and flatten the loop. Run the iterations of the loop in parallel with a reduction factor of 1_0 for the temporary array and a reduction factor of 1_1 for the final result array. Treat the following function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_atax(int m,int n,double A[116][124],double x[124],double y[124],double tmp[116])\n{\n  int i;\n  int j;\n//#pragma scop\n  for (i = 0; i < 124; i++) \n    y[i] = ((double )0);\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{116}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    tmp[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1_0}\n    for (j = 0; j < 124; j++) {\n      tmp[i] += A[i][j] * x[j];\n    }\n    \n#pragma ACCEL PARALLEL reduction=y FACTOR=auto{1_1}\n    for (j = 0; j < 124; j++) {\n      y[j] += A[i][j] * tmp[i];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": " \n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "2": " \n#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "3": " \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_0}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[j];\n    }\n    \n#pragma ACCEL PIPELINE auto{_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1_1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_1}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L2}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1_2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_2}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L3}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1_3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_3}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L4}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": " \n#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes in C, use the following natural language instruction:\n\n\"Designate the following function as a hardware kernel for acceleration, then automatically pipeline the outer loop, apply a tile factor of 1 to break the loop into smaller chunks, and run the iterations of the inner loops in parallel with a factor of 2 for the outer loop and a factor of 30 for the first inner loop and a factor of 10 for the second inner loop.\"", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n  for (t = 0; t < 35; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To generate the given HLS codes written in C, the following pragma values are used:\n\n1. Treat the following function as a hardware kernel for acceleration: '#pragma ACCEL kernel'\n2. Don't automatically pipeline this loop: '#pragma ACCEL PIPELINE \"off\"'\n3. Process this loop in its original, full form without breaking it into smaller chunks: '#pragma ACCEL TILE FACTOR=1'\n4. Run the iterations of this loop one after the other, not in parallel: '#pragma ACCEL PARALLEL FACTOR=1'\n\nThe comprehensive but very concise natural language instruction to generate these HLS codes would be:\n\"Mark the function as a hardware kernel, turn off auto-pipelining for the outer loop, set the tile factor to 1 for all loops, and run the iterations sequentially instead of in parallel.\"", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{2}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_0}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{off_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1_1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_1}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1_1_0}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1_2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_2}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1_2_0}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1_3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_3}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1_3_0}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n"}}
{"input": "Process the first loop in parallel with automatic factor determination, turn off automatic loop pipelining, use automatic tiling with factor 1, and process the second loop in parallel with automatic factor determination and reduction.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (j = 0; j < 70; j++) {\n      double tmp = A[i][0] * B[0][j];\n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (k = 1; k < 80; k++) {\n        tmp += A[i][k] * B[k][j];\n      }\n      C[i][j] += alpha * tmp;\n    }\n  }\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To compile this C code with the correct HLS pragmas, do the following:\n\n1. For the outer loop, use \"#pragma ACCEL PIPELINE auto\" to automatically pipeline the loop.\n\n2. For the outer loop, use \"#pragma ACCEL TILE FACTOR=auto{1}\" to break it into smaller chunks with automatic factor determination.\n\n3. For the first inner loop, use \"#pragma ACCEL PARALLEL FACTOR=auto{12}\" to run iterations in parallel with an auto-determined factor.\n\n4. For the second inner loop, use \"#pragma ACCEL PARALLEL FACTOR=auto{3}\" to run iterations in parallel with an auto-determined factor.\n\nFinally, annotate the 'kernel_jacobi_1d' function with the \"#pragma ACCEL kernel\" pragma to treat it as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n\n\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL WORKER FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n\n\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL WORKER FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n\n\n\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n\n\n\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORKER__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To generate the given HLS codes in C, use the following natural language instruction for each specific #pragma value:\n\n- \"Automatically flatten and pipeline this loop\" - for the line `#pragma ACCEL PIPELINE auto{flatten}`.\n- \"Set the tile factor automatically to 1\" - for the line `#pragma ACCEL TILE FACTOR=auto{1}`.\n- \"Automatically parallelize this loop with a factor of 2\" - for the line `#pragma ACCEL PARALLEL FACTOR=auto{2}`.\n- \"Automatically parallelize this loop with a factor of 12\" - for the line `#pragma ACCEL PARALLEL FACTOR=auto{12}`.\n- \"Automatically parallelize this loop with a factor of 1\" - for the line `#pragma ACCEL PARALLEL FACTOR=auto{1}`.\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n**seq.c**\n\n #include <math.h>\n #include <stdio.h>\n #include <sys/time.h>\n#pragma ACCEL kernel\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "1": "- \"Automatically parallelize this loop with a factor of 2\" - for the line `#pragma ACCEL PARALLEL FACTOR=auto{2}`.\n\n**seq.c**: 1 loop \n\n\n\n#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n**seqjacf.c**\n\n```\n #include <math.h>\n #include <stdio.h>\n #include <sys/time.h>\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n**seq.c**\n\n #include <stdio.h> \n #include <sys/time.h>\n#include <math.h>\n#include <stdlib.h>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n#define N 120\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ndouble A[N][N];\ndouble B[N][N];\ndouble C[N][N];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][60],double A[60][60],double B[60][60])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (j = 0; j < 60; j++) {\n      C[i][j] *= beta;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (j = 0; j < 60; j++) {\n      double temp = A[i][0] * B[0][j];\n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (k = 1; k < 30; k++) {\n        temp += A[i][k] * B[k][j];\n      }\n      C[i][j] += temp;\n    }\n  }\n}\n \nint main()\n{\n  int i;\n  int j;\n  int ki;\n  int kj;\n  double alpha = (double )1.8;\n  double beta = (double )0.9;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (j = 0; j < 60; j++) {\n      C[i][j] = 0.0;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (j = 0; j < 60; j++) {\n      A[i][j] = 0.0;\n    }\n  }\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (j = 0; j < 60; j++) {\n      B[i][j] = 0.0;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    for (j = 0; j < 60; j++) {\n      for (ki = 0; ki < 30; ki++) {\n        A[i][j] += alpha * B[ki][j] * A[ki][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    for (j = 0; j < 60; j++) {\n      C[i][j] += A[i][j];\n    }\n  }\n/* End Do", "4": "- \"Automatically parallelize this loop with a factor of 2\" - for the line `#pragma ACCEL PARALLEL FACTOR=auto{2}`.\n\n**pearson_correlation_part1.c**\n\n```\n #include <math.h>\n#pragma ACCEL kernel\n\nvoid kernel_correlation(double float_n,double data[100][80],double corr[80][80],double mean[80],double stddev[80])\n{\n  int i;\n  int j;\n  int k;\n  double eps = 0.1;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (j = 0; j < 80; j++) {\n    mean[j] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (i = 0; i < 100; i++) {\n      mean[j] += data[i][j];\n    }\n    mean[j] /= float_n;\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n  for (j = 0; j < 80; j++) {\n    stddev[j] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 100; i++) {\n      stddev[j] += pow(data[i][j] - mean[j],(double )2);\n    }\n    stddev[j] /= float_n;\n    stddev[j] = sqrt(stddev[j]);\n    stddev[j] = (stddev[j] <= 1.0e-10 ? 1.0 : stddev[j]);\n  }\n// Matrix-matrix multiplication\n// AxB, A: mean of data, B: data\n// Note:\n// Need to use \"inner\" layout for B to get good performance.\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n  for (i = 0; i < 80; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (j = 0; j < 80; j++) {\n      corr[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (k = 0; k < 100; k++) {\n        corr[i][j] += (data[k][i] - mean[i]) * (data[k][j] - mean[j]);\n      }\n      corr[i][j] /= stddev[i] * stddev[j];\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes written in C, use the following natural language instructions:\n\n- For the `kernel_jacobi_1d` function, insert the directive to treat the function as a hardware kernel for acceleration.\n- For the outer loop, automatically pipeline the entire loop in the code without flattening the multi-dimensional access pattern.\n- For the outer loop, use auto{1} factor to tile the loop into smaller chunks with size determined automatically.\n- For the outer loop, use auto{2} factor to parallelize the loop with an auto-determined parallel factor.\n- For the inner loop, use auto{30} factor to parallelize the loop with an auto-determined parallel factor.\n- For the second inner loop, use auto{1} factor to parallelize the loop with an auto-determined parallel factor.\n\nBy implementing these natural language instructions, you can generate the given HLS codes in C with the corresponding #pragma values.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To generate the given HLS codes in C, you need to treat the following function as a hardware kernel for acceleration and use the following #pragma values:\n\n1. Use `#pragma ACCEL PIPELINE auto{flatten}` to automatically pipeline the loop.\n2. Use `#pragma ACCEL TILE FACTOR=auto{1}` to process the loop in its original, full form without breaking it into smaller chunks.\n3. Use `#pragma ACCEL PARALLEL FACTOR=auto{2}` to run the iterations of the loop in parallel with a factor of 2.\n4. Use `#pragma ACCEL PARALLEL FACTOR=auto{12}` for the inner loop to run in parallel with a factor of 12.\n5. Use `#pragma ACCEL PARALLEL FACTOR=auto{1}` for the subsequent loop to run in parallel with a factor of 1.\n\nGiven these instructions and #pragma values, the HLS codes should be generated in C.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n", "1": "\n", "2": "\n", "3": "\n", "4": "\n"}}
{"input": "Process the outer loop in parallel, processing iterations in parallel as much as possible. Pipeline the inner loops to improve throughput. Use a tile factor of 1 to retain the original loop structure. Additionally, treat the function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 30; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L4}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 30; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To generate the given HLS codes written in C, you need to treat the `kernel_doitgen` function as a hardware kernel for acceleration and apply the following specific #pragma values for optimization:\n\n1. Disable automatic pipelining for the outermost loop:\n   `#pragma ACCEL PIPELINE auto{off}`\n\n2. Process the outermost loop in its original, full form without breaking it into smaller chunks:\n   `#pragma ACCEL TILE FACTOR=auto{1}`\n\n3. Enable automatic loop pipelining with flattening for the middle loop:\n   `#pragma ACCEL PIPELINE auto{flatten}`\n\n4. Process the middle loop in its original, full form without breaking it into smaller chunks:\n   `#pragma ACCEL TILE FACTOR=auto{1}`\n\n5. Disable automatic pipelining for the innermost loop:\n   `#pragma ACCEL PIPELINE auto{off}`\n\n6. Process the innermost loop in its original, full form without breaking it into smaller chunks:\n   `#pragma ACCEL TILE FACTOR=auto{1}`\n\nWith the above #pragma values, the given C code can be optimized for HLS processing.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n", "1": "\n", "2": "\n", "3": "\n\n#pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{2}\n      for (p = 0; p < 30; p++) {\n        double sum_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=sum_tmp FACTOR=auto{1}\n\tfor (s = 0; s < 30; s++) {\n          sum_tmp += A[r][q][s] * C4[s][p];\n        }\n\tsum[p] = sum_tmp;\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": " \n\n"}}
{"input": "Perform the following steps to optimize the C code using HLS pragmas:\n- First, mark the function as a hardware kernel for acceleration using '#pragma ACCEL kernel'.\n- Then, parallelize the loop iterating over 's' array by replacing '#pragma ACCEL PARALLEL FACTOR=auto{1}' with '#pragma ACCEL PARALLEL FACTOR=1'.\n- Next, do not automatically pipeline the loop iterating over 's' array by replacing '#pragma ACCEL PIPELINE auto{off}' with '#pragma ACCEL PIPELINE off'.\n- Finally, keep the loop iterating over 'q' array in its original form without breaking it into smaller chunks and process it without parallelization by keeping '#pragma ACCEL TILE FACTOR=auto{1}' and '#pragma ACCEL PARALLEL FACTOR=auto{1}' unchanged.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n \n#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[410][390],double s[390],double q[410],double p[390],double r[410])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 390; i++) {\n    s[i] = ((double )0);\n    q[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 410; i++) {\n    q[0] += r[i] * A[i][0];\n    s[0] += r[i] * A[i][0];\n  }\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 390; i++) {\n    p[i] = -q[i] / s[0];\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (i = 0; i < 410; i++) {\n    q[0] += r[i] * A[i][0] * p[0];\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 1; j < 390; j++) {\n      q[j] += r[i] * A[i][j] * p[j - 1];\n      s[j] += r[i] * A[i][j] * q[j - 1];\n    }\n  }\n}\n", "1": "\n \n#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[410][390],double s[390],double q[410],double p[390],double r[410])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 390; i++) {\n    s[i] = ((double )0);\n    q[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 410; i++) {\n    q[0] += r[i] * A[i][0];\n    s[0] += r[i] * A[i][0];\n  }\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 390; i++) {\n    p[i] = -q[i] / s[0];\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (i = 0; i < 410; i++) {\n    q[0] += r[i] * A[i][0] * p[0];\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 1; j < 390; j++) {\n      q[j] += r[i] * A[i][j] * p[j - 1];\n      s[j] += r[i] * A[i][j] * q[j - 1];\n    }\n  }\n}\n", "2": "\n \n#pragma ACCEL kernel\n\nvoid kernel_gemver(int n,double alpha,double beta,double A[40][50],double u1[40],double v1[40],double u2[50],double v2[50],double w[50],double x[40],double y[50],double z[40])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    double tmp1 = 0.0;\n    double tmp2 = 0.0;\n    double tmp3 = 0.0;\n    double tmp4 = 0.0;\n    \n#pragma ACCEL PARALLEL reduction=tmp1 FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp1 += A[i][j] * u1[j];\n      tmp4 += A[i][j] * v1[j];\n    }\n    \n#pragma ACCEL PARALLEL reduction=tmp2 FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp2 += A[i][j] * u2[j];\n      tmp3 += A[i][j] * v2[j];\n    }\n    \n#pragma ACCEL PARALLEL reduction=x[i] FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      x[i] += beta * A[i][j] * y[j];\n    }\n    x[i] = alpha * tmp1 + x[i];\n    y[i] = alpha * tmp2 + x[i];\n    z[i] = alpha * tmp3 + beta * tmp4 + z[i];\n  }\n}\n", "3": "\n \n#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[410][390],double s[390],double q[410],double p[390],double r[410])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 390; i++) {\n    s[i] = ((double )0);\n    q[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 410; i++) {\n    q[0] += r[i] * A[i][0];\n    s[0] += r[i] * A[i][0];\n  }\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 390; i++) {\n    p[i] = -q[i] / s[0];\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (i = 0; i < 410; i++) {\n    int jj_limit = 0;\n    int jj_buf = 0;\n    jj_buf = 0;\n    jj_limit = ((jj_buf + BLIS_JC_USE_BUF) <= JC_DIM);\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (j = 0; j < 390; j++) {\n      int ii_limit = 0;\n      int ii_buf = 0;\n      ii_buf = 0;\n      ii_limit = ((ii_buf + BLIS_IC_USE_BUF) <= IC_DIM);\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (jj = jj_buf; jj < ((jj_buf + BLIS_JC_USE_BUF) < JC_DIM ? BLIS_JC_USE_BUF : JC_DIM); jj++) {\n        int _in_i = i;\n        int _in_j = j;\n        int _in_jj = jj;\n        s[jj] += r[i] * A[_in_i][_in_j];\n        q[i] += A[_in_i][_in_j] * p[_in_j];\n      }\n    }\n  }\n}\n", "4": "\n \n#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[410][390],double s[390],double q[410],double p[390],double r[410])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 390; i++) {\n    s[i] = ((double )0);\n    q[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 410; i++) {\n    q[0] += r[i] * A[i][0];\n    s[0] += r[i] * A[i][0];\n  }\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 390; i++) {\n    p[i] = -q[i] / s[0];\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (i = 0; i < 410; i++) {\n    int jj_limit = 0;\n    int jj_upperbound = min(390, 1 + 0L * L PARALLEL FACTOR=auto{__PARA__L3}\n  for (i = 0; i < 410; i++) {\n    int jj_limit = 1;\n    int jj_upperbound = 390;\n    int jj_stride = 1;\n    int jj_init = 0;\n    int jj;\n    jj = jj_init;\n    jj_no_pipeline: \n#pragma ACCEL PIPELINE auto{off}\n    jj_no_tile: \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (j = 0; j < 390; j++) {\n      s[j] += r[i] * A[i][j];\n    }\n  }\n}\n"}}
{"input": "Process the following function as a hardware kernel for acceleration, and within the loops, turn off automatic pipelining and use a tile factor of 1.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{}\n      \n#pragma ACCEL TILE FACTOR=auto{2}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 0;\n        int _in_i = 0;\n        double _in_val = 0.0;\n        double _out_val = 0.0;\n        _in_j = 1 + 0;\n        _in_i = 1 + 0;\n        _in_val = ex[i][_in_j];\n        _out_val = _out_val + _in_val;\n        _in_j = 1 + 160;\n        _in_val = ex[i][_in_j];\n        _out_val = _out_val + _in_val;\n        _in_j = 1 + 80;\n        _in_val = 0.5 * (_in_val + ex[i][_in_j]);\n        ey[i][j] = ey[i][j] - 0.5 * (_in_val - ey[i][j]);\n        _in_val = _in_val * ((hz[i][j] - hz[i][j + 1]) - (hz[i + 1][j] - hz[i + 1][j + 1]));\n        _out_val = _out_val + _in_val;\n        _in_val = ey[i][j + 1];\n        _out_val = _out_val + _in_val;\n        ex[i][j] = _out_val;\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 0;\n        int _in_i = 0;\n        double _in_val = 0.0;\n        double _out_val = 0.0;\n        _in_j = 1 + 0;\n        _in_i = 1 + 0;\n        _in_val = ey[i][_in_j];\n        _out_val = _out_val + _in_val;\n        _in_j = 1 + 160;\n        _in_val = ey[i][_in_j];\n        _out_val = _out_val + _in_val;\n        _in_j = 1 + 80;\n        _in_val = 0.5 * (_in_val + ey[i][_in_j]);\n        hz[i][j] = hz[i][j] - 0.5 * (_in_val - hz[i][j]);\n        _in_val = _in_val * ((ex[i][j] - ex[i][j + 1]) - (ey[i + 1][j] - ey[i + 1][j + 1])) ;\n        _out_val = _out_val + _in_val;\n        _in_val = ey[i + 1][j];\n        _out_val = _out_val + _in_val;\n        ey[i][j] = _out_val;\n      }\n    }\n  }\n}\n"}}
{"input": "To optimize the given C code for HLS acceleration, use the following comprehensive but concise natural language instruction:\n\n\"Set the pipeline directive to manual, do not automatically pipeline the loops, and set the tile factor to 8 for the outermost loop; keep the loops in their original, full form without breaking them into smaller chunks, and process them one after the other without parallelization, treating the function as a hardware kernel for acceleration.\"\n\nThis instruction encompasses the necessary #pragma values and their specific settings for the given HLS code.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{8}\n    for (j = 0; j < 70; j++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n"}}
{"input": "Process the loop for the variable 'i' in parallel, run all the iterations of this loop one after the other, not in parallel, and treat this function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n  for (t = 0; t < 3  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL reduction=B FACTOR=auto{__PARA__L5}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL reduction=A FACTOR=auto{__PARA__L8}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_doit(double A[250][250],double C4[250][250],double sum[250])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 250; i++) {\n    double tmp = 0.0;\n    \n#pragma ACCEL PIPELINE auto{off}\n    for (k = 0; k < 250; k++) {\n      tmp += A[i][k] * C4[k][i];\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 250; j++) {\n      C4[i][j] = A[i][j] * tmp;\n    }\n    sum[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 250; i++) {\n    for (j = 0; j < 250; j++) {\n      sum[i] += C4[i][j];\n    }\n  }\n//#pragma endscop\n}\n", "4": " The kernel will be automatically parallelized by TTA. \n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "Process the following function as a hardware kernel for acceleration. Automatically pipeline the first loop, use automatic tile factor of 2, and run iterations of the second loop in parallel with reduction operations for variables 'tmp' and 'y'.", "output": "#pragma ACCEL kernel\n\nvoid kernel_atax(int m,int n,double A[116][124],double x[124],double y[124],double tmp[116])\n{\n  int i;\n  int j;\n//#pragma scop\n  for (i = 0; i < 124; i++) \n    y[i] = ((double )0);\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    tmp[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1_0}\n    for (j = 0; j < 124; j++) {\n      tmp[i] += A[i][j] * x[j];\n    }\n    \n#pragma ACCEL PARALLEL reduction=y FACTOR=auto{1_1}\n    for (j = 0; j < 124; j++) {\n      y[j] += A[i][j] * tmp[i];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_mvt(double x[400],double y[400],double u1[400],double u2[400],double v[400],int n)\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 400; i++) {\n    x[i] = ((double )0);\n    y[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 400; i++) {\n    for (j = 0; j < 400; j++) {\n      x[i] += v[j] * u1[j * 400 + i];\n    }\n    y[i] = u2[i] * x[i];\n  }\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_mvt(double x[120],double y[120],double u1[120],double u2[120],double v[140])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 120; i++) {\n    x[i] = ((double )0);\n    y[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 120; i++) {\n    for (j = 0; j < 140; j++) {\n      x[i] += v[j] * u1[j * 120] * u2[i * 120];\n      y[i] += v[j] * u1[j * 120];\n    }\n  }\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_mvt(double x[400],double y[400],double u1[400],double u2[400],double v[400],int n)\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 400; i++) {\n    x[i] = 1.0;\n    y[i] = 1.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n  for (i = 0; i < 400; i++) {\n    \n#pragma ACCEL PARALLEL reduction=u1 FACTOR=auto{__PARA__L50}\n    for (j = 0; j < 400; j++) {\n      u1[i] += x[j] * v[j];\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n  for (i = 0; i < 400; i++) {\n    \n#pragma ACCEL PARALLEL reduction=y FACTOR=auto{__PARA__L30}\n    for (j = 0; j < 400; j++) {\n      y[i] += u1[j] * u2[j];\n    }\n  }\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_atax(double A[340],double x[420],double y[420],int idx[420])\n{\n  int i;\n  int j;\n  double tmp;\n  double si;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  y[0] = 0.0;\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 1; i < 420; i++) {\n    tmp = 0.0;\n    \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{32}\n    for (j = 0; j < 340; j++) {\n      tmp += A[j * 420] * x[j * 420];\n    }\n    si = tmp / (1.0 + 1.0);\n    y[i] = si;\n    j = 0;\n    \n#pragma ACCEL PARALLEL reduction=y FACTOR=auto{32}\n    for (j = 0; j < 340; j++) {\n      y[i] += A[j * 420] * x[j];\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes in C, follow these natural language instructions:\n1. Mark the function as a hardware kernel for acceleration.\n2. Turn off automatic pipeline for the following loop.\n3. Keep the loop in its original form without breaking it into smaller chunks.\n4. Run iterations of the loop in parallel with a factor of 2.\n5. Run the inner loop iterations in parallel with a factor of 30.\n6. Run the inner loop iterations in parallel with a factor of 12.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n7. Turn off automatic parallelization for the following loop.\n8. Turn off automatic parallelization for the following loop.\n9. Turn off automatic parallelization for the following loop.\n10. Turn off automatic parallelization for the following loop.\n11. Turn off automatic parallelization for the following loop.\n12. Turn off automatic parallelization for the following loop.\n13. Turn off automatic parallelization for the following loop.\n14. Turn off automatic parallelization for the following loop.\n15. Turn off automatic parallelization for the following loop.\n16. Turn off automatic parallelization for the following loop.\n17. Turn off automatic parallelization for the following loop.\n18. Turn off automatic parallelization for the following loop.\n19. Turn off automatic parallelization for the following loop.\n20. Turn off automatic parallelization for the following loop.\n21. Turn off automatic parallelization for the following loop.\n22. Turn off automatic parallelization for the following loop.\n23. Turn off automatic parallelization for the following loop.\n24. Turn off automatic parallelization for the following loop.\n25. Turn off automatic parallelization for the following loop.\n26. Turn off automatic parallelization for the following loop.\n27. Turn off automatic parallelization for the following loop.\n28. Turn off automatic parallelization for the following loop.\n29. Turn off automatic parallelization for the following loop.\n30. Turn off automatic parallelization for the following loop.\n31. Turn off automatic parallelization for the following loop.\n32. Turn off automatic parallelization for the following loop.\n33. Turn off automatic parallelization for the following loop.\n34. Turn off automatic parallelization for the following loop.\n35. Turn off automatic parallelization for the following loop.\n36. Turn off automatic parallelization for the following loop.\n37. Turn off automatic parallelization for the following loop.\n38. Turn off automatic parallelization for the following loop.\n39. Turn off automatic parallelization for the following loop.\n40. Turn off automatic parallelization for the following loop.\n41. Turn off automatic parallelization for the following loop.\n42. Turn off automatic parallelization for the following loop.\n43. Turn off automatic parallelization for the following loop.\n44. Turn off automatic parallelization for the following loop.\n45. Turn off automatic parallelization for the following loop.\n46. Turn off automatic parallelization for the following loop.\n47. Turn off automatic parallelization for the following loop.\n48. Turn off automatic parallelization for the following loop.\n49. Turn off automatic parallelization for the following loop.\n50. Turn off automatic parallelization for the following loop.\n51. Turn off automatic parallelization for the following loop.\n52. Turn off automatic parallelization for the following loop.\n53. Turn off automatic parallelization for the following loop.\n54. Turn off automatic parallelization for the following loop.\n55. Turn off automatic parallelization for the following loop.\n56. Turn off automatic parallelization for the following loop.\n57. Turn off automatic parallelization for the following loop.\n58. Turn off automatic parallelization for the following loop.\n59. Turn off automatic parallelization for the following loop.\n60. Turn off automatic parallelization for the following loop.\n61. Turn off automatic parallelization for the following loop.\n62. Turn off automatic parallelization for the following loop.\n63. Turn off automatic parallelization for the following loop.\n64. Turn off automatic parallelization for the following loop.\n65. Turn off automatic parallelization for the following loop.\n66. Turn off automatic parallelization for the following loop.\n67. Turn off automatic parallelization for the following loop.\n68. Turn off automatic parallelization for the following loop.\n69. Turn off automatic parallelization for the following loop.\n70. Turn off automatic parallelization for the following loop.\n71. Turn off automatic parallelization for the following loop.\n72. Turn off automatic parallelization for the following loop.\n73. Turn off automatic parallelization for the following loop.\n74. Turn off automatic parallelization for the following loop.\n75. Turn off automatic parallelization for the following loop.\n76. Turn off automatic parallelization for the following loop.\n77. Turn off automatic parallelization for the following loop.\n78. Turn off automatic parallelization for the following loop.\n79. Turn off automatic parallelization for the following loop.\n80. Turn off automatic parallelization for the following loop.\n81. Turn off automatic parallelization for the following loop.\n82. Turn off automatic parallelization for the following loop.\n83. Turn off automatic parallelization for the following loop.\n84. Turn off automatic parallelization for the following loop.\n85. Turn off automatic parallelization for the following loop.\n86. Turn off automatic parallelization for the following loop.\n87. Turn off automatic parallelization for the following loop.\n88. Turn off automatic parallelization for the following loop.\n89. Turn off automatic parallelization for the following loop.\n90. Turn off automatic parallelization for the following loop.\n91. Turn off automatic parallelization for the following loop.\n92. Turn off automatic parallelization for the following loop.\n93. Turn off automatic parallelization for the following loop.\n94. Turn off automatic parallelization for the following loop.\n95. Turn off automatic parallelization for the following loop.\n96. Turn off automatic parallelization for the following loop.\n97. Turn off automatic parallelization for the following loop.\n98. Turn off automatic parallelization for the following loop.\n99. Turn off automatic parallelization for the following loop.\n100. Turn off automatic parallelization for the following loop.\n", "2": "\n7. Mark the following loop as FAST_EXIT{__PARA__L2}\n \n#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n7. Turn off automatic pipeline for the following loop.\n8. Keep the loop in its original form without breaking it into smaller chunks.\n9. Run iterations of the loop in parallel with a factor of 4.\n10. Run the inner loop iterations in parallel with a factor of 16.\n11. Turn off automatic parallelization for the following loop.\n12. Keep the loop in its original form without breaking it into smaller chunks.\n13. Turn off automatic parallelization for the following loop.\n14. Keep the loop in its original form without breaking it into smaller chunks.\n15. Turn off automatic parallelization for the following loop.\n16. Keep the loop in its original form without breaking it into smaller chunks.\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _row = i * 240 + j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "\n7. Turn off automatic parallelization for the following loop.\n8. Mark the following loop as FAST_FOURIER_TRANSFORM\n9. Mark the following loop as FAST_WALSH_TRANSFORM\n10. Turn off automatic parallelization for the following loop.\n11. Mark the following loop as FAST_WALSH_TRANSFORM\n \n#pragma ACCEL kernel\n\nvoid kernel_atax(double A[390][410],double x[410],double y[410],double tmp[390])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 410; i++) {\n    tmp[0] = 0.0;\n    x[i] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (j = 0; j < 390; j++) {\n      tmp[0] += A[j][i] * x[j];\n      y[i] += A[j][i] * x[j];\n    }\n    x[i] = x[i] + 1.0e+00 * tmp[0] * 4.0e-50;\n  }\n}\n\nvoid kernel_bicg(int m,int n,double A[90][90],double s[90],double q[90],double p[90],double r[90],double d[90],double tmp[90])\n{\n  int i;\n  int k;\n  int j;\n  int k_col;\n  double tmp_sum;\n  double tmp_x_q;\n  double s_q;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 90; i++) {\n    s[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 90; i++) {\n    tmp_sum = ((double )0);\n    \n#pragma ACCEL PARALLEL reduction=tmp_sum FACTOR=auto{__PARA__L5}\n    for (k = 0; k < 90; k++) {\n      tmp_sum += A[i][k] * d[k];\n    }\n    s[i] = tmp_sum;\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n  for (i = 0; i < 90; i++) {\n    q[i] = s[i] / r[i];\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n  for (i = 0; i < 90; i++) {\n    tmp_x_q = 0.0;\n    \n#pragma ACCEL PARALLEL reduction=tmp_x_q FACTOR=auto{__PARA__L6}\n    for (k = 0; k < 90; k++) {\n      k_col = (int )A[k][i];\n      tmp_x_q += A[k][i] * q[k_col];\n    }\n    p[i] = s[i] + tmp_x_q;\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L7}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L7}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n  for (i = 0; i < 90; i++) {\n    s_q = 0.0;\n    \n#pragma ACCEL PARALLEL reduction=s_q FACTOR=auto{__PARA__L8}\n    for (k = 0; k < 90; k++) {\n      s_q += A[i][k] * q[k];\n    }\n    tmp[i] = s_q;\n    q[i] = r[i] * q[i];\n  }\n}\n\nvoid kernel_bicg_2(int m,int n,double A[90][90],double s[90],double q[90],double p[90],double r[90],double d[90],double tmp[90])\n{\n  int i;\n  int k;\n  int j;\n  int k_col;\n  double tmp_sum;\n  double tmp_x_q;\n  double s_q;\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L9}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L9}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n  for (i = 0; i < 90; i++) {\n    s[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L10}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L10}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L10}\n  for (i = 0; i < 90; i++) {\n    tmp_sum = ((double )0);\n    \n#pragma ACCEL PARALLEL reduction=tmp_sum FACTOR=auto{__PARA__L11}\n    for (k = 0; k < 90; k++) {\n      tmp_sum += A[i][k] * d[k];\n    }\n    s[i] = tmp_sum;\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L12}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L12}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L12}\n  for (i = 0; i < 90; i++) {\n    q[i] = s[i] / r[i];\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L13}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L13}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L13}\n  for (i = 0; i < 90; i++) {\n    tmp_x_q = 0.0;\n    \n#pragma ACCEL PARALLEL reduction=tmp_x_q FACTOR=auto{__PARA__L14}\n    for (k = 0; k < 90; k++) {\n      k_col = (int )A[k][i];\n      tmp_x_q += A[k][i] * q[k_col];\n    }\n    p[i] = s[i] + tmp_x_q;\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L15}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L15}\n  \n#pragma ACCEL PARALLEL FACT"}}
{"input": "Process the loop with automatic pipelining, use automatic tiling, and run the iterations of the loop in parallel with a reduction clause. Also, treat the following function as a hardware kernel for acceleration.", "output": "\n#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[410][390],double s[390],double q[410],double p[390],double r[410])\n{\n  int i;\n  int j;\n  for (i = 0; i < 390; i++) \n    s[i] = ((double )0);\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 410; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 390; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To generate the given HLS codes written in C, use the following natural language instruction:\n\n\"Mark the following function as a hardware kernel for acceleration, and for the loops within it:\n1. Disable automatic pipelining.\n2. Process the loops in their original, full form without breaking them into smaller chunks.\n3. Perform pipelining with flattening for the innermost loop.\n4. Use a tile factor of 8 for the innermost loop.\"\n\nTranslate the above natural language instruction to the specific #pragma values as follows:\n```c\n#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{8}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    \n```", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{8}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n#pragma endscop\n}\n", "1": "\n#pragma endscop\n}\n", "2": "\n#pragma endscop\n}\n", "3": "\n#pragma endscop\n}\n", "4": "\n#pragma endscop\n}\n"}}
{"input": "Process the following loop sequentially without pipeline optimization: `#pragma ACCEL PIPELINE auto{off}`\nProcess the loop using its original, full form without breaking it into smaller chunks: `#pragma ACCEL TILE FACTOR=auto{1}`\nRun the iterations of this loop in parallel by breaking it into smaller chunks: `#pragma ACCEL TILE FACTOR=auto{4}`\nTreat the following function as a hardware kernel for acceleration: `#pragma ACCEL kernel`", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{}\n      \n#pragma ACCEL TILE FACTOR=auto{4}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "1": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n"}}
{"input": "To generate the HLS codes in C, use the following natural language instruction:\n\n\"Optimize hardware pipeline manually instead of automatic, do not tile the loop, and parallelize with a factor of 2 for the outer loop, 30 for the first inner loop, and 10 for the second inner loop. Treat the function as a hardware kernel for acceleration.\"", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 35; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 35; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i - 1) + 1;\n        int j_col = 2L * (j - 1) + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_col][j_col + 1] - ex[i_col][j_col] + ey[i_col + 1][j_col] - ey[i_col][j_col]);\n      }\n    }\n  }\n}\n", "3": "\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_up = i + 1;\n        int j_right = j + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_up][j] - ex[i][j]) - 0.7 * (ey[i][j_right] - ey[i][j]) + 1.0 * q[i][j];\n      }\n    }\n  }\n}\n", "4": "\n#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double B[25][30][40],double C[20][30][50])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n  int t;\n  int u;\n  double temp1;\n  double temp2;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    for (q = 0; q < 30; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n      for (p = 0; p < 20; p++) {\n        temp1 = ((double )0);\n        temp2 = ((double )0);\n#pragma ACCEL PARALLEL reduction=temp1 FACTOR=auto{__PARA__L5}\n\tfor (s = 0; s < 30; s++) {\n          for (t = 0; t < 40; t++) {\n            temp1 += A[r][p][s] * B[r][s][t];\n          }\n        }\n#pragma ACCEL PARALLEL reduction=C[p][q] FACTOR=auto{__PARA__L6}\n\tfor (s = 0; s < 30; s++) {\n          for (t = 0; t < 40; t++) {\n            temp2 += A[r][p][s] * B[r][s][t];\n          }\n        }\n        C[p][q] = C[p][q] + te1 * C[p][q];\n        C[p][q] = temp1 + te2 * C[p][q];\n      }\n    }\n  }\n}\n"}}
{"input": "Process the `kernel_doitgen` function as a hardware kernel for acceleration, and for the loops within, use the following pragma values:\n- For the outer loop over `r`, do not automatically pipeline it (`#pragma ACCEL PIPELINE auto{off}`).\n- For the loop over `r`, break it into smaller chunks with a factor of 2 in tiling (`#pragma ACCEL TILE FACTOR=2`).\n- For the loop over `q`, automatically pipeline it in a flattened manner (`#pragma ACCEL PIPELINE auto{flatten}`), and do not break it into smaller chunks (`#pragma ACCEL TILE FACTOR=1`).\n- For the loop over `p`, do not automatically pipeline it (`#pragma ACCEL PIPELINE auto{off}`), and do not break it into smaller chunks (`#pragma ACCEL TILE FACTOR=1`).", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\nAfter the transformations, the kernel should look like this:\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        double sum_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=sum_tmp FACTOR=auto{1}\n\tfor (s = 0; s < 30; s++) {\n          sum_tmp += A[r][q][s] * C4[s][p];\n        }\n\tsum[p] = sum_tmp;\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n//#pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][25][20],double sum[25][20])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[r][q] += A[r][q][p] * C4[p][r][q];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\nAfter acceleration, the generated C code should look like this:\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        double sum_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=sum_tmp FACTOR=auto{1}\n\tfor (s = 0; s < 30; s++) {\n          sum_tmp += A[r][q][s] * C4[s][p];\n        }\n\tsum[p] = sum_tmp;\n\tdouble A_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=A_tmp FACTOR=auto{1}\n\tfor (s = 0; s < 30; s++) {\n          A_tmp += A[r][q][s] * sum[s];\n        }\n\tA[r][q][0] = A_tmp;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n- For the loop over `q`, unroll it by a factor of 2 (`#pragma ACCEL PARALLEL FACTOR=2`)\n- For the loop over `p`, unroll it by a factor of 2 (`#pragma ACCEL PARALLEL FACTOR=2`)\nAfter acceleration, the generated C++ code should look like this:\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        double sum_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=sum_tmp FACTOR=auto{2}\n\tfor (s = 0; s < 30; s++) {\n          sum_tmp += A[r][q][s] * C4[s][p];\n        }\n\tsum[p] = sum_tmp;\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n- For the loop over `q`, unroll it by a factor of 2 (`#pragma ACCEL PIPELINE auto{flatten} UNROLL=2`)).\n- For the loop over `p`, unroll it by a factor of 2 (`#pragma ACCEL PIPELINE auto{off} UNROLL=2`)).\nAfter the above optimizations, the generated kernel should be similar to the following with no pipeline pragmas:\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{2}\n      for (p = 0; p < 30; p++) {\n        double sum_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=sum_tmp FACTOR=auto{1}\n\tfor (s = 0; s < 30; s++) {\n          sum_tmp += A[r][q][s] * C4[s][p];\n        }\n\tsum[p] = sum_tmp;\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To generate the provided HLS codes, use the following natural language instructions:\n\n1. Enable automatic pipelining for the loop: `#pragma ACCEL PIPELINE auto`\n\n2. Set the tiling factor automatically to 1 for the loop: `#pragma ACCEL TILE FACTOR=auto{1}`\n\n3. Set the parallelization factor automatically to 2 for the outer loop: `#pragma ACCEL PARALLEL FACTOR=auto{2}`\n\n4. Set the parallelization factor automatically to 30 for the inner loop (first computation loop): `#pragma ACCEL PARALLEL FACTOR=auto{30}`\n\n5. Set the parallelization factor automatically to 10 for the inner loop (second computation loop): `#pragma ACCEL PARALLEL FACTOR=auto{10}`\n\nRemember, in each pragma, the 'auto' specifies that the value should be determined automatically by the hardware.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n", "1": "\n", "2": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L2}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L4}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L5}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L6}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": "\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 119; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 119; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "4": " \n\n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n\n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n\n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (j = 16; j < 24; j++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 16; i < 24; i++) {\n      C[j][i] = C[j][i] + B[j][i] * A[i][j];\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes in C, follow these natural language instructions:\n\n1. Treat the following function as a hardware kernel for acceleration\n   ```\n   #pragma ACCEL kernel\n   ```\n\n2. Don't automatically pipeline the outermost loop\n   ```\n   #pragma ACCEL PIPELINE auto{off}\n   ```\n\n3. Process the outermost loop with a factor of 4\n   ```\n   #pragma ACCEL TILE FACTOR=auto{4}\n   ```\n\n4. Automatically pipeline the middle loop with flattening\n   ```\n   #pragma ACCEL PIPELINE auto{flatten}\n   ```\n\n5. Process the middle loop in its original, full form without breaking it into smaller chunks\n   ```\n   #pragma ACCEL TILE FACTOR=auto{1}\n   ```\n\n6. Don't automatically pipeline the innermost loop\n   ```\n   #pragma ACCEL PIPELINE auto{off}\n   ```\n\n7. Process the innermost loop in its original, full form without breaking it into smaller chunks\n   ```\n   #pragma ACCEL TILE FACTOR=auto{1}\n   ```", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n", "1": "\n\n", "2": "\n\n\n#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n\n### FLATTEN SPECIFICATION\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "\n\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_in_j = i * 240 + j;\n        int i_min_j = (i + 1) * 240 + j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i + 1][j] - ex[i][j]) * (ey[i][j + 1] - ey[i][j]) / (ex[i + 1][j + 1] - ex[i][j + 1]) - 0.7 * (ey[i][j + 1] - ey[i][j]) * (hz[i + 1][j + 1] - hz[i][j + 1]) / (ey[i + 1][j + 1] - ey[i + 1][j + 1]) + _fict_[i_in_j];\n      }\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes in C, for the function `kernel_jacobi_1d`, use the following natural language instructions for the respective #pragma values:\n\n1. \"Automatically pipeline the loops for parallel execution\" - for `#pragma ACCEL PIPELINE auto{flatten}`\n2. \"Divide the loops into smaller units of iteration to be processed in parallel, with the specified automatic factor\" - for `#pragma ACCEL TILE FACTOR=auto{1}`\n3. \"Execute the iterations of the loops in parallel with the specified automatic factor\" - for `#pragma ACCEL PARALLEL FACTOR=auto{2}` (first loop) and `#pragma ACCEL PARALLEL FACTOR=auto{30}` (second loop)\n4. \"Treat the following function as a hardware kernel for acceleration\" - for `#pragma ACCEL kernel`", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n\n**/\n \n#include <math.h>\n#ifndef CELL_SIZE\n#define CELL_SIZE 80\n#endif // CELL_SIZE\n#ifndef N\n#define N 400\n#endif // N\n#ifndef NUM_ITERS\n#define NUM_ITERS 40\n#endif // NUM_ITERS\n  \ndouble A[400];\ndouble B[400];\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[400],double B[400])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 400 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 400 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n\n**Total Kernel Code Size = 8984**\n\n\n```\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n```\n", "4": "\n\n** further information is available in the following site: https://github.com/IntelAI/hlsexamples/blob/master/jacobi-1d/jacobi-1d.c**\n\n  \n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "Process the following function as a hardware kernel for acceleration. Do not automatically pipeline the first loop. Use a tile factor of 1 for loop tiling. Run the iterations of the second loop one after the other, not in parallel, with reduction of 'tmp' and 'y' using a factor of 1 for both reductions.", "output": "#pragma ACCEL kernel\n\nvoid kernel_atax(int m,int n,double A[116][124],double x[124],double y[124],double tmp[116])\n{\n  int i;\n  int j;\n//#pragma scop\n  for (i = 0; i < 124; i++) \n    y[i] = ((double )0);\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    tmp[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1_0}\n    for (j = 0; j < 124; j++) {\n      tmp[i] += A[i][j] * x[j];\n    }\n    \n#pragma ACCEL PARALLEL reduction=y FACTOR=auto{1_1}\n    for (j = 0; j < 124; j++) {\n      y[j] += A[i][j] * tmp[i];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_correlation(double float_n,double data[100][80],double corr[80][80],double tmp[80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (j = 0; j < 80; j++) {\n    tmp[j] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{__PARA__L2}\n    for (i = 0; i < 100; i++) {\n      tmp[j] += data[i][j] / float_n;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n  for (i = 0; i < 100; i++) {\n    \n#pragma ACCEL PARALLEL reduction=corr FACTOR=auto{__PARA__L3}\n    for (j = 0; j < 80; j++) {\n      corr[i][j] = tmp[j] - data[i][j] / float_n;\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_correlation(double float_n,double data[100][80],double corr[80][80],double k[80])\n{\n  int i;\n  int j;\n  int k_col;\n  double tmp;\n  double sum_v;\n  double mul_v;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  loop_j:\n  for (j = 0; j < 80; j++) {\n    loop_k:\n    for (k_col = 0; k_col < 80; k_col++) {\n      tmp = ((double )0);\n      sum_v = k[k_col] * ((double )1.0E+20);\n      loop_i:\n      for (i = 0; i < 100; i++) {\n        mul_v = data[i][j] * k[k_col];\n        tmp += mul_v;\n        sum_v += mul_v;\n      }\n      corr[j][k_col] = tmp / sum_v;\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes in C, use the following concise natural language instructions for the specific #pragma values:\n\n1. Mark the function as a hardware kernel for acceleration: \n   - \"Treat the following function as a hardware kernel for acceleration\"\n\n2. Pipeline the loop with auto scheduling:\n   - \"Automatically pipeline this loop\"\n\n3. Tile the loop with a factor of 4:\n   - \"Break this loop into smaller chunks with a factor of 4\"\n\n4. Run the iterations one after the other, not in parallel, with automatic scheduling:\n   - \"Automatically process this loop without running iterations in parallel\"\n\n5. Turn off automatic pipelining for the loop:\n   - \"Turn off automatic pipelining for this loop\"\n\n6. Tile the loop with a factor of 1:\n   - \"Break this loop into smaller chunks with a factor of 1\"\n\n7. Run the iterations one after the other, not in parallel, with automatic scheduling:\n   - \"Automatically process this loop without running iterations in parallel\"\n\n8. Pipeline the loop with auto scheduling:\n   - \"Automatically pipeline this loop\"\n\n9. Tile the loop with a factor of 1:\n   - \"Break this loop into smaller chunks with a factor of 1\"\n\n10. Run the iterations one after the other, not in parallel, with automatic scheduling:\n    - \"Automatically process this loop without running iterations in parallel\"\n\n11. Pipeline the loop with a specific identifier (__PIPE__L3) for scheduling:\n    - \"Pipeline this loop with a specific identifier\"\n\n12. Tile the loop with a specific identifier (__TILE__L3) for scheduling:\n    - \"Break this loop into smaller chunks with a specific identifier\"\n\n13. Run the iterations in parallel with a factor of 1:\n    - \"Run the iterations of this loop in parallel with a factor of 1\"\n\nBy implementing these instructions, the HLS codes in C can be generated as described.", "output": "#include <math.h>\n#pragma ACCEL kernel\n\nvoid kernel_correlation(double float_n,double data[100][80],double corr[80][80],double mean[80],double stddev[80])\n{\n  int i;\n  int j;\n  int k;\n  double eps = 0.1;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n  for (j = 0; j < 80; j++) {\n    mean[j] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 100; i++) {\n      mean[j] += data[i][j];\n    }\n    mean[j] /= float_n;\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n  for (j = 0; j < 80; j++) {\n    stddev[j] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 0; i < 100; i++) {\n      stddev[j] += pow(data[i][j] - mean[j],(double )2);\n    }\n    stddev[j] /= float_n;\n    stddev[j] = sqrt(stddev[j]);\n/* The following in an inelegant but usual way to handle\n         near-zero std. dev. values, which below would cause a zero-\n         divide. */\n    stddev[j] = (stddev[j] <= eps?1.0 : stddev[j]);\n  }\n/* Center and reduce the column vectors. */\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (i = 0; i < 100; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (j = 0; j < 80; j++) {\n      data[i][j] -= mean[j];\n      data[i][j] /= sqrt(float_n) * stddev[j];\n    }\n  }\n/* Calculate the m * m correlation matrix. */\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 80 - 1; i++) {\n    corr[i][i] = 1.0;\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L7}\n    for (j = i + 1; j < 80; j++) {\n      corr[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7_0}\n      for (k = 0; k < 100; k++) {\n        corr[i][j] += data[k][i] * data[k][j];\n      }\n      corr[j][i] = corr[i][j];\n    }\n  }\n  corr[80 - 1][80 - 1] = 1.0;\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction=D FACTOR=auto{__PARA__L2}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col;\n        int j_col;\n        double ey_x;\n        double ex_y;\n        double _in_val_;\n        double _in_val_0;\n        double _in_val_1;\n        double _in_val_2;\n        double _in_val_3;\n        double _in_val_4;\n        i_col = 240 * i + j + 1;\n        j_col = 240 * (j + 1) + i;\n        ey_x = ey[i][j + 1] - ey[i][j];\n        ex_y = ex[i + 1][j] - ex[i][j];\n        _in_val_ = ex[i][j] - ey[i][j];\n        _in_val_0 = _in_val_ + ey_x;\n        _in_val_1 = _in_val_0 + ex_y;\n        _in_val_2 = _in_val_1 * ((double )0 / 2.0);\n        _in_val_3 = _in_val_2 + hz[i][j];\n        _in_val_4 = _in_val_3 - hz[i + 1][j + 1];\n        hz[i][j] = _in_val_4;\n      }\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes, use the following comprehensive but concise natural language instruction:\n\"Mark the following function as a hardware kernel for acceleration, then pipeline the loop automatically, tile the loop with a factor of 8, and run the iterations of the loop in parallel with a parallel factor of 1.0 for reduction variables 'tmp' and 1.1 for reduction variables 'y'.\"\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_atax(int m,int n,double A[116][124],double x[124],double y[124],double tmp[116])\n{\n  int i;\n  int j;\n//#pragma scop\n  for (i = 0; i < 124; i++) \n    y[i] = ((double )0);\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    tmp[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1_0}\n    for (j = 0; j < 124; j++) {\n      tmp[i] += A[i][j] * x[j];\n    }\n    \n#pragma ACCEL PARALLEL reduction=y FACTOR=auto{1_1}\n    for (j = 0; j < 124; j++) {\n      y[j] += A[i][j] * tmp[i];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": " #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma endscop\n}\n", "1": " #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "2": " #pragma ACCEL kernel\n\nvoid kernel_gemver(int n,double alpha,double beta,double A[120][120],double u1[120],double v1[120],double u2[120],double v2[120],double w[120],double x[120],double y[120],double z[120])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 120; i++) {\n    x[i] = 0.0;\n    y[i] = 0.0;\n    z[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 120; i++) {\n    double tmp = 0.0;\n    double u = 0.0;\n    double v = 0.0;\n    \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{__PARA__L4}\n    for (j = 0; j < 120; j++) {\n      tmp += A[i][j] * u1[j];\n      u += A[i][j] * v1[j];\n    }\n    \n#pragma ACCEL PARALLEL reduction=x FACTOR=auto{__PARA__L5}\n    for (j = 0; j < 120; j++) {\n      x[i] += A[i][j] * w[j];\n    }\n    v = v1[i];\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L7}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L7}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n    for (j = 0; j < 120; j++) {\n      z[i] += A[i][j] * y[j];\n    }\n    y[i] = beta * y[i] + alpha * u * v + tmp;\n  }\n}\n", "3": " #pragma ACCEL kernel\n\nvoid kernel_gemver(int n,double alpha,double beta,double A[120][120],double u1[120],double v1[120],double u2[120],double v2[120],double w[120],double x[120],double y[120],double z[120])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 120; i++) {\n    x[i] = 0.0;\n    y[i] = 0.0;\n    z[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 120; i++) {\n    double tmp1 = 0.0;\n    double tmp2 = 0.0;\n    double uu = 0.0;\n    double vv = 0.0;\n    double ww = 0.0;\n    double xx = 0.0;\n    double yy = 0.0;\n    double zz = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 120; j++) {\n      tmp1 = A[i][j] * u1[j];\n      tmp2 = A[i][j] * v1[j];\n      uu += A[i][j] * u1[j] * v1[j];\n      vv += A[i][j] * u1[j] * v1[j];\n      ww += A[i][j] * v1[j] * v1[j];\n      xx += A[i][j] * x[j];\n      yy += A[i][j] * y[j];\n      zz += A[i][j] * z[j];\n    }\n    x[i] = tmp1 - xx;\n    y[i] = tmp2 - yy;\n    z[i] = A[i][i] * zz - z[i];\n    double delta = (y[i] - vv - x[i] * uu) / n;\n    w[i] = z[i] + alpha * ((x[i]) * delta - y[i]);\n  }\n}\n", "4": " #pragma ACCEL kernel\n\nvoid kernel_gemver(int n,double alpha,double beta,double A[120][120],double u1[120],double v1[120],double u2[120],double v2[120],double w[120],double x[120],double y[120],double z[120])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 120; i++) {\n    x[i] = 0.0;\n    y[i] = 0.0;\n    z[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n  for (i = 0; i < 120; i++) {\n    double tmp = 0.0;\n    double tmp_x = 0.0;\n    double tmp_y = 0.0;\n    double u_i;\n    double v_i;\n    double w_i;\n    double Aij;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (j = 0; j < 120; j++) {\n      u_i = u1[i];\n      v_i = v1[i];\n      w_i = w[j];\n      Aij = A[i][j];\n      tmp += Aij * u_i * v_i;\n      tmp_x += Aij * v_i;\n      tmp_y += Aij * u_i;\n      x[j] += tmp_x * w_i;\n      y[j] += tmp_y * w_i;\n      z[i] += Aij * u_i * v_i;\n    }\n    z[i] = beta * z[i] + alpha * tmp;\n    x[i] = x[i] + tmp_x;\n    y[i] = y[i] + tmp_y;\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n  for (i = 0; i < 120; i++) {\n    double x_i = x[i];\n    double y_i = y[i];\n    double u_ip1;\n    double v_ip1;\n    double tmp_x = 0.0;\n    double tmp_y = 0.0;\n    double Aip1j;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (j = 0; j < 120; j++) {\n      if (i < j) {\n        Aip1j = A[i + 1][j];\n        u_ip1 = u1[i + 1];\n        v_ip1 = v1[i + 1];\n        tmp_x += Aip1j * v_ip1;\n        tmp_y += Aip1j * u_ip1;\n        x[j] += tmp_x;\n        y[j] += tmp_y;\n      }\n    }\n    x[i] = x_i + tmp_x;\n    y[i] = y_i + tmp_y;\n    z[i] += x_i * u_i * v_i + y_i * v_i * u_i + x_i * v_ip1 * u_i + y_i * u_ip1 * v_i;\n  }\n}\n"}}
{"input": "To generate the given HLS codes, you need to treat the function as a hardware kernel for acceleration. Then, don't automatically pipeline the loop, process the loop in its original form without breaking it into smaller chunks, and run the iterations of the loop one after the other, not in parallel. Finally, reduce the loop variables 'tmp' and 'y' in separate parallel processes.", "output": "#pragma ACCEL kernel\n\nvoid kernel_atax(int m,int n,double A[116][124],double x[124],double y[124],double tmp[116])\n{\n  int i;\n  int j;\n//#pragma scop\n  for (i = 0; i < 124; i++) \n    y[i] = ((double )0);\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    tmp[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1_0}\n    for (j = 0; j < 124; j++) {\n      tmp[i] += A[i][j] * x[j];\n    }\n    \n#pragma ACCEL PARALLEL reduction=y FACTOR=auto{1_1}\n    for (j = 0; j < 124; j++) {\n      y[j] += A[i][j] * tmp[i];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_atax(double A[390][410],double x[410],double y[410],double tmp[390])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 410; i++) {\n    tmp[0] = A[0][i] * x[i];\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 410; i++) {\n    y[i] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 390; j++) {\n      y[i] += A[j][i] * tmp[j];\n    }\n  }\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_atax(double A[390][410],double x[410],double y[410],double tmp[390])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 410; i++) {\n    tmp[0] = A[0][i] * x[i];\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 410; i++) {\n    y[i] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 390; j++) {\n      y[i] += A[j][i] * tmp[j];\n    }\n  }\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_atax(double A[390][410],double x[410],double y[410],double tmp[390])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 410; i++) {\n    tmp[0] = A[0][i] * x[i];\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 410; i++) {\n    y[i] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 390; j++) {\n      y[i] += tmp[j] * A[j][i];\n    }\n  }\n}\n", "3": " \n #pragma ACCEL kernel\n\nvoid kernel_atax(double A[340][420],double x[420],double y[420],double tmp[340])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 420; i++) {\n    tmp[0] = A[0][i] * x[i];\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 420; i++) {\n    y[i] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 340; j++) {\n      y[i] += tmp[j] * A[j][i];\n    }\n  }\n}\n", "4": " \n #pragma ACCEL kernel\n\nvoid kernel_mvt(double x[120], double y[120], double u1[120], double u2[120], double v1[120], double v2[120], int n)\n{\n  int i;\n  int j;\n  double tmp;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 120; i++) {\n    tmp = (x[i] * u1[i] + y[i] * v1[i]) ;\n    v2[i] = (x[i] * u2[i] + y[i] * v2[i]) ;\n    u2[i] = tmp;\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (i = 0; i < 120; i++) {\n    y[i] = u2[i];\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n  for (i = 0; i < 120; i++) {\n    v1[i] = u1[i] + v2[i];\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n  for (i = 0; i < 120; i++) {\n    x[i] = u1[i] + v1[i];\n  }\n}\n"}}
{"input": "Process this loop in its original, full form without breaking it into smaller chunks\nRun the iterations of this loop one after the other, not in parallel\nTreat the following function as a hardware kernel for acceleration", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1*i;\n        int j_col = j + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_col][j] - ex[i][j_col]) - 0.7 * (ey[i][j_col] - ey[i_col][j]);\n      }\n    }\n  }\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1*i;\n        int j_col = j + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_col + 1][j] - ex[i][j] + ey[i][j_col + 1] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        z_pe[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ey[i + 1][j] - ey[i][j] + ex[i][j + 1] - ex[i][j]);\n      }\n    }\n  }\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n  for (t = 0; t < 3A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1];\n      }\n    }\n    \n#pragma endscop\n//#pragma end auto{ }\n}\n0; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[i - 1][j] + A[i - 1][j - 1] + A[i - 1][1 + j] + "}}
{"input": "To generate the given HLS codes in C, use the following natural language instruction:\n\"Designate the following function as a hardware kernel for acceleration. Pipeline the outer loop automatically with flattening. Break the loop into tiles with a factor chosen automatically. Run the iterations of the outer loop in parallel with a factor of 2, followed by running the inner loops in parallel with a factor of 16 and then a factor of 1.\"", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To generate the given HLS codes in C, use the following natural language instruction: \"Treat the following function as a hardware kernel for acceleration, process the loops in their original, full form without breaking them into smaller chunks, don't automatically pipeline the loops, and run the iterations of the loops one after the other, not in parallel.\"", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 2L * j;\n        int _in_i = 2L * i;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "1": "\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L8}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": "\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": "\ninline void kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        zx[i][j] = _fict_[t] - 0.5 * (ex[i][j + 1] - ex[i][j]);\n        zy[i][j] = _fict_[t] - 0.5 * (ey[i + 1][j] - ey[i][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 1; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n      for (j = 1; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (zy[i][j + 1] - zy[i][j] - zx[i + 1][j] + zx[i][j]);\n      }\n    }\n  }\n}\n"}}
{"input": "Process the function as a hardware kernel for acceleration.\nDisable automatic pipelining for all loops.\nDo not break the loops into smaller chunks.\nSet the tile factor to 1 for all loops.\nEnable automatic pipelining for the innermost loop with a tile factor of 8.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{}\n      \n#pragma ACCEL TILE FACTOR=auto{8}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\nConfigure storage tiling for the B input of the innermost loop with a size of 8.\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "1": "\n\n #pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{8}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L14}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] -= 0.5 * (A[i][j] - A[i][j - 1]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\nConfigure CONV_FACTOR = private:auto{4}\n \n#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "3": "\nConfigure storage tiling for A\n  with a size of 4096\n  \n\n  resize A{1}\n  \n\n  \n#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "4": "\nConfigure storage for A\n#pragma ACCEL PIPELINE auto{off}\n  for (c_row = 0; c_row < 4; c_row++) {\n    for (c_col = 0; c_col < 4; c_col++) {\n      tmp = 0.0;\n      coef = 1.0;\n      for (a_row = 0; a_row < 4; a_row++) {\n        tmp += coef * A[a_row][c_col] * B[c_row][a_row];\n        coef = A[a_row][c_col];\n      }\n      C[c_row][c_col] = tmp;\n    }\n  }\n// Matrix multiplication for 2 matrices with dim = 4\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (c_row = 0; c_row < 4; c_row++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (c_col = 0; c_col < 4; c_col++) {\n      tmp = C[c_row][c_col];\n      total = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=total FACTOR=auto{__PARA__L2}\n      for (a_row = 0; a_row < 4; a_row++) {\n        total += tmp * A[a_row][c_col] * B[a_row][c_row];\n      }\n      C[c_row][c_col] = total;\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes in C, you can use the following comprehensive but concise natural language instruction:\n\n\"Optimize loop iteration processing for acceleration by automatically pipelining it, breaking it into smaller chunks, and running parallel iterations with specific factors. Treat the function as a hardware kernel for acceleration.\"\n\nThis instruction encompasses the use of the following specific #pragma values:\n- '#pragma ACCEL PIPELINE auto{flatten}' for automatically pipelining the loop\n- '#pragma ACCEL TILE FACTOR=auto{1}' for automatically breaking the loop into smaller chunks\n- '#pragma ACCEL PARALLEL FACTOR=auto{2}' to run parallel iterations with a specific factor\n- '#pragma ACCEL kernel' to treat the function as a hardware kernel for acceleration", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "1": "\n\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": "\n\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": "\n\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_low = i - 1;\n        int j_low = j - 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "\n\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1 * i * nx;\n        int j_col = -1 * j * ny;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]) / (1.0 + 0.5 * (sky[i_col + 64][j_col + 64] - rain[i_col + 64][j_col + 64])) / (1.0 * nx * ny);\n      }\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes in C:\n\n1. Invoke hardware acceleration for the following function\n   ```c\n   #pragma ACCEL kernel\n   void kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n   {\n     // code\n   }\n   ```\n\n2. Apply pipeline optimization to the loop\n   ```c\n   #pragma ACCEL PIPELINE auto{flatten}\n   ```\n\n3. Perform tiling with a factor of 1 for loop optimization\n   ```c\n   #pragma ACCEL TILE FACTOR=auto{1}\n   ```\n\n4. Enable loop parallelization with a factor of 2\n   ```c\n   #pragma ACCEL PARALLEL FACTOR=auto{2}\n   ```\n\n5. Parallelize the loop with a factor of 16\n   ```c\n   #pragma ACCEL PARALLEL FACTOR=auto{16}\n   ```\n\n6. Sequentially execute the loop iterations with a factor of 1 for optimization\n   ```c\n   #pragma ACCEL PARALLEL FACTOR=auto{1}\n   ```", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n", "1": "\n\n", "2": "\n\n", "3": "\n\n", "4": "\n\n7. Parallelize the outer loop with a factor of 8\n   ```c\n   #pragma ACCEL PARALLEL FACTOR=auto{8}\n   ```\n\n"}}
{"input": "To generate the given HLS C codes, follow these natural language instructions:\n\n- Treat the following function as a hardware kernel for acceleration.\n- Don't automatically pipeline the outer loop.\n- Process the loops in their original, full form without breaking them into smaller chunks.\n- Run the iterations of the inner loops one after the other, not in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{8}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1*i;\n        int j_col = j + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_col][j] - ex[i][j_col]) - 0.7 * (ey[i][j_col] - ey[i_col][j]);\n      }\n    }\n  }\n}\n", "2": "\n- #pragma ACCEL kernel\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i % 100);\n        int i_row = 2L * (i / 100);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_col + 1][j] - ex[i_col][j] + ey[i][j_col + 1] - ey[i][j_row]);\n      }\n    }\n  }\n}\n", "3": "\n- Do not change the order of the computed terms.\n- #pragma ACCEL kernel\n\n#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction=D FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n- #pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DX2;\n  double DY2;\n  double DXDY;\n  double C1;\n  double C2;\n  double C12;\n  double C1D2;\n  double ND;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 39; t++) {\n//#pragma scop\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n      for (j = 1; j < 59; j++) {\n        DX = ((((float )60)) - (((float )59)));\n        DY = ((((float )60)) - (((float )59)));\n        DX2 = (DX * DX);\n        DY2 = (DY * DY);\n        DXDY = (DX * DY);\n        C1 = ((-2.0) * DX2 / (DX2 + DY2));\n        C2 = ((-2.0) * DY2 / (DX2 + DY2));\n        C12 = (C1 * C2);\n        C1D2 = (C1 * DY2);\n        ND = (1.0 + C12 + C1D2);\n        u[i][j] = ((((-1.0) * ((((float )4.0) * (u[i - 1][j] - 2.0 * u[i][j] + u[i + 1][j])) + (v[i][j - 1] - 2.0 * v[i][j] + v[i][j + 1]))) / ND) + (p[i][j]));\n        v[i][j] = ((((-1.0) * ((((float )4.0) * (v[i - 1][j] - 2.0 * v[i][j] + v[i + 1][j])) + (u[i][j - 1] - 2.0 * u[i][j] + u[i][j + 1]))) / ND) + (q[i][j]));\n      }\n    }\n//#pragma endscop\n  }\n}\n"}}
{"input": "Process the loops in their original, full form without breaking them into smaller chunks. Run the iterations of the loops one after the other, not in parallel. Treat the following function as a hardware kernel for acceleration. Also, don't automatically pipeline the loops.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": " You have 4 cycles (loops) left.\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4_0}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[j];\n    }\n    \n#pragma ACCEL PIPELINE auto{off_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1_1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4_1}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4_1_0}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1_2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4_2}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4_2_0}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1_3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4_3}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4_3_0}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": " The original code is for HEMM.\n #pragma ACCEL kernel\n\nvoid gemm(double m1[4096],double m2[4096],double prod[4096])\n{\n  int i;\n  int j;\n  int k;\n  int k_col;\n  int i_col;\n  double mult;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  outer:\n  for (i = 0; i < 64; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    middle:\n    for (j = 0; j < 64; j++) {\n      i_col = i * 64;\n      double sum = (double )0;\n      \n#pragma ACCEL PARALLEL reduction=sum FACTOR=auto{1}\n      inner:\n      for (k = 0; k < 64; k++) {\n        k_col = k * 64;\n        mult = m1[i_col + k] * m2[k_col + j];\n        sum += mult;\n      }\n      prod[i_col + j] = sum;\n    }\n  }\n}\n", "2": " You have 4 loop(s) in your kernel function. Compile time loop blocking:off\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i % 100);\n        int j_col = 2L * (j % 120);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": " You have 40000000 elements in each array. After the above kernel has been applied, the results should match with the reference data. \n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[400][500],double A[400][700],double B[700][800],double C[500][800],double D[400][800])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 400; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 500; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{8}\n      for (k = 0; k < 700; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 400; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 800; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction=D FACTOR=auto{2}\n      for (k = 0; k < 500; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": " You have 4000000 elements.\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1;\n        int j_col = -1;\n        double dxy_2 = ((ex[i][j + 1] - ex[i][j]) * (ey[i + 1][j] - ey[i][j])) + ((ey[i][j + 1] - ey[i][j]) * (ex[i + 1][j] - ex[i][j]));\n        double dzt_2 = hz[i][j] - hz[i][j + 1];\n        double dzq_2 = hz[i + 1][j] - hz[i + 1][j + 1];\n        double dX_2 = ex[i][j + 1] - ex[i][j];\n        double dY_2 = ey[i + 1][j] - ey[i][j];\n        double dZ_2 = hz[i + 1][j + 1] - hz[i][j + 1];\n        double nx_2 = dY_2 * dzq_2 - dZ_2 * dY_2;\n        double ny_2 = dZ_2 * dX_2 - dX_2 * dzq_2;\n        double nz_2 = dX_2 * dY_2 - dY_2 * dX_2;\n        double s_2 = 1.0 / (1.0 + nx_2 + ny_2 + nz_2);\n        double ex_2 = s_2 * (nx_2 * ex[i][j] + ny_2 * ex[i][j + 1] + nz_2 * ex[i + 1][j + 1] + nx_2 * ex[i + 1][j] + ny_2 * ex[i][j] + nz_2 * ex[i][j + 1] - dxy_2);\n        double ey_2 = s_2 * (nx_2 * ey[i][j] + ny_2 * ey[i + 1][j] + nz_2 * ey[i + 1][j + 1] + nx_2 * ey[i + 1][j] + ny_2 * ey[i][j] + nz_2 * ey[i][j + 1] - dxy_2);\n        double hz_2 = s_2 * (nx_2 * hz[i][j] + ny_2 * hz[i][j + 1] + nz_2 * hz[i + 1][j + 1] + nx_2 * hz[i + 1][j] + ny_2 * hz[i + 1][j] + nz_2 * hz[i][j] - dzq_2 - dzt_2);\n        ex[i_col][j_col] = ex_2;\n        ey[i_col][j_col] = ey_2;\n        hz[i_col][j_col] = hz_2;\n      }\n    }\n  }\n}\n"}}
{"input": "Process the following function as a hardware kernel for acceleration, and for the loop nest within, don't automatically pipeline the outermost loop and process it in its original, full form without breaking it into smaller chunks. For the inner loops, automatically pipeline the loops with a factor of 8 for the second loop, and flatten the third loop automatically with a factor of 1.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{8}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": " \n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "1": " \n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": " \n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": " \n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n"}}
{"input": "To generate the HLS codes, use the following natural language instructions:\n\n- For the outer loop, \"Don't automatically pipeline this loop\" and \"Process this loop in its original, full form without breaking it into smaller chunks\" should be used to turn off autopipelining and set the tile factor to 1.\n- For the second loop, \"Don't automatically pipeline this loop\" and \"Process this loop in its original, full form without breaking it into smaller chunks\" should be used to turn off autopipelining and set the tile factor to 1.\n- For the innermost loop, \"Automatically pipeline this loop\" and \"Set the tile factor to 8\" should be used to enable autopipelining and set the tile factor to 8.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{}\n      \n#pragma ACCEL TILE FACTOR=auto{8}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "1": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": "\n\n#pragma ACCEL kernel\n\nvoid kernel_gesummv(double alpha,double beta,double A[250][250],double B[250][250],double tmp[250],double x[250],double y[250])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 250; i++) {\n    tmp[i] = 0.0;\n    y[i] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 250; j++) {\n      tmp[i] += A[i][j] * x[j];\n      y[i] += B[i][j] * x[j];\n    }\n    y[i] = alpha * tmp[i] + beta * y[i];\n  }\n}\n", "3": "\n\n#pragma ACCEL kernel\n\nvoid kernel_gesummv(double alpha,double beta,double A[250][250],double B[250][250],double tmp[250],double x[250],double y[250])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 250; i++) {\n    tmp[i] = 0.0;\n    y[i] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 250; j++) {\n      tmp[i] += A[i][j] * x[j];\n      y[i] += B[i][j] * x[j];\n    }\n    y[i] = alpha * tmp[i] + beta * y[i];\n  }\n}\n", "4": "\n\n #pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "Process the loop in its original, full form without breaking it into smaller chunks.  \nRun the iterations of this loop one after the other, not in parallel.  \nTreat the following function as a hardware kernel for acceleration.  \nAutomatically pipeline this loop, flatten the loop body.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "  \n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "  \n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "2": "  \n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "3": "  \n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i % 100);\n        int j_col = 2L * (j % 120);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "  \n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1;\n        int j_col = -1;\n        double dxy_col = 0.0;\n        double ex_x = 0.0;\n        double ey_y = 0.0;\n        double hz_col = hz[i][j] + ex[i][j] * 0.5 + ey[i][j] * 0.5;\n        dxy_col = ex[i][j + 1] - ex[i][j];\n        ex_x = ex[i][j] - dxy_col;\n        ey_y = ey[i][j] - (hz[i][j + 1] - hz[i][j]) - (ex[i][j + 1] - ex[i][j]);\n        hz[i][j] = hz_col - 0.25 * (sin(ex_x) * sin(ey_y) * dxy_col);\n      }\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes in C, follow these concise natural language instructions:\n\n- Treat the following function as a hardware kernel for acceleration\n- Don't automatically pipeline this loop\n- Process this loop in its original, full form without breaking it into smaller chunks\n- Run the iterations of this loop one after the other, not in parallel", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this loop\n- Don't automatically distribute this loop\n- Don't automatically parallelize this loop\n- Don't automatically pipeline this", "1": "\n- Don't accelerate this function\n \n#pragma ACCEL kernel\n\nvoid kernel_gesummv(double alpha,double beta,double A[250][250],double B[250][250],double tmp[250],double x[250],double y[250])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 250; i++) {\n    tmp[i] = 0.0;\n    y[i] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 250; j++) {\n      tmp[i] += A[i][j] * x[j];\n      y[i] += B[i][j] * x[j];\n    }\n    y[i] = alpha * tmp[i] + beta * y[i];\n  }\n}\n", "2": "\n- Don't use multistage pipeline\n \n#pragma ACCEL kernel\n\nvoid kernel_gesummv(double alpha,double beta,double A[250][250],double B[250][250],double tmp[250],double x[250],double y[250])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 250; i++) {\n    tmp[i] = 0.0;\n    y[i] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 250; j++) {\n      tmp[i] += A[i][j] * x[j];\n      y[i] += B[i][j] * x[j];\n    }\n    y[i] = alpha * tmp[i] + beta * y[i];\n  }\n}\n", "3": "\n- Don't use any other auto-pipeline option\n- Don't use any other auto-parallelization option\n- Don't use any other auto-parallelization option\n- #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n \n#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    for (k = 0; k < 70; k++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 0; j < 50; j++) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    for (k = 0; k < 60; k++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 80; j++) {\n        D[i][j] += beta * C[k][j] * D[k][j];\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    for (k = 0; k < 70; k++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 0; j < 80; j++) {\n        D[i][j] += tmp[i][k] * D[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To generate the HLS code written in C, use the \"pragma\" directives in the following natural language instructions:\n\n1. Mark the following function as a hardware kernel for acceleration:\n   - Use: `#pragma ACCEL kernel`\n\n2. Implement a loop that is pipelined automatically by the HLS tool:\n   - Use: `#pragma ACCEL PIPELINE auto{flatten}`\n\n3. Break the loop into smaller chunks for processing, with the chunk factor determined automatically:\n   - Use: `#pragma ACCEL TILE FACTOR=auto{4}`\n\n4. Run the iterations of this loop one after the other, not in parallel, with parallel factor determined automatically:\n   - Use: `#pragma ACCEL PARALLEL FACTOR=auto{1}`\n\n5. For the inner loop, perform parallel reduction on variable \"tmp\" with the factor determined automatically:\n   - Use: `#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1_0}`\n\n6. For the inner loop, perform parallel reduction on variable \"y\" with the factor determined automatically:\n   - Use: `#pragma ACCEL PARALLEL reduction=y FACTOR=auto{1_1}`", "output": "#pragma ACCEL kernel\n\nvoid kernel_atax(int m,int n,double A[116][124],double x[124],double y[124],double tmp[116])\n{\n  int i;\n  int j;\n//#pragma scop\n  for (i = 0; i < 124; i++) \n    y[i] = ((double )0);\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    tmp[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1_0}\n    for (j = 0; j < 124; j++) {\n      tmp[i] += A[i][j] * x[j];\n    }\n    \n#pragma ACCEL PARALLEL reduction=y FACTOR=auto{1_1}\n    for (j = 0; j < 124; j++) {\n      y[j] += A[i][j] * tmp[i];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n7. Implement the code below in a function called \"kernel_gemm\":\n    #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{1}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "1": "\n\n7. For the inner loop, perform parallel reduction on variable \"x\" with the factor determined automatically:\n   - Use: `#pragma ACCEL PARALLEL reduction=x FACTOR=auto{1_2}`\n\n8. For the outer loop, perform parallel reduction on variable \"sum\" with the factor determined automatically:\n   - Use: `#pragma ACCEL PARALLEL reduction=sum FACTOR=auto{1_3}`\n\n  \n#pragma ACCEL kernel\n\nvoid kernel_gemver(int n,double alpha,double beta,double A[400][400],double u1[400],double v1[400],double u2[400],double v2[400],double w[400],double x[400],double y[400],double z[400])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 400; i++) {\n    double tmp = 0.0;\n    double tmp_x = 0.0;\n    double tmp_y = 0.0;\n    double tmp_z = 0.0;\n    double AiJ;\n    double uij;\n    double xij;\n    double yij;\n    double zij;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 400; j++) {\n      AiJ = A[i][j];\n      uij = u1[i] * u1[j];\n      xij = x[i] * x[j];\n      yij = y[i] * y[j];\n      zij = z[i] * z[j];\n      tmp += AiJ * (uij + xij + yij + zij);\n      tmp_x += AiJ * (u1[j] + xij);\n      tmp_y += AiJ * (y[j] + yij);\n      tmp_z += AiJ * (z[j] + zij);\n    }\n    z[i] = beta * z[i] + tmp;\n    y[i] = beta * y[i] + tmp_x;\n    x[i] = beta * x[i] + tmp_y;\n    w[i] = beta * w[i] + tmp_z;\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 400; i++) {\n    double yi = y[i];\n    double xi = x[i];\n    double zi = z[i];\n    double uj[400];\n    double vj[400];\n    double mul[400];\n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 400; j++) {\n      uj[j] = u1[j] * yi + v1[j] * zi;\n      vj[j] = u1[j] * xi + v1[j] * yi;\n    }\n    \n#pragma ACCEL PARALLEL reduction=mul FACTOR=auto{1}\n    for (j = 0; j < 400; j++) {\n      mul[j] = alpha * A[i][j] * ( uj[j] + vj[j] );\n    }\n    \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1}\n    for (j = 0; j < 400; j++) {\n      w[i] += mul[j];\n    }\n  }\n}\n", "2": "\n\n7. For the inner loop, perform parallel reduction on variable \"x\" with the factor determined automatically:\n   - Use: `#pragma ACCEL PARALLEL reduction=x FACTOR=auto{1_2}`\n\n8. For the outer loop, perform parallel reduction on variable \"t\" with the factor determined automatically:\n   - Use: `#pragma ACCEL PARALLEL reduction=t FACTOR=auto{__PARA__L2}`\n\n9. For the middle loop, perform parallel reduction on variable \"u\" with the factor determined automatically:\n   - Use: `#pragma ACCEL PARALLEL reduction=u FACTOR=auto{__PARA__L3}`\n\n10. For the middle loop, perform parallel reduction on variable \"v\" with the factor determined automatically:\n   - Use: `#pragma ACCEL PARALLEL reduction=v FACTOR=auto{__PARA__L4}`\n\n11. Mark the following function as a configuration function for kernel gemm:\n   - Def: `void kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])`\n   - ACCEL kernel\n   - ACCEL PIPELINE auto{flatten}\n   - ACCEL TILE FACTOR=auto{4}\n   - ACCEL PARALLEL FACTOR=auto{1}\n   \n#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_0}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "3": "\n\n7. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n8. Implement a loop that is parallelized auto{__PARA__L2}:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n   - Use: `#pragma ACCEL TILE FACTOR=auto{1}`\n   - Use: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}`\n\n9. Implement the loop below by parallelizing the reduction operation with a factor of 1:\n   - Use: `#pragma ACCEL PARALLEL reduction=y FACTOR=auto{1}`\n\n **>  Y = sum( A )\n **>  A = input\n **>  Y = 0.0\n\nvoid kernel_gemver(int n,double alpha,double beta,double A[400][400],double u1[400],double v1[400],double u2[400],double v2[400],double w[400],double x[400],double y[400],double z[400])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 400; i++) {\n    double tmp = 0.0;\n    double tmp_x = 0.0;\n    double tmp_y = 0.0;\n    double tmp_z = 0.0;\n    \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1}\n    for (j = 0; j < 400; j++) {\n      tmp += A[i][j] * u1[j];\n      tmp_x += A[i][j] * v1[j];\n    }\n\n    y[i] = beta * y[i] + alpha * tmp;\n    \n#pragma ACCEL PARALLEL reduction=tmp_x FACTOR=auto{__PARA__L2}\n    for (j = 0; j < 400; j++) {\n      tmp_x += A[i][j] * u2[j];\n    }\n\n    x[i] = beta * x[i] + alpha * tmp_x;\n    \n#pragma ACCEL PARALLEL reduction=tmp_y FACTOR=auto{__PARA__L3}\n    for (j = 0; j < 400; j++) {\n      tmp_y += A[i][j] * x[j];\n    }\n\n    z[i] = beta * z[i] + alpha * tmp_y;\n    \n#pragma ACCEL PARALLEL reduction=tmp_z FACTOR=auto{__PARA__L4}\n    for (j = 0; j < 400; j++) {\n      tmp_z += A[i][j] * v2[j];\n    }\n\n    w[i] = beta * w[i] + alpha * tmp_z;\n  }\n}\n", "4": "\n\n7. For the inner loop, perform parallel reduction on variable \"x\" with the factor determined automatically:\n   - Use: `#pragma ACCEL PARALLEL reduction=x FACTOR=auto{1_2}`\n\n8. For the inner loop, perform parallel reduction on variable \"z\" with the factor determined automatically:\n   - Use: `#pragma ACCEL PARALLEL reduction=z FACTOR=auto{1_3}`\n\n9. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n10. Implement the following loop with the automatic scoping option:\n     ACCEL PIPELINE auto{off}\n     ACCEL TILE FACTOR=auto{8}\n     ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 4; i++) {\n      tmp = x;\n      x = y;\n      y = z;\n      z = tmp + sqrt(x) * y;\n    }\n\n #pragma ACCEL kernel\n\nvoid kernel_gemver(int n,double alpha,double beta,double A[40][50],double u1[40],double v1[40],double u2[50],double v2[50],double w[50],double x[40],double y[50],double z[40])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    x[i] = 0.0;\n    y[i] = 0.0;\n    z[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    double tmp = u1[i];\n    v1[i] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      x[i] += A[i][j] * tmp * v2[j];\n      v1[i] += A[i][j] * u2[j] * v2[j];\n      y[j] += A[i][j] * tmp * u2[j];\n      z[i] += A[i][j] * v2[j];\n    }\n    u1[i] = -1.0 * beta * y[i];\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    w[i] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 40; j++) {\n      w[i] += A[j][i] * x[j];\n    }\n    w[i] = w[i] + alpha * (x[0] + y[i]);\n  }\n}\n"}}
{"input": "To generate the given HLS codes in C, use the following pragma instructions:\n- Treat the following function as a hardware kernel for acceleration: '#pragma ACCEL kernel'\n- Don't automatically pipeline this loop: '#pragma ACCEL PIPELINE auto{off}'\n- Process this loop in its original, full form without breaking it into smaller chunks: '#pragma ACCEL TILE FACTOR=auto{1}'\n- Run the iterations of this loop one after the other, not in parallel: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Automatically pipeline this loop and fully unroll the inner loop: '#pragma ACCEL PIPELINE auto{flatten}' and '#pragma ACCEL TILE FACTOR=auto{4}'", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{4}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with 4 workers: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this loop with", "1": "\n- Treat the following loop as a parallelized reduction: '#pragma ACCEL PIPELINE auto{off}'\n \n#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "2": "\n- Do not annotate the following loop: ACCEL PIPELINE auto{off}\n \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_low = i - 1;\n        int i_high = i + 1;\n        int j_low = j - 1;\n        int j_high = j + 1;\n        double update = ((ey[i_low][j] - ey[i_low][j_low]) * (ex[i][j_low] - ex[i][j])) + ((ey[i_low][j_high] - ey[i_low][j]) * (ex[i][j_high] - ex[i][j])) + ((ey[i_high][j] - ey[i][j]) * (ex[i][j_low] - ex[i][j])) + ((ey[i_high][j_low] - ey[i][j]) * (ex[i][j_high] - ex[i][j]));\n        hz[i][j] = hz[i][j] - 0.7 * update;\n      }\n    }\n  }\n}\n", "3": "\n- Do not automatically distribute the array computation across nodes: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically distribute the data communication across nodes: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically distribute the kernel computation across threads: '#pragma ACCEL THREADS FACTOR=auto{1}'\n \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i % 10) + 1;\n        int j_col = 2L * (j % 10) + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "\n- Do not parallelize the inner loop when the TILE FACTOR is 4: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not parallelize the outer loop when the TILE FACTOR is 4: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Automatically pipeline this loop and fully unroll the inner loop: '#pragma ACCEL PIPELINE auto{__PIPE__L2}' and '#pragma ACCEL TILE FACTOR=auto{__TILE__L2}'\n- Do not parallelize the inner loop when the TILE FACTOR is 2: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not parallelize the outer loop when the TILE FACTOR is 4: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Automatically pipeline this loop: '#pragma ACCEL PIPELINE auto{__PIPE__L3}'\n- Parallelize this loop with 24000000/4=6000000 threads: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n  for (tint_t r = 0;r < 120;r++) {\n    tmp[r] = U[r][0] * f[0][r] + U[r][1] * f[1][r];\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (tint_t r = 0;r < 120;r++) {\n    f[0][r] = tmp[r];\n  }\n}\n"}}
{"input": "Generate HLS codes for the following C code:\n\n'Process the entire loop without automatic pipeline'\n\n'Process the loop in its original, full form without smaller tiling'\n\n'Pipeline the loop without automatic parallelization'\n\n'Treat the function as a hardware kernel for acceleration'", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{}\n      \n#pragma ACCEL TILE FACTOR=auto{2}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 119; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 119; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "4": "\n\n#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To generate the given HLS codes, follow these concise natural language instructions:\n\n1. Mark the function as a hardware kernel for acceleration.\n2. Turn off automatic loop pipelining for the following loop.\n3. Use the original, full form of the loop without breaking it into smaller chunks.\n4. Run the iterations of the loop with a parallel factor of 2.\n5. Run the iterations of the first inner loop with a parallel factor of 3.\n6. Run the iterations of the second inner loop with a parallel factor of 1.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n7. Turn off automatic loop blocking for the following loop.\n8. Use the original, full form of the loop without breaking it into smaller chunks.\n9. Run the iterations of the loop with a parallel factor of 2.\n10. Run the iterations of the first inner loop with a parallel factor of 2.\n11. Run the iterations of the second inner loop with a parallel factor of 2.\n12. Turn off automatic loop parallelization for the following loop.\n13. Use the original, full form of the loop without breaking it into smaller chunks.\n14. Run the iterations of the loop with a parallel factor of 2.\n15. Run the iterations of the first inner loop with a parallel factor of 2.\n16. Run the iterations of the second inner loop with a parallel factor of 2.\n17. Turn off automatic loop parallelization for the following loop.\n18. Use the original, full form of the loop without breaking it into smaller chunks.\n19. Run the iterations of the loop with a parallel factor of 2.\n20. Run the iterations of the first inner loop with a parallel factor of 2.\n21. Run the iterations of the second inner loop with a parallel factor of 2.\n22. Turn off automatic loop parallelization for the following loop.\n23. Use the original, full form of the loop without breaking it into smaller chunks.\n24. Run the iterations of the loop with a parallel factor of 2.\n25. Run the iterations of the first inner loop with a parallel factor of 2.\n26. Run the iterations of the second inner loop with a parallel factor of 2.\n27. Turn off automatic loop parallelization for the following loop.\n28. Use the original, full form of the loop without breaking it into smaller chunks.\n29. Run the iterations of the loop with a parallel factor of 2.\n30. Run the iterations of the first inner loop with a parallel factor of 2.\n31. Run the iterations of the second inner loop with a parallel factor of 2.\n32. Turn off automatic loop parallelization for the following loop.\n33. Use the original, full form of the loop without breaking it into smaller chunks.\n34. Run the iterations of the loop with a parallel factor of 2.\n35. Run the iterations of the first inner loop with a parallel factor of 2.\n36. Run the iterations of the second inner loop with a parallel factor of 2.\n37. Turn off automatic loop parallelization for the following loop.\n38. Use the original, full form of the loop without breaking it into smaller chunks.\n39. Run the iterations of the loop with a parallel factor of 2.\n40. Run the iterations of the first inner loop with a parallel factor of 2.\n41. Run the iterations of the second inner loop with a parallel factor of 2.\n42. Turn off automatic loop parallelization for the following loop.\n43. Use the original, full form of the loop without breaking it into smaller chunks.\n44. Run the iterations of the loop with a parallel factor of 2.\n45. Run the iterations of the first inner loop with a parallel factor of 2.\n46. Run the iterations of the second inner loop with a parallel factor of 2.\n47. Turn off automatic loop parallelization for the following loop.\n48. Use the original, full form of the loop without breaking it into smaller chunks.\n49. Run the iterations of the loop with a parallel factor of 2.\n50. Run the iterations of the first inner loop with a parallel factor of 2.\n51. Run the iterations of the second inner loop with a parallel factor of 2.\n52. Turn off automatic loop parallelization for the following loop.\n53. Use the original, full form of the loop without breaking it into smaller chunks.\n54. Run the iterations of the loop with a parallel factor of 2.\n55. Run the iterations of the first inner loop with a parallel factor of 2.\n56. Run the iterations of the second inner loop with a parallel factor of 2.\n57. Turn off automatic loop parallelization for the following loop.\n58. Use the original, full form of the loop without breaking it into smaller chunks.\n59. Run the iterations of the loop with a parallel factor of 2.\n60. Run the iterations of the first inner loop with a parallel factor of 2.\n61. Run the iterations of the second inner loop with a parallel factor of 2.\n62. Turn off automatic loop parallelization for the following loop.\n63. Use the original, full form of the loop without breaking it into smaller chunks.\n64. Run the iterations of the loop with a parallel factor of 2.\n65. Run the iterations of the first inner loop with a parallel factor of 2.\n66. Run the iterations of the second inner loop with a parallel factor of 2.\n67. Turn off automatic loop parallelization for the following loop.\n68. Use the original, full form of the loop without breaking it into smaller chunks.\n69. Run the iterations of the loop with a parallel factor of 2.\n70. Run the iterations of the first inner loop with a parallel factor of 2.\n71. Run the iterations of the second inner loop with a parallel factor of 2.\n72. Turn off automatic loop parallelization for the following loop.\n73. Use the original, full form of the loop without breaking it into smaller chunks.\n74. Run the iterations of the loop with a parallel factor of 2.\n75. Run the iterations of the first inner loop with a parallel factor of 2.\n76. Run the iterations of the second inner loop with a parallel factor of 2.\n77. Turn off automatic loop parallelization for the following loop.\n78. Use the original, full form of the loop without breaking it into smaller chunks.\n79. Run the iterations of the loop with a parallel factor of 2.\n80. Run the iterations of the first inner loop with a parallel factor of 2.\n81. Run the iterations of the second inner loop with a parallel factor of 2.\n82. Turn off automatic loop parallelization for the following loop.\n83. Use the original, full form of the loop without breaking it into smaller chunks.\n84. Run the iterations of the loop with a parallel factor of 2.\n85. Run the iterations of the first inner loop with a parallel factor of 2.\n86. Run the iterations of the second inner loop with a parallel factor of 2.\n87. Turn off automatic loop parallelization for the following loop.\n88. Use the original, full form of the loop without breaking it into smaller chunks.\n89. Run the iterations of the loop with a parallel factor of 2.\n90. Run the iterations of the first inner loop with a parallel factor of 2.\n91. Run the iterations of the second inner loop with a parallel factor of 2.\n92. Turn off automatic loop parallelization for the following loop.\n93. Use the original, full form of the loop without breaking it into smaller chunks.\n94. Run the iterations of the loop with a parallel factor of 2.\n95. Run the iterations of the first inner loop with a parallel factor of 2.\n96. Run the iterations of the second inner loop with a parallel factor of 2.\n97. Turn off automatic loop parallelization for the following loop.\n98. Use the original, full form of the loop without breaking it into smaller chunks.\n99. Run the iterations of the loop with a parallel factor of 2.\n100. Run the iterations of the first inner loop with a parallel factor of 2.\n101. Run the iterations of the second inner loop with a parallel factor of 2.\n102. Turn off automatic loop parallelization for the following loop.\n103. Use the original, full form of the loop without breaking it into smaller chunks.\n104. Run the iterations of the loop with a parallel factor of 2.\n105. Run the iterations of the first inner loop with a parallel factor of 2.\n106. Run the iterations of the second inner loop with a parallel factor of 2.\n107. Turn off automatic loop parallelization for the following loop.\n108. Use the original, full form of the loop without breaking it into smaller chunks.\n109. Run the iterations of the loop with a parallel factor of 2.\n110. Run the iterations of the first inner loop with a parallel factor of 2.\n111. Run the iterations of the second inner loop with a parallel factor of 2.\n112. Turn off automatic loop parallelization for the following loop.\n113. Use the original, full form of the loop without breaking it into smaller chunks.\n114. Run the iterations of the loop with a parallel factor of 2.\n115. Run the iterations of", "1": "\n7. Turn off automatic loop blocking for the following loop.\n8. Use the original, full form of the loop without breaking it into smaller chunks.\n9. Run the iterations of the loop with a parallel factor of 2.\n10. Run the iterations of the first inner loop with a parallel factor of 3.\n11. Run the iterations of the second inner loop with a parallel factor of 1.\n12. Turn off automatic loop unrolling for the following loop.\n13. Use the original, full form of the loop without breaking it into smaller chunks.\n14. Run the iterations of the loop with a parallel factor of 2.\n15. Run the iterations of the first inner loop with a parallel factor of 3.\n16. Run the iterations of the second inner loop with a parallel factor of 1.\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n7. Turn off automatic loop blocking for the following loop.\n8. Use the original, full form of the loop without breaking it into smaller chunks.\n9. Run the iterations of the loop with a parallel factor of 16.\n10. Run the iterations of the first inner loop with a parallel factor of 2.\n11. Run the iterations of the second inner loop with a parallel factor of 2.\n12. Turn off automatic loop blocking for the following loop.\n13. Use the original, full form of the loop without breaking it into smaller chunks.\n14. Run the iterations of the loop with a parallel factor of 1.\n15. Run the iterations of the first inner loop with a parallel factor of 2.\n16. Run the iterations of the second inner loop with a parallel factor of 2.\n17. Turn off automatic loop blocking for the following loop.\n18. Use the original, full form of the loop without breaking it into smaller chunks.\n19. Run the iterations of the loop with a parallel factor of 1.\n20. Run the iterations of the first inner loop with a parallel factor of 1.\n21. Run the iterations of the second inner loop with a parallel factor of 1.\n22. Turn off automatic loop blocking for the following loop.\n23. Use the original, full form of the loop without breaking it into smaller chunks.\n24. Run the iterations of the loop with a parallel factor of 1.\n25. Run the iterations of the first inner loop with a parallel factor of 2.\n26. Run the iterations of the second inner loop with a parallel factor of 2.\n27. Turn off automatic loop blocking for the following loop.\n28. Use the original, full form of the loop without breaking it into smaller chunks.\n29. Run the iterations of the loop with a parallel factor of 1.\n30. Run the iterations of the first inner loop with a parallel factor of 1.\n31. Run the iterations of the second inner loop with a parallel factor of 1.\n32. Turn off automatic loop blocking for the following loop.\n33. Use the original, full form of the loop without breaking it into smaller chunks.\n34. Run the iterations of the loop with a parallel factor of 1.\n35. Run the iterations of the first inner loop with a parallel factor of 1.\n36. Run the iterations of the second inner loop with a parallel factor of 1.\n37. Turn off automatic loop blocking for the following loop.\n38. Use the original, full form of the loop without breaking it into smaller chunks.\n39. Run the iterations of the loop with a parallel factor of 1.\n40. Run the iterations of the first inner loop with a parallel factor of 1.\n41. Run the iterations of the second inner loop with a parallel factor of 1.\n42. Turn off automatic loop blocking for the following loop.\n43. Use the original, full form of the loop without breaking it into smaller chunks.\n44. Run the iterations of the loop with a parallel factor of 1.\n45. Run the iterations of the first inner loop with a parallel factor of 1.\n46. Run the iterations of the second inner loop with a parallel factor of 1.\n47. Turn off automatic loop blocking for the following loop.\n48. Use the original, full form of the loop without breaking it into smaller chunks.\n49. Run the iterations of the loop with a parallel factor of 1.\n50. Run the iterations of the first inner loop with a parallel factor of 1.\n51. Run the iterations of the second inner loop with a parallel factor of 1.\n52. Turn off automatic loop blocking for the following loop.\n53. Use the original, full form of the loop without breaking it into smaller chunks.\n54. Run the iterations of the loop with a parallel factor of 1.\n55. Run the iterations of the first inner loop with a parallel factor of 1.\n56. Run the iterations of the second inner loop with a parallel factor of 1.\n57. Turn off automatic loop blocking for the following loop.\n58. Use the original, full form of the loop without breaking it into smaller chunks.\n59. Run the iterations of the loop with a parallel factor of 1.\n60. Run the iterations of the first inner loop with a parallel factor of 1.\n61. Run the iterations of the second inner loop with a parallel factor of 1.\n62. Turn off automatic loop blocking for the following loop.\n63. Use the original, full form of the loop without breaking it into smaller chunks.\n64. Run the iterations of the loop with a parallel factor of 1.\n65. Run the iterations of the first inner loop with a parallel factor of 1.\n66. Run the iterations of the second inner loop with a parallel factor of 1.\n67. Turn off automatic loop blocking for the following loop.\n68. Use the original, full form of the loop without breaking it into smaller chunks.\n69. Run the iterations of the loop with a parallel factor of 1.\n70. Run the iterations of the first inner loop with a parallel factor of 1.\n71. Run the iterations of the second inner loop with a parallel factor of 1.\n72. Turn off automatic loop blocking for the following loop.\n73. Use the original, full form of the loop without breaking it into smaller chunks.\n74. Run the iterations of the loop with a parallel factor of 1.\n75. Run the iterations of the first inner loop with a parallel factor of 1.\n76. Run the iterations of the second inner loop with a parallel factor of 1.\n77. Turn off automatic loop blocking for the following loop.\n78. Use the original, full form of the loop without breaking it into smaller chunks.\n79. Run the iterations of the loop with a parallel factor of 1.\n80. Run the iterations of the first inner loop with a parallel factor of 1.\n81. Run the iterations of the second inner loop with a parallel factor of 1.\n82. Turn off automatic loop blocking for the following loop.\n83. Use the original, full form of the loop without breaking it into smaller chunks.\n84. Run the iterations of the loop with a parallel factor of 1.\n85. Run the iterations of the first inner loop with a parallel factor of 1.\n86. Run the iterations of the second inner loop with a parallel factor of 1.\n87. Turn off automatic loop blocking for the following loop.\n88. Use the original, full form of the loop without breaking it into smaller chunks.\n89. Run the iterations of the loop with a parallel factor of 1.\n90. Run the iterations of the first inner loop with a parallel factor of 1.\n91. Run the iterations of the second inner loop with a parallel factor of 1.\n92. Turn off automatic loop blocking for the following loop.\n93. Use the original, full form of the loop without breaking it into smaller chunks.\n94. Run the iterations of the loop with a parallel factor of 1.\n95. Run the iterations of the first inner loop with a parallel factor of 1.\n96. Run the iterations of the second inner loop with a parallel factor of 1.\n97. Turn off automatic loop blocking for the following loop.\n98. Use the original, full form of the loop without breaking it into smaller chunks.\n99. Run the iterations of the loop with a parallel factor of 1.\n100. Run the iterations of the first inner loop with a parallel factor of 1.\n101. Run the iterations of the second inner loop with a parallel factor of 1.\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL", "3": "\n7. Turn off automatic loop blocking for the following loop.\n8. Use the original, full form of the loop without breaking it into smaller chunks.\n9. Run the iterations of the loop with a parallel factor of 2.\n10. Run the iterations of the first inner loop with a parallel factor of 32.\n11. Run the iterations of the second inner loop with a parallel factor of 1.\n12. Turn off automatic loop unrolling for the following loop.\n13. Use the original, full form of the loop without breaking it into smaller chunks.\n14. Run the iterations of the loop with a parallel factor of 2.\n15. Run the iterations of the first inner loop with a parallel factor of 2.\n16. Run the iterations of the second inner loop with a parallel factor of 1.\n17. Turn off automatic loop unrolling for the following loop.\n18. Use the original, full form of the loop without breaking it into smaller chunks.\n19. Run the iterations of the loop with a parallel factor of 2.\n20. Run the iterations of the first inner loop with a parallel factor of 16.\n21. Run the iterations of the second inner loop with a parallel factor of 1.\n22. Turn off automatic loop unrolling for the following loop.\n23. Use the original, full form of the loop without breaking it into smaller chunks.\n24. Run the iterations of the loop with a parallel factor of 2.\n25. Run the iterations of the first inner loop with a parallel factor of 4.\n26. Run the iterations of the second inner loop with a parallel factor of 1.\n27. Turn off automatic loop unrolling for the following loop.\n28. Use the original, full form of the loop without breaking it into smaller chunks.\n29. Run the iterations of the loop with a parallel factor of 2.\n30. Run the iterations of the first inner loop with a parallel factor of 8.\n31. Run the iterations of the second inner loop with a parallel factor of 1.\n32. Turn off automatic loop unrolling for the following loop.\n33. Use the original, full form of the loop without breaking it into smaller chunks.\n34. Run the iterations of the loop with a parallel factor of 2.\n35. Run the iterations of the first inner loop with a parallel factor of 4.\n36. Run the iterations of the second inner loop with a parallel factor of 1.\n37. Turn off automatic loop unrolling for the following loop.\n38. Use the original, full form of the loop without breaking it into smaller chunks.\n39. Run the iterations of the loop with a parallel factor of 2.\n40. Run the iterations of the first inner loop with a parallel factor of 2.\n41. Run the iterations of the second inner loop with a parallel factor of 1.\n42. Turn off automatic loop unrolling for the following loop.\n43. Use the original, full form of the loop without breaking it into smaller chunks.\n44. Run the iterations of the loop with a parallel factor of 2.\n45. Run the iterations of the first inner loop with a parallel factor of 1.\n46. Run the iterations of the second inner loop with a parallel factor of 1.\n47. Turn off automatic loop unrolling for the following loop.\n48. Use the original, full form of the loop without breaking it into smaller chunks.\n49. Run the iterations of the loop with a parallel factor of 2.\n50. Run the iterations of the first inner loop with a parallel factor of 1.\n51. Run the iterations of the second inner loop with a parallel factor of 1.\n52. Turn off automatic loop unrolling for the following loop.\n53. Use the original, full form of the loop without breaking it into smaller chunks.\n54. Run the iterations of the loop with a parallel factor of 2.\n55. Run the iterations of the first inner loop with a parallel factor of 1.\n56. Run the iterations of the second inner loop with a parallel factor of 1.\n57. Turn off automatic loop unrolling for the following loop.\n58. Use the original, full form of the loop without breaking it into smaller chunks.\n59. Run the iterations of the loop with a parallel factor of 2.\n60. Run the iterations of the first inner loop with a parallel factor of 1.\n61. Run the iterations of the second inner loop with a parallel factor of 1.\n62. Turn off automatic loop unrolling for the following loop.\n63. Use the original, full form of the loop without breaking it into smaller chunks.\n64. Run the iterations of the loop with a parallel factor of 2.\n65. Run the iterations of the first inner loop with a parallel factor of 1.\n66. Run the iterations of the second inner loop with a parallel factor of 1.\n67. Turn off automatic loop unrolling for the following loop.\n68. Use the original, full form of the loop without breaking it into smaller chunks.\n69. Run the iterations of the loop with a parallel factor of 2.\n70. Run the iterations of the first inner loop with a parallel factor of 1.\n71. Run the iterations of the second inner loop with a parallel factor of 1.\n72. Turn off automatic loop unrolling for the following loop.\n73. Use the original, full form of the loop without breaking it into smaller chunks.\n74. Run the iterations of the loop with a parallel factor of 2.\n75. Run the iterations of the first inner loop with a parallel factor of 1.\n76. Run the iterations of the second inner loop with a parallel factor of 1.\n77. Turn off automatic loop unrolling for the following loop.\n78. Use the original, full form of the loop without breaking it into smaller chunks.\n79. Run the iterations of the loop with a parallel factor of 2.\n80. Run the iterations of the first inner loop with a parallel factor of 1.\n81. Run the iterations of the second inner loop with a parallel factor of 1.\n82. Turn off automatic loop unrolling for the following loop.\n83. Use the original, full form of the loop without breaking it into smaller chunks.\n84. Run the iterations of the loop with a parallel factor of 2.\n85. Run the iterations of the first inner loop with a parallel factor of 1.\n86. Run the iterations of the second inner loop with a parallel factor of 1.\n87. Turn off automatic loop unrolling for the following loop.\n88. Use the original, full form of the loop without breaking it into smaller chunks.\n89. Run the iterations of the loop with a parallel factor of 2.\n90. Run the iterations of the first inner loop with a parallel factor of 1.\n91. Run the iterations of the second inner loop with a parallel factor of 1.\n92. Turn off automatic loop unrolling for the following loop.\n93. Use the original, full form of the loop without breaking it into smaller chunks.\n94. Run the iterations of the loop with a parallel factor of 2.\n95. Run the iterations of the first inner loop with a parallel factor of 1.\n96. Run the iterations of the second inner loop with a parallel factor of 1.\n97. Turn off automatic loop unrolling for the following loop.\n98. Use the original, full form of the loop without breaking it into smaller chunks.\n99. Run the iterations of the loop with a parallel factor of 2.\n100. Run the iterations of the first inner loop with a parallel factor of 1.\n101. Run the iterations of the second inner loop with a parallel factor of 1.\n102. Turn off automatic loop unrolling for the following loop.\n103. Use the original, full form of the loop without breaking it into smaller chunks.\n104. Run the iterations of the loop with a parallel factor of 2.\n105. Run the iterations of the first inner loop with a parallel factor of 1.\n106. Run the iterations of the second inner loop with a parallel factor of 1.\n107. Turn off automatic loop unrolling for the following loop.\n108. Use the original, full form of the loop without breaking it into smaller chunks.\n109. Run the iterations of the loop with a parallel factor of 2.\n110. Run the iterations of the first inner loop with a parallel factor of 1.\n111. Run the iterations of the second inner loop with a parallel factor of 1.\n112. Turn off automatic loop unrolling for the following loop.\n113. Use the original, full form of the loop without breaking it into smaller chunks.\n114. Run the iterations of the loop with a parallel factor of 2.\n115. Run the", "4": "\n7. Turn off automatic loop blocking for the following loop.\n8. Use the original, full form of the loop without breaking it into smaller chunks.\n9. Run the iterations of the loop with a parallel factor of 1.\n10. Run the iterations of the first inner loop with a parallel factor of 1.\n11. Run the iterations of the second inner loop with a parallel factor of 1.\n12. Turn off automatic loop unrolling for the following loop.\n13. Use the original, full form of the loop without breaking it into smaller chunks.\n14. Run the iterations of the loop with a parallel factor of 1.\n15. Run the iterations of the first inner loop with a parallel factor of 1.\n16. Run the iterations of the second inner loop with a parallel factor of 1.\n17. Turn off automatic loop fusion for the following loop.\n18. Use the original, full form of the loop without breaking it into smaller chunks.\n19. Run the iterations of the loop with a parallel factor of 1.\n20. Run the iterations of the first inner loop with a parallel factor of 1.\n21. Run the iterations of the second inner loop with a parallel factor of 1.\n22. Turn off automatic loop partitioning equal_split{1} for the following loop.\n23. Use the original, full form of the loop without breaking it into smaller chunks.\n24. Run the iterations of the loop with a parallel factor of 1.\n25. Run the iterations of the first inner loop with a parallel factor of 2.\n26. Run the iterations of the second inner loop with a parallel factor of 2.\n27. Turn off automatic loop partitioning equal_split{1} for the following loop.\n28. Use the original, full form of the loop without breaking it into smaller chunks.\n29. Run the iterations of the loop with a parallel factor of 1.\n30. Run the iterations of the first inner loop with a parallel factor of 1.\n31. Run the iterations of the second inner loop with a parallel factor of 1.\n32. Turn off automatic loop flattening for the following loop.\n33. Use the original, full form of the loop without breaking it into smaller chunks.\n34. Run the iterations of the loop with a parallel factor of 1.\n35. Run the iterations of the first inner loop with a parallel factor of 2.\n36. Run the iterations of the second inner loop with a parallel factor of 2.\n37. Turn off automatic loop partitioning equal_split{1} for the following loop.\n38. Use the original, full form of the loop without breaking it into smaller chunks.\n39. Run the iterations of the loop with a parallel factor of 1.\n40. Run the iterations of the first inner loop with a parallel factor of 1.\n41. Run the iterations of the second inner loop with a parallel factor of 1.\n42. Turn off automatic loop unrolling for the following loop.\n43. Use the original, full form of the loop without breaking it into smaller chunks.\n44. Run the iterations of the loop with a parallel factor of 2.\n45. Run the iterations of the first inner loop with a parallel factor of 2.\n46. Run the iterations of the second inner loop with a parallel factor of 2.\n47. Turn off automatic loop partitioning equal_split{1} for the following loop.\n48. Use the original, full form of the loop without breaking it into smaller chunks.\n49. Run the iterations of the loop with a parallel factor of 2.\n50. Run the iterations of the first inner loop with a parallel factor of 1.\n51. Run the iterations of the second inner loop with a parallel factor of 1.\n52. Turn off automatic loop partitioning equal_split{2} for the following loop.\n53. Use the original, full form of the loop without breaking it into smaller chunks.\n54. Run the iterations of the loop with a parallel factor of 2.\n55. Run the iterations of the first inner loop with a parallel factor of 2.\n56. Run the iterations of the second inner loop with a parallel factor of 2.\n57. Turn off automatic loop partitioning equal_split{1} for the following loop.\n58. Use the original, full form of the loop without breaking it into smaller chunks.\n59. Run the iterations of the loop with a parallel factor of 1.\n60. Run the iterations of the first inner loop with a parallel factor of 2.\n61. Run the iterations of the second inner loop with a parallel factor of 2.\n62. Turn off automatic loop partitioning equal_split{2} for the following loop.\n63. Use the original, full form of the loop without breaking it into smaller chunks.\n64. Run the iterations of the loop with a parallel factor of 1.\n65. Run the iterations of the first inner loop with a parallel factor of 1.\n66. Run the iterations of the second inner loop with a parallel factor of 1.\n67. Turn off automatic loop partitioning equal_split{1} for the following loop.\n68. Use the original, full form of the loop without breaking it into smaller chunks.\n69. Run the iterations of the loop with a parallel factor of 1.\n70. Run the iterations of the first inner loop with a parallel factor of 1.\n71. Run the iterations of the second inner loop with a parallel factor of 1.\n72. Turn off automatic loop unrolling for the following loop.\n73. Use the original, full form of the loop without breaking it into smaller chunks.\n74. Run the iterations of the loop with a parallel factor of 1.\n75. Run the iterations of the first inner loop with a parallel factor of 1.\n76. Run the iterations of the second inner loop with a parallel factor of 1.\n77. Turn off automatic loop partitioning equal_split{1} for the following loop.\n78. Use the original, full form of the loop without breaking it into smaller chunks.\n79. Run the iterations of the loop with a parallel factor of 1.\n80. Run the iterations of the first inner loop with a parallel factor of 1.\n81. Run the iterations of the second inner loop with a parallel factor of 1.\n82. Turn off automatic loop partitioning equal_split{1} for the following loop.\n83. Use the original, full form of the loop without breaking it into smaller chunks.\n84. Run the iterations of the loop with a parallel factor of 1.\n85. Run the iterations of the first inner loop with a parallel factor of 1.\n86. Run the iterations of the second inner loop with a parallel factor of 1.\n87. Turn off automatic loop unrolling for the following loop.\n88. Use the original, full form of the loop without breaking it into smaller chunks.\n89. Run the iterations of the loop with a parallel factor of 1.\n90. Run the iterations of the first inner loop with a parallel factor of 1.\n91. Run the iterations of the second inner loop with a parallel factor of 1.\n92. Turn off automatic loop unrolling for the following loop.\n93. Use the original, full form of the loop without breaking it into smaller chunks.\n94. Run the iterations of the loop with a parallel factor of 1.\n95. Run the iterations of the first inner loop with a parallel factor of 1.\n96. Run the iterations of the second inner loop with a parallel factor of 1.\n97. Turn off automatic loop unrolling for the following loop.\n98. Use the original, full form of the loop without breaking it into smaller chunks.\n99. Run the iterations of the loop with a parallel factor of 1.\n100. Run the iterations of the first inner loop with a parallel factor of 1.\n101. Run the iterations of the second inner loop with a parallel factor of 1.\n102. Turn off automatic loop unrolling for the following loop.\n103. Use the original, full form of the loop without breaking it into smaller chunks.\n104. Run the iterations of the loop with a parallel factor of 1.\n105. Run the iterations of the first inner loop with a parallel factor of 1.\n106. Run the iterations of the second inner loop with a parallel factor of 1.\n107. Turn off automatic loop unrolling for the following loop.\n108. Use the original, full form of the loop without breaking it into smaller chunks.\n109. Run the iterations of the loop with a parallel factor of 1.\n110. Run the iterations of the first inner loop with a parallel factor of 1.\n111. Run the iterations of the second inner loop with a parallel factor of 1.\n112. Turn"}}
{"input": "Ensure that the following function is treated as a hardware kernel for acceleration. Also, do not automatically pipeline the outermost loop, and process it in its original, full form without breaking it into smaller chunks. For the innermost loops, pipeline them to a factor of 4 and flatten the loop.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{8}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 90; t++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    for (i = 1; i < 90 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 1; j < 90 - 1; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[j][j - 1] + A[j][1 + j] + A[1 + i][j] + A[i - 1][j] + A[1 + i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (i = 1; i < 90 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 1; j < 90 - 1; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[j][j - 1] + B[j][1 + j] + B[1 + i][j] + B[i - 1][j] + B[1 + i][j - 1]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n  for (t = 0; t < 35; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = (double )0;\n        A[i][j] = A[i][j] + A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1];\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = A[i][j] / ((double )9);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": " Also, distribute the code to all four cores.\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "Process the loop in its original, full form without breaking it into smaller chunks.\nRun the iterations of this loop two at a time in parallel.\nAutomatically pipeline this loop and flatten its structure to optimize performance.\nTreat the following function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 0 + 1L * jump;\n        int _in_i = 0 + 1L * tile;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i + 1) - 1 - 1;\n        int j_col = 2L * (j + 1) - 1 - 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_col][j_col + 1] - ex[i_col][j_col] + ey[i_col + 1][j_col] - ey[i_col][j_col]);\n      }\n    }\n  }\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1*i;\n        int j_col = j + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_col][j] - ex[i][j_col]) - 0.7 * (ey[i][j_col] - ey[i_col][j]);\n      }\n    }\n  }\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i % 100);\n        int j_col = 2L * (j % 120);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 0 + 1L * (- 1L + 0L) + ((240) * (0 + 1L * (- 1L + 0L)));\n        int _in_i = 0 + 1L * (- 1L + 0L) + ((200) * (0 + 1L * (- 1L + 0L)));\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes for the C program, use the following comprehensive but concise natural language instruction set:\n- Use hardware acceleration for the function: 'Treat the following function as a hardware kernel for acceleration'\n- Pipeline the outer loop: 'Automatically pipeline this loop'\n- Process the loop in its original, full form without breaking it into smaller chunks: 'Set the tile factor to 1'\n- Run the iterations of the outer loop in parallel with a factor of 2: 'Set the parallel factor to 2 for the outer loop'\n- Run the inner loops in parallel with a factor of 32 and 10 respectively: 'Set the parallel factor to 32 for the first inner loop and 10 for the second inner loop'", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{10}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction=D FACTOR=auto{25}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_doit(int nr,int nq,int np,double A[25][20][30],double B[25][30][40],double C[25][20][40])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  outer:\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    middle:\n    for (q = 0; q < 30; q++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      inner:\n      for (p = 0; p < 20; p++) {\n        float tmp = A[r][p][s] * B[r][s][q];\n\t\t\t\tclacc:\n\t\t\t\tfor (i = 0; i < 40; i++) {\n\t\t\t\t  C[r][p][i] += tmp * A[r][p][t] * B[t][s][i];\n\t\t\t\t}\n      }\n    }\n  }\n}\n", "3": "\n#pragma ACCEL kernel\n\nvoid kernel_doitgen(int A[25][20][30],int B[25][20][30],int C[25][20][30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n  int t;\n  int i;\n  int j;\n  int k;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = ((long )r) * ((long )p) * 64 + ((long )q) * 64;\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n      for (p = 0; p < 30; p++) {\n        B[r][q][p] = 1.0;\n        for (i = 0; i < 5; i++) {\n          s = r + ((long )i) * 5;\n          B[s][q][p] *= A[r][q][p];\n        }\n        for (i = 0; i < 5; i++) {\n          s = r - ((long )i) * 5;\n          if (s >= 0 && s < 25) {\n            B[s][q][p] *= A[r][q][p];\n          }\n        }\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L7}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L7}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L8}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L8}\n      for (p = 0; p < 30; p++) {\n        C[r][q][p] = 0.0;\n        for (i = 0; i < 5; i++) {\n          t = q + ((long )i) * 5;\n          C[r][q][p] += B[r][t][p];\n        }\n        for (i = 0; i < 5; i++) {\n          t = q - ((long )i) * 5;\n          if (t >= 0 && t < 20) {\n            C[r][q][p] += B[r][t][p];\n          }\n        }\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n- Flatten the following loop nest: 'Flatten the following loop nest'\n- Parallelize the following loop nest: 'Parallelize this loop with 4096 threads'\n- Distribute the following loop nest across 256 processors: 'Distribute this kernel to 256 processes'\n- Use the following number of threads: 'Set the number of threads to 4096'\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes, use the following natural language compilation instructions:\n\n1. \"Process this function as a hardware kernel for acceleration\": \n```c\n#pragma ACCEL kernel\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n```\n\n2. \"Don't automatically pipeline this loop\":\n```c\n#pragma ACCEL PIPELINE \"off\"\n```\n\n3. \"Process this loop in its original, full form without breaking it into smaller chunks\":\n```c\n#pragma ACCEL TILE FACTOR=1\n```\n\n4. \"Run the iterations of this loop one after the other, not in parallel\":\n```c\n#pragma ACCEL PARALLEL FACTOR=1\n```", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n5. \"Don't automatically distribute this loop\":\n```c\n#pragma ACCEL DISTRIBUTE FACTOR=1\n  for (t = 0; t < 40; t++) {\n    #pragma ACCEL PIPELINE auto{flatten}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n    #pragma ACCEL PIPELINE auto{__PIPE__L2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n  }\n```\n", "1": "\n\n5. \"This loop has no parallelized version\":\n```c\n  for (t = 0; t < 40; t++) {\n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n  }\n```\n", "2": "\n\n5. \"Assign this loop to FACTOR=auto{__PARA__L2}\":\n```c\n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (t = 0; t < 40; t++) {\n    jacobi_1d(A,B,n);\n    jacobi_1d(B,A,n);\n  }\n```\n\n", "3": "\n\n5. \"Don't automatically distribute this loop\":\n```c\n#pragma ACCEL DISTRIBUTE FACTOR=1\n  for (t = 0; t < 40; t++) {\n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n#pragma ACCEL PARALLEL FACTOR=auto{120}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n  }\n```\n", "4": "\n\n5. \"This loop has no parallelized loop within it, but it is still paralleized\":\n```c\n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n  }\n```\n"}}
{"input": "To generate the given HLS codes for the C function 'kernel_doitgen', follow these natural language instructions:\n\n1. Mark the entire function as a hardware kernel for acceleration.\n2. Don't automatically pipeline the outermost loop.\n3. Process the outermost loop in its original, full form without breaking it into smaller chunks.\n4. Don't automatically pipeline the middle loop.\n5. Process the middle loop in its original, full form without breaking it into smaller chunks.\n6. Automatically pipeline the innermost loop.\n7. Break the innermost loop into smaller chunks with a tile factor of 4.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{}\n      \n#pragma ACCEL TILE FACTOR=auto{4}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        double sum_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=sum_tmp FACTOR=auto{__PARA__L3}\n\tfor (s = 0; s < 20; s++) {\n          sum_tmp += A[r][s][p] * C4[s][p];\n        }\n\tsum[p] = sum_tmp;\n\tdouble A_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=A_tmp FACTOR=auto{__PARA__L4}\n\tfor (s = 0; s < 20; s++) {\n          A_tmp += A[r][s][p] * sum[p];\n        }\n\tA[r][q][p] = A_tmp;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n8. Don't use dynamic parallelism.\n9. Automatically flatten the original loop nests.\n\n\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        double sum_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=sum_tmp FACTOR=auto{__PARA__L3}\n\tfor (s = 0; s < 30; s++) {\n          sum_tmp += A[r][q][s] * C4[s][p];\n        }\n\tsum[p] = sum_tmp;\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n8. Don't automatically distribute the middle loop across multiple processors.\n9. Automatically distribute the outermost loop across 1 processors.\n10. Set the auto_parallelizer's aggregate partitioning factor to 2.\n\n\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        double sum_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=sum_tmp FACTOR=auto{__PARA__L3}\n\tfor (s = 0; s < 30; s++) {\n          sum_tmp += A[r][q][s] * C4[s][p];\n        }\n\tsum[p] = sum_tmp;\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n8. Don't automatically distribute the middle loop.\n9. Automatically distribute the outermost loop across 1500 cores.\n10. Automatically parallelize the middle loop across 128 cores.\n11. Automatically parallelize the outermost loop across 1500 cores.\n\n\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,int nalphas,double eps,double sigma,double alpha[4],double A[40][50],double B[50][80],double C[40][80])\n{\n  int i;\n  int j;\n  int k;\n  int n;\n  int q;\n  double val;\n  double sum;\n  double tmp;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  loopj:\n  for (j = 0; j < 80; j++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    loopk:\n    for (k = 0; k < 40; k++) {\n      sum = ((double )0);\n      \n#pragma ACCEL PARALLEL reduction=sum FACTOR=auto{__PARA__L4}\n      loopn:\n      for (n = 0; n < 50; n++) {\n        sum += A[k][n] * B[n][j];\n      }\n      C[k][j] = sum;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n  loopi:\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    loopq:\n    for (q = 0; q < 50; q++) {\n      val = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=val FACTOR=auto{__PARA__L3}\n      loopn:\n      for (n = 0; n < 50; n++) {\n        tmp = A[i][n] * B[n][q];\n        val += tmp * C[n][q];\n      }\n      A[i][q] = val;\n    }\n  }\n}\n", "4": "\n8. Set the following options:\n\tA0 = 1\n\tB0 = 1\n\tC0 = 1\n\tP0 = 2\n\tQ0 = 2\n\tR0 = 2\n\tS0 = 256\n\tT0 = 256\n\tA = 1\n\tB = 256\n\tC = 256\n\tP = 4\n\tQ = 4\n\tR = 4\n\tS = 8\n\tT = 8\n\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (j = 0; j < 60; j++) {\n      A[i][j] = ((double )0);\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=E FACTOR=auto{1}\n      for (k = 0; k < 30; k++) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = ((double )0);\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      C[i][j] = ((double )0);\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 30; k++) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 30; k++) {\n        A[i][k] += E[i][j] * F[j][k];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To generate the given HLS codes in C, use the following pragma values:\n\n1. For the outermost loop, do not automatically pipeline:\n   - Use `#pragma ACCEL PIPELINE auto{off}`\n\n2. For the outermost loop, process it in its original, full form without breaking it into smaller chunks:\n   - Use `#pragma ACCEL TILE FACTOR=auto{1}`\n\n3. For the middle loop, do not automatically pipeline:\n   - Use `#pragma ACCEL PIPELINE auto{off}`\n\n4. For the middle loop, process it in its original, full form without breaking it into smaller chunks:\n   - Use `#pragma ACCEL TILE FACTOR=auto{1}`\n\n5. For the innermost loop, automatically pipeline:\n   - Use `#pragma ACCEL PIPELINE auto{}`\n\n6. For the innermost loop, process it with a factor of 4:\n   - Use `#pragma ACCEL TILE FACTOR=auto{4}`\n\nRemember to also use `#pragma ACCEL kernel` to treat the given function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{}\n      \n#pragma ACCEL TILE FACTOR=auto{4}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n", "1": "\n", "2": "\n", "3": "\n", "4": "\nMoreover, since this kernel will be invoked in a software kernel, you need to add `#pragma ACCEL program` in front of the overall function.\n\n#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 30; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n  }\n//#pragma endscop\n}\n"}}
{"input": "To generate the given HLS code in C:\n\n\"Declare the following function as a hardware kernel for acceleration, then for the loop within the function:\n  - Implement automatic pipelining\n  - Use the original loop form without breaking it into smaller chunks, and\n  - Run the iterations of the first inner loop in parallel, and then the iterations of the second inner loop in parallel with a factor of 3, followed by a factor of 16.\"\n\nThe corresponding #pragma values to use are:\n- Hardware kernel declaration: #pragma ACCEL kernel\n- Pipelining: #pragma ACCEL PIPELINE auto{}\n- Loop full form: #pragma ACCEL TILE FACTOR=auto{1}\n- Inner loop parallelization: \n  - First inner loop: #pragma ACCEL PARALLEL FACTOR=auto{16}\n  - Second inner loop: #pragma ACCEL PARALLEL FACTOR=auto{3}", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n\n\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n\n #pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n\n**/\n\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/time.h>\n#include <hip/hip_runtime.h>\n#include <hip/hip_runtime_api.h>\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n  }\n//#pragma endscop\n}\nint main(int argc,char **argv)\n{\n  double A[120];\n  double B[120];\n  int t;\n  int i;\n// Standardize the format across platforms\n  for (t = 0; t < 40; t++) {\n    for (i = 0; i < 120; i++) {\n      A[i] = ((double )1);\n      B[i] = ((double )0);\n    }\n    kernel_jacobi_1d(70,120,A,B);\n  }\n/*\n    BENCHMARK INFORMATION\n    kernel_jacobi_1d\n      Time = 0.544489\n    \n    Number of bytes spilled = 248\n*/\n  return 0;\n}\n"}}
{"input": "To generate the specific HLS codes in C, you need to follow these natural language instructions:\n\n1. Treat the following function as a hardware kernel for acceleration.\n2. Don't automatically pipeline the outermost loop.\n3. Process the outermost loop in its original, full form without breaking it into smaller chunks.\n4. Don't automatically pipeline the mid-level loop.\n5. Process the mid-level loop in its original, full form without breaking it into smaller chunks.\n6. Automatically pipeline the innermost loop with flattening optimization.\n7. Break the innermost loop into smaller chunks with a tile factor of 2 for optimization.\n\nBy following these instructions, you can generate the given HLS codes for the C program.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{2}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double B[25][30],double D[20][30],double E[25][20])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n  int t;\n  int u;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  loop_r:\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    loop_q:\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      loop_p:\n      for (p = 0; p < 30; p++) {\n        loop_s:\n        for (s = 0; s < 30; s++) {\n          A[r][q][p] += D[q][s] * C4[p][s];\n        }\n      }\n      loop_t:\n      for (t = 0; t < 20; t++) {\n        loop_u:\n        for (u = 0; u < 30; u++) {\n          B[r][q][u] += E[t][q] * A[t][q][u];\n        }\n      }\n    }\n  }\n}\n", "4": "\n\n\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To generate the given HLS codes in C, use the following natural language instruction:\n\n\"For the kernel function 'kernel_jacobi_1d' with parameters 'tsteps', 'n', 'A[120]', and 'B[120]', first apply automatic loop pipelining. Then, tile the loops with an automatic factor of 1, and process the loops in parallel with an automatic factor of 2. Inside the outer loop, parallelize the loop iterations with a factor of 16. Followed by that, parallelize the loop iterations with a factor of 3. End by treating the function as a hardware kernel for acceleration.\"", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To process the given C code using HLS pragma values, follow the following comprehensive but very concise natural language instruction for each pragma:\n\n1. For the loop pipeline, use `Don't automatically pipeline this loop` to describe `#pragma ACCEL PIPELINE auto{off}`.\n2. For the loop tiling, use `Process this loop with its original, full form without breaking it into smaller chunks` to describe `#pragma ACCEL TILE FACTOR=auto{1}`.\n3. For the loop parallelization, use `Run the iterations of this loop one after the other, not in parallel` to describe `#pragma ACCEL PARALLEL FACTOR=auto{2}`.\n4. Treat the following function as a hardware kernel for acceleration by using `Treat the following function as a hardware kernel for acceleration` to describe `#pragma ACCEL kernel`.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 119; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 119; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n\n#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "2": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": "\n\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{120}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        z_pe[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n      for (j = 0; j < 240 - 1; j++) {\n        ex[i][j] = ex[i][j] + 0.7 * (z_pe[i][j + 1] - z_pe[i][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n      for (j = 0; j < 240 - 1; j++) {\n        ey[i][j] = ey[i][j] + 0.7 * (z_pe[i + 1][j] - z_pe[i][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L7}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L7}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L10}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] + 0.7 * (ex[i + 1][j] - ex[i][j] + ey[i][j + 1] - ey[i][j]);\n      }\n    }\n  }\n}\n"}}
{"input": "To generate the HLS codes:\n1. Designate the following function as a hardware kernel for acceleration using the directive '#pragma ACCEL kernel'.\n2. Don't automatically pipeline the outer loop using '#pragma ACCEL PIPELINE \"off\"'.\n3. Process the outer loop in its full form without breaking it into smaller chunks using '#pragma ACCEL TILE FACTOR=1'.\n4.  Don't automatically pipeline the middle loop using '#pragma ACCEL PIPELINE \"off\"'.\n5. Process the middle loop in chunks of size 2 using '#pragma ACCEL TILE FACTOR=2'.\n6. Flatten the inner loop automatically using '#pragma ACCEL PIPELINE auto{flatten}'.\n7. Process the inner loop in its full form without breaking it into smaller chunks using '#pragma ACCEL TILE FACTOR=1'.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{2}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "\n \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        double delta_e = (ex[i][j + 1] - ex[i][j]) + (ey[i + 1][j] - ey[i][j]);\n        double  delta_h = hz[i][j + 1] - hz[i][j];\n        double  Dx = dcx[i] * delta_e;\n        double  Dy = dcy[j] * delta_e;\n        double  Dz = dcz[i] * delta_h;\n        double  Dx2 = Dx * Dx;\n        double  Dy2 = Dy * Dy;\n        double  Dz2 = Dz * Dz;\n        double  R = sqrt((Dx2 + Dy2 + Dz2));\n        double  e = 50.0 * (Dz2 - Dy2);\n        double  f = 50.0 * (Dx2 - Dy2);\n        double  g = 50.0 * (Dx2 + Dy2 - Dz2);\n        double  Jx = Dx*(-e + 2.0*f) - Dy*(g - 2.0*Dz) - Dz*2.0*Dx*Dy;\n        double  Jy = Dy*(-e + 2.0*f) - Dx*(g - 2.0*Dz) - Dz*2.0*Dy*Dx;\n        double  Jz = Dz*(-e + 2.0*f) - Dx*g + Dy*Dz - 2.0*Dz2*Dx - 2.0*Dy2*Dy;\n        ex[i][j] = ex[i][j] + 0.7 * Jx;\n        ey[i][j] = ey[i][j] + 0.7 * Jy;\n        hz[i][j] = hz[i][j] + 0.7 *(Jz - 0.005 * R);\n      }\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes in C, use the following natural language instruction:\n\n\"Designate the following function as a hardware kernel for acceleration, and within the function, apply automatic loop pipelining, tile factor and parallelization for optimization.\"", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction=D FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        z_sum = hz[i][j] + hz[i][j + 1] + hz[i + 1][j] + hz[i + 1][j + 1];\n        hz[i][j] = z_sum * jacobian;\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n      for (j = 0; j < 240 - 1; j++) {\n        e_x = -ex[i][j] + ex[i][j + 1];\n        e_y = -ey[i][j] + ey[i + 1][j];\n        hz[i][j] = hz[i][j] - 1.0 / (6.0 * a) * (e_x * (hz[i + 1][j + 1] - hz[i + 1][j]) - e_y * (hz[i + 1][j] - hz[i][j + 1]) + (hz[i][j + 1] - hz[i][j]));\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n      for (j = 0; j < 240 - 1; j++) {\n        e_x = -ex[i][j] + ex[i][j + 1];\n        e_y = -ey[i][j] + ey[i + 1][j];\n        ez[i][j] = ez[i][j] - 1.0 / (6.0 * a) * (e_y * (hz[i + 1][j + 1] - hz[i][j + 1]) - e_x * (hz[i + 1][j] - hz[i][j + 1]) + (hz[i + 1][j + 1] - hz[i][j + 1]));\n      }\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes in C for hardware acceleration, use the following comprehensive but concise natural language instruction:\n\n\"Declare the following function as a hardware kernel for acceleration and apply specific optimizations to the loops: turn off automatic pipelining, set the tile factor to 1 for original full processing, and parallelize the loops with specific factors of 2, 32, and 12.\"\n\nThis instruction covers the key pragma values to use:\n\n- '#pragma ACCEL kernel' for hardware acceleration\n- '#pragma ACCEL PIPELINE auto{off}' for turning off automatic pipelining\n- '#pragma ACCEL TILE FACTOR=auto{1}' for setting the tile factor to 1\n- '#pragma ACCEL PARALLEL FACTOR=auto{2}' for parallelizing the loop with a factor of 2\n- '#pragma ACCEL PARALLEL FACTOR=auto{32}' for parallelizing the loop with a factor of 32\n- '#pragma ACCEL PARALLEL FACTOR=auto{12}' for parallelizing the loop with a factor of 12", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "1": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _row = i * 240 + j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        double  _tmp_1 = 0.0;\n        double  _tmp_2 = 0.0;\n        double  _tmp_3 = 0.0;\n        double  _tmp_4 = 0.0;\n        double  _tmp_5 = 0.0;\n        double  _tmp_6 = 0.0;\n        double  _tmp_7 = 0.0;\n        double  _tmp_8 = 0.0;\n        double  _tmp_9 = 0.0;\n        double  _tmp_10 = 0.0;\n        double  _tmp_11 = 0.0;\n        double  _tmp_12 = 0.0;\n        double  _tmp_13 = 0.0;\n        double  _tmp_14 = 0.0;\n        double  _tmp_15 = 0.0;\n        double  _tmp_16 = 0.0;\n        double  _tmp_17 = 0.0;\n        double  _tmp_18 = 0.0;\n        double  _tmp_19 = 0.0;\n        double  _tmp_20 = 0.0;\n        double  _tmp_21 = 0.0;\n        double  _tmp_22 = 0.0;\n        double  _tmp_23 = 0.0;\n        double  _tmp_24 = 0.0;\n        double  _tmp_25 = 0.0;\n        _tmp_1 = ex[i][j+1];\n        _tmp_2 = ey[i][j+1];\n        _tmp_3 = hz[i][j+1];\n        _tmp_4 = ex[i][j];\n        _tmp_5 = ey[i][j];\n        _tmp_6 = hz[i][j];\n        _tmp_7 = ex[i][j-1];\n        _tmp_8 = ey[i][j-1];\n        _tmp_9 = hz[i][j-1];\n        _tmp_10 = ex[i+1][j];\n        _tmp_11 = ey[i+1][j];\n        _tmp_12 = hz[i+1][j];\n        _tmp_13 = ex[i+1][j+1];\n        _tmp_14 = ey[i+1][j+1];\n        _tmp_15 = hz[i+1][j+1];\n        _tmp_16 = ex[i+1][j-1];\n        _tmp_17 = ey[i+1][j-1];\n        _tmp_18 = hz[i+1][j-1];\n        _tmp_19 = _tmp_6 - _tmp_5;\n        _tmp_20 = _tmp_5 - _tmp_4;\n        _tmp_21 = _tmp_4 - _tmp_3;\n        _tmp_22 = _tmp_5 - _tmp_8;\n        _tmp_23 = _tmp_8 - _tmp_7;\n        _tmp_24 = _tmp_7 - _tmp_6;\n        _tmp_25 = s_ex[0] * _tmp_19;\n        ey[i][j] = _tmp_5 + ((_tmp_25 + s_ey[0] * _tmp_21) / (2.0));\n        _hz[i][j] = _tmp_6 + ((_tmp_21 * (_tmp_20 - _tmp_24) + _tmp_25 * (_tmp_13 - _tmp_16)) / (_tmp_19 * (_tmp_12 - _tmp_15) - _tmp_22 * (_tmp_14 - _tmp_17)));\n        _tmp_26 = _tmp_7 - _tmp_6;\n        _tmp_27 = _tmp_8 - _tmp_7;\n        _tmp_28 = _tmp_6 - _tmp_5;\n        ex[i][j] = _tmp_4 + ((_tmp_27 * _tmp_26 + _tmp_28 * _tmp_24) / (_tmp_23 * _tmp_25 - _tmp_20 * _tmp_22));\n      }\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes in C, use the following natural language instructions for the #pragma values:\n\n1. Apply automatic pipelining to the loop: \n   Use '#pragma ACCEL PIPELINE auto{}' to automatically pipeline the loop.\n   \n2. Set the tiling factor for the loop to its automatic value:\n   Use '#pragma ACCEL TILE FACTOR=auto{1}' to set the tiling factor automatically.\n   \n3. Set the parallelization factor for the first loop to its automatic value:\n   Use '#pragma ACCEL PARALLEL FACTOR=auto{2}' to parallelize the loop automatically.\n\n4. Set a specific parallelization factor for the inner loop to its automatic value:\n   Use '#pragma ACCEL PARALLEL FACTOR=auto{32}' to parallelize the inner loop with the specified factor.\n\n5. Set a different parallelization factor for the subsequent inner loop to its automatic value:\n   Use '#pragma ACCEL PARALLEL FACTOR=auto{12}' to parallelize the second inner loop with the specified factor.\n\nBy following these instructions, you can generate the given HLS codes in C with the appropriate #pragma values.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": "\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 1; j < 80; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j] - ex[i][j - 1]) - 0.7 * (ey[i][j] - ey[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To auto pipeline the loop, use `#pragma ACCEL PIPELINE auto`  \nTo auto tile the loop with factor 1, use `#pragma ACCEL TILE FACTOR=auto{1}`  \nTo auto parallelize the loop with factor 2, use `#pragma ACCEL PARALLEL FACTOR=auto{2}`  \nTo auto parallelize the inner loop with factor 32, use `#pragma ACCEL PARALLEL FACTOR=auto{32}`  \nTo auto parallelize the inner loop with factor 12, use `#pragma ACCEL PARALLEL FACTOR=auto{12}`", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "  \nAfter auto: \n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L2}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L4}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L5}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L6}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "1": "  \n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 2 * j;\n        int _in_i = 2 * i;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][_in_j + 1] - ex[i][_in_j] + ey[ _in_i + 1][j] - ey[ _in_i][j]);\n      }\n    }\n  }\n}\n", "2": "  \n::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::  \n  \n#include <math.h>\n#include <stdio.h>\n#include <sys/time.h>\n#include <unistd.h>\n  \n#include \"gemm.h\"\n  \ndouble time_gemm(double A[4096],double B[4096],double C[4096])\n{\n  int i;\n  int j;\n  int k;\n  int k_col;\n  int i_col;\n  double mult;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  outer:\n  for (i = 0; i < 64; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    middle:\n    for (j = 0; j < 64; j++) {\n      i_col = i * 64;\n      double sum = (double )0;\n      \n#pragma ACCEL PARALLEL reduction=sum FACTOR=auto{12}\n      inner:\n      for (k = 0; k < 64; k++) {\n        k_col = k * 64;\n        mult = A[i_col + k] * B[k_col + j];\n        sum += mult;\n      }\n      C[i_col + j] = sum;\n    }\n  }\n}\n  \nvoid gemm(double A[4096],double B[4096],double C[4096])\n{\n  int i;\n  int j;\n  int k;\n  int k_col;\n  int i_col;\n  double mult;\n  double sum;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  outer:\n  for (i = 0; i < 64; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    middle:\n    for (j = 0; j < 64; j++) {\n      i_col = i * 64;\n      sum = (double )0;\n      \n#pragma ACCEL PARALLEL reduction=sum FACTOR=auto{12}\n      inner:\n      for (k = 0; k < 64; k++) {\n        k_col = k * 64;\n        mult = A[i_col + k] * B[k_col + j];\n        sum += mult;\n      }\n      C[i_col + j] = sum;\n    }\n  }\n}\n", "3": "  \nAfter auto transformations: \n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{_1}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L2}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L3_0}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L4_0}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "  \nTo annotate PE, use `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}`  \nTo annotate PE, use `#pragma ACCEL PIPELINE auto{__PIPE__L0}`  \nTo annotate TILE FACTOR=auto{1}, use `#pragma ACCEL TILE FACTOR=auto{__TILE__L0}`  \nTo annotate PE, use `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}`  \nTo annotate PIPELINE auto{__PIPE__L1}, use `#pragma ACCEL PIPELINE auto{__PIPE__L1}`  \nTo annotate TILE FACTOR=auto{__TILE__L1}, use `#pragma ACCEL TILE FACTOR=auto{__TILE__L1}`  \nTo annotate PARALLEL FACTOR=auto{__PARA__L2}, FACTOR=auto{32}, SCALE=auto{2}  \nTo annotate PARALLEL FACTOR=auto{__PARA__L3}, FACTOR=auto{__PARA__L3}, SCALE=auto{__SCALE__L3}  \n  \n#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To generate the given HLS codes in C, follow these concise natural language instructions:\n1. Treat the following function as a hardware kernel for acceleration.\n2. Don't automatically pipeline this loop.\n3. Process this loop in its original, full form without breaking it into smaller chunks.\n4. Run the iterations of this loop in parallel with a factor of 2.\n5. Run the iterations of this loop in parallel with a factor of 4.\n6. Run the iterations of this loop in parallel with a factor of 8.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n7. Don't automatically distribute this loop across nodes or cores.\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "1": "\n7. Don't automatically distribute arrays.\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_up = i + 1;\n        int j_right = j + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_up][j] - ex[i][j]) - 0.7 * (ey[i][j_right] - ey[i][j]) + 1.0 * q[i][j];\n      }\n    }\n  }\n}\n", "2": "\n7. Don't automatically distribute this loop.\n8. Don't automatically pipeline this loop.\n9. Process this loop in its original, full form without breaking it into smaller chunks.\n10. Run the iterations of this loop in parallel with a factor of 1.\n11. Don't automatically distribute this loop.\n12. Don't automatically pipeline this loop.\n13. Process this loop in its original, full form without breaking it into smaller chunks.\n14. Run the iterations of this loop in parallel with a factor of 1.\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int s = i * 240 + j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": "\n7. Don't automatically distribute this loop across threads.\n8. Try to automatically parallelize this loop with 4 workers.\n9. Don't automatically parallelize this loop.\n10. Don't automatically distribute this loop across threads.\n11. Try to automatically parallelize this loop with 2 workers.\n12. Try to automatically parallelize this loop with 4 workers.\n13. Don't automatically pipeline this loop.\n \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "\n7. Don't automatically distribute this loop.\n8. Distribute the iterations of this loop by tiling2d\n9. Don't automatically distribute this loop.\n10. Distribute the iterations of this loop by 2\n11. Don't automatically distribute this loop.\n12. Distribute the iterations of this loop by 2\n13. Don't automatically distribute this loop.\n14. Distribute the iterations of this loop by 2\n \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_up = i + 1;\n        int j_up = j + 1;\n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7_0}\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_up][j] - ex[i][j]) - 0.7 * (ey[i][j_up] - ey[i][j]);\n      }\n    }\n  }\n}\n"}}
{"input": "To automatically pipeline the loop, set the pragma value to '#pragma ACCEL PIPELINE auto{}'. To process the loop in its original, full form without breaking it into smaller chunks, set the pragma value to '#pragma ACCEL TILE FACTOR=auto{1}'. To run the iterations of the loop one after the other, not in parallel, set the pragma value to '#pragma ACCEL PARALLEL FACTOR=auto{2}'.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\nFor more information about how to invoke and options supported by ACCEL compilers, please refer to the ACCEL user manual.\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "1": "\nThe best time achieved:\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        zx[i][j] = sqrt((ex[i][j + 1] - ex[i][j]) * (ex[i][j + 1] - ex[i][j]) + (ey[i + 1][j] - ey[i][j]) * (ey[i + 1][j] - ey[i][j])) / (hz[i + 1][j] - hz[i][j]);\n        zy[i][j] = sqrt((ex[i + 1][j] - ex[i][j]) * (ex[i + 1][j] - ex[i][j]) + (ey[i][j + 1] - ey[i][j]) * (ey[i][j + 1] - ey[i][j])) / (hz[i + 1][j + 1] - hz[i][j + 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (zx[i][j] * (ey[i][j + 1] - ey[i][j]) - zy[i][j] * (ex[i + 1][j] - ex[i][j]));\n      }\n    }\n  }\n}\n", "2": "\nEXP_VAL = 1220703125\nIN_ROW_SCALE = 2.0\nIN_COL_SCALE = 2.0\nIN_SUM_SCALE = 2.0\nA[31][31] = 1.0\nA[31][30] = 2.0\nA[31][29] = 3.0\nA[31][28] = 4.0\nA[31][27] = 5.0\nA[31][26] = 6.0\nA[31][25] = 7.0\nA[31][24] = 8.0\nA[31][23] = 9.0\nA[31][22] = 10.0\nA[31][21] = 11.0\nA[31][20] = 12.0\nA[31][19] = 13.0\nA[31][18] = 14.0\nA[31][17] = 15.0\nA[31][16] = 16.0\nA[31][15] = 17.0\nA[31][14] = 18.0\nA[31][13] = 19.0\nA[31][12] = 20.0\nA[31][11] = 21.0\nA[31][10] = 22.0\nA[31][9] = 23.0\nA[31][8] = 24.0\nA[31][7] = 25.0\nA[31][6] = 26.0\nA[31][5] = 27.0\nA[31][4] = 28.0\nA[31][3] = 29.0\nA[31][2] = 30.0\nA[31][1] = 31.0\nA[31][0] = 32.0\nA[30][31] = 33.0\nA[30][30] = 45.0\nA[30][29] = 57.0\nA[30][28] = 69.0\nA[30][27] = 81.0\nA[30][26] = 93.0\nA[30][25] = 105.0\nA[30][24] = 117.0\nA[30][23] = 129.0\nA[30][22] = 141.0\nA[30][21] = 153.0\nA[30][20] = 165.0\nA[30][19] = 177.0\nA[30][18] = 189.0\nA[30][17] = 201.0\nA[30][16] = 213.0\nA[30][15] = 225.0\nA[30][14] = 237.0\nA[30][13] = 249.0\nA[30][12] = 261.0\nA[30][11] = 273.0\nA[30][10] = 285.0\nA[30][9] = 297.0\nA[30][8] = 309.0\nA[30][7] = 321.0\nA[30][6] = 333.0\nA[30][5] = 345.0\nA[30][4] = 357.0\nA[30][3] = 369.0\nA[30][2] = 381.0\nA[30][1] = 393.0\nA[30][0] = 405.0\nA[29][31] = 417.0\nA[29][30] = 449.0\nA[29][29] = 481.0\nA[29][28] = 513.0\nA[29][27] = 545.0\nA[29][26] = 577.0\nA[29][25] = 609.0\nA[29][24] = 641.0\nA[29][23] = 673.0\nA[29][22] = 705.0\nA[29][21] = 737.0\nA[29][20] = 769.0\nA[29][19] = 801.0\nA[29][18] = 833.0\nA[29][17] = 865.0\nA[29][16] = 897.0\nA[29][15] = 929.0\nA[29][14] = 961.0\nA[29][13] = 993.0\nA[29][12] = 1025.0\nA[29][11] = 1057.0\nA[29][10] = 1089.0\nA[29][9] = 1121.0\nA[29][8] = 1153.0\nA[29][7] = 1185.0\nA[29][6] = 1217.0\nA[29][5] = 1249.0\nA[29][4] = 1281.0\nA[29][3] = 1313.0\nA[29][2] = 1345.0\nA[29][1] = 1377.0\nA[29][0] = 1409.0\nA[28][31] = 1441.0\nA[28][30] = 1473.0\nA[28][29] = 1505.0\nA[28][28] = 1537.0\nA[28][27] = 1569.0\nA[28][26] = 1601.0\nA[28][25] = 1633.0\nA[28][24] = 1665.0\nA[28][23] = 1697.0\nA[28][22] = 1729.0\nA[28][21] = 1761.0\nA[28][20] = 1793.0\nA[28][19] = 1825.0\nA[28][18] = 1857.0\nA[28][17] = 1889.0\nA[28][16] = 1921.0\nA[28][15] = 1953.0\nA[28][14] = 1985.0\nA[28][13] = 2017.0\nA[28][12] = 2049.0\nA[28][11] = 2081.0\nA[28][10] = 2113.0\nA[28][9] = 2145.0\nA[28][8] = 2177.0\nA[28][7] = 2209.0\nA[28][6] = 2241.0\nA[28][5] = 2273.0\nA[28][4] = 2305.0\nA[28][3] = 2337.0\nA[28][2] = 2369.0\nA[28][1] = 2401.0\nA", "3": "\nWARNING: Cannot declare 2 sections with the same name \"default\"\n \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_in_j = 2*(i + 1) + 0;\n        int i_in_j_plus_1 = 2*(i + 1) + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_in_j][j + 1] - ex[i_in_j][j] + ey[i][j + 1] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "\nThe program was compiled and ran on:\nA compute device was selected based on the BACKEND environment variable:\nNumber of kernels: 1\n\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n"}}
{"input": "Process the following function as a hardware kernel for acceleration. Code the loops for r, q, and p to be pipelined without using automatic pipeline. Use a tile factor of 1 for each loop.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{2}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1*i;\n        int j_col = j + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_col][j] - ex[i][j_col]) - 0.7 * (ey[i][j_col] - ey[i_col][j]);\n      }\n    }\n  }\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        z_pe[i][j] = hz[i][j] - 0.25 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 1; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n      for (j = 1; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.25 * (ex[i + 1][j + 1] - ex[i + 1][j] - ey[i][j + 1] + ey[i][j]) + 0.7071 * (sqrts - z_pe[i][j]);\n      }\n    }\n  }\n}\n", "3": " \n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        double  delta_x = (double )(ex[i][j + 1] - ex[i][j]);\n        double  delta_y = (double )(ey[i + 1][j] - ey[i][j]);\n        double  delta_z = (double )(hz[i + 1][j] - hz[i][j]);\n        double  si = delta_x - delta_y * 0.5;\n        double  sj = delta_y + delta_x * 1j;\n        double  sk = delta_x + delta_y * 0.5;\n        double  _fj = _fict_[i * j];\n        double  ei = -_fj * si;\n        double  ej = -_fj * sj;\n        double  ek = -_fj * sk;\n        double  ux = 2.0 * (ei - ej * 1i) / (ei * ei + ej * ej);\n        double  uy = 2.0 * (ej - ei * 1i) / (ei * ei + ej * ej);\n        double  uz = 2.0 * (ek - ej * 1i) / (ek * ek + sj * sj);\n        double  vx = 2.0 * (ei + ux * sj) / (si * si + ux * ux);\n        double  vy = 2.0 * (ey[i][j] - uy * si) / (sj * sj + uy * uy);\n        double  vz = 2.0 * (ek + uy * si) / (sk * sk + uy * uy);\n        double  wx = 2.0 * (ek - vz * 1i) / (ek * ek + vz * vz);\n        double  wy = 2.0 * (vz - ek * 1i) / (sk * sk + vz * vz);\n        double  wz = 2.0 * (ek + vx * 1i) / (sk * sk + vx * vx);\n        double  div = 4.0 + (double )uz * (ux * ux + vy * vy + wz * wz) + (double )vz * (ux * ux + vy * vy + vz * vz) + (double )wz * (ux * ux + vy * vy + vz * vz);\n        ex[i][j] = vx;\n        ey[i][j] = vy;\n        hz[i][j] = wz;\n        ex[i][j + 1] = vx + delta_x;\n        ey[i + 1][j] = vy + delta_y;\n        hz[i][j + 1] = wz + delta_z;\n        ex[i + 1][j] = vx + delta_x;\n        ey[i][j + 1] = vy + delta_y;\n        hz[i + 1][j] = wz + delta_z;\n        ex[i + 1][j + 1] = vx + delta_x;\n        ey[i + 1][j + 1] = vy + delta_y;\n        hz[i + 1][j + 1] = wz + delta_z;\n        div[i][j] = div;\n      }\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes written in C:\nUse '#pragma ACCEL kernel' to designate the following function as a hardware kernel for acceleration.\n\nUse '#pragma ACCEL PIPELINE auto{}' to enable automatic pipeline scheduling for the loop.\n\nUse '#pragma ACCEL TILE FACTOR=auto{1}' to process the loop in its original, full form without breaking it into smaller chunks.\n\nUse '#pragma ACCEL PARALLEL FACTOR=auto{2}' to run iterations of the loop in parallel, with a parallel factor of 2.\n\nUse '#pragma ACCEL PARALLEL FACTOR=auto{32}' to run the inner loop iterations in parallel, with a parallel factor of 32.\n\nUse '#pragma ACCEL PARALLEL FACTOR=auto{12}' to run iterations of the inner loop in parallel, with a parallel factor of 12.\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": " #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "  \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 2L * j;\n        int _in_i = 2L * i;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": "  \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_0 = i;\n        int j_0 = j;\n        \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n        for (k = 0; k < 40; k++) {\n          hz[i_0][j_0] = hz[i_0][j_0] - 0.7 * (ex[i_0][j_0 + 1] - ex[i_0][j_0] + ey[i_0 + 1][j_0] - ey[i_0][j_0]);\n        }\n      }\n    }\n  }\n}\n", "3": "  \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        double  delta = 1.0 / ((double )(1 << 12));\n        double  p1 = ex[i][j] - ex[i][j + 1];\n        double  p2 = ey[i][j] - ey[i + 1][j];\n        double  p3 = hz[i][j] - hz[i + 1][j];\n        double  p4 = ex[i][j + 1] + ex[i][j] - ey[i + 1][j] - ey[i][j];\n        double  p5 = ey[i][j + 1] + ey[i][j] - hz[i][j] - hz[i][j + 1];\n        double  num1 = p4 * p4;\n        double  num2 = 4.0 * p3 * p5;\n        double  den = num1 + num2;\n        hz[i][j] = hz[i][j] + delta * (p1 * num2 - p2 * num1 + p3 * (p4 + p5));\n        ey[i][j] = ey[i][j] + delta * (p1 * num2 + p2 * num1 + p3 * (p4 - p5));\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n      for (j = 0; j < 240 - 1; j++) {\n        double  delta = 1.0 / ((double )(1 << 12));\n        double  p1 = ex[i][j] - ex[i][j + 1];\n        double  p2 = ey[i][j] - ey[i + 1][j];\n        double  p3 = hz[i][j] - hz[i + 1][j];\n        double  p4 = ex[i][j + 1] + ex[i][j] - ey[i + 1][j] - ey[i][j];\n        double  p5 = ey[i + 1][j + 1] + ey[i][j + 1] - hz[i + 1][j + 1] - hz[i][j + 1];\n        double  num1 = p4 * p4;\n        double  num2 = 4.0 * p3 * p5;\n        double  den = num1 + num2;\n        ex[i][j] = ex[i][j] + delta * (p1 * num2 - p2 * num1 + p3 * (p4 + p5));\n      }\n    }\n  }\n}\n", "4": "  \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_in_j = i * 240 + j;\n        int i_prev_j = (i - 1) * 240 + j;\n        int i_next_j = (i + 1) * 240 + j;\n        int i_in_j_prev = i * 240 + j - 1;\n        int i_in_j_next = i * 240 + j + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n"}}
{"input": "Transform the following function into a hardware kernel for acceleration, and apply parallelization to the outer and inner loops. Also, pipeline the loop for better performance.\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": " #pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[410][390],double s[390],double q[410],double p[390],double r[410])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 390; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 410; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 390; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n}\n", "1": " #pragma ACCEL kernel\n\nvoid kernel_gesummv(int n,double alpha,double beta,double A[90][90],double B[90][90],double tmp[90],double x[90],double y[90])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 90; i++) {\n    tmp[i] = 0.0;\n    y[i] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 90; j++) {\n      tmp[i] = A[i][j] * x[j] + tmp[i];\n      y[i] = B[i][j] * x[j] + y[i];\n    }\n    y[i] = alpha * tmp[i] + beta * y[i];\n  }\n}\n", "2": " #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L4}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "3": " #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "4": " #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        double  delta_x = (double )(ex[i][j + 1] - ex[i][j]);\n        double  delta_y = (double )(ey[i + 1][j] - ey[i][j]);\n        double  delta_z = (double )(hz[i + 1][j] - hz[i][j]);\n        double  si_x = delta_x / (4.0 * (1.0 + delta_x * delta_x + delta_y * delta_y));\n        double  si_y = delta_y / (4.0 * (1.0 + delta_x * delta_x + delta_y * delta_y));\n        double  si_z = delta_z / (4.0 * (1.0 + delta_x * delta_x + delta_y * delta_y));\n        double  co_x = - 1.0 * delta_x / (2.0 * (1.0 + delta_x * delta_x + delta_y * delta_y));\n        double  co_y = - 1.0 * delta_y / (2.0 * (1.0 + delta_x * delta_x + delta_y * delta_y));\n        double  co_z = - 1.0 * delta_z / (2.0 * (1.0 + delta_x * delta_x + delta_y * delta_y));\n        double  r_x = si_x - ex[i][j] ;\n        double  r_y = si_y - ey[i][j] ;\n        double  r_z = si_z - hz[i][j] ;\n        double  t_x = - 1.0 * co_x - ex[i][j] ;\n        double  t_y = - 1.0 * co_y - ey[i][j] ;\n        double  t_z = - 1.0 * co_z - hz[i][j] ;\n        double  w_x = co_x - ex[i][j] ;\n        double  w_y = co_y - ey[i][j] ;\n        double  w_z = co_z - hz[i][j] ;\n        double  b_x = ((double )7.0) * (r_x - t_x) ;\n        double  b_y = ((double )7.0) * (r_y - t_y) ;\n        double  b_z = ((double )7.0) * (r_z - t_z) ;\n        double  c_x = w_x - ((double )2.0) * r_x ;\n        double  c_y = w_y - ((double )2.0) * r_y ;\n        double  c_z = w_z - ((double )2.0) * r_z ;\n        double  e_x = ((double )2.0) * r_x ;\n        double  e_y = ((double )2.0) * r_y ;\n        double  e_z = ((double )2.0) * r_z ;\n        double  d_x = ((double )2.0) * (co_x - ex[i + 1][j]) ;\n        double  d_y = ((double )2.0) * (co_y - ey[i + 1][j]) ;\n        double  d_z = ((double )2.0) * (co_z - hz[i + 1][j]) ;\n        ex[i][j] = e_x + ((double )1.0 / (12.0)) * (b_x + ((double )4.0) * (c_x + d_x));\n        ey[i][j] = e_y + ((double )1.0 / (12.0)) * (b_y + ((double )4.0) * (c_y + d_y));\n        hz[i][j] = e_z + ((double )1.0 / (12.0)) * (b_z + ((double )4.0) * (c_z + d_z));\n      }\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes in C, you need to apply the following #pragma values:\n\n1. For the outermost loop:\n   - Use `#pragma ACCEL PIPELINE \"off\"` to prevent automatic pipelining.\n\n2. For the nested loops:\n   - Use `#pragma ACCEL TILE FACTOR=1` to process the loops in their original, full form without breaking them into smaller chunks.\n\n3. Inside the innermost loop:\n   - Use `#pragma ACCEL PIPELINE \"off\"` to disable automatic pipelining.\n\nCombine these pragma directives with the function declaration `#pragma ACCEL kernel` to treat the function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 2L * (j + 1) - 1 - 1;\n        int _in_i = 2L * (i + 1) - 1 - 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "1": "\n\n\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        double sum_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=sum_tmp FACTOR=auto{__PARA__L3}\n\tfor (s = 0; s < 30; s++) {\n          sum_tmp += A[r][q][s] * C4[s][p];\n        }\n\tsum[p] = sum_tmp;\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 2 * j;\n        int _in_i = 2 * i;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "\n\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 240;\n        int _in_i = 200;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n"}}
{"input": "Process the following loops in their original, full form without breaking them into smaller chunks and automatically pipeline each loop. Treat the 'kernel_doitgen' function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        double sum_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=sum_tmp FACTOR=auto{__PARA__L3}\n\tfor (s = 0; s < 30; s++) {\n          sum_tmp += A[r][q][s] * C4[s][p];\n        }\n\tsum[p] = sum_tmp;\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        double sum_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=sum_tmp FACTOR=auto{__PARA__L3}\n\tfor (s = 0; s < 30; s++) {\n          sum_tmp += A[r][q][s] * C4[s][p];\n        }\n\tsum[p] = sum_tmp;\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = ((double )0);\n      }\n    }\n    for (p = 0; p < 30; p++) {\n      A[r][14][p] = 1.0;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n      for (p = 0; p < 30; p++) {\n        for (s = 0; s < 30; s++) {\n          A[r][q][p] += C4[p][s] * A[r][q][s];\n        }\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        double sum = A[r][q][p];\n#pragma ACCEL PARALLEL reduction=sum FACTOR=auto{__PARA__L3}\n\tfor (s = 0; s < 30; s++) {\n          if (s == p) {\n            sum += ((double )0);\n          }\n          else {\n            sum += A[r][q][s] * C4[s][p];\n          }\n        }\n\tA[r][q][p] = sum;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(int A[25][20][30],int B[25][20][30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        B[r][q][p] = ((long )0);\n      }\n    }\n    for (p = 0; p < 30; p++) {\n      A[r][0][p] = B[r][0][p];\n    }\n    for (q = 0; q < 20; q++) {\n      A[r][q][0] = B[r][q][0];\n    }\n    for (s = 1; s < 30; s++) {\n      for (q = 0; q < 20; q++) {\n        A[r][q][s] = A[r][q][s - 1] + B[r][q][s];\n      }\n    }\n    for (p = 1; p < 20; p++) {\n      for (q = 0; q < 20; q++) {\n        A[r][q][p] = A[r][q][p] + A[r][p][q];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "Apply pipeline optimization to the outermost loop, and enable tiling with a factor of 2 for parallelism. Disable pipeline optimization and set tiling factor to 1 for the inner loops to maintain the original, unbroken form. Additionally, mark the following function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][80],double C[80][50],double D[40][50])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      for (k = 0; k < 70; k++) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 50; j++) {\n      D[i][j] *= beta;\n      for (k = 0; k < 80; k++) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        z_p[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ey[i + 1][j + 1] - ey[i + 1][j] - ey[i][j + 1] + ey[i][j]) + ex[i + 1][j + 1];\n      }\n    }\n  }\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        z_x[i][j] = hz[i][j + 1] - hz[i][j];\n        z_y[i][j] = hz[i + 1][j] - hz[i][j];\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n      for (j = 0; j < 240 - 1; j++) {\n        _x[0][j] = -1.0 * (ey[i][j + 1] - ey[i][j]) / (2 * (hx[j + 1] - hx[j])) + ex[i][j + 1] - ex[i][j];\n        _y[0][j] = -1.0 * (ex[i + 1][j] - ex[i][j]) / (2 * (hy[i + 1] - hy[i])) + ey[i + 1][j] - ey[i][j];\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 1; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n      for (j = 1; j < 240 - 1; j++) {\n        _x[i][j] = -1.0 * (ey[i][j + 1] - ey[i][j - 1]) / (2.0 * (hx[j + 1] - hx[j - 1])) + ex[i][j + 1] - ex[i][j - 1];\n        _y[i][j] = -1.0 * (ex[i + 1][j] - ex[i - 1][j]) / (2.0 * (hy[i + 1] - hy[i - 1])) + ey[i + 1][j] - ey[i - 1][j];\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L7}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L7}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L10}\n      for (j = 0; j < 240 - 1; j++) {\n        ex[i][j] = ex[i][j] + SIX_SEPT_NO_OVRD * (_x[i][j] - _x[i][j + 1]);\n        ey[i][j] = ey[i][j] + SIX_SEPT_NO_OVRD * (_y[i][j] - _y[i + 1][j]);\n        hz[i][j] = hz[i][j] + SIX_SEPT_NO_OVRD * (z_x[i][j] - z_y[i][j]);\n      }\n    }\n  }\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        z_x[i][j] = hz[i][j + 1] - hz[i][j];\n        z_y[i][j] = hz[i + 1][j] - hz[i][j];\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n      for (j = 0; j < 240 - 1; j++) {\n        _x[0][j] = ex[i][j + 1] - ex[i][j];\n        _y[0][j] = ey[i + 1][j] - ey[i][j];\n      }\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L9}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L9}\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n      for (k = 1; k < 4; k++) {\n        \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L10}\n        for (j = 0; j < 240 - 1; j++) {\n          _x[k][j] = _x[k][j] - 0.5 * (z_x[i + 1][j + 1] - z_x[i + 1][j]);\n          _y[k][j] = _y[k][j] - 0.5 * (z_y[i + 1][j + 1] - z_y[i][j + 1]);\n        }\n      }\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{2}\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L11}\n      for (j = 0; j < 240 - 1; j++) {\n        ey[i][j] = ((_x[0][j] + _y[0][j]) + ((_x[1][j] + _y[1][j]) + ((_x[2][j] + _y[2][j]) + _y[3][j]))) / 4.0;\n        ex[i][j + 1] = ((_x[0][j] + _x[1][j]) + ((_y[0][j] + _x[2][j]) + ((_x[3][j] + _y[2][j]) + (_x[4][j] + _y[3][j])))) / 4.0;\n      }\n    }\n  }\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        z_sum = hz[i][j] + hz[i][j + 1] + hz[i + 1][j] + hz[i + 1][j + 1];\n        hz[i][j] = z_sum;\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n      for (j = 0; j < 240 - 1; j++) {\n        e_x = ex[i][j] - ex[i][j + 1];\n        e_y = ey[i][j] - ey[i + 1][j];\n        e_z = hz[i][j] - hz[i + 1][j + 1];\n        r_x = sqrt((double )((e_x * e_x) + (e_y * e_y) + (e_z * e_z)));\n        tmp = 0.05 * r_x;\n        p_x = e_x - (tmp * e_x);\n        p_y = e_y - (tmp * e_y);\n        p_z = e_z - (tmp * e_z);\n        ex[i][j] = p_x;\n        ey[i][j] = p_y;\n        hz[i][j] = p_z;\n        q_x = p_y * e_z - p_z * e_y;\n        q_y = p_z * e_x - p_x * e_z;\n        q_z = p_x * e_y - p_y * e_x;\n        div = q_x + q_y + q_z;\n        ex[i][j + 1] = ex[i][j] + q_x;\n        ey[i + 1][j] = ey[i][j] + q_y;\n        hz[i][j + 1] = hz[i][j] + q_z;\n        _fict_[i * j] = div;\n      }\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes:\n\n1. Treat the following function `kernel_jacobi_1d` as a hardware kernel for acceleration - Use `#pragma ACCEL kernel` before the function declaration.\n\n2. Don't automatically pipeline the loop - Use `#pragma ACCEL PIPELINE \"off\"` before the loop to disable automatic pipelining.\n\n3. Process this loop in its original, full form without breaking it into smaller chunks - Use `#pragma ACCEL TILE FACTOR=1` before the loop to set the tile factor to 1.\n\n4. Run the iterations of this loop one after the other, not in parallel - Use `#pragma ACCEL PARALLEL FACTOR=1` before the loop to set the parallel factor to 1.\n\nThese instructions will help you generate the given HLS codes written in C.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "Process the functions 'kernel_doitgen' as hardware kernels for acceleration. For the loops in the function, ensure they are not automatically pipelined and are processed in their original, full form without breaking them into smaller chunks. Additionally, ensure that the iterations of the loops are not run in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        double sum_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=sum_tmp FACTOR=auto{__PARA__L3}\n\tfor (s = 0; s < 30; s++) {\n          sum_tmp += A[r][q][s] * C4[s][p];\n        }\n\tsum[p] = sum_tmp;\n\tdouble A_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=A_tmp FACTOR=auto{__PARA__L4}\n\tfor (s = 0; s < 30; s++) {\n          A_tmp += A[r][q][s] * sum[s];\n        }\n\tA[r][q][0] = A_tmp;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        double sum_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=sum_tmp FACTOR=auto{__PARA__L3}\n\tfor (s = 0; s < 30; s++) {\n          sum_tmp += A[r][q][s] * C4[s][p];\n        }\n\tsum[p] = sum_tmp;\n\tdouble A_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=A_tmp FACTOR=auto{__PARA__L4}\n\tfor (s = 0; s < 30; s++) {\n          A_tmp += A[r][q][s] * sum[s];\n        }\n\tA[r][q][0] = A_tmp;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        double sum_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=sum_tmp FACTOR=auto{__PARA__L3}\n\tfor (s = 0; s < 30; s++) {\n          sum_tmp += A[r][q][s] * C4[s][p];\n        }\n\tsum[p] = sum_tmp;\n        A[r][q][p] = sum_tmp;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        double sum_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=sum_tmp FACTOR=auto{__PARA__L3}\n\tfor (s = 0; s < 30; s++) {\n          sum_tmp += A[r][q][s] * C4[s][p];\n        }\n\tsum[p] = sum_tmp;\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        double sum_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=sum_tmp FACTOR=auto{__PARA__L3}\n\tfor (s = 0; s < 30; s++) {\n          sum_tmp += A[r][q][s] * C4[s][p];\n        }\n\tsum[p] = sum_tmp;\n\tdouble A_tmp = A[r][q][p];\n\tC4[p][a[q][p];\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p] + A_tmp;\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "Apply automatic pipeline directive to the loop\nApply automatic tiling directive to the loop with a factor of 1\nApply automatic parallelization directive to the loop with a factor of 2\nApply automatic parallelization directive to the inner loop with a factor of 4\nApply automatic parallelization directive to the inner loop with a factor of 8", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (j = 1; j <= n; j++) {\n    \n#pragma ACCEL PARALLEL reduction=A FACTOR=auto{__PARA__L2}\n    for (i = j; i <= n; i++) {\n      A[i][j] = A[i][j] - A[i][1] * A[j][1] - A[i][2] * A[j][2];\n    }\n    \n#pragma ACCEL PARALLEL reduction=A FACTOR=auto{__PARA__L3}\n    for (i = j; i <= n; i++) {\n      A[i][j] = A[i][j] / A[j][j];\n    }\n  }\n}\n", "1": "\n #pragma ACCEL PIPELINE auto{__PIPE__L0}\n\n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n\n#pragma ACCEL PARALLEL FACTOR=auto{2}\n   for (i = 1; i <= 250; i++) {\n      z[i] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 1; j <= 250; j++) {\n         z[i] += a[i] * b[j];\n      }\n   }\n}\n", "2": "\n #pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (r = 0; r < 128; r++) {\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{__PARA__L2}\n    for (q = 0; q < 128; q++) {\n      sum = 0.0;\n      \n#pragma ACCEL PARALLEL reduction FACTOR=auto{__PARA__L3}\n      for (p = 0; p < 128; p++) {\n        sum += A[p][r] * B[r][q];\n      }\n      C[r][q] = sum;\n    }\n    for (q = 0; q < 128; q++) {\n      double tmp = 0.0;\n      for (p = 0; p < 128; p++) {\n        tmp += A[p][r] * C[p][q];\n      }\n      D[r][q] = tmp;\n    }\n  }\n}\n", "3": "\n #pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n     tmp = dt * D[0];\n     D[0] = C[0] * (A[0] * u[0] + A[1] * u[1] + A[2] * u[2]) + D[0];\n     D[1] = C[1] * (A[1] * u[0] + A[3] * u[1] + A[4] * u[2]) + D[1];\n     D[2] = C[2] * (A[2] * u[0] + A[4] * u[1] + A[5] * u[2]) + D[2];\n     q[0] = - ex[0] * D[0] + ey[0] * D[1] - hz[0] * D[2];\n     q[1] = - ex[1] * D[0] + ey[1] * D[1] - hz[1] * D[2];\n     q[2] = - ex[2] * D[0] + ey[2] * D[1] - hz[2] * D[2];\n     p[0] = B[0] * q[0] - B[1] * q[1] + B[2] * q[2];\n     p[1] = B[1] * q[0] - B[3] * q[1] + B[4] * q[2];\n     p[2] = B[2] * q[0] - B[4] * q[1] + B[5] * q[2];\n     r[0] += - fu[0] * u[0] - fv[0] * u[1] - fw[0] * u[2];\n     r[1] += - fu[1] * u[0] - fv[1] * u[1] - fw[1] * u[2];\n     r[2] += - fu[2] * u[0] - fv[2] * u[1] - fw[2] * u[2];\n     u[0] += tmp * f[0];\n     u[1] += tmp * f[1];\n     u[2] += tmp * f[2];\n     int _in_blk_0 = 0;\n    int _in_blk_1 = 1;\n    int _in_blk_2 = 2;\n    int _in_prev = 0;\n    int _in_idx = 1;\n    int _out_idx = 0;\n    D[_in_blk_0] = r[_out_idx++];\n    D[_in_blk_1] = r[_out_idx++];\n    D[_in_blk_2] = r[_out_idx++];\n    Q[_in_blk_0] = p[_out_idx++];\n    Q[_in_blk_1] = p[_out_idx++];\n    Q[_in_blk_2] = p[_out_idx++];\n    S[_in_blk_0] = u[_out_idx++];\n    S[_in_blk_1] = u[_out_idx++];\n    S[_in_blk_2] = u[_out_idx++];\n    A[_in_blk_0][_in_blk_0] = ex[_in_idx];\n    A[_in_blk_0][_in_blk_1] = ey[_in_idx];\n    A[_in_blk_0][_in_blk_2] = hz[_in_idx];\n    A[_in_blk_1][_in_blk_0] = ey[_in_idx];\n    A[_in_blk_1][_in_blk_1] = ey[_in_prev];\n    A[_in_blk_1][_in_blk_2] = hz[_in_prev];\n    A[_in_blk_2][_in_blk_0] = hz[_in_idx];\n    A[_in_blk_2][_in_blk_1] = hz[_in_prev];\n    A[_in_blk_2][_in_blk_2] = ey[_in_prev];\n    B[_in_blk_0][_in_blk_0] = q[_in_idx];\n    B[_in_blk_0][_in_blk_1] = q[_in_prev];\n    B[_in_blk_0][_in_blk_2] = q[_in_prev];\n    B[_in_blk_1][_in_blk_0] = q[_in_prev];\n    B[_in_blk_1][_in_blk_1] = q[_in_idx];\n    B[_in_blk_1][_in_blk_2] = q[_in_prev];\n    B[_in_blk_2][_in_blk_0] = q[_in_prev];\n    B[_in_blk_2][_in_blk_1] = q[_in_prev];\n    B[_in_blk_2][_in_blk_2] = q[_in_idx];\n    C[_in_blk_0] = f[_in_idx];\n    C[_in_blk_1] = f[_in_prev];\n    C[_in_blk_2] = f[_in_prev];\n  }\n}\n", "4": "\n #pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 1; i <= 256; i++) {\n     force_in_vec = 0.0;\n     j_col_begin = 1L + (i - 1) * 256L;\n     j_col_end = 1L + i * 256L;\n     j_col_col = j_col_begin;\n     force_in_row_begin = 1 + (j_col_begin - 1) * 256L;\n     force_in_row_end = 1 + (j_col_end - 1) * 256L;\n     force_in_row_row = force_in_row_begin;\n     for (j = 1; j_col_col < j_col_end; j++) {\n        j_col = j * 256L;\n        tmp = 0.0;\n        force_in_row = force_in_row_row;\n        flm = 0.0;\n        _in_off = 0;\n        _col_off = j_col * 256L;\n         _in_ptr =  _in_off +  _in_row_ptr;\n         flm +=  _in_ptr[0] * 4.0;\n        flm +=  _in_ptr[1] * 4.0;\n        flm +=  _in_ptr[2] * 4.0;\n        flm +=  _in_ptr[3] * 4.0;\n        flm +=  _in_ptr[4] * 4.0;\n        flm +=  _in_ptr[5] * 4.0;\n        flm +=  _in_ptr[6] * 4.0;\n        flm +=  _in_ptr[7] * 4.0;\n        flm +=  _in_ptr[8] * 4.0;\n        flm +=  _in_ptr[9] * 4.0;\n        flm +=  _in_ptr[10] * 4.0;\n        flm +=  _in_ptr[11] * 4.0;\n        flm +=  _in_ptr[12] * 4.0;\n        flm +=  _in_ptr[13] * 4.0;\n        flm +=  _in_ptr[14] * 4.0;\n        flm +=  _in_ptr[15] * 4.0;\n        flm +=  _in_ptr[16] * 4.0;\n        flm +=  _in_ptr[17] * 4.0;\n        flm +=  _in_ptr[18] * 4.0;\n        flm +=  _in_ptr[19] * 4.0;\n        flm +=  _in_ptr[20] * 4.0;\n        flm +=  _in_ptr[21] * 4.0;\n        flm +=  _in_ptr[22] * 4.0;\n        flm +=  _in_ptr[23] * 4.0;\n        flm +=  _in_ptr[24] * 4.0;\n        flm +=  _in_ptr[25] * 4.0;\n        flm +=  _in_ptr[26] * 4.0;\n        flm +=  _in_ptr[27] * 4.0;\n        flm +=  _in_ptr[28] * 4.0;\n        flm +=  _in_ptr[29] * 4.0;\n        flm +=  _in_ptr[30] * 4.0;\n        flm +=  _in_ptr[31] * 4.0;\n        flm +=  _in_ptr[32] * 4.0;\n        flm +=  _in_ptr[33] * 4.0;\n        flm +=  _in_ptr[34] * 4.0;\n        flm +=  _in_ptr[35] * 4.0;\n        flm +=  _in_ptr[36] * 4.0;\n        flm +=  _in_ptr[37] * 4.0;\n        flm +=  _in_ptr[38] * 4.0;\n        flm +=  _in_ptr[39] * 4.0;\n        flm +=  _in_ptr[40] * 4.0;\n        flm +=  _in_ptr[41] * 4.0;\n        flm +=  _in_ptr[42] * 4.0;\n        flm +=  _in_ptr[43] * 4.0;\n        flm +=  _in_ptr[44] * 4.0;\n        flm +=  _in_ptr[45] * 4.0;\n        flm +=  _in_ptr[46] * 4.0;\n        flm +=  _in_ptr[47] * 4.0;\n        flm +=  _in_ptr[48] * 4.0;\n        flm +=  _in_ptr[49] * 4.0;\n        flm +=  _in_ptr[50] * 4.0;\n        flm +=  _in_ptr[51] * 4.0;\n        flm +=  _in_ptr[52] * 4.0;\n        flm +=  _in_ptr[53] * 4.0;\n        flm +=  _in_ptr[54] * 4.0;\n        flm +=  _in_ptr[55] * 4.0;\n        flm +=  _in_ptr[56] * 4.0;\n        flm +=  _in_ptr[57] * 4.0;\n        flm +=  _in_ptr[58] * 4.0;\n        flm +=  _in_ptr[59] * 4.0;\n        flm +=  _in_ptr[60] * 4.0;\n        flm +=  _in_ptr[61] * 4.0;\n        flm +=  _in_ptr[62] * 4.0;\n        flm +=  _in_ptr[63] * 4.0;\n        for (k = 0; k < 64; k++) {\n          tmp += force_in_row[k * 256L] * flm;\n        }\n        j_row = j_col_row;\n        out_off = 0 + j_row * 64L;\n        _out_ptr =  out_off +  _out_row_ptr;\n        _out_ptr[0] = tmp;\n      }\n      for (k = 0; k < 64; k++) {\n        force_in_row[k] = force_in_row[k + 64] + force_in_row[k + 128] + force_in_row[k + 192];\n      }\n      j_row = i * 256L;\n      out_off = 0 + j_row * 64L;\n      _out_ptr =  out_off +  _out_row_ptr;\n      for (k = 0; k < 64; k++) {\n        _out_ptr[k] = force_in_row[k];\n      }\n    }\n}\n"}}
{"input": "To accelerate the 'kernel_jacobi_1d' function, use the following comprehensive but very concise natural language instruction:\n\n\"Automatically pipeline the loop, break it into smaller chunks, and run iterations in parallel with specific factors.\"\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L10}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L11}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L12}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L13}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L14}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L15}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L16}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L17}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L18}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L19}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L20}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L21}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L22}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L23}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L24}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L25}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L26}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L27}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L28}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L29}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L30}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L31}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L32}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L33}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L34}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L35}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L36}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L37}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L38}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L39}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L40}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L41}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L42}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L43}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L44}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L45}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L46}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L47}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L48}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L49}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L50}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L51}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L52}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L53}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L54}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L55}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L56}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L57}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L58}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L59}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L60}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L61}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L62}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L63}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L64}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L65}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L66}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L67}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L68}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L69}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L70}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L71}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L72}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L73}\n  \n#pragma", "1": "  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 30; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 120; i++) {\n      b[i] = 0.0;\n      si = i - 1;\n      sj = i;\n      sk = i + 1;\n      b[i] = a[i] + a[si] + a[sj] + a[sk] + a[sj - 1] + a[sk - 1] + a[sk + 1];\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 120; i++) {\n      a[i] = 0.33333 * b[i];\n    }\n  }\n}\n", "2": "  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 30; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 120; i++) {\n      b[i] = 0.0;\n      si = i - 1;\n      bi = i;\n      bp = i + 1;\n      sum = a[si] + a[bi] + a[bp];\n      b[i] = 0.333333333333333333333333333 * sum;\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 120; i++) {\n      a[i] = b[i];\n    }\n  }\n}\n", "3": "  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 30; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 120; i++) {\n      b[i] = 0.0;\n      si = s[i] ;\n      b[i] = b[i] + a[i] * si;\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i <= 120; i++) {\n      _in_ = a[i];\n      _i_ = i;\n      _j_ = seidel_L2[0][_i_];\n      b[_j_] = b[_j_] + _in_ * gi;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (i = 1; i <= 120; i++) {\n      _in_ = b[i];\n      _i_ = i;\n      _j_ = seidel_L1[0][_i_];\n      a[_j_] = a[_j_] + _in_ * gj;\n    }\n  }\n}\n", "4": "  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 30; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i <= 120; i++) {\n      b[i] = 0.0;\n      si = i - 1;\n      sj = i - 1;\n      double _in_val = A[i];\n      b[si] = b[si] + 1.0 * _in_val;\n      b[sj] = b[sj] + 1.0 * _in_val;\n      b[si + 1] = b[si + 1] + 2.0 * _in_val;\n      b[sj + 1] = b[sj + 1] + 2.0 * _in_val;\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i <= 120; i++) {\n      tmp = b[i];\n      A[i] = 0.25 * (b[i - 1] - 2.0 * tmp + b[i + 1]);\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes in C, you should use the following concise natural language instructions for the specific #pragma values:\n\n1. \"Process this loop in its original, full form without breaking it into smaller chunks and don't automatically pipeline it\" to describe `#pragma ACCEL PIPELINE off`\n2. \"Break this loop into smaller chunks of the same size for optimization\" to describe `#pragma ACCEL TILE FACTOR=1`\n3. \"Run the iterations of this loop in parallel with a factor of 2\" to describe `#pragma ACCEL PARALLEL FACTOR=2`\n4. \"Treat the following function as a hardware kernel for acceleration\" to describe `#pragma ACCEL kernel`\n\nBy using these natural language instructions, you can generate the HLS codes written in C as provided.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 119; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 119; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": "\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2_0}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[j];\n    }\n    \n#pragma ACCEL PIPELINE auto{off_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1_1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2_1}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2_1_0}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1_2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2_2}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2_2_0}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1_3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2_3}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2_3_0}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "4": " \n#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To generate the provided HLS codes in C, use the following natural language instructions for specific #pragma values:\n\nEnsure this function is treated as a hardware kernel for acceleration:\n```c\n#pragma ACCEL kernel\n```\n\nDon't automatically pipeline the outermost loop:\n```c\n#pragma ACCEL PIPELINE \"off\"\n```\n\nProcess the loops in their original, full form without breaking them into smaller chunks:\n```c\n#pragma ACCEL TILE FACTOR=1\n```\n\nRun the iterations of the inner loop one after the other, not in parallel:\n```c\n#pragma ACCEL PARALLEL FACTOR=1\n```", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{}\n      \n#pragma ACCEL TILE FACTOR=auto{4}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\nEnsure this function is treated as a hardware kernel for acceleratio...\n#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "1": "\n\nDo not pipeline the original outer loop:\n #pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L7}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L7}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L8}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L8}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L9}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L9}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L10}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L10}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L11}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L11}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L12}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L12}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L13}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L13}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L14}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L14}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L15}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L15}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L16}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L16}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L17}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L17}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L18}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L18}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L19}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L19}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L20}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L20}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L21}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L21}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L22}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L22}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L23}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L23}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L24}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L24}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L25}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L25}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L26}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L26}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L27}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L27}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L28}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L28}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L29}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L29}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L30}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L30}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L31}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L31}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L32}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L32}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L33}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L33}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L34}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L34}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L35}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L35}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L36}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L36}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L37}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L37}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L38}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L38}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L39}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L39}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L40}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L40}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L41}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L41}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L42}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L42}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L43}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L43}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L44}\n  \n#pragma ACCEL TILE", "2": "\n\nEnsure the following function is treated as a kernel, with an automatic pipeline and loop tile: \n  \n# ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n\nEnsure the following loop is not distributed further but executed in the CPU:\n```c\n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (j = 1; j < 120; j++) {\n      y[j] = y[j] + z[j];\n    }\n```\n\nEnsure the following loop is not distributed further but executed in the CPU:\n```c\n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n  for (i = 1; i < 40; i++) {\n      x[i] = x[i] + y[i];\n    }\n```\n\n", "4": "\n\nLower the target frequency to 1.20GHz:\n```c\n#pragma ACCEL PARAMS TRIPCOUNT=__PARAMS__TC\n\n #pragma ACCEL PARAMS FREQ=1.20\n\n```\n\n### Version 1\n \n#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n"}}
{"input": "### Instruction: \nOptimize the loop to run efficiently for hardware acceleration, and attempt automatic strategies for pipelining, tiling, and parallelization.\n\n### Pragma Values:\n- `#pragma ACCEL PIPELINE auto{off}`: Don't automatically pipeline this loop\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Process this loop in its original, full form without breaking it into smaller chunks\n- `#pragma ACCEL PARALLEL FACTOR=auto{2}`: Run the iterations of this loop in parallel with factor 2\n- `#pragma ACCEL PARALLEL FACTOR=auto{3}`: Run the inner loop iterations in parallel with factor 3\n- `#pragma ACCEL PARALLEL FACTOR=auto{12}`: Run the outer loop iterations in parallel with factor 12\n- `#pragma ACCEL kernel`: Treat the following function as a hardware kernel for acceleration", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n", "1": "\n\n", "2": "\n\n", "3": "\n\n", "4": "\n\n"}}
{"input": "Process the loops in their original, full form without breaking them into smaller chunks, and do not automatically pipeline the loops. Treat the function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{2}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": " Offload the kernel from the CPU.\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5_0}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[j];\n    }\n    \n#pragma ACCEL PIPELINE auto{off_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1_1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5_1}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5_1_0}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1_2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5_2}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5_2_0}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1_3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5_3}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5_3_0}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": " Offload the kernel from the CPU.\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": " Offload the function \"kernel_jacobi_2d\" from \"kernel_jacobi_2d.cpp\"\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[i - 1][j] + A[i - 1][j - 1] + A[i - 1][1 + j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[i - 1][j] + B[i - 1][j - 1] + B[i - 1][1 + j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": " Offload the kernel from the CPU and invoke it automatically on a GPU. Offload the kernel from the CPU and invoke it automatically on an FPGA.\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": " Offload the kernel from the CPU and invoke the kernel on a FPGA.  \n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "Process both loops in their original, full form without breaking them into smaller chunks; run the iterations of the loops in parallel with a factor of 2; pipeline both loops automatically.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL PIPELINE auto{}\n\n#pragma ACCEL TILE FACTOR=auto{2}\n\n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (j = 16; j < 96; j++) {\n     tmp = ((double )a[j]);\n     b[j] = 1.0 / tmp;\n     d[j] = b[j] * ((double )a[j] * x[j] - y[j]) + d[j - 16];\n     for (i = 16; i < 96; i++) {\n        tmp = b[i] * a[j];\n        e[i] = b[j] * a[i] + tmp * e[i];\n        d[i] = tmp * d[i] + b[j] * (x[j] - x[i]) + d[i];\n     }\n     d[j] = -d[j];\n     e[j] = -e[j];\n  }\n  double float_temp = 0.0;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 16; i++) {\n    float_temp = d[i];\n    y[i] = float_temp;\n    b[i] = e[i] * float_temp;\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 16; i++) {\n    y[i + 16] = b[i] + y[i + 16];\n  }\n}\n", "3": "\n #pragma ACCEL PIPELINE auto{off}\n\n#pragma ACCEL TILE FACTOR=auto{2}\n\n#pragma ACCEL PARALLEL FACTOR=auto{16}\n  for (j = 1; j < 13; j++) {\n     dy[0] = dy[1];\n     dy[1] = out[0] - ex[0];\n     for (i = 1; i < 120; i++) {\n        dy[i + 1] = dy[i] + (out[i + 1] - ex[i]);\n     }\n     dout = dy[119];\n     ex[0] = ex[1];\n     eout = ey[119];\n     ey[0] = 1.0 + dex * dout;\n     for (i = 1; i < 120; i++) {\n        ex[i] = ex[i + 1];\n        ey[i] = 1.0 / (1.0 + dex * dy[i]);\n     }\n     beta[j] = dout * eout;\n     tmp = 1.0;\n     y[0] = tmp;\n     for (i = 0; i < 120; i++) {\n        y[i] = tmp = y[i] - beta[j] * dy[i];\n     }\n     out[0] = y[0];\n     for (i = 0; i < 119; i++) {\n        out[i + 1] = y[i + 1] - beta[j] * dy[i + 1];\n     }\n  }\n}\n \nvoid kernel_jacobi_1(int tsteps,int n,double A[120][120],double B[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n  for (t = 0; t < 40; t++) {\n     \r\n#pragma ACCEL PIPELINE auto{__PIPE__L2}\r\n     \r\n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\r\n     \r\n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 120 - 1; i++) {\n       \r\n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 120 - 1; j++) {\n        B[i][j] = 0.2 * (A[i][j] - (A[i][j - 1] + A[i][1 + j] + A[i - 1][j] + A[1 + i][j]));\n      }\n    }\n     \r\n#pragma ACCEL PIPELINE auto{__PIPE__L3}\r\n     \r\n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\r\n     \r\n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 1; i < 120 - 1; i++) {\n       \r\n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 120 - 1; j++) {\n        A[i][j] = 0.2 * (B[i][j] - (B[i][j - 1] + B[i][1 + j] + B[i - 1][j] + B[1 + i][j]));\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double a;\n  double mu;\n  double la;\n  double bpp;\n  double bqq;\n  double bpq;\n  double expt;\n  \n#pragma ACCEL PIPELINE auto{off}\n  DX = 1.0;\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n  DY = 1.0;\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  DT = 1.0;\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n  B1 = 2.0;\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n  B2 = 1.0;\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n  a = -(B1 + B2);\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n  mu = B1 - B2;\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L7}\n  la = B2;\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L8}\n  bpp = 2.0 * DT * DX * DX;\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L9}\n  bqq = 2.0 * DT * DY * DY;\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L10}\n  bpq = 2.0 * DT * DX * DY;\n  \n//Column Sweep\n  for (t = 1; t <= 40; t++) {\n// Row Sweep\n    for (i = 1; i < 58; i++) {\n      expt = exp(-la * DT);\n      v[0][i] = ((B2 * u[0][i]) + ((1.0 - B1 - B2) * u[1][i]) + (B1 * u[2][i]));\n      p[i][0] = 0.0;\n      q[i][0] = ((v[0][i] - u[0][i]) / DX);\n      q[i][0] -= ((p[i][1] - p[i][0]) / DY);\n      q[i][0] = ((q[i][0]) * expt);\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L11}\n      \n#pragma ACCEL PARALLEL reduction=v FACTOR=auto{__PARA__L1}\n      for (j = 1; j < 58; j++) {\n        v[i][j] = ((B2 * u[i][j]) + ((1.0 - B1 - B2) * u[i][j] + u[i][j - 1]) + (B1 * u[i][j + 1])) - ((DX * DX) * p[i][j] + (DY * DY) * q[i][j] + 2.0 * DX * DY * p[i][j + 1] * q[i][j]);\n        p[i][j] =  - ((DX * DX) * inv_sqr_DX) * (a * p[i][j] + bpp * v[i][j]) + ((1.0 - 2.0 * a) * p[i][j] + (1.0 + 4.0 * bpp) * v[i][j] - expt * p[i][j + 1]));\n        q[i][j] =  - ((DY * DY) * inv_sqr_DY) * (a * q[i][j] + bqq * v[i][j]) + ((1.0 - 2.0 * a) * q[i][j] + (1.0 + 4.0 * bqq) * v[i][j] - expt * q[i][j + 1]) - DX * (p[i][j + 1] - p[i][j]) / DY;\n      }\n    }\n// Row Sweep\n    for (i = 57; 0 < i; i--) {\n      expt = exp(-la * DT);\n      u[0][i] = v[i][0];\n      q[i][0] = 0.0;\n      p[i][0] = ((v[i][0] - u[i][0]) / DY) - (DX * DX * p[i][1] / DY) + ((1.0 - 2.0 * a) * p[i][0] + (1.0 + 4.0 * bpp) * v[i][0] - expt * p[i][1]);\n      p[i][0] /= (- 2.0 * a * DX * DX);\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L12}\n      \n#pragma ACCEL PARALLEL reduction=u FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 58; j++) {\n        u[i][j] = v[i][j] - DX * (p[i][j] - p[i][j - 1]) / DX - DY * (q[i][j] - q[i][j - 1]) / DY;\n        q[i][j] =  - ((DX * DX) * inv_sqr_DX) * (a * q[i][j] + bqq * u[i][j]) + ((1.0 - 2.0 * a) * q[i][j] + (1.0 + 4.0 * bqq) * u[i][j] - expt * q[i][j + 1]) - (DY * DY) * p[i][j] / DX;\n      }\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes, follow these concise natural language instructions:\n- Optimize the loop using automatic pipelining.\n- Split the loop into smaller chunks with a factor of 1.\n- Parallelize the loop with a factor of 2.\n- Further parallelize the inner loop with a factor of 4.\n- Further parallelize the loop with a factor of 8.\n\nThis will result in the same HLS codes in C using #pragma directives.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L8}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 119; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 119; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L8}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{4}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{16}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To generate the given HLS codes in C:\n\n1. Treat the following function as a hardware kernel for acceleration.\n2. Don't automatically pipeline this loop.\n3. Process this loop in its original, full form without breaking it into smaller chunks.\n4. Run the iterations of this loop one after the other, not in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n5. Automatically parallelize this loop with 255 tiles\n \n#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[410][390],double s[390],double q[410],double p[390],double r[410])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PARALLEL FACTOR=auto{255}\n  for (i = 0; i < 390; i++) {\n    s[i] = ((double )0);\n    q[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{255}\n  for (i = 0; i < 410; i++) {\n    q[0] += r[i] * A[i][0];\n    s[0] += r[i] * A[i][0];\n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 1; j < 390; j++) {\n      q[j] += r[i] * A[i][j];\n      s[j] += A[i][j] * p[j];\n    }\n  }\n}\n", "1": "\n5. Automatically parallelize this loop with a factor of 128\n \n#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[410][390],double s[390],double q[410],double p[390],double r[410])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PARALLEL FACTOR=auto{128}\n  for (i = 0; i < 390; i++) {\n    s[i] = ((double )0);\n    q[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 410; i++) {\n    q[0] += r[i] * A[i][0];\n    s[0] += r[i] * A[i][0];\n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 1; j < 390; j++) {\n      q[j] += r[i] * A[i][j];\n      s[j] += A[i][j] * p[j];\n    }\n  }\n}\n", "2": "\n5. Automatically pipeline this loop.\n6. This loop is scheduled with auto{1}\n \n#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "3": "\n5. Automatically scale the break trip counts of for loop #2.\n  \n#pragma ACCEL kernel\n\nvoid kernel_gesummv(double alpha,double beta,double A[250][250],double B[250][250],double tmp[250],double x[250],double y[250])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 250; i++) {\n    tmp[i] = 0.0;\n    y[i] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 250; j++) {\n      tmp[i] += A[i][j] * x[j];\n      y[i] += B[i][j] * x[j];\n    }\n    y[i] = alpha * tmp[i] + beta * y[i];\n  }\n}\n", "4": "\n5. Automatically detect the loops that can be parallelized.\n6. Enable array operations fusion. \n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To generate the given HLS codes in C, follow the natural language instruction:\n\n\"For the function `kernel_doitgen`, mark it as a hardware kernel for acceleration by treating it as such.\"\nUse the following #pragma values:\n1. `#pragma ACCEL kernel` - Treat the following function as a hardware kernel for acceleration.\n\nThis will correctly generate the provided HLS codes in C.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{8}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n", "1": "\n", "2": "\n", "3": "\n\n#pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        double sum_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=sum_tmp FACTOR=auto{__PARA__L3}\n\tfor (s = 0; s < 30; s++) {\n          sum_tmp += A[r][q][s] * C4[s][p];\n        }\n\tsum[p] = sum_tmp;\n\tdouble A_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=A_tmp FACTOR=auto{__PARA__L4}\n\tfor (s = 0; s < 30; s++) {\n          A_tmp += A[r][q][s] * sum[s];\n        }\n\tA[r][q][0] = A_tmp;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double B[25][30],double D[20][30],double E[25][20])\n{\n  int r;\n  int q;\n  int p;\n  int a;\n  int b;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PARALLEL reduction=A FACTOR=auto{__PARA__L3}\n      for (a = 0; a < 30; a++) {\n        A[r][q][a] = ((double )0);\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PARALLEL reduction=B FACTOR=auto{__PARA__L5}\n      for (a = 0; a < 30; a++) {\n        B[r][a] += D[q][a] * E[r][q];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PARALLEL reduction=C4 FACTOR=auto{__PARA__L7}\n      for (a = 0; a < 30; a++) {\n        C4[a] += A[r][q][a] * B[r][a];\n      }\n    }\n  }\n}\n"}}
{"input": "Optimize nested loops for FPGA acceleration by automatically parallelizing and pipelining the outer and inner loops. Use the specified array reduction factor for parallelism. Apply tiling to the loops with a factor of 1 to maintain the original loop structure. Treat the \"kernel_big\" function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_3mm(double A[25][20][30],double B[25][30][40],double C[20][30][40],double D[25][30][50],double E[25][40][50])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (i = 0; i < 25; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    for (j = 0; j < 30; j++) {\n      for (k = 0; k < 40; k++) {\n        A[i][j][k] = 0.0;\n        for (int n = 0; n < 20; n++) {\n          A[i][j][k] += B[i][n][k] * C[n][j][k];\n        }\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n  for (i = 0; i < 25; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    for (j = 0; j < 30; j++) {\n      for (k = 0; k < 50; k++) {\n        E[i][j][k] = 0.0;\n        for (int n = 0; n < 40; n++) {\n          E[i][j][k] += A[i][j][n] * D[i][n][k];\n        }\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_big(int tsteps,int n,double u[60][60],double v[60][60],double w[60][60],double x[60][60],double y[60][60],double z[60][60])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 1; j < 59; j++) {\n        u[i][j] = 1.0 / ((1.0 + ((double )(i * j))) * (1.0 + ((double )(i * j))));\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 1; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 1; j < 59; j++) {\n        v[i][j] = 1.0 / ((1.0 + ((double )(i * j))) * (1.0 + ((double )(i * j))));\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 1; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 1; j < 59; j++) {\n        w[i][j] = 1.0 / ((1.0 + ((double )(i * j))) * (1.0 + ((double )(i * j))));\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L8}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n    for (i = 1; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n      for (j = 1; j < 59; j++) {\n        x[i][j] = ((double )(i * j)) / ((((double )(1 + i)) * (1.0 + ((double )(i * j)))));\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L10}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L10}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L10}\n    for (i = 1; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L11}\n      for (j = 1; j < 59; j++) {\n        y[i][j] = ((double )(i * j)) / ((((double )(1 + j)) * (1.0 + ((double )(i * j)))));\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L12}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L12}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L12}\n    for (i = 1; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L13}\n      for (j = 1; j < 59; j++) {\n        z[i][j] = ((double )(4.0 - (i * (j + 1.0)))) / ((((double )(1 + i)) * (1.0 + ((double )(i * j)))));\n      }\n    }\n  }\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_3mm(double m1[4096],double m2[4096],double m3[4096],double prod[32768])\n{\n  double mult1;\n  double mult2;\n  double PIPEL_m3[4096];\n  double PIPEL_prod[4096];\n  double PIPEL_m1[32];\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (int i = 0; i < 64; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    for (int j = 0; j < 64; j++) {\n      PIPEL_m1[j] = m1[i + j * 64];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    for (int k = 0; k < 32; k++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n      for (int j = 0; j < 64; j++) {\n        PIPEL_m3[j + 64 * k] = m3[i + j * 64] * PIPEL_m1[j];\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n    for (int k = 0; k < 32; k++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n      for (int j = 0; j < 64; j++) {\n        mult1 = PIPEL_m1[j + 0] * PIPEL_m2[j + 64 * k];\n        mult2 = PIPEL_m1[j + 1] * PIPEL_m2[j + 64 * k + 1];\n        for (int i = 0; i < 16; i++) {\n          prod[i + 64L * k + 64L * j + 4096L * i] = mult1 + mult2 * ((double )(long )0);\n        }\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L7}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L7}\n  for (int i = 0; i < 64; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L8}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L8}\n    for (int k = 0; k < 32; k++) {\n      PIPEL_prod[k] = PIPEL_prod[k] + PIPEL_m3[i + 64L * k];\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L9}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L9}\n  for (int i = 0; i < 64; i++) {\n    for (int k = 0; k < 32; k++) {\n      prod[i + 64L * k] = PIPEL_prod[k];\n    }\n  }\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_big(int tsteps,int n,double u[60][80],double v[60][80],double w[60][80],double x[60][80],double y[60][80],double z[60][80])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 0; i <= 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 0; j <= 79;j++) {\n        v[i][j] = u[i][j] - 0.5 * (x[i][j] - ((u[i][j] * y[i][j]) / z[i][j]));\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i <= 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j <= 79;j++) {\n        w[i][j] = v[i][j] - 0.5 * (y[i][j] - ((v[i][j] * x[i][j]) / z[i][j])) - 1.0 / (240.0) * (6.0 * u[i][j] - 8.0 * u[i][j - 1] - 8.0 * u[i][1 + j] - u[i][j + 1] + 5.0 * v[i][j - 1] - 5.0 * v[i][1 + j] + v[i][j + 1] - 1.0 / (sqrt(6.28)) * (sin(z[i][j]) - sin(z[i][j - 1])));\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i <= 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j <= 79;j++) {\n        x[i][j] = w[i][j] - 0.5 * (v[i][j] - 1.0 / (240.0) * (6.0 * w[i][j] - 8.0 * w[i][j - 1] - 8.0 * w[i][1 + j] - w[i][j + 1] + 5.0 * u[i][j] - 5.0 * u[i][j - 1] + u[i][j + 1] - 1.0 / (sqrt(6.28)) * (cos(z[i][j]) - cos(z[i][j - 1]))));\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L8}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n    for (i = 0; i <= 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n      for (j = 0; j <= 79;j++) {\n        y[i][j] = x[i][j] - 0.5 * (u[i][j] - 1.0 / (240.0) * (6.0 * x[i][j] - 8.0 * x[i][j - 1] - 8.0 * x[i][1 + j] - x[i][j + 1] + 5.0 * w[i][j] - 5.0 * w[i][j - 1] + w[i][j + 1] - 1.0 / (sqrt(6.28)) * (sin(z[i][j]) - sin(z[i][j - 1]))));\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L10}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L10}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L10}\n    for (i = 0; i <= 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L11}\n      for (j = 0; j <= 79;j++) {\n        z[i][j] = y[i][j] - (1.0 / 720.0) * (x[i][j] - 2.0 * y[i][j] + x[i][j - 1] + x[i][1 + j] - 2.0 * y[i][j - 1] + y[i][1 + j] - x[i - 1][j] - 2.0 * x[i - 1][j] + x[i - 1][j - 1] - 2.0 * y[i - 1][j - 1] + y[i - 1][j - 1] - x[i - 1][j + 1] - 2.0 * y[i - 1][j + 1] + y[i - 1][j + 1] - x[i + 1][j] - 2.0 * x[i + 1][j] + x[i + 1][j - 1] - 2.0 * y[i + 1][j - 1] + y[i + 1][j - 1] - x[i + 1][j + 1] - 2.0 * y[i + 1][j + 1] + y[i + 1][j + 1]);\n      }\n    }\n  }\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_big(int tsteps,int n,double u[60][60],double v[60][60],double w[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n\n  \n#pragma ACCEL PIPELINE auto{off}\n\n/* DX = 1.0/(60.0) */\n  DX = 1.0 / ((double )60);\n/* DY = 1.0/(60.0) */\n  DY = 1.0 / ((double )60);\n/* DT = 1.0/(40.0) */\n  DT = 1.0 / ((double )40);\n/* B1 = 2.0*D*DY*DY */\n  B1 = ((double )2) * DY * DY * DX * DX;\n/* B2 = 2.0*D*DX*DX */\n  B2 = ((double )2) * DX * DX * DY * DY;\n/* A = -D*D*DY*DY - 1.0 */\n  a = (-DX * DX * DY * DY - 1.0);\n/* C = -D*D*DX*DX - 1.0 */\n  c = (-DX * DX * DY * DY - 1.0);\n/* E = 2.0*D*DY*DY */\n  e = ((double )2) * DY * DY * DX;\n/* F = 2.0*D*DX*DX */\n  f = ((double )2) * DX * DX * DY;\n/* B0 = B1 + B2 */\n  b = B1 + B2;\n/* mul1 = A*B0 */\n  mul1 = a * b;\n/* mul2 = F*B1 - C*B2 */\n  mul2 = f * B1 - c * B2;\n/* P = u*/\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n/* Q = V - DT*(B1*Ux - B2*Uy) */\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 1; j < 59; j++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (i = 1; i < 59; i++) {\n        q[j][i] = v[j][i] - DT * (B1 * (u[j][i] - u[j][i - 1]) - B2 * (u[j][i] - u[j - 1][i]));\n      }\n    }\n/* U = P + DT*( 1/2*(- 4*P + 3*Q + 2*R) - D*D*Ux - (D*D/2)*Uy ) */\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (j = 1; j < 59; j++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (i = 1; i < 59; i++) {\n        u[j][i] = p[j][i] + DT * (mul1 * ( - ((4 * p[j][i]) + (3 * q[j][i]) + (2 * r[j][i])) - (u[j][i] * B1) - (0.5 * u[j][i] * b * DY)) + mul2 * ( - (u[j][i] * B2) - (0.5 * u[j][i] * b * DX)));\n      }\n    }\n/* R = W - DT*( D*D*Ux - 1.0*Uy ) */\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (j = 1; j < 59; j++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (i = 1; i < 59; i++) {\n        r[j][i] = w[j][i] - DT * (a * (u[j][i] - u[j][i - 1]) - b * (u[j][i] - u[j - 1][i]));\n      }\n    }\n/* V = W + DT*(1/2*(4*R - 3*P + 1*Q) - D*D*Uy - (D*D/2)*Ux ) */\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (j = 1; j < 59; j++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (i = 1; i < 59; i++) {\n        v[j][i] = w[j][i] + DT * (mul1 * ( - (4 * r[j][i]) + (3 * p[j][i]) + (1 * q[j][i]) - (u[j][i] * B1) - (0.5 * u[j][i] * a * DY)) + mul2 * ( - (u[j][i] * B2) - (0.5 * u[j][i] * a * DX)));\n      }\n    }\n  }\n}\n"}}
{"input": "To generate the given C code with HLS pragma directives::\n1. Mark the function as a hardware kernel for acceleration: Use `#pragma ACCEL kernel` before the function definition.\n2. Turn off automatic pipeline for the outer loop: Use `#pragma ACCEL PIPELINE auto{off}` before the outer loop.\n3. Set the tile factor to 1 for the outer loop: Use `#pragma ACCEL TILE FACTOR=auto{1}` before the outer loop.\n4. Turn off automatic pipeline for the inner loops: Use `#pragma ACCEL PIPELINE auto{off}` before the inner loops.\n5. Set the tile factor to 1 for the inner loops: Use `#pragma ACCEL TILE FACTOR=auto{1}` before the inner loops.\n\nThese directives will configure the hardware design for the given C code and control the pipelining and tiling behavior for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n\n#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction=D FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction=D FACTOR=auto{25}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (j = 0; j < 70; j++) {\n      for (k = 0; k < 80; k++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "4": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        double  _tmp_2 = 0.0;\n        double  _tmp_3 = 0.0;\n        double  _tmp_4 = 0.0;\n        double  _tmp_5 = 0.0;\n        double  _tmp_6 = 0.0;\n        double  _tmp_7 = 0.0;\n        double  _tmp_8 = 0.0;\n        double  _tmp_9 = 0.0;\n        double  _tmp_10 = 0.0;\n        double  _tmp_11 = 0.0;\n\t_tmp_2 = ex[i][j + 1] - ex[i][j];\n\t_tmp_3 = ey[i + 1][j] - ey[i][j];\n\t_tmp_4 = hz[i + 1][j] - hz[i][j];\n\t_tmp_5 = ex[i + 1][j + 1] - ex[i + 1][j];\n\t_tmp_6 = ey[i + 1][j + 1] - ey[i + 1][j];\n\t_tmp_7 = hz[i + 1][j + 1] - hz[i + 1][j];\n\t_tmp_8 = ex[i][j] - ex[i + 1][j + 1];\n\t_tmp_9 = ey[i][j] - ey[i + 1][j + 1];\n\t_tmp_10 = hz[i][j] - hz[i + 1][j + 1];\n\t_tmp_11 = _tmp_2 * _tmp_4 + _tmp_3 * _tmp_5 + _tmp_6 * _tmp_10;\n\thz[i][j] = _tmp_11;\n\tez[i][j] = _tmp_11 - _tmp_8 / (1.0 + _tmp_10):_ez;\n\t_fict_[i][j] = _tmp_11;\n      }\n    }\n  }\n}\n"}}
{"input": "Process the `doitgen` function as a hardware kernel for acceleration. \nFor the outer loop with loop variable `r`, do not automatically pipeline and process in its original, full form without breaking it into smaller chunks. For the inner loop with loop variable `q`, automatically pipeline and process in smaller chunks with factor of 8. And for the innermost loop with loop variable `p`, automatically pipeline with flattening and process in its original form without breaking it into smaller chunks.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{8}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "1": "\n \n#pragma ACCEL kernel\n\nvoid kernel_gemm(double m1[4096],double m2[4096],double prod[4096])\n{\n  int i;\n  int j;\n  int k;\n  int k_col;\n  int i_col;\n  double mult;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  outer:\n  for (i = 0; i < 64; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    middle:\n    for (j = 0; j < 64; j++) {\n      i_col = i * 64;\n      double sum = (double )0;\n      \n#pragma ACCEL PARALLEL reduction=sum FACTOR=auto{1}\n      inner:\n      for (k = 0; k < 64; k++) {\n        k_col = k * 64;\n        mult = m1[i_col + k] * m2[k_col + j];\n        sum += mult;\n      }\n      prod[i_col + j] = sum;\n    }\n  }\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[200][240][30],double C4[30][30],double B[200][30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 200; r++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{8}\n    for (q = 0; q < 240; q++) {\n      A[r][q][0] = 1.0;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 200; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    for (p = 0; p < 30; p++) {\n      B[r][p] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=B FACTOR=auto{1}\n      for (s = 0; s < 30; s++) {\n        B[r][p] += C4[p][s] * A[r][s][0];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (p = 0; p < 30; p++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n    for (r = 0; r < 200; r++) {\n      double sum = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=sum FACTOR=auto{1}\n      for (q = 0; q < 240; q++) {\n        sum += A[r][q][0] * B[q][p];\n      }\n      A[r][0][p] = sum;\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n \n#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 30; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = (double )0;\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 1; j < 89; j++) {\n        for (r = 0; r < 90; r++) {\n          A[i][j] += A[i][r] * kernel[r][j];\n        }\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n \n#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i <= 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 1; j <= 89; j++) {\n        A[i][j] = (double )0;\n        for (q = 1; q <= 9; q++) {\n          A[i][j] += _in_[(i + ((q - 1) * 1))][j] * _out[q];\n        }\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n    for (i = 1; i <= 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j <= 89; j++) {\n        _in_[i][j] = A[i][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "Process this loop in its original, full form without breaking it into smaller chunks: #pragma ACCEL TILE FACTOR=1\n\nRun the iterations of this loop one after the other, not in parallel: #pragma ACCEL PARALLEL FACTOR=1\n\nDon't automatically pipeline this loop: #pragma ACCEL PIPELINE \"off\"\n\nTreat the following function as a hardware kernel for acceleration: #pragma ACCEL kernel", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 240;\n        int _in_i = 200;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": "\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n\n#pragma ACCEL PARAMETER MAX_DIM=auto\n#pragma ACCEL PARAMETER M=128\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        double  delx =  (double )(ex[i + 1][j + 1] - ex[i][j + 1]);\n        double  dely =  (double )(ey[i + 1][j + 1] - ey[i][j + 1]);\n        double  delz =  (double )(hz[i + 1][j + 1] - hz[i][j + 1]);\n        double  icoef =  - 1.0 / 3.0;\n        double  x1 = delx + icoef * (dely * (hz[i + 1][j + 1] - hz[i + 1][j]) - delz * (ey[i + 1][j + 1] - ey[i + 1][j]));\n        double  y1 = dely + icoef * (delz * (ex[i + 1][j + 1] - ex[i][j + 1]) - delx * (hz[i + 1][j + 1] - hz[i][j + 1]));\n        double  x2 = icoef * (dely * (hz[i][j + 1] - hz[i][j]) - delz * (ey[i][j + 1] - ey[i][j]));\n        double  y2 = icoef * (delz * (ex[i][j + 1] - ex[i][j]) - delx * (hz[i][j + 1] - hz[i][j]));\n        double  jac = 0.5 * (delx * (dely + x2) + dely * (delz + y2) + delz * (delx + x1));\n        \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n\tfor (v = 0; v < 40; v++) {\n          hz[i][j] +=  (((double )(se[v] * (ex[i][j] - ex[i][j] + ey[i][j] - ey[i][j] + hz[i][j] - hz[i][j]))) / jac);\n        }\n      }\n    }\n  }\n}\n"}}
{"input": "Process the loop of the function 'kernel_jacobi_1d' in its original, full form without breaking it into smaller chunks. Automatically pipeline this loop. Run the iterations of this loop in parallel with a factor of 2. Then run the inner loop iterations of this loop in parallel with a factor of 8. Finally, run the inner loop iterations of this loop one after the other, not in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 30; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 30; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 30; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 30; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 30; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To generate the given HLS codes in C, use the following natural language instructions for the specific #pragma values:\n\n1. Don't automatically pipeline the loop: '#pragma ACCEL PIPELINE auto{off}'\n2. Process this loop in its original, full form without breaking it into smaller chunks: '#pragma ACCEL TILE FACTOR=auto{1}'\n3. Run the iterations of this loop one after the other, not in parallel: '#pragma ACCEL PARALLEL FACTOR=auto{2}'\n4. Treat the following function as a hardware kernel for acceleration: '#pragma ACCEL kernel'", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "1": "\n \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": "\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i - 1) + 1;\n        int j_col = 2L * (j - 1) + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_col][j_col + 1] - ex[i_col][j_col] + ey[i_col + 1][j_col] - ey[i_col][j_col]);\n      }\n    }\n  }\n}\n", "3": "\n\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n\t\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        double  _val_27 = 0.0;\n        double  _val_28 = 0.0;\n        double  _val_29 = 0.0;\n        double  _val_30 = 0.0;\n        double  _val_31 = 0.0;\n        double  _val_32 = 0.0;\n        double  _val_33 = 0.0;\n        double  _val_34 = 0.0;\n        double  _val_35 = 0.0;\n        double  _val_36 = 0.0;\n        double  _val_37 = 0.0;\n        double  _val_38 = 0.0;\n        double  _val_39 = 0.0;\n        double  _val_40 = 1.0;\n        _val_27 = ex[i][j] - ex[i][j + 1];\n        _val_28 = ey[i][j] - ey[i + 1][j];\n        _val_29 = hz[i][j] - hz[i + 1][j];\n        _val_30 = ex[i][j] - ex[i][j + 1];\n        _val_31 = ey[i][j] - ey[i + 1][j];\n        _val_32 = hz[i][j] - hz[i][j + 1];\n        _val_33 = _val_27 * _val_28 - _val_29 * _val_30;\n        _val_34 = _val_27 * _val_31 + _val_28 * _val_30;\n        _val_35 = _val_29 * _val_32 - _val_30 * _val_31;\n        _val_36 = sqrt(_val_33 * _val_33 + _val_34 * _val_34 + _val_35 * _val_35);\n        _val_37 = 2.0 * PI * _val_36;\n        _val_38 = _val_37 / (2.0 * 10.0);\n        _val_39 = exp(-_val_38);\n        _fict_[t] = _fict_[t] + _val_39;\n        hz[i][j] = _val_36 + _val_40;\n        ey[i][j] = _val_28 + _val_38 * (_val_29 - _val_32);\n        ex[i][j] = _val_27 + _val_38 * (_val_31 - _val_33);\n      }\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes, use the following pragma values:\n\n1.  Treat the following function as a hardware kernel for acceleration.\n```c\n#pragma ACCEL kernel\n```\n\n2.  Don't automatically pipeline this loop.\n```c\n#pragma ACCEL PIPELINE \"off\"\n```\n\n3.  Process this loop in its original, full form without breaking it into smaller chunks.\n```c\n#pragma ACCEL TILE FACTOR=1\n```\n\n4.  Run the iterations of this loop one after the other, not in parallel.\n```c\n#pragma ACCEL PARALLEL FACTOR=1\n```", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{8}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n5.  Don't automatically distribute this loop.\n```c\n#pragma ACCEL DISTRIBUTE FACTOR=1\n  for (tfix=0;tfix<20;tfix++) {\n    a[0] = ((long )0);\n    b[0] =  ((long )1);\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (i=1; i<120; i++) {\n      a[i] =  a[i-1] +  b[i-1];\n      b[i] =  a[i] +  b[i];\n    }\n  }\n```\n\n", "1": "\n\n5.  Don't automatically distribute this loop on nodes or cores.\n```c\n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for(j = 1; j < 31; j++) {\n      y_0 = _in_0[0] + _in_2[0];\n      y_1 = _in_0[1] + _in_2[1];\n  \n      z_0 = _in_0[0] - _in_2[0];\n      z_1 = _in_0[1] - _in_2[1];\n  \n      _out_0[0] = y_0 + (sqrt(2.0) * z_1);\n      _out_0[1] = y_1 + (sqrt(2.0) * z_0);\n      _out_2[0] = y_0 - (sqrt(2.0) * z_1);\n      _out_2[1] = y_1 - (sqrt(2.0) * z_0);\n  \n      for(i = 1; i < 31; i++) {\n          y_0 = _in_0[2 * i] + _in_2[2 * i];\n          y_1 = _in_0[2 * i + 1] + _in_2[2 * i + 1];\n  \n          z_0 = _in_0[2 * i] - _in_2[2 * i];\n          z_1 = _in_0[2 * i + 1] - _in_2[2 * i + 1];\n  \n          _out_1[2 * i] = y_0 + (sqrt(2.0) * z_1);\n          _out_1[2 * i + 1] = y_1 + (sqrt(2.0) * z_0);\n          _out_3[2 * i] = y_0 - (sqrt(2.0) * z_1);\n          _out_3[2 * i + 1] = y_1 - (sqrt(2.0) * z_0);\n      }\n      _in_0 = _out_0;\n      _in_2 = _out_2;\n      _out_0 = _out_1;\n      _out_2 = _out_3;\n  }\n}\n```\n", "2": "\n\n5.  Specify that the following function must be implemented in a data-flow pipeline.\n    \n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        double  delta = 1.0 / (1.0 + exp(  - (double )(j - 100) / 20.0 ));\n        hz[i][j] = delta * (4.0 * hz[i][j] - hz[i][j + 1] - hz[i + 1][j] + hz[i + 1][j + 1]);\n      }\n    }\n  }\n}\n", "3": "\n\n5.  This loop has the dynamic loop trip count of: trips = 160\n```c\n   for(i = 1;i < 120;i++) {\n      b[i] = 2.0*b[i];\n    }\n```\n\n6.  This loop has the dynamic loop trip count of: trips = 40\n```c\n   for(i = 1;i < 60;i++) {\n      a[i] = 2.0*a[i];\n    }\n```\n\n7.  This loop has the dynamic loop trip count of: trips = 1\n      A = 1\n      B = 2\n      1 {\n      2   d = 1.0;\n      3   e = 2.0;\n      4   f = 4.0;\n      5   float f1 = 0.5;\n      6   float f2 = 1.0;\n      7   float f3 = 4.0;\n      8   float f4 = 8.0;\n      9   float f5 = 16.0;\n     10   float s1 = a[1] * b[1] * f1;\n     11   d = s1 + d;\n     12   s2 = a[1] * b[2] * f2;\n     13   e = s2 + e;\n     14   s3 = a[1] * b[3] * f3;\n     15   f = s3 + f;\n     16   s4 = a[2] * b[1] * f1;\n     17   d = s4 + d;\n     18   s5 = a[2] * b[2] * f2;\n     19   e = s5 + e;\n     20   s6 = a[2] * b[3] * f3;\n     21   f = s6 + f;\n     22   s7 = a[3] * b[1] * f1;\n     23   d = s7 + d;\n     24   s8 = a[3] * b[2] * f2;\n     25   e = s8 + e;\n     26   s9 = a[3] * b[3] * f3;\n     27   f = s9 + f;\n     28   s10 = a[4] * b[1] * f4;\n     29   d = s10 + d;\n     30   s11 = a[4] * b[2] * f4;\n     31   e = s11 + e;\n     32   s12 = a[4] * b[3] * f4;\n     33   f = s12 + f;\n     34   s13 = a[5] * b[1] * f4;\n     35   d = s13 + d;\n     36   s14 = a[5] * b[2] * f4;\n     37   e = s14 + e;\n     38   s15 = a[5] * b[3] * f4;\n     39   f = s15 + f;\n     40   s16 = a[6] * b[1] * f4;\n     41   d = s16 + d;\n     42   s17 = a[6] * b[2] * f4;\n     43   e = s17 + e;\n     44   s18 = a[6] * b[3] * f4;\n     45   f = s18 + f;\n     46   s19 = a[7] * b[1] * f4;\n     47   d = s19 + d;\n     48   s20 = a[7] * b[2] * f4;\n     49   e = s20 + e;\n     50   s21 = a[7] * b[3] * f4;\n     51   f = s21 + f;\n     52   s22 = a[8] * b[1] * f4;\n     53   d = s22 + d;\n     54   s23 = a[8] * b[2] * f4;\n     55   e = s23 + e;\n     56   s24 = a[8] * b[3] * f4;\n     57   f = s24 + f;\n     58   s25 = a[9] * b[1] * f4;\n     59   d = s25 + d;\n     60   s26 = a[9] * b[2] * f4;\n     61   e = s26 + e;\n     62   s27 = a[9] * b[3] * f4;\n     63   f = s27 + f;\n     64   s28 = a[10] * b[1] * f4;\n     65   d = s28 + d;\n     66   s29 = a[10] * b[2] * f4;\n     67   e = s29 + e;\n     68   s30 = a[10] * b[3] * f4;\n     69   f = s30 + f;\n     70   s31 = a[11] * b[1] * f4;\n     71   d = s31 + d;\n     72   s32 = a[11] * b[2] * f4;\n     73   e = s32 + e;\n     74   s33 = a[11] * b[3] * f4;\n     75   f = s33 + f;\n     76   s34 = a[12] * b[1] * f4;\n     77   d = s34 + d;\n     78   s35 = a[12] * b[2] * f4;\n     79   e = s35 + e;\n     80   s36 = a[12] * b[3] * f4;\n     81   f = s36 + f;\n     82   s37 = a[13] * b[1] * f4;\n     83   d = s37 + d;\n     84   s38 = a[13] * b[2] * f4;\n     85   e = s38 + e;\n     86   s39 = a[13] * b[3] * f4;\n     87   f = s39 + f;\n     88   s40 = a[14] * b[1] * f4;\n     89   d = s40 + d;\n     90   s41 = a[14] * b[2] * f4;\n     91   e = s41 + e;\n     92   s42 = a[14] * b[3] * f4;\n     93   f = s42 + f;\n     94   s43 = a[15] * b[1] * f4;\n     95   d = s43 + d;\n     96   s44 = a[15] * b[2] * f4;\n     97   e = s44 + e;\n     98   s45 = a[15] * b[3] * f4;\n     99   f = s45 + f;\n    100   s46 = a[16] * b[1] * f4;\n    101   d = s46 + d;\n    102   s47 = a[16] * b[2] * f4;\n    103   e = s47 + e;\n    104   s48 = a[16] * b[3] * f4;\n    105   f = s48 + f;\n    106   s49 = a[17] * b[1] * f4;\n    107   d = s49 + d;\n    108   s50 = a[17] * b[2] * f4;\n    109   e = s50 + e;\n    110   s51 = a[17] * b[3", "4": "\n\n5.  Don't automatically distribute this loop, i.e., don't automatically partition the original problem into smaller regions to be handled by each of the compute nodes.\n```c\n#pragma ACCEL DISTRIBUTE FACTOR=1\n  for (t = 0; t < 40; t++) {\n    dt = (t * 5.0) / 4.0;\n    dpc = 1.0 / (pow(2.0,dt));\n    mul1 = dpc * dpc;\n    mul2 = mul1 * dpc;\n    expt1 = 2.0 * M_PI * mul1;\n    expt2 = 2.0 * M_PI * mul2;\n    clear = 0.0;\n    qclean = 0.0;\n    qg = 0.0;\n    qle = 0.0;\n    qne = 0.0;\n    \n#pragma ACCEL PIPELINE auto{off}\n    for (j = 0; j < 120; j++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      for (i = 0; i < 120; i++) {\n        temp = _in[i * 120 + j];\n        ix = dpc * (i - 60.0);\n        iy = dpc * (j - 60.0);\n        dist = sqrt(ix * ix + iy * iy);\n        e_dot_j = e[0] * ix + e[1] * iy;\n        e_cross_j_dot_j = e[0] * iy - e[1] * ix;\n        b_dot_j = b[0] * ix + b[1] * iy;\n        b_cross_j_dot_j = b[0] * iy - b[1] * ix;\n        leaky_req = mul1 * temp - dpc * (qlean[i * 120 + j] + qne[i * 120 + j] - qn[i * 120 + j]);\n        gain = mul2 * (qclean[i * 120 + j] - qle[i * 120 + j]);\n        dqclean_dqle = (qclean[i * 120 + j] * qle[i * 120 + j]) - 1.0;\n        dqne_dqn = (qne[i * 120 + j] * qn[i * 120 + j]) - 1.0;\n        dqne_dclean = qne[i * 120 + j] - qclean[i * 120 + j];\n        dqne_dle = qne[i * 120 + j] - qle[i * 120 + j];\n        dqn_dqne = (qn[i * 120 + j] * qne[i * 120 + j]) - 1.0;\n        dqn_dclean = qn[i * 120 + j] - qclean[i * 120 + j];\n        dqn_dle = qn[i * 120 + j] - qle[i * 120 + j];\n        dqle_dqne = qle[i * 120 + j] - qne[i * 120 + j];\n        dqle_dclean = qle[i * 120 + j] - qclean[i * 120 + j];\n        dqle_dqn = qle[i * 120 + j] - qn[i * 120 + j];\n        dqn_dqclean = qn[i * 120 + j] - qclean[i * 120 + j];\n        dqn_db = b_cross_j_dot_j * qn[i * 120 + j];\n        dqne_db = b_cross_j_dot_j * qne[i * 120 + j];\n        dqle_db = b_cross_j_dot_j * qle[i * 120 + j];\n        dqclean_dqle = qclean[i * 120 + j] * qle[i * 120 + j];\n        dqclean_db = b_dot_j * qclean[i * 120 + j];\n        dqne_dqclean = qne[i * 120 + j] * qclean[i * 120 + j];\n        dqne_db = (b_dot_j * qne[i * 120 + j] + b_cross_j_dot_j * qne[i * 120 + j]) - mul2 * dqne_dqn;\n        dqle_dqne = qle[i * 120 + j] * qne[i * 120 + j];\n        dqle_dqclean = qle[i * 120 + j] * qclean[i * 120 + j];\n        dqle_db = (b_dot_j * qle[i * 120 + j] + b_cross_j_dot_j * qle[i * 120 + j]) - mul2 * dqle_dqn;\n        dqn_db = (b_dot_j * qn[i * 120 + j] + b_cross_j_dot_j * qn[i * 120 + j]) - mul1 * dqn_dqne;\n        dqne_dqn = qne[i * 120 + j] * qn[i * 120 + j];\n        dqne_dqclean = qne[i * 120 + j] * qclean[i * 120 + j];\n        dqne_dclean = qne[i * 120 + j] * dqclean_dqle;\n        dqle_dqle = qle[i * 120 + j] * qle[i * 120 + j];\n        dqle_dclean = qle[i * 120 + j] * dqclean_dqne;\n        dqle_db = (b_dot_j * qle[i * 120 + j] + b_cross_j_dot_j * qle[i * 120 + j]) - mul2 * dqle_dqclean;\n        dqn_dqn = qn[i * 120 + j] * qn[i * 120 + j];\n        dqn_dqclean = qn[i * 120 + j] * qclean[i * 120 + j];\n        dqn_dclean = qn[i * 120 + j] * dqclean_dqne;\n        dqne_dclean = qne[i * 120 + j] * dqclean_dqle;\n        dqne_db = (b_dot_j * qne[i * 120 + j] + b_cross_j_dot_j * qne[i * 120 + j]) - mul2 * dqne_dqclean;\n        dqclean_db = (b_dot_j * qclean[i * 120 + j] + b_cross_j_dot_j * qclean[i * 120 + j]) - mul1 * dqclean_dqne;\n        qclean[i * 120 + j] = qclean[i * 120 + j] + leaky_req - gain;\n        qne[i * 120 + j] = qne[i * 120 + j] + e_dot_j * (leaky_req - gain) - mul2 * (dqne_dqn + dqne_dclean);\n        qle[i * 120 + j] = qle[i * 120 + j] + mul2 * (dqle_dqne + dqle_dclean) - mul2 * (dqle_dqclean + dqle_db);\n        qn"}}
{"input": "To generate the given HLS codes written in C, use the following concise natural language instruction:\n\n\"Optimize the loop iterations for pipelining, tiling with a factor of 1, and parallelizing with factors of 2, 5, and 8, respectively. Treat the function as a hardware kernel for acceleration.\"\n\nThis instruction captures the process of the codes and specifies the appropriate #pragma values to use.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "1": "\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": "\n\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (i = 1; i < 119; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 119; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n"}}
{"input": "Parallelize the outer loop with a factor chosen automatically. Pipeline the loops using flattening. Tile the loops with a factor chosen automatically. Parallelize the outer and inner loops with a factor chosen automatically and perform reduction on inner loop. Treat the function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{80}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      double B_times_C_j = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=B_times_C_j FACTOR=auto{1}\n      for (k = 0; k < 70; k++) {\n        B_times_C_j += B[i][k] * C[k][j];\n      }\n      double A_times_B_j = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=A_times_B_j FACTOR=auto{1}\n      for (k = 0; k < 80; k++) {\n        A_times_B_j += A[i][k] * B_times_C_j;\n      }\n      tmp[i][j] = A_times_B_j;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      double tmp_ij = tmp[i][j];\n      double alphabeta = alpha * tmp_ij;\n      double D_ij = D[i][j];\n      D[i][j] = D_ij + alphabeta;\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      double Bji = B[i][j];\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1}\n      for (k = 0; k < 70; k++) {\n        tmp[i][j] += A[i][k] * Bji * C[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      double sum = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=sum FACTOR=auto{1}\n      for (k = 0; k < 50; k++) {\n        sum += D[i][k] * C[k][j];\n      }\n      D[i][j] = sum;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 50; j++) {\n      D[i][j] = alpha * tmp[i][j] + beta * D[i][j];\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      int _in_j = 0;\n      int _in_k = 0;\n      for (k = 0; k < 70; k++) {\n        if (k < ((0 + 70) - 1)) {\n          j = _in_j;\n          k = _in_k;\n        }\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      int _in_j = 0;\n      int _in_k = 0;\n      for (k = 0; k < 50; k++) {\n        if (k < ((0 + 50) - 1)) {\n          j = _in_j;\n          k = _in_k;\n        }\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(double m1[4096],double m2[4096],double prod[4096])\n{\n  double tmp_d[4096];\n  double mul;\n  int i;\n  int j;\n  int k;\n\n#pragma ACCEL PIPELINE auto{flatten}\n\n#pragma ACCEL TILE FACTOR=auto{1}\n\n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  matmul:\n  for (i = 0; i < 64; i++) {\n    tmp_d[i] = ((double )0);\n  }\n  mul_lbl2:\n  for (i = 0; i < 64; i++) {\n    mul_lbl3:\n    for (j = 0; j < 64; j++) {\n      tmp_d[j] += m1[i * 64] * m2[i * 64 + j];\n    }\n  }\n  add_lbl4:\n  for (i = 0; i < 64; i++) {\n    prod[i * 64] = tmp_d[i];\n  }\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(double m1[4096],double m2[4096],double prod[4096])\n{\n  double temp_1[32768];\n  double temp_2[32768];\n  double mul[1024];\n  int i;\n  int j;\n  int k;\n  int k_col;\n  int temp_1_idx;\n  int temp_2_idx;\n  int mul_idx;\n  int mul_col;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  loopj:\n  for (j = 0; j < 64; j++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    loopi:\n    for (i = 0; i < 64; i++) {\n      temp_1_idx = (((64) * i) + j);\n      double sum = m1[temp_1_idx] * 0;\n      \n#pragma ACCEL PARALLEL reduction=sum FACTOR=auto{__PARA__L5}\n      loopk:\n      for (k = 0; k < 64; k++) {\n        k_col = (((64) * k) + j);\n        mul_idx = (64 * k) + i;\n        sum += m1[k_col] * m2[mul_idx];\n      }\n      temp_2_idx = (((64) * i) + j);\n      mul[temp_2_idx] = sum;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  loopk_col:\n  for (k_col = 0; k_col < 64; k_col++) {\n    \n#pragma ACCEL PARALLEL reduction=prod FACTOR=auto{__PARA__L6}\n    loopi:\n    for (i = 0; i < 64; i++) {\n      mul_idx = (64 * i) + k_col;\n      prod[mul_idx] = mul[mul_idx] * 0;\n    }\n    int _in_prod = prod[k_col];\n    prod[k_col] = _in_prod;\n  }\n}\n"}}
{"input": "Process the following function as a hardware kernel for acceleration and apply the following pragma values:\n1. For the outer loop of 'r', turn off automatic pipelining and maintain the loop in its original, full form without breaking it into smaller chunks.\n2. For the inner loop of 'q', also turn off automatic pipelining and maintain the loop in its original, full form without breaking it into smaller chunks.\n3. For the most inner loop of 'p', again turn off automatic pipelining and maintain the loop in its original, full form without breaking it into smaller chunks.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 30; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n      for (j = 1; j < 120 - 1; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    for (i = 1; i < 120 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 120 - 1; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To generate the given HLS codes in C, use the following comprehensive but concise natural language instruction:\n\n\"Convert the function to a hardware kernel for acceleration and apply automatic pipeline, tile factor, and parallel factor optimizations based on the compiler's decision.\"\n\nThis instruction covers the specific pragmas like \"#pragma ACCEL kernel\", \"#pragma ACCEL PIPELINE auto{}\", \"#pragma ACCEL TILE FACTOR=auto{1}\", and \"#pragma ACCEL PARALLEL FACTOR=auto{}\" and sets the compiler to make automatic decisions for pipeline, tiling, and parallelization factors.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L4}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction=D FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 2L * (j + _in_j_col);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][_in_j] - ey[i][_in_j]);\n      }\n    }\n  }\n}\n"}}
{"input": "Process this loop in its original, full form without breaking it into smaller chunks; don't automatically pipeline this loop; run the iterations of this loop one after the other, not in parallel; treat the following function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i % 100);\n        int j_col = 2L * (j % 120);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "3": "  #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1*i;\n        int j_row = -1*j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_col + 1][j_row + 1] - ex[i][j_row + 1] - ey[i_col + 1][j][j_row + 1] + ey[i][j][j_row + 1]);\n      }\n    }\n  }\n}\n", "4": " This function was auto-prototyped:\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To generate the given HLS codes, use the following natural language instruction:\n\n\"Designate the following function as a hardware kernel for acceleration, then automatically pipeline the outer loop, tile the loops with a factor of 1, and parallelize the outer loop with a factor of 2 and the inner loops with factors of 6 and 5 respectively.\"\n\nI hope this helps!", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n", "1": "\n", "2": "\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_in_j = i + j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes in C:\n\n- Enhance parallelism by automatically pipelining this loop using '#pragma ACCEL PIPELINE auto{}'\n- Process this loop with its original, full form without breaking it into smaller chunks using '#pragma ACCEL TILE FACTOR=auto{1}'\n- Run the iterations of this loop in parallel with a factor automatically determined using '#pragma ACCEL PARALLEL FACTOR=auto{2}'\n- Further maximize parallelism by automatically determining the parallel factor of 5 for the inner loop using '#pragma ACCEL PARALLEL FACTOR=auto{5}'\n- Finally, achieve higher parallelism with an automatic parallel factor of 8 for the second inner loop using '#pragma ACCEL PARALLEL FACTOR=auto{8}'\n\nEnsure these pragmas are placed appropriately in the code to achieve the specified hardware acceleration behavior.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "1": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{_1}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": "\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        double  _tmp_2 = 0.0;\n        double  _tmp_3 = 0.0;\n        double  _tmp_4 = 0.0;\n        double  _tmp_5 = 0.0;\n        double  _tmp_6 = 0.0;\n        double  _tmp_7 = 0.0;\n        double  _tmp_8 = 0.0;\n        double  _tmp_9 = 0.0;\n        _tmp_2 = ex[i][j + 1] - ex[i][j];\n        _tmp_3 = ey[i + 1][j] - ey[i][j];\n        _tmp_4 = hz[i][j + 1] - hz[i][j];\n        _tmp_5 = hz[i + 1][j] - hz[i][j];\n        _tmp_6 = _tmp_2 * _tmp_3;\n        _tmp_7 = _tmp_4 - _tmp_5;\n        _tmp_8 = _tmp_6 * _tmp_7;\n        _tmp_9 = _tmp_8 + 1.0;\n        ez[i][j] = _tmp_9;\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n      for (j = 0; j < 240 - 1; j++) {\n        double  _tmp_10 = 0.0;\n        _tmp_10 = ex[i][j + 1] - ex[i][j];\n        ey[i][j] = _tmp_10;\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n      for (j = 0; j < 240 - 1; j++) {\n        double  _tmp_11 = 0.0;\n        _tmp_11 = ey[i + 1][j] - ey[i][j];\n        ex[i][j] = _tmp_11;\n      }\n    }\n  }\n}\n", "3": "\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_low = 1 + 0 * (1L << 0);\n        int i_high = 1 + 1 * (1L << 0);\n        int j_low = 1 + 0 * (1L << 5);\n        int j_high = 1 + 1 * (1L << 5);\n        double update = ((ey[i][j + 1] - ey[i][j]) / (hz[i][j + 1] - hz[i][j])) + ((ey[i][j] - ey[i][j - 1]) / (hz[i][j] - hz[i][j - 1])) + ((ex[i + 1][j] - ex[i][j]) / (hz[i + 1][j] - hz[i][j])) + ((ex[i][j] - ex[i - 1][j]) / (hz[i][j] - hz[i - 1][j]));\n        hz[i][j] = hz[i][j] + 1.0 / (2.0 * (1L << t)) * (((double )(fict_[t])) - update);\n      }\n    }\n  }\n}\n", "4": "\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_low = 1 + 0 * (1L << 0);\n        int i_high = 1 + 1 * (1L << 0);\n        int j_low = 1 + 0 * (1L << 5);\n        int j_high = 1 + 1 * (1L << 5);\n        double DX = 1.0;\n        double DY = 1.0;\n        double DZ = 1.0;\n        double C1 = -1.0 / (DX * DX);\n        double C2 = -1.0 / (2.0 * DY * DY);\n        double C3 = -1.0 / (DZ * DZ);\n        double C4 = 2.0 * (C2 + C3);\n        double C5 = C1 + C4;\n        double EXT_A = ex[i][j];\n        double EXT_B = ey[i][j];\n        double EXT_C = hz[i][j];\n        double dJdX = 2.0;\n        double dJdY = 2.0 * ( (404) - 1);\n        double dJdZ = 2.0 * ( (240) - 1);\n        double partial[9];\n        partial[0] = C5 * (EXT_A - ex[i_low][j]);\n        partial[1] = C4 * (EXT_A - ex[i_high][j]);\n        partial[2] = C4 * (EXT_A - ex[i_low][j_low]) - C5 * (EXT_A - ex[i_high][j_low]) + C2 * (EXT_B - ey[i][j_low]);\n        partial[3] = C4 * (EXT_A - ex[i_high][j_low]) - C5 * (EXT_A - ex[i_low][j_high]) - C2 * (EXT_B - ey[i][j_high]);\n        partial[4] = C4 * (EXT_A - ex[i_low][j_high]) - C5 * (EXT_A - ex[i_high][j_high]) + C2 * (EXT_B - ey[i][j_low] - dJdY * ey[i][j_high]);\n        partial[5] = C1 * (EXT_C - hz[i_low][j]);\n        partial[6] = C4 * (EXT_A - ex[i_low][j_low]) - C5 * (EXT_A - ex[i_high][j_high]) + C3 * (EXT_C - hz[i_low][j_low]) - C5 * (EXT_C - hz[i_high][j_high]) + C2 * (EXT_B - ey[i][j_low] - dJdY * ey[i][j_high] - dJdX * hz[i][j_low] + dJdX * hz[i][j_high]);\n        partial[7] = C4 * (EXT_A - ex[i_high][j_low]) - C5 * (EXT_A - ex[i_low][j_high]) - C3 * (EXT_C - hz[i_high][j_low]) - C5 * (EXT_C - hz[i_low][j_high]) + C2 * (EXT_B - ey[i][j_low] - dJdY * ey[i][j_high] - dJdX * hz[i][j_low] - dJdX * hz[i][j_high]);\n        partial[8] = C5 * (EXT_B - ey[i_low][j]) - C4 * (EXT_B - ey[i_high][j]) + C3 * (EXT_C - hz[i_low][j]) - C5 * (EXT_C - hz[i_high][j]) + 2.0 * (C4 * (EXT_C - hz[i][j]) + C1 * (EXT_A - ex[i][j]) - C2 * (EXT_B - ey[i][j]));\n        double A = partial[0] + partial[1] + partial[4];\n        double B = partial[1] + partial[2] + partial[5];\n        double C = partial[4] + partial[5] + partial[8];\n        double D = partial[2] + partial[3] + partial[6];\n        double E = partial[3] + partial[7] + partial[8];\n        double F = partial[6] + partial[7];\n        double G = ex[i][j] - (A * ey[i][j] + B * hz[i][j]);\n        double H = ey[i][j] - (C * ey[i][j] + D * hz[i][j]);\n        double I = hz[i][j] - (E * ey[i][j] + F * hz[i][j]);\n        ex[i][j] = G;\n        ey[i][j] = H;\n        hz[i][j] = I;\n      }\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes written in C, use the following natural language instructions for the specific #pragma values:\n\n1. 'Treat the following function as a hardware kernel for acceleration'\n   Use: `#pragma ACCEL kernel`\n\n2. 'Don't automatically pipeline this loop'\n   Use: `#pragma ACCEL PIPELINE \"off\"`\n\n3. 'Process this loop in its original, full form without breaking it into smaller chunks'\n   Use: `#pragma ACCEL TILE FACTOR=1`\n\n4. 'Run the iterations of this loop one after the other, not in parallel'\n   Use: `#pragma ACCEL PARALLEL FACTOR=1`", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n   \nint bbgemm(double m1[4096],double m2[4096],double prod[4096])\n{\n  int i;\n  int k;\n  int j;\n  int jj;\n  int kk;\n  int i_row;\n  int k_row;\n  double temp_x;\n  double mul;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  loopjj:\n/* Standardize from: for(jj = 0;jj < 64;jj += 8) {...} */\n  for (jj = 0; jj <= 7; jj++) {\n    int _in_jj = 0 + 8L * jj;\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    loopkk:\n/* Standardize from: for(kk = 0;kk < 64;kk += 8) {...} */\n    for (kk = 0; kk <= 7; kk++) {\n      int _in_kk = 0 + 8L * kk;\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      loopi:\n      for (i = 0; i < 64; ++i) {\n        \n#pragma ACCEL PIPELINE auto{}\n        \n#pragma ACCEL TILE FACTOR=auto{1}\n        loopk:\n        for (k = 0; k < 8; ++k) {\n          i_row = i * 64;\n          k_row = (k + _in_kk) * 64;\n          temp_x = m1[i_row + k + _in_kk];\n          loopj:\n          for (j = 0; j < 8; ++j) {\n            mul = temp_x * m2[k_row + j + _in_jj];\n            prod[i_row + j + _in_jj] += mul;\n          }\n        }\n      }\n    }\n    kk = _in_kk;\n  }\n  jj = _in_jj;\n}\n", "1": "\n\n5. 'Unroll this loop by a factor of 1'\n   Use: `#pragma ACCEL PIPELINE auto{__PIPE__L1} UNROLL auto{__UNROLL__L1}`\n\n6. 'Unroll this loop by a factor of 2'\n   Use: `#pragma ACCEL PIPELINE auto{__PIPE__L2} UNROLL auto{__UNROLL__L2}`\n\n7. ' #pragma ACCEL kernel'\n\n8. ' #pragma ACCEL PIPELINE auto{off}'\n\n9. ' #pragma ACCEL TILE FACTOR=auto{1}'\n\n10. ' #pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}'\n\n11. ' #pragma ACCEL PIPELINE auto{__PIPE__L2}'\n\n12. ' #pragma ACCEL TILE FACTOR=auto{__TILE__L2}'\n\n13. ' #pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}'\n\n14. ' #pragma ACCEL PIPELINE auto{__PIPE__L3}'\n\n15. ' #pragma ACCEL TILE FACTOR=auto{__TILE__L3}'\n\n16. ' #pragma ACCEL PIPELINE auto{__PIPE__L4}'\n\n17. ' #pragma ACCEL TILE FACTOR=auto{__TILE__L4}'\n\n18. ' #pragma ACCEL PIPELINE auto{__PIPE__L5}'\n\n19. ' #pragma ACCEL TILE FACTOR=auto{__TILE__L5}'\n\n20. ' #pragma ACCEL PIPELINE auto{__PIPE__L6}'\n\n21. ' #pragma ACCEL TILE FACTOR=auto{__TILE__L6}'\n\n22. ' #pragma ACCEL PIPELINE auto{__PIPE__L7}'\n\n23. ' #pragma ACCEL TILE FACTOR=auto{__TILE__L7}'\n\n24. ' #pragma ACCEL PIPELINE auto{__PIPE__L8}'\n\n25. ' #pragma ACCEL TILE FACTOR=auto{__TILE__L8}'\n\n26. ' #pragma ACCEL PIPELINE auto{__PIPE__L9}'\n\n27. ' #pragma ACCEL TILE FACTOR=auto{__TILE__L9}'\n\n28. ' #pragma ACCEL PIPELINE auto{__PIPE__L10}'\n\n29. ' #pragma ACCEL TILE FACTOR=auto{__TILE__L10}'\n\n30. ' #pragma ACCEL PIPELINE auto{__PIPE__L11}'\n\n31. ' #pragma ACCEL TILE FACTOR=auto{__TILE__L11}'\n\n32. ' #pragma ACCEL PIPELINE auto{__PIPE__L12}'\n\n33. ' #pragma ACCEL TILE FACTOR=auto{__TILE__L12}'\n\n34. ' #pragma ACCEL PIPELINE auto{__PIPE__L13}'\n\n35. ' #pragma ACCEL TILE FACTOR=auto{__TILE__L13}'\n\n36. ' #pragma ACCEL PIPELINE auto{__PIPE__L14}'\n\n37. ' #pragma ACCEL TILE FACTOR=auto{__TILE__L14}'\n\n38. ' #pragma ACCEL PIPELINE auto{__PIPE__L15}'\n\n39. ' #pragma ACCEL TILE FACTOR=auto{__TILE__L15}'\n\n40. ' #pragma ACCEL PIPELINE auto{__PIPE__L16}'\n\n41. ' #pragma ACCEL TILE FACTOR=auto{__TILE__L16}'\n\n42. ' #pragma ACCEL PIPELINE auto{__PIPE__L17}'\n\n43. ' #pragma ACCEL TILE FACTOR=auto{__TILE__L17}'\n\n44. ' #pragma ACCEL PIPELINE auto{__PIPE__L18}'\n\n45. ' #pragma ACCEL TILE FACTOR=auto{__TILE__L18}'\n\n46. ' #pragma ACCEL PIPELINE auto{__PIPE__L19}'\n\n47. ' #pragma ACCEL TILE FACTOR=auto{__TILE__L19}'\n\n48. ' #pragma ACCEL PIPELINE auto{__PIPE__L20}'\n\n49. ' #pragma ACCEL TILE FACTOR=auto{__TILE__L20}'\n\n50. ' #pragma ACCEL PIPELINE auto{__PIPE__L21}'\n\n51. ' #pragma ACCEL TILE FACTOR=auto{__TILE__L21}'\n\n52. ' #pragma ACCEL PIPELINE auto{__PIPE__L22}'\n\n53. ' #pragma ACCEL TILE FACTOR=auto{__TILE__L22}'\n\n54. ' #pragma ACCEL PIPELINE auto{__PIPE__L23}'\n\n55. ' #pragma ACCEL TILE FACTOR=auto{__TILE__L23}'\n\n56. ' #pragma ACCEL PIPELINE auto{__PIPE__L24}'\n\n57. ' #pragma ACCEL TILE FACTOR=auto{__TILE__L24}'\n\n58. ' #pragma ACCEL PIPELINE auto{__PIPE__L25}'\n\n59. ' #pragma ACCEL TILE FACTOR=auto{__TILE__L25}'\n\n60. ' #pragma ACCEL PIPELINE auto{__PIPE__L26}'\n\n61. ' #pragma ACCEL TILE FACTOR=auto{__TILE__L26}'\n\n62. ' #pragma ACCEL PIPELINE auto{__PIPE__L27}'\n\n63. ' #pragma ACCEL TILE FACTOR=auto{__TILE__L27}'\n\n64. ' #pragma ACCEL PIPELINE auto{__PIPE__L28}'\n\n65. ' #pragma ACCEL TILE FACTOR=auto{__TILE__L28}'\n\n66. ' #pragma ACCEL PIPELINE auto{__PIPE__L29}'\n\n67. ' #pragma ACCEL TILE FACTOR=auto{__TILE__L29}'\n\n68. ' #pragma ACCEL PIPELINE auto{__PIPE__L30}'\n\n69. ' #pragma ACCEL TILE FACTOR=auto{__TILE__L30}'\n\n70. ' #pragma ACCEL PIPELINE auto{__PIPE__L31}'\n\n71. ' #pragma ACCEL TILE FACTOR=auto{__TILE__L31}'\n\n72. ' #pragma ACCEL PIPELINE auto{__PIPE__L32}'\n\n73. ' #pragma ACCEL TILE FACTOR=auto{__TILE__L32}'\n\n74. ' #pragma ACCEL PIPELINE auto{__PIPE__L33}'\n\n75. ' #pragma ACCEL TILE FACTOR=auto{__TILE__L33}'\n\n76. ' #pragma ACCEL PIPELINE auto{__PIPE__L34}'\n\n77. ' #pragma ACCEL TILE FACTOR=auto{__TILE__L34}'\n\n78. ' #pragma ACCEL PIPELINE auto{__PIPE__L35}'\n\n79. ' #pragma ACCEL TILE FACTOR=auto{__TILE__L35}'\n\n80. ' #pragma ACCEL PIPELINE auto{__PIPE__L36}'\n\n81. ' #pragma ACCEL TILE FACTOR=auto{__TILE__L3", "2": "\n\n5. 'Automatically pick the best schedule for this loop'\n   Use: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}`\n\n6. 'Complete kernel 'gemm'\n   Use: `#pragma ACCEL kernel`\n\n#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "3": "\n\n5. 'Transform the code using auto-pipelining'\n   Use: `#pragma ACCEL PIPELINE auto{off}`\n\n6. 'Transform the code using automatic unrolling'\n   Use: `#pragma ACCEL UNROLL auto{1}`\n\n7. 'Transform the code using the auto-parallelizer'\n   Use: `#pragma ACCEL PARALLEL FACTOR=auto{128}`\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n\n5. 'Set the size of the reduction buffer to 128'\n   Use: `#pragma ACCEL PARAMS auto{sum = 128}`\n\n6. 'Set the size of the A and B arrays to 128'\n   Use: `#pragma ACCEL PARAMS auto{A = 128} auto{B = 128}`\n#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes in C, use the following natural language instructions for the specific #pragma values:\n\n1. \"Treat the following function as a hardware kernel for acceleration\" - Use `#pragma ACCEL kernel` to indicate that the function should be treated as a hardware kernel for acceleration.\n\n2. \"Don't automatically pipeline this loop\" - Use `#pragma ACCEL PIPELINE \"off\"` to turn off automatic pipelining for the loop.\n\n3. \"Process this loop in its original, full form without breaking it into smaller chunks\" - Use `#pragma ACCEL TILE FACTOR=1` to set the tiling factor to 1, indicating that the loop should not be broken into smaller chunks.\n\n4. \"Run the iterations of this loop one after the other, not in parallel\" - Use `#pragma ACCEL PARALLEL FACTOR=1` to specify that the loop iterations should not be run in parallel and should instead be executed one after the other.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{}\n      \n#pragma ACCEL TILE FACTOR=auto{8}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n5. \"Unroll this loop by a factor of 32\" - Use `#pragma ACCEL PIPELINE auto{__PIPE__L1}` attribute to automatically unroll the loop by a factor of 32.\n\n6. \" #pragma ACCEL PIPELINE auto{__PIPE__L2}\"\n\n7. \" #pragma ACCEL PIPELINE auto{__PIPE__L3}\"\n\n8. \" #pragma ACCEL PIPELINE auto{__PIPE__L4}\"\n\n9. \" #pragma ACCEL PIPELINE auto{__PIPE__L5}\"\n\n10. \" #pragma ACCEL PIPELINE auto{__PIPE__L6}\"\n\n11. \" #pragma ACCEL PIPELINE auto{__PIPE__L7}\"\n\n12. \" #pragma ACCEL PIPELINE auto{__PIPE__L8}\"\n\n13. \" #pragma ACCEL PIPELINE auto{__PIPE__L9}\"\n\n14. \" #pragma ACCEL PIPELINE auto{__PIPE__L10}\"\n\n15. \" #pragma ACCEL PIPELINE auto{__PIPE__L11}\"\n\n16. \" #pragma ACCEL PIPELINE auto{__PIPE__L12}\"\n\n17. \" #pragma ACCEL PIPELINE auto{__PIPE__L13}\"\n\n18. \" #pragma ACCEL PIPELINE auto{__PIPE__L14}\"\n\n19. \" #pragma ACCEL PIPELINE auto{__PIPE__L15}\"\n\n20. \" #pragma ACCEL PIPELINE auto{__PIPE__L16}\"\n\n21. \" #pragma ACCEL PIPELINE auto{__PIPE__L17}\"\n\n22. \" #pragma ACCEL PIPELINE auto{__PIPE__L18}\"\n\n23. \" #pragma ACCEL PIPELINE auto{__PIPE__L19}\"\n\n24. \" #pragma ACCEL PIPELINE auto{__PIPE__L20}\"\n\n25. \" #pragma ACCEL PIPELINE auto{__PIPE__L21}\"\n\n26. \" #pragma ACCEL PIPELINE auto{__PIPE__L22}\"\n\n27. \" #pragma ACCEL PIPELINE auto{__PIPE__L23}\"\n\n28. \" #pragma ACCEL PIPELINE auto{__PIPE__L24}\"\n\n29. \" #pragma ACCEL PIPELINE auto{__PIPE__L25}\"\n\n30. \" #pragma ACCEL PIPELINE auto{__PIPE__L26}\"\n\n31. \" #pragma ACCEL PIPELINE auto{__PIPE__L27}\"\n\n32. \" #pragma ACCEL PIPELINE auto{__PIPE__L28}\"\n\n33. \" #pragma ACCEL PIPELINE auto{__PIPE__L29}\"\n\n34. \" #pragma ACCEL PIPELINE auto{__PIPE__L30}\"\n\n35. \" #pragma ACCEL PIPELINE auto{__PIPE__L31}\"\n\n36. \" #pragma ACCEL PIPELINE auto{__PIPE__L32}\"\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L7}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L7}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n      for (j = 0; j < 240 - 1; j++) {\n        z_pe[i][j] = hz[i][j] - 0.25 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L9}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L9}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L10}\n      for (j = 0; j < 240 - 1; j++) {\n        ex[i][j] = ex[i][j] + 0.25 * (z_pe[i][j] - z_se[i][j + 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L11}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L11}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L11}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L12}\n      for (j = 0; j < 240 - 1; j++) {\n        ey[i][j] = ey[i][j] + 0.25 * (z_se[i][j] - z_pe[i + 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L13}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L13}\n    \n#pragma", "1": "\n\n5. \"Auto-parallelize outer loop only\" - Use `#pragma ACCEL PARALLEL FACTOR=auto{1}` to specify the parallelization factor for this loop.\n\n6. \"Fully automatic auto{1} = 2\" - Use `#pragma ACCEL PARALLEL FACTOR=auto{2}` to set the parallelization factor.\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n\n5. \"This loop has no parallelized version; this kernel is automatically timed\" - Use `#pragma ACCEL KERNEL FACTOR=auto{128}` to set the kernel's automatic array size to 128.\n  \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i % 100);\n        int j_col = 2L * (j % 120);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": "\n\n5. \"Transform this for loop automatically into a parallelized form by unrolling it automatically\" - Use `#pragma ACCEL PARALLEL FACTOR=auto{1}` to specify that the parallelization factor should be automatically decided by ACCEL. The number 1 is used to unroll the loop by a factor of 1.\n\n6. \"Transform this for loop automatically into a parallelized form by unrolling it automatically and breaking it down by tiles of 4\" - Use `#pragma ACCEL PIPELINE auto{off}`\n\t\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1;\n        int j_col = -1;\n        double ey_x = (ey[i][j + 1] - ey[i][j]) / (ex[i][j + 1] - ex[i][j]);\n        double ex_y = (ex[i + 1][j] - ex[i][j]) / (ey[i + 1][j] - ey[i][j]);\n        double _tmp_ = ex[i][j] + (1.0 - 2.0 * rdt) * hz[i][j] + rdt * (ex_y + ey_x);\n        hz[i][j] = hz[i][j] + (1.0 - 2.0 * rdt) * _tmp_ + rdt * (hz[i + 1][j] - hz[i][j + 1]);\n        ey[i][j] = ey[i][j] + rdt * (_tmp_ - hz[i][j]);\n        ex[i][j] = ex[i][j] + rdt * (hz[i][j] - _tmp_);\n      }\n    }\n  }\n}\n", "4": "\n\n5. \"Map A to B\" - Use `#pragma ACCEL kernel FACTOR=auto{__PARA__L1}` to autoparallelize the L1 operation.\n\n6. \" #pragma ACCEL PIPELINE auto{off}\"\n/*\n  This test case is a simplified version of matmul.c. It uses row-major\n  to show how ACCEL PIPELINE work.\n  Original from MATMUL subroutine in:\n  \n  Wilkes, D. L. (1995). \"A protocol for testing parallel algorithms\".\n  In Proceedings of the 1995 ACM SIGPLAN symposium on Parallel\n  programming (PP'95). ACM, New York, NY, USA, 96-106.\n  http://doi.acm.org/10.1145/202374.202381\n*/\n\n#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n"}}
{"input": "Process this function as a hardware kernel for acceleration. Pipeline the outer loop with offloading disabled. Use an automatic tiling factor of 2 for the outer loop. Pipeline the middle loop with flattening enabled and use an automatic tiling factor of 1 for the middle and inner loops.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": " Pipeline the inner loop with offloading enabled and use an automatic tiling factor of 256 for the inner loop.\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{256}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "Process the nested loops in their original, full form without breaking them into smaller chunks, and treat the function as a hardware kernel for acceleration. Additionally, don't automatically pipeline the loops and use a tile factor of 1 for each loop.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_0}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[j];\n    }\n    \n#pragma ACCEL PIPELINE auto{off_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1_1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_1}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1_1_0}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1_2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_2}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1_2_0}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1_3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_3}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1_3_0}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[j];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2_0}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{off_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1_1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2_1}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2_1_0}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1_2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2_2}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2_2_0}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1_3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2_3}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2_3_0}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n"}}
{"input": "Process the following function as a hardware kernel for acceleration, and don't automatically pipeline the outermost loop; process the outermost loop in its original, full form without breaking it into smaller chunks; process the inner loops with a tile factor of 1, and turn off automatic pipelining for the inner loops.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{8}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_0}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[j];\n    }\n    \n#pragma ACCEL PIPELINE auto{off_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1_1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_1}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1_1_0}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1_2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_2}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1_2_0}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1_3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_3}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1_3_0}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_0}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[j];\n    }\n    \n#pragma ACCEL PIPELINE auto{off_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1_1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_1}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1_1_0}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1_2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_2}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1_2_0}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1_3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_3}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1_3_0}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 2;\n        int _in_i = 2;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n"}}
{"input": "Process the three nested loops in function 'kernel_doitgen' in the original, full form without breaking them into smaller chunks. Ensure that the loops are not automatically pipelined and that they are not treated as flattened. Set the tile factor as 1 for the outer two loops and 8 for the inner loop to optimize for hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{8}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][25])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        double sum = ((double )0);\n#pragma ACCEL PARALLEL reduction=sum FACTOR=auto{__PARA__L3}\n\tfor (s = 0; s < 30; s++) {\n          sum += A[r][q][s] * C4[s][p];\n        }\n\tA[r][q][p] = sum;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(int A[25][20][30],int B[25][20][30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        B[r][q][p] = A[r][q][p];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n      for (p = 0; p < 30; p++) {\n        int Aval = 0;\n#pragma ACCEL PARALLEL reduction=Aval FACTOR=auto{__PARA__L5}\n\tfor (s = 0; s < 30; s++) {\n\t  Aval += A[r][q][s] * B[r][s][p];\n\t}\n\tA[r][q][p] = Aval;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][25])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = ((double )0);\n      }\n    }\n    for (p = 0; p < 30; p++) {\n      A[r][14][p] = 4.0;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n      for (p = 0; p < 30; p++) {\n        double sum = 0.0;\n#pragma ACCEL PARALLEL reduction=sum FACTOR=auto{__PARA__L5}\n\tfor (s = 0; s < 30; s++) {\n          sum += A[r][q][s] * C4[s][p];\n        }\n\tA[r][q][p] = sum;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,int nq2,double A[25][20][30],double C4[30][30],double B[25][20])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n  int t;\n  double tmp;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  loop_r:\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    loop_q:\n    for (q = 0; q < 20; q++) {\n      loop_s:\n      for (s = 0; s < 30; s++) {\n        A[r][q][s] = ((double )0);\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  loop_r_2:\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    loop_q_2:\n    for (q = 0; q < 20; q++) {\n      loop_p:\n      for (p = 0; p < 30; p++) {\n        loop_t:\n        for (t = 0; t < 30; t++) {\n          tmp = A[r][q][t] * B[t][p];\n          A[r][q][p] = A[r][q][p] + tmp;\n        }\n      }\n      loop_s_2:\n      for (s = 0; s < 30; s++) {\n        C4[p][s] = ((double )0);\n      }\n      loop_s_1:\n      for (s = 0; s < 30; s++) {\n        loop_t_1:\n        for (t = 0; t < 30; t++) {\n          C4[p][s] = C4[p][s] + A[r][q][t] * B[t][s];\n        }\n      }\n      loop_cp:\n      for (p = 0; p < 30; p++) {\n        B[r][q] = C4[p][s];\n      }\n    }\n  }\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(int A[25][20][30],int cmd[4104])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n  int r_col;\n  int r_row;\n  int r_slice;\n  int s_col;\n  int s_row;\n  int s_slice;\n  int elem_col;\n  int elem_row;\n  int elem_slice;\n  int tmp;\n  int tmp_row;\n  int tmp_col;\n  int tmp_slice;\n  \n#pragma ACCEL PIPELINE auto{off}\n  loop_r:\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    loop_q:\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      loop_p:\n      for (p = 0; p < 30; p++) {\n        r_col = 0;\n        tmp_col = 1;\n        loop_rc:\n        for (r_col = 0; r_col < 5; r_col++) {\n          r_row = 0;\n          tmp_row = 1;\n          loop_rc_row:\n          for (r_row = 0; r_row < 5; r_row++) {\n            s_col = 0;\n            tmp_col = ((4 - r_col) * 20);\n            loop_s_col:\n            for (s_col = 0; s_col < 4; s_col++) {\n              s_row = 0;\n              tmp_row = ((4 - r_row) * 20);\n              loop_s_row:\n              for (s_row = 0; s_row < 4; s_row++) {\n                elem_col = 0;\n                tmp_col = tmp_col + 1;\n                loop_ec:\n                for (elem_col = 0; elem_col < 4; elem_col++) {\n                  elem_row = 0;\n                  tmp_row = tmp_row + 1;\n                  loop_er:\n                  for (elem_row = 0; elem_row < 4; elem_row++) {\n                    s_slice = 0;\n                    tmp_slice = ((4 - s_col) * 30);\n                    loop_s_slice:\n                    for (s_slice = 0; s_slice < 4; s_slice++) {\n                      s_slice = s_slice + 1;\n                      tmp_slice = tmp_slice + 1;\n                      sum = A[r][q][p] * B[r_col][r_row][s_col][s_row][s_slice] + sum;\n                    }\n                  }\n                  tmp_row = ((4 - elem_row) * 20);\n                }\n                tmp_col = ((4 - elem_col) * 20);\n              }\n              tmp_row = ((4 - s_row) * 20);\n            }\n            tmp_col = ((4 - s_col) * 20);\n          }\n          tmp_row = ((4 - r_row) * 20);\n        }\n        tmp_slice = ((4 - s_col) * 30);\n      }\n      A[r][q][p] = sum;\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes in C, you should use the following comprehensive but concise natural language instructions for the #pragma values:\n\n1. Don't automatically pipeline this loop.\n2. Process this loop in its original, full form without breaking it into smaller chunks.\n3. Run the iterations of this loop two at a time in parallel.\n4. Treat the following function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1;\n        int j_col = -1;\n        double hz_col = 0.0;\n        i_col = 200 - 1 - i;\n        j_col = 240 - 1 - j;\n        hz_col = hz[i_col][j_col];\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_col][j_col + 1] - ex[i_col][j_col] + ey[i_col + 1][j_col] - ey[i_col][j_col]);\n      }\n    }\n  }\n}\n", "4": "\n5. Do not change the order of code generation.\n \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n"}}
{"input": "Process the loops with automatic pipeline and tiling, and use the default tile factor for the tiling.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{}\n      \n#pragma ACCEL TILE FACTOR=auto{4}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1 * i + 120;\n        int j_col = -1 * j + 120;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "1": "\n  #pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (j = 16; j < 96; j++) {\n    \n#pragma ACCEL PARALLEL reduction=u FACTOR=auto{__PARA__L3}\n    for (i = 16; i < 96; i++) {\n      r1 = (double )0;\n      r2 = (double )0;\n      for (k = 16; k < 96; k++) {\n        r1 += A[i * 96 + k] * B[k * 96 + j];\n        r2 += A[i * 96 + k] * B[k * 96 + j];\n      }\n      Q1[i * 96 + j] = r1;\n      Q2[i * 96 + j] = r2;\n    }\n  }\n}\n", "2": "\n  #pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n  for (i = 16; i < 24; i++) {\n    tmp = 1.0;\n    sum = e[i];\n    for (j = 0; j < 20; j++) {\n      tmp = tmp * r[j];\n      sum = sum + offset[i] * v[j] * tmp;\n    }\n    e[i] = sum;\n  }\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1;\n        int j_col = -1;\n        double dxy_x = 0.5 * (ex[i + 1][j + 1] - ex[i + 1][j - 1]);\n        double dxy_y = 0.5 * (ey[i + 1][j + 1] - ey[i - 1][j + 1]);\n        double dzz_x = 0.5 * (hz[i + 1][j + 1] - hz[i + 1][j - 1]);\n        double dzz_y = 0.5 * (hz[i + 1][j + 1] - hz[i - 1][j + 1]);\n        double ex_x = ex[i][j] + 0.7071 * dxy_x - 0.5661 * dzz_x;\n        double ex_y = ey[i][j] + 0.7071 * dxy_y + 0.5661 * dzz_x;\n        double ey_x = ex[i][j] - 0.7071 * dxy_x + 0.5661 * dzz_y;\n        double ey_y = ey[i][j] - 0.7071 * dxy_y - 0.5661 * dzz_y;\n        double hz_x = hz[i][j] + 1.0 * dzz_x + 1.0 * dxy_y;\n        double hz_y = hz[i][j] + 1.0 * dzz_y - 1.0 * dxy_x;\n        ex[i][j + 1] = ex_x;\n        ey[i + 1][j] = ey_y;\n        ey[i][j] = ey_x;\n        hz[i][j] = hz_x;\n        hz[i + 1][j] = hz_y;\n      }\n    }\n  }\n}\n", "4": "\n  #pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (tj = 0; tj < 40; tj++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (ti = 0; ti < 40; ti++) {\n      Model_Col_Dump = 0.0;\n      Model_Row_Dump = 0.0;\n      pad_col_idx = ti*5;\n      pad_row_idx = tj*5;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (i = 0; i < 3; i++) {\n        pad_i = i + pad_row_idx;\n        cols = 0;\n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n        for (j = 0; j < 3; j++) {\n          pad_j = j + pad_col_idx;\n          cols = cols + orig[pad_i][pad_j] * k[i][j];\n        }\n        Model_Row_Dump += cols;\n      }\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (i = 0; i < 3; i++) {\n        pad_i = i + pad_row_idx;\n        cols = 0;\n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n        for (j = 0; j < 3; j++) {\n          pad_j = j + pad_col_idx;\n          cols = cols + Model_Row_Dump[j] * a[i][j];\n        }\n        Model_Col_Dump += cols;\n      }\n      pad_row_idx_idx = tj*40;\n      pad_col_idx_idx = ti*40;\n      out[pad_row_idx_idx][pad_col_idx_idx] = Model_Col_Dump;\n    }\n  }\n}\n"}}
{"input": "Process the following function as a hardware kernel for acceleration and apply the following pragma values: Do not automatically pipeline the loops using pragma ACCEL PIPELINE auto{off}, and process the loops without breaking them into smaller chunks using pragma ACCEL TILE FACTOR=2, and for each loop, turn off automatic pipelining with pragma ACCEL PIPELINE auto{off} and use pragma ACCEL TILE FACTOR=1 to process the iterations in their original, full form without breaking them into smaller chunks.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\nauto tmax = 40;\nauto n = 40;\n \n#pragma ACCEL kernel\n\nvoid gemm(double m1[40][40],double m2[40][40],double prod[40][40])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (j = 0; j < 40; j++) {\n      double sum = (double )0;\n      \n#pragma ACCEL PARALLEL reduction=sum FACTOR=auto{1}\n      for (k = 0; k < 40; k++) {\n        sum += m1[i][k] * m2[k][j];\n      }\n      prod[i][j] = sum;\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n:: ACCEL kernel\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = 0.0;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = 0.0;\n      }\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n      for (j = 1; j < 240; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j] - ex[i][j - 1]) - 0.7 * (ey[i][j] - ey[i - 1][j]);\n      }\n    }\n  }\n}\n", "2": "\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1 * i;\n        int j_col = j + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_col][j] - ex[i][j_col]) - 0.7 * (ey[i][j_col] - ey[i_col][j]);\n      }\n    }\n  }\n}\n", "3": "\n\\\\begin{equation}\n\\begin{aligned}\n  & f\\left( x, y \\right) = \\sum_{i=1}\n\\end{aligned}\n\\end{equation}\n\tfor(i = 1; i < 120; i++) {\n\t  tmp = 0.0;\n\t  float tmp_stddev = 0.0;\n\t  for(j = 1; j < 120; j++) {\n\t    tmp += A[i][j] * B[i][j];\n\t  }\n\t  \n#pragma ACCEL PIPELINE auto{off}\n\t  \n#pragma ACCEL TILE FACTOR=auto{2}\n\t  for(j = 1; j < 120; j++) {\n\t    tmp_stddev += (A[i][j] - tmp) * (A[i][j] - tmp);\n\t  }\n\t  tmp_stddev = sqrt(tmp_stddev / 119.0);\n\t  Q[i] = tmp / tmp_stddev;\n\t}\n}\n", "4": "\n\n #pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60],double r[60][60],double s[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DX2;\n  double DY2;\n  double DXDY;\n  double C1;\n  double C2;\n  double C12;\n  double C22;\n  double del;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DX2 = DX * DX;\n  DY2 = DY * DY;\n  DXDY = DX * DY;\n  C1 = 3.0 * DX2 * DY2;\n  C2 = 3.0 * DX2 - 2.0 * DXDY * DY2;\n  C12 = C1 * C2;\n  C22 = C2 * C2;\n  del = 1.0 / 41.0;\n  mul1 = -1.0 * del * DXDY * C22;\n  mul2 = 1.0 - 2.0 * del * DY2 * C2 + del * C22;\n  a = 1.0 + (mul1 + mul2);\n  b = DXDY * (C1 - 2.0 * C2) + mul2;\n  c = DX2 * (C1 - C2) + (1.0 - 2.0 * del) * DX2 * C22;\n  d = DY2 * C12;\n  e = -1.0 - (mul1 + mul2);\n  f = DXDY * (C12 - 2.0 * C22) + mul1;\n// First tsteps loop\n  for (t = 0; t <= 39; t++) {\n// Four nested parallelized loops\n    for (i = 1; i <= 38; i++) {\n      for (j = 1; j <= 38; j++) {\n// A = Dx2*Dy2\n\tu[i][j] = a * (*(u + (i - 1) * 60) + *(u + (i + 1) * 60) + *(u + (j - 1) * 60) + *(u + (j + 1) * 60)) + b * (*(u + (i - 1) * 60) - *(u + (i + 1) * 60) - *(u + (j - 1) * 60) + *(u + (j + 1) * 60)) + c * (*(u + (i - 1) * 60) + *(u + (i + 1) * 60) - 2.0 * (*(u + (j - 1) * 60) + *(u + (j + 1) * 60))) + d * (*(u + (j - 1) * 60));\n      }\n    }\n    for (i = 1; i <= 38; i++) {\n      for (j = 1; j <= 38; j++) {\n// B = Dy2*Dx2\n\tv[i][j] = e * (*(v + (i - 1) * 60) + *(v + (i + 1) * 60) + *(v + (j - 1) * 60) + *(v + (j + 1) * 60)) + f * (*(v + (i - 1) * 60) - *(v + (i + 1) * 60) - *(v + (j - 1) * 60) + *(v + (j + 1) * 60)) + c * (*(v + (i - 1) * 60) + *(v + (i + 1) * 60) - 2.0 * (*(v + (j - 1) * 60) + *(v + (j + 1) * 60))) + d * (*(v + (j - 1) * 60));\n      }\n    }\n    for (i = 1; i <= 38; i++) {\n      for (j = 1; j <= 38; j++) {\n// C = B + Dx(A - q)\n\tp[i][j] = b * (*(p + (i - 1) * 60) + *(p + (i + 1) * 60) + *(p + (j - 1) * 60) + *(p + (j + 1) * 60)) + f * (*(p + (i - 1) * 60) - *(p + (i + 1) * 60) - *(p + (j - 1) * 60) + *(p + (j + 1) * 60)) + c * (*(p + (i - 1) * 60) + *(p + (i + 1) * 60) - 2.0 * (*(p + (j - 1) * 60) + *(p + (j + 1) * 60))) + d * (*(p + (j - 1) * 60)) - (*(u + (i - 1) * 60) - q[i][j]);\n      }\n    }\n    for (i = 1; i <= 38; i++) {\n      for (j = 1; j <= 38; j++) {\n// D = Dx(A - r)\n\tq[i][j] = a * (*(q + (i - 1) * 60) + *(q + (i + 1) * 60) + *(q + (j - 1) * 60) + *(q + (j + 1) * 60)) + c * (*(q + (i - 1) * 60) + *(q + (i + 1) * 60) - 2.0 * (*(q + (j - 1) * 60) + *(q + (j + 1) * 60))) + d * (*(q + (i - 1) * 60)) - (*(u + (i - 1) * 60) - r[i][j]);\n      }\n    }\n    for (i = 1; i <= 38; i++) {\n      for (j = 1; j <= 38; j++) {\n// S = Dy(A - p)\n\ts[i][j] = a * (*(s + (i - 1) * 60) + *(s + (i + 1) * 60) + *(s + (j - 1) * 60) + *(s + (j + 1) * 60)) + d * (*(s + (j - 1) * 60)) - (*(v + (i - 1) * 60) - p[i][j]);\n      }\n    }\n    for (i = 1; i <= 38; i++) {\n      for (j = 1; j <= 38; j++) {\n// P = Dy(B - s)\n\tp[i][j] = b * (*(p + (i - 1) * 60) + *(p + (i + 1) * 60) + *(p + (j - 1) * 60) + *(p + (j + 1) * 60)) + d * (*(p + (j - 1) * 60)) - (*(v + (i - 1) * 60) - s[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To generate the given HLS codes in C, use these natural language instructions:\n\n1. Treat the following function as a hardware kernel for acceleration.\n2. Don't automatically pipeline this loop.\n3. Process this loop in its original, full form without breaking it into smaller chunks.\n4. Run the iterations of this loop one after the other, not in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{2}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n5. Don't use multistage pipeline\n \n#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "1": "\n5. Don't automatically distribute this loop.\n6. Don't automatically parallelize this loop.\n7. #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n5. #pragma ACCEL PIPELINE auto{off}\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        double  _tmp_2 = 0.0;\n        _tmp_2 = ex[i][j + 1] - ex[i][j];\n        double  _tmp_3 = 0.0;\n        _tmp_3 = ey[i + 1][j] - ey[i][j];\n        double  _tmp_4 = 0.0;\n        _tmp_4 = hz[i][j] - (_tmp_2 + _tmp_3);\n        double  _tmp_5 = 0.0;\n        _tmp_5 = _fict_[i];\n        hz[i][j] = _tmp_4 - _tmp_5;\n      }\n    }\n  }\n}\n", "3": "\n5. Automatically pipeline this loop.\n6. This loop is marked as auto{__PIPE__L2}\n \n#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n5. Don't distribute the original loop to any accelerators.\n   #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To generate the given HLS codes in C, use the following natural language instructions for the specific #pragma values:\n- For the top-level kernel function: 'Treat the following function as a hardware kernel for acceleration'\n- For the outermost loop over 'r': 'Don't automatically pipeline this loop' and 'Process this loop in its original, full form without breaking it into smaller chunks'\n- For the loop over 'q' inside the 'r' loop: 'Don't automatically pipeline this loop' and 'Process this loop in its original, full form without breaking it into smaller chunks'\n- For the innermost loop over 'p' inside the 'q' loop: 'Don't automatically pipeline this loop' and 'Process this loop in its original, full form without breaking it into smaller chunks'\n\nThese natural language instructions map to the following specific #pragma values in the C code:\n- '#pragma ACCEL kernel' for the top-level kernel function\n- '#pragma ACCEL PIPELINE \"off\"' for the outermost loop over 'r'\n- '#pragma ACCEL TILE FACTOR=1' for the outermost loop over 'r'\n- '#pragma ACCEL PIPELINE \"off\"' for the loop over 'q' inside the 'r' loop\n- '#pragma ACCEL TILE FACTOR=1' for the loop over 'q' inside the 'r' loop\n- '#pragma ACCEL PIPELINE \"off\"' for the loop over 'p' inside the 'q' loop\n- '#pragma ACCEL TILE FACTOR=1' for the loop over 'p' inside the 'q' loop", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n- '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}' for the loop over 'p' inside the 'q' loop\n- '#pragma ACCEL PIPELINE auto{__PIPE__L3}' for the loop over 'r'\n- '#pragma ACCEL TILE FACTOR=auto{__TILE__L3}' for the loop over 'r'\n- '#pragma ACCEL PIPELINE auto{__PIPE__L4}' for the loop over 'q'\n- '#pragma ACCEL TILE FACTOR=auto{__TILE__L4}' for the loop over 'q'\n\n\n #pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n- '#pragma ACCEL PIPELINE auto{__PIPE__L3}' for the loop over 'r' inside the 'kernel_seidel_2d' loop\n- '#pragma ACCEL TILE FACTOR=auto{__TILE__L3}' for the loop over 'r' inside the 'kernel_seidel_2d' loop\n- '#pragma ACCEL PIPELINE auto{__PIPE__L2}' for the loop over 'q' inside the 'kernel_seidel_2d' loop\n- '#pragma ACCEL TILE FACTOR=auto{__TILE__L2}' for the loop over 'q' inside the 'kernel_seidel_2d' loop\n- '#pragma ACCEL PIPELINE auto{__PIPE__L1}' for the loop over 'p' inside the 'kernel_seidel_2d' loop\n- '#pragma ACCEL TILE FACTOR=auto{__TILE__L1}' for the loop over 'p' inside the 'kernel_seidel_2d' loop\n\n\n #pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int p;\n  int q;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (p = 1; p <= 118; p++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (q = 1; q <= 118; q++) {\n        A[p][q] = (A[p - 1][q - 1] + A[p - 1][q] + A[p - 1][q + 1] + A[p][q - 1] + A[p][q] + A[p][q + 1] + A[p + 1][q - 1] + A[p + 1][q] + A[p + 1][q + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n- '#pragma ACCEL PIPELINE auto{__PIPE__L3}' for the loop over 'r' inside the 'kernel_seidel_2d' loop\n- '#pragma ACCEL TILE FACTOR=auto{__TILE__L3}' for the loop over 'r' inside the 'kernel_seidel_2d' loop\n- '#pragma ACCEL PIPELINE auto{__PIPE__L2}' for the loop over 'q' inside the 'kernel_seidel_2d' loop\n- '#pragma ACCEL TILE FACTOR=auto{__TILE__L2}' for the loop over 'q' inside the 'kernel_seidel_2d' loop\n- '#pragma ACCEL PIPELINE auto{__PIPE__L1}' for the loop over 'p' inside the 'kernel_seidel_2d' loop\n- '#pragma ACCEL TILE FACTOR=auto{__TILE__L1}' for the loop over 'p' inside the 'kernel_seidel_2d' loop\n\n\n #pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int p;\n  int q;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 32; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (p = 1; p < 120 - 1; p++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (q = 1; q < 120 - 1; q++) {\n        A[p][q] = (A[p - 1][q - 1] + A[p - 1][q] + A[p - 1][q + 1] + A[p][q - 1] + A[p][q] + A[p][q + 1] + A[p + 1][q - 1] + A[p + 1][q] + A[p + 1][q + 1]) / 9.0;\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (p = 1; p < 120 - 1; p++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (q = 1; q < 120 - 1; q++) {\n        A[p][q] -= 0.2 * (A[p][q] - ((A[p - 1][q - 1] + A[p - 1][q] + A[p - 1][q + 1] + A[p][q - 1] + A[p][q] + A[p][q + 1] + A[p + 1][q - 1] + A[p + 1][q] + A[p + 1][q + 1]) / 9.0));\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n- '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}' for the loop over 'p' inside the 'q' loop\n- '#pragma ACCEL PIPELINE auto{__PIPE__L3}' for the loop over 'r'\n- '#pragma ACCEL TILE FACTOR=auto{__TILE__L3}' for the loop over 'r'\n- '#pragma ACCEL PIPELINE auto{__PIPE__L4}' for the loop over 'q'\n- '#pragma ACCEL TILE FACTOR=auto{__TILE__L4}' for the loop over 'q'\n- '#pragma ACCEL PIPELINE auto{__PIPE__L5}' for the loop over 'p'\n- '#pragma ACCEL TILE FACTOR=auto{__TILE__L5}' for the loop over 'p'\n\n\n #pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n- '#pragma ACCEL PIPELINE auto{__PIPE__L3}' for the loop over 'r' in the inner 'kernel_seidel_2d'\n- '#pragma ACCEL TILE FACTOR=auto{__TILE__L3}' for the loop over 'r' in the inner 'kernel_seidel_2d'\n- '#pragma ACCEL PIPELINE auto{__PIPE__L2}' for the loop over 'q' in the inner 'kernel_seidel_2d'\n- '#pragma ACCEL TILE FACTOR=auto{__TILE__L2}' for the loop over 'q' in the inner 'kernel_seidel_2d'\n- '#pragma ACCEL PIPELINE auto{__PIPE__L1}' for the loop over 'p' in the inner 'kernel_seidel_2d'\n- '#pragma ACCEL TILE FACTOR=auto{__TILE__L1}' for the loop over 'p' in the inner 'kernel_seidel_2d'\n\n\n #pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int p;\n  int q;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 32; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (p = 1; p < 120 - 1; p++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (q = 1; q < 120 - 1; q++) {\n        A[p][q] = (A[p - 1][q - 1] + A[p - 1][q] + A[p - 1][q + 1] + A[p][q - 1] + A[p][q] + A[p][q + 1] + A[p + 1][q - 1] + A[p + 1][q] + A[p + 1][q + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To generate the given HLS codes in C, you should use the following natural language instructions for the #pragma values:\n\n1. Enable automatic pipelining for the loop: '#pragma ACCEL PIPELINE auto{flatten}'\n2. Specify the tiling factor automatically for the loop: '#pragma ACCEL TILE FACTOR=auto{1}'\n3. Set the parallelization factor automatically for the loop: '#pragma ACCEL PARALLEL FACTOR=auto{2}'\n4. Set the parallelization factor automatically for the inner loop: '#pragma ACCEL PARALLEL FACTOR=auto{6}' (inside the outer loop)\n5. Set the parallelization factor automatically for the inner loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}' (inside the outer loop)\n\nBy following these instructions, you can effectively incorporate hardware acceleration into the C codes using the specified HLS #pragma values.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n", "1": "\n", "2": "\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        double  _tmp_1 = 0.0;\n        double  _tmp_2 = 0.0;\n        double  _tmp_3 = 0.0;\n        double  _tmp_4 = 0.0;\n        double  _tmp_5 = 0.0;\n        double  _tmp_6 = 0.0;\n        double  _tmp_7 = 0.0;\n        double  _tmp_8 = 0.0;\n        double  _tmp_9 = 0.0;\n        _tmp_1 = ex[i][j + 1] - ex[i][j];\n        _tmp_2 = ey[i + 1][j] - ey[i][j];\n        _tmp_3 = hz[i + 1][j] - hz[i][j];\n        _tmp_4 = ex[i + 1][j + 1] - ex[i + 1][j];\n        _tmp_5 = ey[i + 1][j + 1] - ey[i + 1][j];\n        _tmp_6 = hz[i + 1][j + 1] - hz[i + 1][j];\n        _tmp_7 = ex[i][j] - ex[i][j + 1];\n        _tmp_8 = ey[i][j] - ey[i + 1][j];\n        _tmp_9 = hz[i][j] - hz[i + 1][j];\n        hz[i][j] = _hz_ex_ey + _fict_;\n        ey[i][j] = _ey_ex_hz + _tmp_9;\n      }\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes in C, follow these natural language instructions:\n- Mark the following function as a hardware kernel for acceleration: `#pragma ACCEL kernel`\n- Don't automatically pipeline any of the loops: `#pragma ACCEL PIPELINE \"off\"`\n- Process each loop in its original, full form without breaking it into smaller chunks: `#pragma ACCEL TILE FACTOR=1`\n- Run the iterations of each loop one after the other, not in parallel: `#pragma ACCEL PARALLEL FACTOR=1`", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "1": "\n \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_up = i + 1;\n        int j_up = j + 1;\n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7_0}\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_up][j] - ex[i][j]) - 0.7 * (ey[i][j_up] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": "\n \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_up = i + 1;\n        int j_right = j + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_up][j] - ex[i][j]) - 0.7 * (ey[i][j_right] - ey[i][j]) + 1.0 * q[i][j];\n      }\n    }\n  }\n}\n", "3": "\n \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_low = i - 1;\n        int i_high = i + 1;\n        int j_low = j - 1;\n        int j_high = j + 1;\n        double out = ((ex[i][j] - ex[i_low][j]) + (ey[i][j] - ey[i][j_low])) - ey[i_low][j_low];\n        double in = _fict_[i * j_high + j + 1];\n        hz[i][j] = out + in;\n      }\n    }\n  }\n}\n", "4": "\n-#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DX_2;\n  double DY_2;\n  double DX_4;\n  double DY_4;\n  double D;\n  double C1;\n  double C2;\n  double C1_2;\n  double C1_4;\n  double C2_2;\n  double A1;\n  double A2;\n  double A3;\n  double A4;\n  double mul1;\n  double mul2;\n  double mul3;\n  double mul4;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n  double g;\n  double h;\n  double coeff;\n  double _in_u;\n  double _in_v;\n  double _in_p;\n  double _in_q;\n  double _out_u;\n  double _out_v;\n  double _out_p;\n  double _out_q;\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n  for (t = 1; t <= 39; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (i = 1; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3_0}\n      for (j = 0; j < 59; j++) {\n        DX = (((double )(((int )i - 1) - ((int )60 - 1))) * 1.0);\n        DY = (((double )(((int )j - 1) - ((int )60 - 1))) * 1.0);\n        DX_2 = DX * DX;\n        DY_2 = DY * DY;\n        DX_4 = DX_2 * DX_2;\n        DY_4 = DY_2 * DY_2;\n        D = 2.0 * (DX_2 + DY_2) - DX_4 - DY_4;\n        C1 = exp(-(DX_4 - DY_4) / (2.0 * 2.10685678115243741622e-1));\n        C2 = exp(-(DX_4 + DY_4) / (2.0 * 2.10685678115243741622e-1));\n        C1_2 = C1 * C1;\n        C1_4 = C1_2 * C1_2;\n        C2_2 = C2 * C2;\n//A1 = C1_4 * (D2 - D3 - D4 + D5);\n//A2 = C2_4 * (D3 - D4 - A1);\n//A3 = C1_4 * (D4 - D5 - A2);\n//A4 = C2_4 * (D5 - D1 - A3 - A1);\n        mul1 = D2 * C1_4;\n        mul2 = D3 * C2_2;\n        mul3 = D4 * C1_4;\n        mul4 = D5 * C2_4;\n        a = mul1 - mul2 - mul3 + mul4;\n        b = mul2 - mul3 - a;\n        c = mul3 - a;\n        d = mul4 - a;\n//u_t[i][j] =  a*B1 + b*B2 + c*B3 + d*B4 +u[i][j];\n//v_t[i][j] =  a*B4 + b*B3 + c*B2 + d*B1  +v[i][j];\n//p_t[i][j] = -a*C1 - b*C2 - c*C3 - d*C4  +p[i][j];\n//q_t[i][j] = -a*D1 - b*D2 - c*D3 - d*D4  +q[i][j];\n        _in_u = ((double )u[i][j]);\n        _in_v = ((double )v[i][j]);\n        _in_p = ((double )p[i][j]);\n        _in_q = ((double )q[i][j]);\n        coeff = 2.095876209165944e-05;\n        A1 = coeff * C1_4 * (D2 - D3 - D4 + D5);\n        A2 = coeff * C2_4 * (D3 - D4 - A1);\n        A3 = coeff * C1_4 * (D4 - D5 - A2);\n        A4 = coeff * C2_4 * (D5 - D1 - A3 - A1);\n        _out_u = _in_u + coeff * (a * B1 + b * B2 + c * B3 + d * B4) + A1 * _in_u + A2 * _in_v + A3 * _in_p + A4 * _in_q;\n        _out_v = _in_v + coeff * (a * B4 + b * B3 + c * B2 + d * B1) - (A1 + A2 + A3 + A4) * _in_u;\n        _out_p = _in_p + coeff * (-a * C1 - b * C2 - c * C3 - d * C4) + (A1 * (_in_p - _in_u) + A2 * (_in_p - _in_v) + A3 * (_in_p - _in_p + _in_q) + A4 * (_in_p - _in_u - _in_v)) / 2.0;\n        _out_q = _in_q + coeff * (-a * D1 - b * D2 - c * D3 - d * D4) + (A1 * (_in_q - _in_u) + A2 * (_in_q - _in_v) + A3 * (_in_q - _in_p - _in_q) + A4 * (_in_q - _in_u - _in_v)) / 2.0;\n        u[i][j] = _out_u;\n        v[i][j] = _out_v;\n        p[i][j] = _out_p;\n        q[i][j] = _out_q;\n      }\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6_1}\n      for (j = 1; j < 59; j++) {\n        DX = (((double )(((int )i - 1) - ((int )60 - 1))) * 1.0);\n        DY = (((double )(((int )j - 1) - ((int )60 - 1))) * 1.0);\n        DX_2 = DX * DX;\n        DY_2 = DY * DY;\n        DX_4 = DX_2 * DX_2;\n        DY_4 = DY_2 * DY_2;\n        D = 2.0 * (DX_2 + DY_2) - DX_4 - DY_4;\n        C1 = exp"}}
{"input": "Process the loops with automatic pipelining and tiling. Also, use automatic flattening for the innermost loop to maximize parallelism. Treat the function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{2}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 0 + 1L * jump;\n        int _in_i = 0 + 1L * tile;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        zx[i][j] = sqrt((ex[i][j + 1] - ex[i][j]) * (ex[i][j + 1] - ex[i][j]) + (ey[i + 1][j] - ey[i][j]) * (ey[i + 1][j] - ey[i][j])) / (hx * hy);\n        zy[i][j] = sqrt((ey[i + 1][j] - ey[i][j]) * (ey[i + 1][j] - ey[i][j]) + (ex[i][j + 1] - ex[i][j]) * (ex[i][j + 1] - ex[i][j])) / (hx * hy);\n        hz[i][j] = hz[i][j] + 1.0 / (2.0 * (1.0 + zx[i][j] * zy[i][j])) * (qx[i][j + 1] - qx[i][j] + qy[i + 1][j] - qy[i][j] - zx[i][j] * ((ex[i][j + 1] - ex[i][j]) / (hx * hy)) - zy[i][j] * ((ey[i + 1][j] - ey[i][j]) / (hx * hy)));\n      }\n    }\n  }\n}\n"}}
{"input": "'Automatically pipeline the loops' \nfor '#pragma ACCEL PIPELINE auto{}'\n\n'Use automatic tiling factor for the loop' \nfor '#pragma ACCEL TILE FACTOR=auto{1}'\n\n'Automatically parallelize the loop with maximum factor of 2' \nfor '#pragma ACCEL PARALLEL FACTOR=auto{2}'\n\n'Automatically parallelize the inner loop with factor 8'\nfor 'pragma ACCEL PARALLEL FACTOR=auto{8}'\n\n'Automatically parallelize the inner loop with factor 6'\nfor 'pragma ACCEL PARALLEL FACTOR=auto{6}'\n\n'Treat the following function as a hardware kernel for acceleration' \nfor '#pragma ACCEL kernel'", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3_0}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4_0}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": "\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 2 * j;\n        int _in_i = 2 * i;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][_in_j + 1] - ex[i][_in_j] + ey[i][_in_i + 1] - ey[i][_in_i]);\n      }\n    }\n  }\n}\n", "4": "\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To generate the given HLS codes, use the following natural language instructions:\n\n\"Designate the following function as a hardware kernel for acceleration\"\n\n\"Automatically pipeline this loop, flattening the loop hierarchy\"\n\n\"Break this loop into smaller chunks with a factor of 8 for better acceleration\"\n\n\"Run the iterations of this loop in parallel, with a factor of 2\"\n\n\"Run the iterations of this inner loop in parallel, with a factor of 8\"\n\n\"Run the iterations of this loop one after the other, not in parallel\"", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "1": "\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": "\n\n \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_up = i + 1;\n        int j_up = j + 1;\n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7_0}\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_up][j] - ex[i][j]) - 0.7 * (ey[i][j_up] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DX2;\n  double DY2;\n  double DXDY;\n  double C1;\n  double C2;\n  double C12;\n  double C1D2;\n  double KX;\n  double KY;\n  double o_dT;\n  double b_dT;\n  double a;\n  double b_a;\n  double tmp;\n  double mul;\n  double add;\n  double mul1;\n  double add1;\n  double mul2;\n  double diff_u;\n  double diff_v;\n  double term_u;\n  double term_v;\n  double rho;\n  double rho_i;\n  double np;\n  double b_np;\n  double b_np_q;\n  double a_np;\n  double b_a_np;\n  double c_a;\n  double tmp_process;\n  double tmp_0;\n  double tmp_1;\n  double tmp_2;\n  double tmp_3;\n  double tmp_4;\n  double tmp_5;\n  double tmp_6;\n  double tmp_7;\n  double tmp_8;\n  double tmp_9;\n  double tmp_10;\n  double tmp_11;\n  double tmp_12;\n  double tmp_13;\n  double tmp_14;\n  double tmp_15;\n  double tmp_16;\n  double tmp_17;\n  double tmp_18;\n  double tmp_19;\n  double tmp_20;\n  double tmp_21;\n  double tmp_22;\n  double tmp_23;\n  double tmp_24;\n  double tmp_25;\n  double tmp_26;\n  double tmp_27;\n  double tmp_28;\n  double tmp_29;\n  double tmp_30;\n  double tmp_31;\n  double tmp_32;\n  double tmp_33;\n  double tmp_34;\n  double tmp_35;\n  double tmp_36;\n  double tmp_37;\n  double tmp_38;\n  double tmp_39;\n  double tmp_40;\n  double tmp_41;\n  double tmp_42;\n  double tmp_43;\n  double tmp_44;\n  double tmp_45;\n  double tmp_46;\n  double tmp_47;\n  double tmp_48;\n  double tmp_49;\n  double tmp_50;\n  double tmp_51;\n  double tmp_52;\n  double tmp_53;\n  double tmp_54;\n  double tmp_55;\n  double tmp_56;\n  double tmp_57;\n  double tmp_58;\n  double tmp_59;\n  double tmp_60;\n  double tmp_61;\n  double tmp_62;\n  double tmp_63;\n  double tmp_64;\n  double tmp_65;\n  double tmp_66;\n  double tmp_67;\n  double tmp_68;\n  double tmp_69;\n  double tmp_70;\n  double tmp_71;\n  double tmp_72;\n  double tmp_73;\n  double tmp_74;\n  double tmp_75;\n  double tmp_76;\n  double tmp_77;\n  double tmp_78;\n  double tmp_79;\n  double tmp_80;\n  double tmp_81;\n  double tmp_82;\n  double tmp_83;\n  double tmp_84;\n  double tmp_85;\n  double tmp_86;\n  double tmp_87;\n  double tmp_88;\n  double tmp_89;\n  double tmp_90;\n  double tmp_91;\n  double tmp_92;\n  double tmp_93;\n  double tmp_94;\n  double tmp_95;\n  double tmp_96;\n  double tmp_97;\n  double tmp_98;\n  double tmp_99;\n  double tmp_100;\n  double tmp_101;\n  double tmp_102;\n  double tmp_103;\n  double tmp_104;\n  double tmp_105;\n  double tmp_106;\n  double tmp_107;\n  double tmp_108;\n  double tmp_109;\n  double tmp_110;\n  double tmp_111;\n  double tmp_112;\n  double tmp_113;\n  double tmp_114;\n  double tmp_115;\n  double tmp_116;\n  double tmp_117;\n  double tmp_118;\n  double tmp_119;\n  double tmp_120;\n  double tmp_121;\n  double tmp_122;\n  double tmp_123;\n  double tmp_124;\n  double tmp_125;\n  double tmp_126;\n  double tmp_127;\n  double tmp_128;\n  double tmp_129;\n  double tmp_130;\n  double tmp_131;\n  double tmp_132;\n  double tmp_133;\n  double tmp_134;\n  double tmp_135;\n  double tmp_136;\n  double tmp_137;\n  double tmp_138;\n  double tmp_139;\n  double tmp_140;\n  double tmp_141;\n  double tmp_142;\n  double tmp_143;\n  double tmp_144;\n  double tmp_145;\n  double tmp_146;\n  double tmp_147;\n  double tmp_148;\n  double tmp_149;\n  double tmp_150;\n  double tmp_151;\n  double tmp_152;\n  double tmp_153;\n  double tmp_154;\n  double tmp_155;\n  double tmp_156;\n  double tmp_157;\n  double tmp_158;\n  double tmp_159;\n  double tmp_160;\n  double tmp_161;\n  double tmp_162;\n  double tmp_163;\n  double tmp_164;\n  double tmp_165;\n  double tmp_166;\n  double tmp_167;\n  double tmp_168;\n  double tmp_169;\n  double tmp_170;\n  double tmp_171;\n  double tmp_172;\n  double tmp_173;\n  double tmp_174;\n  double tmp_175;\n  double tmp_176;\n  double tmp_177;\n  double tmp_178;\n  double tmp_179;\n  double tmp_180;\n  double tmp_181;\n  double tmp_182;\n  double tmp_183;\n  double tmp_184;\n  double tmp_185;\n  double tmp_186;\n  double tmp_187;\n  double tmp_188;\n  double tmp_189;\n  double tmp_190;\n  double tmp_191;\n  double tmp_192;\n  double tmp_193;\n  double tmp_194;\n  double tmp_195;\n  double tmp_196;\n  double tmp_197;\n  double tmp_198;\n  double tmp_199;\n  double tmp_200;\n  double tmp_201;\n  double tmp_202;\n  double tmp_203;\n  double tmp_204;\n  double tmp_205;\n  double", "4": "\n\n #pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DX2;\n  double DY2;\n  double DXDY;\n  double C1;\n  double C2;\n  double C12;\n  double C1D2;\n  double x;\n  double y;\n  double u_x;\n  double u_y;\n  double v_x;\n  double v_y;\n  double p_x;\n  double p_y;\n  double q_x;\n  double q_y;\n  double rho;\n  double tmp;\n  double b1;\n  double b2;\n  double a1;\n  double a2;\n  double nu;\n\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 1; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; ++i) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 59; ++j) {\n        DX = ((double )(((int )(((double )60) / ((double )600.0)))));\n        DY = ((double )(((int )(((double )60) / ((double )600.0)))));\n        DX2 = DX * DX;\n        DY2 = DY * DY;\n        DXDY = DX * DY;\n        C1 = 1.0 / (DX2 + DY2);\n        C2 = 1.0 / (2.0 * (1.0 + DX2 + DY2));\n        C12 = C1 * C2;\n        C1D2 = C1 / D2;\n        x = (((int )DX) * i) + 1;\n        y = (((int )DY) * j) + 1;\n        u_x = (u[i + 1][j] - u[i - 1][j]) / ((double )2 * DX);\n        u_y = (u[i][j + 1] - u[i][j - 1]) / ((double )2 * DY);\n        v_x = (v[i + 1][j] - v[i - 1][j]) / ((double )2 * DX);\n        v_y = (v[i][j + 1] - v[i][j - 1]) / ((double )2 * DY);\n        p_x = ((-1.0 * (u_x * u[i][j] - u_y * v[i][j]) + q[i][j]) / ((double )C12 * rho[i][j]) - (u[i][j] * (p[i + 1][j] - p[i - 1][j])) / ((double )2.0 * DX2) + (v[i][j] * (p[i][j + 1] - p[i][j - 1])) / ((double )2.0 * DY2)) + (((((float ) 1.0) / (((float ) 4.0) * DX2)) * (u[i + 1][j + 1] - u[i + 1][j - 1] - u[i - 1][j + 1] + u[i - 1][j - 1])) + (((float ) 1.0) / (((float ) 4.0) * DY2) * (v[i + 1][j + 1] - v[i - 1][j + 1] - v[i + 1][j - 1] - v[i - 1][j - 1]))) * (p[i][j + 1] - p[i][j - 1] - p[i - 1][j] + p[i + 1][j])) / (((double )2) * (1.0 + u_x * ((double )2.0) * DX + v_x * ((double )2.0) * DY));\n        p_y = ((-1.0 * (u_x * v[i][j] - u_y * u[i][j]) + q[i][j]) / ((double )C12 * rho[i][j]) - (u[i][j] * (p[i + 1][j] - p[i - 1][j])) / ((double )2.0 * DX2) + (v[i][j] * (p[i][j + 1] - p[i][j - 1])) / ((double )2.0 * DY2)) + (((((float ) 1.0) / (((float ) 4.0) * DX2)) * (v[i + 1][j + 1] - v[i + 1][j - 1] - v[i - 1][j + 1] + v[i - 1][j - 1])) + (((float ) 1.0) / (((float ) 4.0) * DY2) * (u[i + 1][j + 1] - u[i - 1][j + 1] - u[i + 1][j - 1] - u[i - 1][j - 1]))) * (p[i + 1][j] - p[i - 1][j] - p[i][j + 1] + p[i][j - 1])) / (((double )2) * (1.0 + u_x * ((double )2.0) * DX + v_x * ((double )2.0) * DY));\n        q_x = -1.0 * (u_x * p[i][j] - v_x * ((double )q[i][j]) + ((double )2.0) * (u_x * u_x * u[i][j] + v_x * v_x * v[i][j] - ((double )2.0) * u_x * v_x * (u[i][j] + v[i][j])) / (1.0 + u_x * ((double )2.0) * DX + v_x * ((double )2.0) * DY)) / (DX2 + ((double )2.0) * DX * DY + DY2);\n        q_y = -1.0 * (u_y * p[i][j] - v_y * ((double )q[i][j]) + ((double )2.0) * (u_y * u_y * u[i][j] + v_y * v_y * v[i][j] - ((double )2.0) * u_y * v_y * (u[i][j] + v[i][j])) / (1.0 + u_x * ((double )2.0) * DX + v_x * ((double )2.0) * DY)) / (DX2 + ((double )2.0) * DX * DY + DY2);\n        tmp = - 1.0 * (u_x * u_y * (u[i][j] - ((double )2.0) * (u[i][j] + v[i][j]) / ((double )3.0) + v[i][j]) + v_x * v_y * (v[i][j] - ((double )2.0) * (v[i][j] + u[i][j]) / ((double )3.0) + u[i][j])) / (1.0 + u_x * ((double )2.0) * DX + v_x * ((double )2.0) * DY);\n        b1 = p_x - tmp * v_y;\n"}}
{"input": "To generate the given HLS codes in C, you should use the following concise but comprehensive natural language instruction:\n\n\"Designate the following function as a hardware kernel for acceleration, pipeline the loop automatically, set the tile factor to 1 automatically, and parallelize the loops with factors of 2, 8, and 12 automatically.\"\n\nThis instruction encompasses the specific #pragma values and their configurations needed to generate the provided HLS codes in C.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "1": "\n#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "2": "\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int s = signum(ex[i][j] - ex[i][j + 1]);\n        int e = signum(ey[i][j] - ey[i + 1][j]);\n        int f = signum(hz[i][j] - hz[i + 1][j]);\n        int g = signum(s - e);\n        int d = signum(e - f);\n        int h = signum(f - s);\n        hz[i][j] = hz[i][j] + 0.7 * (s * (ey[i][j + 1] - ey[i][j]) + e * (ex[i + 1][j] - ex[i][j]) + f * (hz[i + 1][j] - hz[i][j + 1]) - g * (hz[i + 1][j + 1] - hz[i][j]) - d * (hz[i + 1][j - 1] - hz[i][j]) - h * (ex[i + 1][j + 1] - ex[i + 1][j]) + d * (ex[i + 1][j - 1] - ex[i][j - 1]) - h * (ey[i + 1][j + 1] - ey[i][j + 1]) + g * (ey[i + 1][j - 1] - ey[i][j - 1])));\n        ey[i][j] = ey[i][j] + 0.7 * (g * (hz[i + 1][j + 1] - hz[i][j + 1]) + d * (hz[i + 1][j] - hz[i][j]) - h * (ex[i + 1][j + 1] - ex[i][j + 1]) + d * (ex[i + 1][j] - ex[i][j]) - h * (ey[i + 1][j + 1] - ey[i][j + 1]));\n        ex[i][j] = ex[i][j] + 0.7 * (d * (hz[i][j + 1] - hz[i][j]) - h * (ey[i][j + 1] - ey[i][j]) + g * (ex[i + 1][j + 1] - ex[i][j + 1]) - d * (ex[i + 1][j] - ex[i][j]));\n      }\n    }\n  }\n}\n", "4": " The C codes are provided below:\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        double  delta = 1.0 / ((double )(1 << 12));\n        double  p1 = ex[i][j] - ex[i][j + 1];\n        double  p2 = ey[i][j] - ey[i + 1][j];\n        double  p3 = hz[i][j] - hz[i + 1][j];\n        double  p4 = hz[i][j + 1] - hz[i + 1][j + 1];\n        double  Dx = (-p1 + p2) * delta;\n        double  Dy = (-p2 + p3) * delta;\n        double  Dz = (p3 - p4) * delta;\n        double  ex_x = Dx * ex[i][j] + Dy * ex[i][j + 1] + Dz * ex[i][j + 1];\n        double  ey_y = Dy * ey[i][j] + Dx * ey[i + 1][j] + Dz * ey[i][j + 1];\n        double  hz_z = Dz * hz[i][j] + Dy * hz[i][j + 1] + Dx * hz[i + 1][j + 1];\n        double  ex_x_p1 = Dx * ex_x + Dy * ey_y + Dz * hz_z;\n        ex[i][j] = ex_x - ex_x_p1 * 1.0;\n        ey[i][j] = ey_y - ex_x_p1;\n        hz[i][j] = hz_z - ex_x_p1;\n      }\n    }\n  }\n}\n"}}
{"input": "Apply full pipeline off and tile factor of 1 to the outer and inner loops of the 'kernel_doitgen' function.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{}\n      \n#pragma ACCEL TILE FACTOR=auto{2}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n#pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][24][20],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 24; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 20; p++) {\n        double sum_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=sum_tmp FACTOR=auto{__PARA__L3}\n\tfor (s = 0; s < 30; s++) {\n          sum_tmp += A[r][p][s] * C4[s][q][p];\n        }\n\tsum[q] = sum_tmp;\n      }\n      for (p = 0; p < 20; p++) {\n        A[r][p][0] = sum[q] + 1.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n  \n#pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][24])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = ((double )(r + 1));\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    for (q = 0; q < 24; q++) {\n      C4[r][q] = 0.0;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n      for (p = 0; p < 30; p++) {\n        for (s = 0; s < 24; s++) {\n          C4[p][s] += A[r][q][p] * C4[q][s];\n        }\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n#pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][24][20],double D[25][20][24])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 24; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 20; p++) {\n        A[r][p][q] = ((double )0);\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n      for (p = 0; p < 30; p++) {\n        double sum = 0.0;\n#pragma ACCEL PARALLEL reduction=sum FACTOR=auto{__PARA__L5}\n\tfor (s = 0; s < 24; s++) {\n          sum += A[s][p][r] * C4[s][q][r];\n        }\n        D[r][q][p] = sum;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n *\n * @param tsteps\n * @param A\n * @param B\n * @param C\n * @param D\n */\n #pragma ACCEL kernel\n\nvoid kernel_2mm(double A[250][250],double B[250][250],double C[250][250],double D[250][250])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (i = 0; i < 250; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    for (j = 0; j < 250; j++) {\n      A[i][j] = ((double )0);\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (i = 0; i < 250; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    for (j = 0; j < 250; j++) {\n      B[i][j] = ((double )0);\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (i = 0; i < 250; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    for (k = 0; k < 250; k++) {\n      for (j = 0; j < 250; j++) {\n        A[i][j] += C[k][i] * D[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (i = 0; i < 250; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n    for (j = 0; j < 250; j++) {\n      for (k = 0; k < 250; k++) {\n        B[i][j] += A[k][j] * D[k][i];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n\t\t\t\t#pragma ACCEL PIPELINE auto{off}\n\t\t\t\t\n\t\t\t\t//#pragma ACCEL TILE FACTOR=auto{1}\n\t\t\t\t \n\t\t\t\t//#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n\t\t\t\tfor (tj = 4; tj <= 36; tj += 4) {\n\t\t\t\t  L2:\n\t\t\t\t  for (ti = 4; ti <= 36; ti += 4) {\n\t\t\t\t    mult[tj][ti] = x[tj][ti] * y[tj][ti];\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//#pragma ACCEL PIPELINE auto{off}\n\t\t\t\t\n\t\t\t\t//#pragma ACCEL TILE FACTOR=auto{1}\n\t\t\t\t \n\t\t\t\t//#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n\t\t\t\tfor (tj = 4; tj < 40; tj++) {\n\t\t\t\t  sj = tj * 20;\n\t\t\t\t  \n#pragma ACCEL PIPELINE auto{off}\n\t\t\t\t  L3:\n\t\t\t\t  for (ti = 4; ti < 40; ti++) {\n\t\t\t\t    si = ti * 20;\n\t\t\t\t    s = 0.0;\n\t\t\t\t    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n\t\t\t\t    L4:\n\t\t\t\t    for (aj = 0; aj < 4; aj++) {\n\t\t\t\t      L5:\n\t\t\t\t      for (ai = 0; ai < 4; ai++) {\n\t\t\t\t        s = s + x[sj + aj][si + ai] * mult[aj][ai + ti];\n\t\t\t\t      }\n\t\t\t\t    }\n\t\t\t\t    z[sj][si] = s;\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t  }\n\t\t\t}\n\t\t  }\n\t\t}\n\t }\n  }\n  \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[20][20],double ey[20][20],double hz[20][20],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n  int k;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 20; j++) {\n      ey[j][0] = _fict_[j];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (i = 0; i < 20; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 20; j++) {\n        ex[j][i] = 0.0;\n      }\n      \n      ey[i][0] = 0.0;\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (k = 1; k < 20; k++) {\n        \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n        for (j = 0; j < 20; j++) {\n          ex[j][i] += 0.25 * (hz[j][k + 1] - hz[j][k - 1]) + 0.25 * (hz[j + 1][k + 1] - hz[j - 1][k + 1]) - 0.25 * (hz[j + 1][k - 1] - hz[j - 1][k - 1]);\n        }\n        ey[i][k] = 0.0;\n        \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n        for (j = 0; j < 20; j++) {\n          ey[j][i] += 0.25 * (hz[k + 1][j] - hz[k - 1][j]) + 0.25 * (hz[j + 1][k + 1] - hz[j - 1][k + 1]) - 0.25 * (hz[j + 1][k - 1] - hz[j - 1][k - 1]);\n        }\n        hz[i][k] = _fict_[i * k] + 0.25 * (ex[i][k] - ex[i][k - 1]) + 0.25 * (ey[i][k] - ey[i][k - 1]);\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "Process the loops with automatic pipelining and tiling with a factor of 1, and flatten the inner loop with a tiling factor of 4. Treat the function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{4}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 30; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 0 + 1L * (-1L + 0L) + 1L * 1L;\n        int _in_i = 0 + 1L * (-1L + 0L) + 1L * 1L;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n"}}
{"input": "\"Perform loop pipelining and do not automatically parallelize the loops; tile the loops with a factor of 1 for r, q, and p loops; and treat the function as a hardware kernel for acceleration.\"", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{4}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\ninline void kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n  for (p = 0; p < 32; p++) {\n    for (r = 0; r < 32; r++) {\n      tmp = A[r] * B[p];\n      C[p] += tmp;\n    }\n  }\n}\n", "2": "\ninline void kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 240;\n        int _in_i = 200;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": "\n  for (p = 0; p < 32; p++) {\n    for (r = 0; r < 32; r++) {\n      tmp = A[p][r];\n      B[p][r] = 0.0;\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (q = 0; q < 32; q++) {\n        B[p][r] += tmp * C[p][q] * D[q][r];\n      }\n    }\n  }\n}\n", "4": "\n  for (r = 0; r < 32; r++) {\n    for (q = 0; q < 32; q++) {\n      tmp = ((double )0);\n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (p = 0; p < 32; p++) {\n        tmp += A[r][p] * B[p][q];\n      }\n      C[r][q] = tmp;\n    }\n  }\n}\n"}}
{"input": "1. Ensure that the loop is automatically pipelined: `#pragma ACCEL PIPELINE auto{flatten}`\n\n2. Break the loop into smaller chunks with automatic tile factor calculation: `#pragma ACCEL TILE FACTOR=auto{1}`\n\n3. Parallelize the loop with automatic factor calculation: `#pragma ACCEL PARALLEL FACTOR=auto{3}`\n\n4. Run the iterations of this loop one after the other, not in parallel: `#pragma ACCEL PARALLEL FACTOR=auto{1}`\n\nEnsure that the following function is treated as a hardware kernel for acceleration: `#pragma ACCEL kernel`", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n  \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "1": "\n  \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": "\n  \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _row = i * 240 + j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": "\n  \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "\n  \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        double \u03b4x = dx;\n        double \u03b4y = dy;\n        double \u03bcx = _mu * \u03b4x;\n        double \u03bcy = _mu * \u03b4y;\n        double sigma = sqrt(\u03bcx * \u03bcx + \u03bcy * \u03bcy);\n        double ex_x = ex[i][j] - ex[i][j + 1];\n        double ey_y = ey[i][j] - ey[i + 1][j];\n        double ey_x = ey[i][j] - ex[i + 1][j];\n        double ex_y = ex[i][j] - ey[i][j + 1];\n        hz[i][j] = hz[i][j] + \u03c3x * \u03bcx * sigma * (ex_x - ex_y) + \u03c3y * \u03bcy * sigma * (ey_x - ey_y);\n      }\n    }\n  }\n}\n"}}
{"input": "Process the loops with tiling, automatically determining the factor for tiling. Pipeline the outer loop and the innermost loops, with automatic determination of pipeline scheduling. Use flatten pipeline for the innermost loop to optimize for vectorization. This function is a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5_0}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{off_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1_1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5_1}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5_1_0}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1_2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5_2}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5_2_0}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1_3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5_3}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5_3_0}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "Process the loops in this function in parallel and pipeline the innermost loop. Use auto scheduling for both tiling and pipelining.\nUse \"#pragma ACCEL PIPELINE auto{}\" for pipelining,\nand \"#pragma ACCEL TILE FACTOR=auto{8}\" for the outer loop,\n\"#pragma ACCEL TILE FACTOR=auto{1}\" for the middle loop,\nand \"#pragma ACCEL TILE FACTOR=auto{1}\" for the innermost loop.\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": " #pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": " #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": " #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": " #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L8}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": " #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _row = i * 240 + j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n"}}
{"input": "Process the loops in their original, full form without breaking them into smaller chunks, and do not automatically pipeline the loops. Treat the following function as a hardware kernel for acceleration.\n```c\n#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr, int nq, int np, double A[25][20][30], double C4[30][30], double sum[30]) {\n  int r;\n  int q;\n  int p;\n  int s;\n  \n  #pragma ACCEL PIPELINE auto{off}\n  #pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    #pragma ACCEL PIPELINE auto{off}\n    #pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      #pragma ACCEL PIPELINE auto{off}\n      #pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n}\n```", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n# Buffer\nauto{off}\n \n# NumTiles\n1\n", "1": "\n# Buffer\nauto{off}\n \n# NumTiles\n1\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n# Bufferized kernel_doitgen (bufferized_kernel_doitgen)\n#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n# Bufferization\n \n# Tiling\n \n# Automatic Pipelining\n \n# Auto-Config\n"}}
{"input": "To generate the given HLS codes in C:\n1. Mark the following function as a hardware kernel for acceleration: `#pragma ACCEL kernel`\n2. Don't automatically pipeline the outer loop: `#pragma ACCEL PIPELINE \"off\"`\n3. Process the outer loop in its original, full form without breaking it into smaller chunks: `#pragma ACCEL TILE FACTOR=1`\n4. Run the iterations of the outer loop one after the other, not in parallel: `#pragma ACCEL PARALLEL FACTOR=1`", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n5. Mark the following loop as a parallelized loop : \n   \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n   for (j = 1; j <= 20; j++) {\n      b[j] = b[j] + 1.0;\n    }\n\n6. Mark the following loop as a parallelized loop : \n   \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n   for (i = 1; i < 120; i++) {\n      s[i] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 1; j < 20; j++) {\n         s[i] = s[i] + a[i][j] * b[j];\n      }\n    }\n\n", "1": "\n5. Don't automatically distribute the inner loop across multiple cores: `#pragma ACCEL PIPELINE auto{off}`\n6. Don't automatically parallelize the inner loop across multiple cores: `#pragma ACCEL PARALLEL FACTOR=auto{1}`\n7. Don't automatically parallelize the inner-most loop across multiple cores: `#pragma ACCEL PARALLEL FACTOR=auto{1}`\n \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": "\n5. Mark the following loop as a parallelized one: \n   \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (j = 16; j < 48; j++) {\n      e = beta * y[j];\n      v = z[j];\n      p = q = e;\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L8}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L8}\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n      for (i = 0; i < 40; i++) {\n        POLYBENCH_POWER_BRAID_2_MULT(p, q, x[i], y[i])\n      }\n      y[j] = v + p;\n      z[j] = q;\n    }\n\n", "3": "\n5. Automatically parallelize the inner loop with a parallelization factor of 2: \n `#pragma ACCEL PARALLEL FACTOR=auto{2}`\n\n**_Inputs:_**\n\n**A:** 128x128\n\n**B:** 128x128\n\n**C:** 128x128\n\n**_Output:_**  C\n\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,int al,int be,int ce,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "4": "\n5. Mark the following loop as a parallelized one: \n   \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n    for (j = 16; j < 64; j++) {\n      b[j] = b[j] + b[j - 16];\n    }\n\n6. Mark the following loop as a parallelized one: \n   \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (i = 1; i < 64; i++) {\n      a[i] = a[i] + a[i - 1];\n      tmp = a[i] * b[i];\n      c[i] = tmp + c[i - 1];\n    }\n\n7. Mark the following loop as a parallelized one: \n   \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 63; i >= 16; i--) {\n      b[i] = b[i] + b[i - 1];\n    }\n\n8. Mark the following loop as a parallelized one: \n   \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 15; i < 64; i++) {\n      tmp2 = c[i];\n      SIMD_LFCT2 tmp3 = a[i] * b[i];\n      SIMD_LFCT2 tmp4 = tmp3 * (SIMD_LF)1.5;\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = i + 1; j < 64; j++) {\n        tmp2 = tmp2 + a[j] * b[j];\n      }\n      c[i] = tmp2 + tmp4;\n    }\n// Matrix multiplication\n  \n#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double A[60][80],double B[60][90],double C[80][90])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* Standardize from: for(i = 0;i < 60;++i) {...} */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n/* Standardize from: for(j = 0;j < 80;++j) {...} */\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      A[i][j]:A[0][0];\n      B[i][j]:B[0][0];\n      C[i][j]:C[0][0] = ((double )0);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (k = 0; k < 90; k++) {\n/* Standardize from: for(j = 0;j < 80;++j) {...} */\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{1}\n      for (j = 0; j < 80; j++) {\n        C[i][k]:C[0][0];\n        A[i][k] * B[k][j]\n        ;\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "Process the loops with automatic pipeline optimization, and keep the original loop structure without breaking it into smaller chunks.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "1": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 0 + 1L * 240L * i;\n        int _in_j_2 = 1 + 1L * 240L * i;\n        int _in_i = 0 + 1L * 240L * j;\n        int _in_i_2 = 1 + 1L * 240L * j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": "\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        double  _tmp_1 = 0.0;\n        double  _tmp_2 = 0.0;\n        double  _tmp_3 = 0.0;\n        double  _tmp_4 = 0.0;\n        double  _tmp_5 = 0.0;\n        double  _tmp_6 = 0.0;\n        double  _tmp_7 = 0.0;\n        double  _tmp_8 = 0.0;\n        double  _tmp_9 = 0.0;\n        _tmp_1 = ex[i][j + 1] - ex[i][j];\n        _tmp_2 = ey[i + 1][j] - ey[i][j];\n        _tmp_3 = hz[i][j + 1] - hz[i][j];\n        _tmp_4 = hz[i + 1][j] - hz[i][j];\n        _tmp_5 = _tmp_1 * _tmp_2;\n        _tmp_6 = _tmp_1 * _tmp_3;\n        _tmp_7 = _tmp_2 * _tmp_3;\n        _tmp_8 = _tmp_4 - _tmp_3;\n        _tmp_9 = _tmp_1 * _tmp_8;\n        ey[i][j] = _tmp_5 - _tmp_9;\n        ex[i][j] = _tmp_6 - _tmp_7;\n        hz[i][j] = _tmp_3 + ((_tmp_4 - _tmp_5) - (_tmp_6 - _tmp_7));\n      }\n    }\n  }\n}\n", "3": "\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 0 + 1L * ;\n}\n\n \nint main(int argc,char** argv) {\n  int tmax = 40;\n  int nx = 240;\n  int ny = 240;\n  \n#pragma ACCEL param:tmax = 40\n  \n#pragma ACCEL param:nx = 240\n  \n#pragma ACCEL param:ny = 240\n  double ex[200][240];\n  double ey[200][240];\n  double hz[200][240];\n  double _fict_[100];\n  \n#pragma ACCEL array:ex\n  ;\n  \n#pragma ACCEL array:ey\n  ;\n  \n#pragma ACCEL array:hz\n  ;\n  \n#pragma ACCEL array:_fict_\n  ;\n  kernel_fdtd_2d(tmax,nx,ny,ex,ey,hz,_fict_);\n  \n#pragma ACCEL exit\nj;\n        int _in_i = 0 + 1L * i;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n\n \nint main(int argc,char** argv) {\n  int tmax = 40;\n  int nx = 240;\n  int ny = 240;\n  double ex[200][240];\n  double ey[200][240];\n  double hz[200][240];\n  double _fict_[100];\n  \n#pragma ACCEL kernel\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  kernel_fdtd_2d(tmax,nx,ny,ex,ey,hz,_fict_);\n}\n \nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 0 + 1L * j;\n        int _in_i = 0 + 1L * i;\n        hz[i][j] = hz[i][j] - 0", "4": "\n\n\t.file\t\"optimize_loop.c\"\n\t.section .mdebug.abi32\n\t.previous\n\t.text\n\t.align 2\n\t.p2align 4,,15\n\t.global optimize_loop\n\t.type\toptimize_loop, @function\noptimize_loop:\n.LFB34:\n\t.cfi_startproc\n\tpushl\t%ebp\n\t.cfi_def_cfa_offset 8\n\t.cfi_offset 5, -8\n\tmovl\t%esp, %ebp\n\t.cfi_def_cfa_register 5\n\tsubl\t$168, %esp\n\tleal\t160(%ebp), %eax\n\tmovl\t%eax, 120(%esp)\n\tleal\t156(%ebp), %eax\n\tmovl\t%eax, 116(%esp)\n\tleal\t152(%ebp), %eax\n\tmovl\t%eax, 112(%esp)\n\tleal\t148(%ebp), %eax\n\tmovl\t%eax, 108(%esp)\n\tleal\t144(%ebp), %eax\n\tmovl\t%eax, 104(%esp)\n\tleal\t140(%ebp), %eax\n\tmovl\t%eax, 100(%esp)\n\tleal\t136(%ebp), %eax\n\tmovl\t%eax, 96(%esp)\n\tleal\t132(%ebp), %eax\n\tmovl\t%eax, 92(%esp)\n\tleal\t128(%ebp), %eax\n\tmovl\t%eax, 88(%esp)\n\tleal\t124(%ebp), %eax\n\tmovl\t%eax, 84(%esp)\n\tleal\t120(%ebp), %eax\n\tmovl\t%eax, 80(%esp)\n\tleal\t116(%ebp), %eax\n\tmovl\t%eax, 76(%esp)\n\tleal\t112(%ebp), %eax\n\tmovl\t%eax, 72(%esp)\n\tleal\t108(%ebp), %eax\n\tmovl\t%eax, 68(%esp)\n\tleal\t104(%ebp), %eax\n\tmovl\t%eax, 64(%esp)\n\tleal\t100(%ebp), %eax\n\tmovl\t%eax, 60(%esp)\n\tleal\t96(%ebp), %eax\n\tmovl\t%eax, 56(%esp)\n\tleal\t92(%ebp), %eax\n\tmovl\t%eax, 52(%esp)\n\tleal\t88(%ebp), %eax\n\tmovl\t%eax, 48(%esp)\n\tleal\t84(%ebp), %eax\n\tmovl\t%eax, 44(%esp)\n\tleal\t80(%ebp), %eax\n\tmovl\t%eax, 40(%esp)\n\tleal\t76(%ebp), %eax\n\tmovl\t%eax, 36(%esp)\n\tleal\t72(%ebp), %eax\n\tmovl\t%eax, 32(%esp)\n\tleal\t68(%ebp), %eax\n\tmovl\t%eax, 28(%esp)\n\tleal\t64(%ebp), %eax\n\tmovl\t%eax, 24(%esp)\n\tleal\t60(%ebp), %eax\n\tmovl\t%eax, 20(%esp)\n\tleal\t56(%ebp), %eax\n\tmovl\t%eax, 16(%esp)\n\tleal\t52(%ebp), %eax\n\tmovl\t%eax, 12(%esp)\n\tleal\t48(%ebp), %eax\n\tmovl\t%eax, 8(%esp)\n\tleal\t44(%ebp), %eax\n\tmovl\t%eax, 4(%esp)\n\tleal\t40(%ebp), %eax\n\tmovl\t%eax, (%esp)\n\tcall\tbbgemm\n\tmovl\t120(%ebp), %eax\n\tmovl\t%eax, 8(%esp)\n\tmovl\t116(%ebp), %eax\n\tmovl\t%eax, 4(%esp)\n\tmovl\t112(%ebp), %eax\n\tmovl\t%eax, (%esp)\n\tcall\tbbgemm\n\tmovl\t108(%ebp), %eax\n\tmovl\t%eax, 8(%esp)\n\tmovl\t104(%ebp), %eax\n\tmovl\t%eax, 4(%esp)\n\tmovl\t100(%ebp), %eax\n\tmovl\t%eax, (%esp)\n\tcall\tbbgemm\n\tmovl\t96(%ebp), %eax\n\tmovl\t%eax, 8(%esp)\n\tmovl\t92(%ebp), %eax\n\tmovl\t%eax, 4(%esp)\n\tmovl\t88(%ebp), %eax\n\tmovl\t%eax, (%esp)\n\tcall\tbbgemm\n\tmovl\t84(%ebp), %eax\n\tmovl\t%eax, 8(%esp)\n\tmovl\t80(%ebp), %eax\n\tmovl\t%eax, 4(%esp)\n\tmovl\t76(%ebp), %eax\n\tmovl\t%eax, (%esp)\n\tcall\tbbgemm\n\tmovl\t72(%ebp), %eax\n\tmovl\t%eax, 8(%esp)\n\tmovl\t68(%ebp), %eax\n\tmovl\t%eax, 4(%esp)\n\tmovl\t64(%ebp), %eax\n\tmovl\t%eax, (%esp)\n\tcall\tbbgemm\n\tmovl\t60(%ebp), %eax\n\tmovl\t%eax, 8(%esp)\n\tmovl\t56(%ebp), %eax\n\tmovl\t%eax, 4(%esp)\n\tmovl\t52(%ebp), %eax\n\tmovl\t%eax, (%esp)\n\tcall\tbbgemm\n\tmovl\t48(%ebp), %eax\n\tmovl\t%eax, 8(%esp)\n\tmovl\t44(%ebp), %eax\n\tmovl\t%eax, 4(%esp)\n\tmovl\t40(%ebp), %eax\n\tmovl\t%eax, (%esp)\n\tcall\tbbgemm\n\tmovl\t36(%ebp), %eax\n\tmovl\t%eax, 8(%esp)\n\tmovl\t32(%ebp), %eax\n\tmovl\t%eax, 4(%esp)\n\tmovl\t28(%ebp), %eax\n\tmovl\t%eax, (%esp)\n\tcall\tbbgemm\n\tmovl\t24(%ebp), %eax\n\tmovl\t%eax, 8(%esp)\n\tmovl\t20(%ebp), %eax\n\tmovl\t%eax, 4(%esp)\n\tmovl\t16(%ebp), %eax\n\tmovl\t%eax, (%esp)\n\tcall\tbbgemm\n\tmovl\t12(%ebp), %eax\n\tmovl\t%eax, 8(%esp)\n\tmovl\t8(%ebp), %eax\n\tmovl\t%eax, 4(%esp)\n\tmovl\t4(%ebp), %eax\n\tmovl\t%eax, (%esp)\n\tcall\tbbgemm\n\tmovl\t4(%ebp), %eax\n\tmovl\t%eax, 4(%esp)\n\tmovl\t%eax, (%esp)\n\tcall\tbcopy\n\tmovl\t4(%ebp), %e"}}
{"input": "To optimize the following C code for hardware acceleration, use the following comprehensive but concise natural language instructions for the specific #pragma values:\n\n1. Enable automatic pipeline optimization for loops: Use '#pragma ACCEL PIPELINE auto{flatten}' to automatically optimize loop pipelining.\n\n2. Keep the original loop structure intact without breaking it into smaller chunks: Use '#pragma ACCEL TILE FACTOR=auto{1}' to maintain the original loop structure.\n\n3. Run loop iterations in parallel, with a factor of 3: Use '#pragma ACCEL PARALLEL FACTOR=auto{3}' to parallelize the loop iterations with a factor of 3.\n\n4. Treat the following function as a hardware kernel for acceleration: Use '#pragma ACCEL kernel' to specify the function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n  \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        double  delx =  (double )(ex[i + 1][j + 1] - ex[i][j + 1]);\n        double  dely =  (double )(ey[i + 1][j + 1] - ey[i][j + 1]);\n        double  hz_update =  (double )(ex[i][j + 1] - ex[i + 1][j]) + delx +  (double )(ey[i + 1][j] - ey[i][j]) + dely;\n        hz[i][j] = hz_update;\n      }\n    }\n  }\n}\n", "1": "\n\n5. Automatic array partitioning: Use '#pragma ACCEL PARTITION FACTOR=auto{__PARA__L2}' to automatically partition the following loop for better performance.\n ACCEL PIPELINE auto{flatten}\n\n#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "2": "\n\n5. Automatically allocate and schedule loads and stores to and from automatic variables: Use '#pragma ACCEL PIPELINE auto{off}' to automatically flatten the pipeline.\n  \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": "\n  \n5. Unroll the following loop manually: Use '#pragma ACCEL PIPELINE auto{off}' to switch off automatic pipeline optimization.\n  \n6. Automatic parallelization enabled.\n  \n7. Automatic flattening enabled.\n  \n8. Automatic unrolling disabled.\n  \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "\n\n5. Enable array separation: Use '#pragma ACCEL PARAMETER 'separate = off' to enable array separation.\n\n6. Set the size of the input and output data arrays: Use '#pragma ACCEL PARAMETER auto{__PARAMS__}' to set the size of the input and output data arrays.\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 240;\n        int _in_i = 200;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n"}}
{"input": "Process the following function as a hardware kernel for acceleration.\n\nProcess the loop without automatic pipelining.\n\nBreak the loop into smaller chunks of size 1 for tiling.\n\nRun the iterations of the loop in parallel, dividing into 2 parallel tasks for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n #pragma ACCEL PIPELINE auto{off}\n \n #pragma ACCEL TILE FACTOR=auto{1}\n \n #pragma ACCEL PARALLEL FACTOR=auto{2}\n  \n/* Matrix multiplication */\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "1": "\n\n  int tsteps;\n  int n;\n  int b;\n  double A[60][80];\n  double B[80][90];\n  double C[60][90]\n      ;\n  \n#pragma ACCEL kernel\n\nvoid kernel_gemm(int tsteps,int n,int m,int p,double alpha,double beta,double A[60][80],double B[80][90],double C[60][90])\n{\n  int t;\n  int i;\n  int j;\n  int k;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 60; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 0; i < 80; i++) {\n      C[t][i] *= beta;\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 90; j++) {\n      for (i = 0; i < 80; i++) {\n        C[t][j] += alpha * A[t][i] * B[i][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n\n  sum = m[0];\n  float tmp = 0.0;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (tile = 1; tile < 8; tile++) {\n    \n#pragma ACCEL PARALLEL reduction=sum FACTOR=auto{1}\n    for (i = 0; i < 200; i++) {\n      sum = sum + m[i * 8 + tile];\n    }\n    tmp = sum;\n    sum = tmp + 1.0;\n    sum = tmp + 2.0;\n  }\n}\n", "3": "\n\n  int tsteps;\n  int d;\n  int n;\n  double u[60][60];\n  double v[60][60];\n  double p[60][60];\n  double q[60][60];\n  double r[60][60];\n  double s[60][60];\n  double pad[60][60];\n\n#pragma ACCEL kernel\n\nvoid kernel_heat_3d(int tsteps,int n,double A[60][60],double B[60][60])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 1; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        s[i][j] = 2.0 * A[i][j] - 1.0 * q[i][j] - 1.0 * p[i][j] - 1.0 * r[i][j];\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = 1.0 * A[i][j] - 1.0 * u[i][j] - 1.0 * s[i][j] - 1.0 * v[i][j];\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 1; j < 59; j++) {\n        q[i][j] = 1.0 * B[i][j] - 1.0 * p[i][j] - 1.0 * u[i][j] - 1.0 * v[i][j];\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 59; j++) {\n        v[i][j] = 1.0 * s[i][j] - 1.0 * q[i][j] - 1.0 * p[i][j] - 1.0 * u[i][j];\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (i = 1; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 1; j < 59; j++) {\n        u[i][j] = 1.0 * r[i][j] - 1.0 * v[i][j] - 1.0 * q[i][j] - 1.0 * p[i][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n\n  int i;\n  int j;\n  int k;j = 1;\n  int tmp;tmp = 1;\n  int SQUARE_DIM;SQUARE_DIM = 12;\n  int INIT_VAL;INIT_VAL = 1;\n  \n#pragma ACCEL kernel\n\n  kernel_heat_3d(i,j,tmp,SQUARE_DIM):\n  for(i = 1; i < 12 - 1; i++) {\n    for(j = 1; j < 12 - 1; j++) {\n      C[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[i - 1][j] + A[1 + i][j]);\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 1; i < 12 - 1; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 1; j < 12 - 1; j++) {\n      C[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[i - 1][j] + A[1 + i][j]);\n    }\n  }\n}\n"}}
{"input": "Process the loop in its original, full form without breaking it into smaller chunks. \n\nDon't automatically pipeline this loop.\n\nRun the iterations of this loop one after the other, not in parallel.\n\nTreat the following function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 0 + 1L * jump;\n        int _in_i = 0 + 1L * tile;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": "\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 0 + 1L;\n        int _in_i = 0 + 1L;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n  for (t = 0; t < 3\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[i - 1][j] + A[i - 1][j - 1] + A[i - 1][1 + j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n9; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[i - 1][j] + A[i - 1][j - 1] + A[i - 1][1 + j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1;\n        int j_col = -1;\n        double dxy_2 = (((double )((ex[i + 1][j] - ex[i][j]))) * (((double )((ey[i][j + 1] - ey[i][j]))) / (1.0 + 0.0)));\n        double dzt_2 = (((double )(hz[i][j] - hz[i][j + 1])) * (((double )(hz[i + 1][j] - hz[i + 1][j + 1])) / (1.0 + 0.0)));\n        double dxy_1 = (((double )((ex[i][j + 1] - ex[i][j]))) * (((double )((ey[i + 1][j] - ey[i + 1][j + 1]) / (1.0 + 0.0)))));\n        double dzt_1 = (((double )(hz[i + 1][j + 1] - hz[i][j])) * (((double )(hz[i + 1][j] - hz[i + 1][j + 1])) / (1.0 + 0.0)));\n        double tmp = dxy_2 + dzt_2;\n        double tmp1 = dxy_1 + dzt_1;\n        hz[i][j] = hz[i][j] + SOR_SOR_SOR_PARAMS[0] * tmp;\n        ey[i][j] = ey[i][j] + SOR_SOR_SOR_PARAMS[0] * (tmp1 - dxy_2);\n        int i_row = 1;\n        int j_row = 1;\n      }\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes written in C, use the following natural language instruction:\n\n\"For the function `kernel_doitgen`, treat it as a hardware kernel for acceleration. Then, automatically pipeline the loops, and apply tiling factor 4 for the outermost loop and tiling factor 1 for the inner loops. Additionally, use flattening for the innermost loop to pipeline it.\"", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      for (s = 0; s < 30; s++) {\n        sum[s] = 0.0;\n      }\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      for (p = 0; p < 20; p++) {\n        for (s = 0; s < 30; s++) {\n          sum[s] += A[r][q][p] * C4[p][s];\n        }\n      }\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n      for (s = 0; s < 30; s++) {\n        A[r][q][s] = sum[s];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      for (s = 0; s < 30; s++) {\n        sum[s] = 0.0;\n      }\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      for (p = 0; p < 20; p++) {\n        for (s = 0; s < 30; s++) {\n          sum[s] += A[r][q][p] * C4[p][s];\n        }\n      }\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n      for (s = 0; s < 30; s++) {\n        A[r][q][s] = sum[s];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(int ni,int nj,int nk,int alpha,int beta,int tmp[60][80],double A[60][60],double B[60][80],double C[60][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      tmp[i][j] = A[i][j];\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (j = 0; j < 80; j++) {\n      double sum = 0.0;\n#pragma ACCEL PARALLEL reduction=sum FACTOR=auto{__PARA__L2_0}\n      for (k = 0; k < 60; k++) {\n        sum += alpha * tmp[i][k] * B[k][j];\n      }\n      C[i][j] = beta * C[i][j] + sum;\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double B[25][30][40],double C[25][40][50])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n  int t;\n  int u;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  loop_r:\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    loop_q:\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      loop_s:\n      for (s = 0; s < 30; s++) {\n        A[r][q][s] = ((double )0);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    loop_t:\n    for (t = 0; t < 30; t++) {\n      \n#pragma ACCEL PIPELINE auto{}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      loop_u:\n      for (u = 0; u < 40; u++) {\n        double sum = 0.0;\n        \n#pragma ACCEL PIPELINE auto{off}\n        loop_v:\n        for (v = 0; v < 20; v++) {\n          sum += A[r][v][t] * B[v][t][u];\n        }\n        A[r][q][s] = sum;\n      }\n    }\n  }\n}\n", "4": "\n\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(int idx,int idy,int full[25][20][30],int filter[20][25][1][9])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      for (p = 0; p < 30; p++) {\n        full[r][q][p] = ((int )0);\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    for (q = 0; q < 20; q++) {\n      for (p = 0; p < 30; p++) {\n        for (s = 0; s < 5; s++) {\n          full[r][q][p] += filter[q][r][0][s] * ((int )((double )((ifthen(s + p - 2 >= 0 && s + p - 2 < 30, 30, ((int )0))) * ((ifthen(r + q - 2 >= 0 && r + q - 2 < 25, 25, ((int )0))) * ((ifthen(s + p - 2 >= 0 && s + p - 2 < 30, 30, ((int )0)))))) * (double )((ifthen(r + q - 2 >= 0 && r + q - 2 < 25, 25, ((int )0)))) * (double )((ifthen(s + p - 2 >= 0 && s + p - 2 < 30, 30, ((int )0)))) * (double )((ifthen(r + q - 2 >= 0 && r + q - 2 < 25, 25, ((int )0))))));\n        }\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "Process the following function as a hardware kernel for acceleration. Automatically pipeline the outer loop. Use an automatic tile factor for the loop, and parallelize the loop with a factor of 4. Within the outer loop, parallelize the inner loops with a factor of 8 and 1 respectively.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] -= 0.5 * (A[i][j] - A[i - 1][j - 1]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 3{\n      B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[i - 1][j] + A[i - 1][j - 1] + A[i - 1][1 + j]);\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n"}}
{"input": "Process the loops in their original, full form without breaking them into smaller chunks and automatically pipeline each loop. Also, treat the following function as a hardware kernel for acceleration.\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": " #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 0 + 1L;\n        int _in_i = ((int )i) + 1L;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "1": " #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i + 1) - 1 - 1;\n        int j_col = 2L * (j + 1) - 1 - 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_col][j_col + 1] - ex[i_col][j_col] + ey[i_col + 1][j_col] - ey[i_col][j_col]);\n      }\n    }\n  }\n}\n", "2": " #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": " #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 0 + 1L * (- 1L) + (( 1L ) * j);\n        int _in_i = 0 + 1L * (- 1L) + (( 1L ) * i);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": " #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        double  _tmp_1 = 0.0;\n        double  _tmp_2 = 0.0;\n        double  _tmp_3 = 0.0;\n        double  _tmp_4 = 0.0;\n        double  _tmp_5 = 0.0;\n        double  _tmp_6 = 0.0;\n        double  _tmp_7 = 0.0;\n        double  _tmp_8 = 0.0;\n        double  _tmp_9 = 0.0;\n        _tmp_1 = ex[i][j + 1] - ex[i][j];\n        _tmp_2 = ey[i + 1][j] - ey[i][j];\n        _tmp_3 = hz[i][j + 1] - hz[i][j];\n        _tmp_4 = hz[i + 1][j] - hz[i][j];\n        _tmp_5 = _tmp_1 * _tmp_2;\n        _tmp_6 = _tmp_3 * _tmp_4;\n        _tmp_7 = _tmp_5 - _tmp_6;\n        _tmp_8 = _tmp_7 * 0.5;\n        _tmp_9 = _tmp_8 + 1.0;\n        ey[i][j] = _tmp_9;\n        _tmp_1 = ey[i + 1][j] - ey[i][j];\n        _tmp_2 = ex[i][j] - ex[i][j + 1];\n        _tmp_3 = hz[i + 1][j] - hz[i][j + 1];\n        _tmp_4 = hz[i][j] - hz[i + 1][j + 1];\n        _tmp_5 = _tmp_1 * _tmp_2;\n        _tmp_6 = _tmp_3 * _tmp_4;\n        _tmp_7 = _tmp_5 - _tmp_6;\n        _tmp_8 = _tmp_7 * 0.5;\n        _tmp_9 = _tmp_8 + 1.0;\n        ex[i][j] = _tmp_9;\n        _tmp_1 = _tmp_6;\n        _tmp_2 = _tmp_5;\n        hz[i][j] = _tmp_9;\n      }\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes in C:\nSpecify the following pragma values for the related loops and functions:\n- Use the '#pragma ACCEL kernel' for the function 'kernel_jacobi_1d'\n- Implement automatic pipeline for the outer loops using '#pragma ACCEL PIPELINE auto{}'\n- Set the tile factor to 'auto{1}' for loop blocking using '#pragma ACCEL TILE FACTOR=auto{1}'\n- Apply automatic parallelization with a factor of 'auto{2}' for the outer loop using '#pragma ACCEL PARALLEL FACTOR=auto{2}'\n- Apply automatic parallelization with a factor of 'auto{30}' and 'auto{12}' for the inner loops using '#pragma ACCEL PARALLEL FACTOR=auto{30}' and '#pragma ACCEL PARALLEL FACTOR=auto{12}' respectively", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n- Use the following pragmas to flatten the specified loop nest(s) for auto{1}\n \n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n- Use the following pragmas to offload the code to FPGA \n #pragma ACCEL POFFLOAD FACTOR=auto{1}\n\n #pragma ACCEL PARALLEL FACTOR=auto{1}\n\n/* DCE code. Must scan the entire live-out data.\n   Can be excluded if one writes all live-out points.\n   Also ignore registration in the code below. */\n #pragma ACCEL POINT PARAMS=flp\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{12}\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To optimize the HLS code:\n\n\"Apply automatic pipeline directives to the loop\"\n```c\n#pragma ACCEL PIPELINE auto\n```\n\n\"Automatically determine the tiling factor for the loop\"\n```c\n#pragma ACCEL TILE FACTOR=auto{1}\n```\n\n\"Automatically determine the parallelization factor for the loop, allowing up to 3 parallel instances\"\n```c\n#pragma ACCEL PARALLEL FACTOR=auto{3}\n```\n\n\"Automatically determine the parallelization factor for the inner loop, allowing up to 10 parallel instances\"\n```c\n#pragma ACCEL PARALLEL FACTOR=auto{10}\n```\n\n\"Automatically determine the parallelization factor for the inner loop, allowing up to 32 parallel instances\"\n```c\n#pragma ACCEL PARALLEL FACTOR=auto{32}\n```", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _row = 240 * i + j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "1": "\n\n\"Set the parallelization factor to 4\"\n", "2": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_in_j = i * 240 + j;\n        int i_below_j = (i + 1) * 240 + j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": "\n\n\"Automatically determine the parallelization factor for the inner loop, allowing up to 64 parallel instances\"\n```c\n#pragma ACCEL PARALLEL FACTOR=auto{64}\n```\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        z_diff[0] = hz[i][j] - hz[i][j + 1];\n        z_diff[1] = hz[i][j + 1] - hz[i + 1][j + 1];\n        z_diff[2] = hz[i + 1][j + 1] - hz[i + 1][j];\n        x_y_diff = ex[i][j] - ex[i][j + 1];\n        y_x_diff = ey[i][j] - ey[i + 1][j];\n        hz[i][j] = hz[i][j] + 0.7 * (x_y_diff - 0.5 * (z_diff[0] + z_diff[1]));\n        ey[i][j] = ey[i][j] + 0.7 * (z_diff[1] - z_diff[0]) + 0.079 * (y_x_diff - x_y_diff);\n        ex[i][j] = ex[i][j] + 0.7 * (z_diff[0] - z_diff[2]) + 0.079 * (x_y_diff - y_x_diff);\n      }\n    }\n  }\n}\n", "4": "\n\n\"Automatically determine the parallelization factor for the inner loop, allowing up to 4 parallel instances\"\n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 40; t++) {\n    float dt = (t * 0.01);\n    float sin_dt = sin(dt);\n    float cos_dt = cos(dt);\n    float temp1 = u[0] - sin_dt * (u[1] + u[2]);\n    float temp2 = u[1] + u[2] * cos_dt - 0.5 * (u[0] - sin_dt * (u[1] + u[2]));\n    float temp3 = u[2] * cos_dt + u[1] * (-sin_dt) - 0.5 * (u[0] - sin_dt * (u[1] + u[2]));\n    f[0] = temp1 * (u[0] * u[0] + u[1] * u[1] + u[2] * u[2]) + 2.0 * (u[1] * u[1] + u[2] * u[2]) + (u[1] * u[1] + u[2] * u[2]);\n    f[1] = temp1 * u[1] + temp2 * (u[0] * u[0] + u[1] * u[1] + u[2] * u[2]) + 2.0 * (u[1] * u[2]) ;\n    f[2] = temp1 * u[2] + temp3 * (u[0] * u[0] + u[1] * u[1] + u[2] * u[2]) + 2.0 * (u[1] * u[2]) ;\n    u[0] = temp1;\n    u[1] = temp2;\n    u[2] = temp3;\n  }\n}\n"}}
{"input": "To generate the given HLS codes in C:\n1. Use '#pragma ACCEL kernel' to designate the function as a hardware kernel for acceleration.\n2. Use '#pragma ACCEL PIPELINE auto{off}' to disable automatic pipelining for the loop.\n3. Use '#pragma ACCEL TILE FACTOR=auto{1}' to process the loop in its original, full form without breaking it into smaller chunks.\n4. Use '#pragma ACCEL PARALLEL FACTOR=auto{4}' to run the iterations of the loop in parallel with a factor of 4.\n5. Use '#pragma ACCEL PARALLEL FACTOR=auto{1}' to run the iterations of the inner loops one after the other, not in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L8}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n//#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n}\n", "2": "\n//#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction=D FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n6. Use '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}' to parallelize the loops with a parallelization factor of 2.\n#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n//#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DX_2;\n  double DY_2;\n  double DX_4;\n  double DY_4;\n  double DX_6;\n  double DY_6;\n  double DX_8;\n  double DY_8;\n  double NDX;\n  double NDY;\n  double tmp;\n  double mul1;\n  double mul2;\n  double mul3;\n  double mul4;\n  double mul5;\n  double add1;\n  double add2;\n  double u_pos;\n  double v_pos;\n  double u_neg;\n  double v_neg;\n  double p_pos;\n  double q_pos;\n  double p_neg;\n  double q_neg;\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  DX = 1.0 / ((double )60);\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  DY = 1.0 / ((double )60);\n  DX_2 = DX * DX;\n  DY_2 = DY * DY;\n  DX_4 = DX_2 * DX_2;\n  DY_4 = DY_2 * DY_2;\n  DX_6 = DX_4 * DX_2;\n  DY_6 = DY_4 * DY_2;\n  DX_8 = DX_6 * DX_2;\n  DY_8 = DY_6 * DY_2;\n  NDX = -1.0 * DX;\n  NDY = -1.0 * DY;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL WORKER FACTOR=auto{1}\n  for (t = 1; t <= 39; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL WORKER FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      DX_tmp = DX_2 * ((double )(4L - 2L * (long )i * (long) 1L));\n      mul1 = DX_tmp * v[i][0];\n      add1 = mul1 + v[i][1];\n      p[i][0] = add1 + p[i][1];\n      mul2 = DX_tmp * u[i][0];\n      add2 = mul2 + u[i][1];\n      q[i][0] = add2 + q[i][1];\n      u_pos = u[i][0] + p[i][0];\n      v_pos = v[i][0] + q[i][0];\n      u_neg = u[i][0] - p[i][0];\n      v_neg = v[i][0] - q[i][0];\n      tmp = DX * DY;\n      mul3 = tmp * v_pos;\n      p_pos = mul3 + u_pos;\n      mul4 = tmp * v_neg;\n      p_neg = mul4 + u_neg;\n      q_pos = mul5 = tmp * u_pos;\n      q_neg = mul5 + v_neg;\n      u[i][0] = u_pos + p_pos;\n      v[i][0] = v_pos + q_pos;\n      u[i][1] = u_pos + p_neg;\n      v[i][1] = v_pos + q_neg;\n      u[i][58] = u_neg + p_neg;\n      v[i][58] = v_neg + q_neg;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL WORKER FACTOR=auto{1}\n    for (j = 1; j < 59; j++) {\n      DY_tmp = DY_2 * ((double )(4L - 2L * (long )j * (long) 1L));\n      mul1 = DY_tmp * v[0][j];\n      add1 = mul1 + v[1][j];\n      p[0][j] = add1 + p[1][j];\n      mul2 = DY_tmp * u[0][j];\n      add2 = mul2 + u[1][j];\n      q[0][j] = add2 + q[1][j];\n      u_pos = u[0][j] + p[0][j];\n      v_pos = v[0][j] + q[0][j];\n      u_neg = u[0][j] - p[0][j];\n      v_neg = v[0][j] - q[0][j];\n      tmp = DX * DY;\n      mul3 = tmp * v_pos;\n      p_pos = mul3 + u_pos;\n      mul4 = tmp * v_neg;\n      p_neg = mul4 + u_neg;\n      q_pos = mul5 = tmp * u_pos;\n      q_neg = mul5 + v_neg;\n      u[0][j] = u_pos + p_pos;\n      v[0][j] = v_pos + q_pos;\n      u[58][j] = u_neg + p_neg;\n      v[58][j] = v_neg + q_neg;\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "Use the following natural language instruction to generate the given HLS codes in C:\n\"Convert the following function into a hardware kernel for acceleration and use specific pragma directives to control loop optimization: turn off automatic pipeline, set the tiling factor to 1, and activate parallelization with a factor of 8 for the outer loop and 1 for the inner loops.\"", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n  for (t = 0; t < 35; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "Process the outermost loops in their full form, without breaking them into smaller chunks, and then run the iterations of these loops one after the other, not in parallel. For the innermost loops, automatically pipeline them and process them in their original, full form without breaking them into smaller chunks.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": " \n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5_0}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[j];\n    }\n    \n#pragma ACCEL PIPELINE auto{_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1_1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5_1}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5_1_0}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1_2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5_2}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5_2_0}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1_3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5_3}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5_3_0}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n\n\n#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n  for (t = 0; t < 30; t++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\nFurther, in the innermost loop, in the kernel_gemm function, perform the pipeline auto-pipeline transform on the loop that has been annotated with the below directive\n #pragma ACCEL PIPELINE auto{off}\n \n#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "4": "\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1;\n        int j_col = -1;\n        double dxy_x = 0.0;\n        double dxy_y = 0.0;\n        double ex_x = 0.0;\n        double ex_y = 0.0;\n        double ey_x = 0.0;\n        double ey_y = 0.0;\n        double hz_x = 0.0;\n        double hz_y = 0.0;\n        double _in_x = ((double )i) + 1.0;\n        double _in_y = ((double )j) + 1.0;\n        dxy_x = ((double )i) * (ey[i][j + 1] - ey[i][j]) - (((double )j) * (ex[i + 1][j] - ex[i][j]));\n        dxy_y = ((ey[i + 1][j] - ey[i][j]) - ((double )(j + 1) * (ex[i + 1][j] - ex[i][j]))) / ((double )(i + 1));\n        ex_x = ex[i + 1][j + 1] - ex[i][j + 1];\n        ex_y = ex[i + 1][j] - ex[i][j];\n        ey_x = ey[i + 1][j + 1] - ey[i][j + 1];\n        ey_y = ey[i + 1][j] - ey[i][j];\n        hz_x = hz[i + 1][j + 1] - hz[i][j + 1];\n        hz_y = hz[i + 1][j] - hz[i][j];\n        int _in_blk_idx = 0;\n        int _in_vec_idx = 0;\n        i_col = 2;\n        for (j_col = 2; j_col < 32; j_col++) {\n          if (j_col >= 2) {\n            i_col *= 4;\n          }\n          int _tmp_222 = 0;\n          int _tmp_223 = 0;\n          _tmp_222 = 4 * i_col + 2;\n          _tmp_223 = 4 * j_col + 2;\n          double _tmp_224 = ((double )_tmp_222) + 1.0;\n          double _tmp_225 = ((double )_tmp_223) + 1.0;\n          double _tmp_226 = _tmp_224 * _in_x;\n          double _tmp_227 = _tmp_225 * _in_y;\n          double _tmp_228 = _in_x + 1.0;\n          double _tmp_229 = _in_y + 1.0;\n          double _tmp_230 = _tmp_228 * _tmp_227;\n          double _tmp_231 = dxy_x * (_tmp_226 * _tmp_230 - _tmp_227 * _tmp_226);\n          double _tmp_232 = ey_x * (hz[i_col + 1][j_col + 1] - hz[i_col][j_col + 1]) - ey_y * (hz[i_col + 1][j_col] - hz[i_col][j_col]);\n          double _tmp_233 = dxy_y * (_tmp_226 * _tmp_232 - _tmp_227 * _tmp_233) + ey_x * (_tmp_227 * _tmp_233 - _tmp_232 * _tmp_227);\n          double _tmp_234 = ex_x * (hz[i_col + 1][j_col + 1] - hz[i_col + 1][j_col]) - ex_y * (hz[i_col][j_col + 1] - hz[i_col][j_col]);\n          double _tmp_235 = ex_x * (_tmp_227 * _tmp_234 - _tmp_234 * _tmp_227) + ex_y * (_tmp_234 * _tmp_226 - _tmp_226 * _tmp_234);\n          double _tmp_236 = hz[i_col][j_col] + 1.0 / (2.0 * (((double )((int )25)) * 1.0)) * (__PARA__L9 * (dxy_x * _tmp_231 + dxy_y * _tmp_233 + ex_x * _tmp_235 + ey_y * _tmp_234 - (ey_x * _tmp_233 + ex_y * _tmp_231)) - _fict_[t]);\n          hz[i_col][j_col] = _tmp_236;\n        }\n      }\n    }\n  }\n}\n"}}
