{"input": "To generate the given HLS codes in C, use the following natural language instructions for specific #pragma values:\n\n1. **Treat the following function as a hardware kernel for acceleration**\n   - Description: Specify the function as a hardware kernel for acceleration\n   - HLS Code: `#pragma ACCEL kernel`\n\n2. **Don't automatically pipeline this loop**\n   - Description: Disable automatic loop pipelining\n   - HLS Code: `#pragma ACCEL PIPELINE \"off\"`\n\n3. **Process this loop in its original, full form without breaking it into smaller chunks**\n   - Description: Set tile factor to 1 to process loop in its original form\n   - HLS Code: `#pragma ACCEL TILE FACTOR=1`\n\n4. **Run the iterations of this loop one after the other, not in parallel**\n   - Description: Set parallel factor to 1 to run loop iterations sequentially\n   - HLS Code: `#pragma ACCEL PARALLEL FACTOR=1`\n\nThese natural language instructions can be used to generate the HLS codes for the given C function.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1 * i;\n        int j_col = j + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_col][j] - ex[i][j] + ey[i][j_col] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": " The following is the HLS code generated by ACCEL.\n\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "3": " The generated kernel can be compiled and run on ALTERA FPGA board.\n", "4": "\n#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{7}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To generate the given HLS codes:\n\n- Apply automatic pipeline optimization to the loop.\n- Set the tile factor to 'auto' so that the loop is processed in its original, full form without breaking it into smaller chunks.\n- Set the parallel factor to 'auto{2}' for the outer loop and 'auto{1}' for the first inner loop, and 'auto{8}' for the second inner loop.\n- Treat the function 'kernel_jacobi_1d' as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n \n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n \n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n \n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n \n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n \n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To generate the given HLS codes, apply the following natural language instructions:\n\n1. Use automatic pipelining for the loop.\n2. Apply tiling with an automatic factor of 1 to the loop.\n3. Parallelize the loop with an automatic factor of 2.\n4. Apply parallelization with an automatic factor of 2 to the inner loop.\n5. Further parallelize the loop with an automatic factor of 10.\n\nThese instructions correspond to the given HLS pragmas in the C code.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L4}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{_auto_pipeline_0}\n  \n#pragma ACCEL TILE FACTOR=auto{_auto_tile_0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{_auto_parallel_0}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PIPELINE auto{_auto_pipeline_1}\n    \n#pragma ACCEL TILE FACTOR=auto{_auto_tile_1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{_auto_parallel_1}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L2}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{10}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{25}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 3 1;\n        B[i] = 0.33333 * (A[i] + A[i - 1] + A[i + 1]);\n      }\n    }\n    \n#pragma endscop\n//#pragma endscop\n}\n"}}
{"input": "To generate the given HLS codes in C, utilize the following concise natural language instructions for specific #pragma values:\n\n- To turn off automatic loop pipelining: \"Disable automatic loop pipelining\"\n- To set the tile factor to 1 for original loop processing: \"Use a tile factor of 1 for loop processing\"\n- To run loop iterations in parallel with a factor of 2: \"Execute loop iterations in parallel with a factor of 2\"\n- To designate the function as a hardware acceleration kernel: \"Designate the following function as a hardware kernel for acceleration\"\n\nOnce implemented with these instructions in mind, the HLS codes when written in C, will execute the desired functionalities.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L8}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "1": "\n\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": "\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_up = i + 1;\n        int j_up = j + 1;\n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7_0}\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_up][j] - ex[i][j]) - 0.7 * (ey[i][j_up] - ey[i][j]) + 1.0 * (tz[i][j] - tz[i][j_up]);\n      }\n    }\n  }\n}\n"}}
{"input": "Generate HLS code with the following natural language instruction:\n\"Mark this function as a hardware kernel for acceleration, pipeline the outer loop automatically, tile the loop with a factor of 1 automatically, and parallelize the loops with a factor of 2 and 6 respectively.\"", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 38; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 3{\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n  }\n//#pragma endscop\n}\n2; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (i = 1; i < 119; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 119; i++) ", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction=D FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 3B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n  }\n//#pragma endscop\n}\n2; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (i = 1; i < 119; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (i = 1; i < 119; i++) {\n      "}}
{"input": "To generate the given HLS codes in C, use the following pragma values:\n\n1. Treat the following function as a hardware kernel for acceleration: `#pragma ACCEL kernel`\n\n2. Don't automatically pipeline this loop: `#pragma ACCEL PIPELINE \"off\"`\n\n3. Process this loop in its original, full form without breaking it into smaller chunks: `#pragma ACCEL TILE FACTOR=1`\n\n4. Run the iterations of this loop one after the other, not in parallel: `#pragma ACCEL PARALLEL FACTOR=1`", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n5. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PARALLEL FACTOR=auto{1}`\n\n6. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PIPELINE auto{off}`\n\n7. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}`\n\n8. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L2}`\n\n9. Do not apply any automatic parallelization for this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L2}`\n\n10. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}`\n\n11. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L3}`\n\n12. Do not apply any automatic parallelization for this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L3}`\n\n13. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}`\n\n14. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L4}`\n\n15. Do not apply any automatic parallelization for this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L4}`\n\n16. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}`\n\n17. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L5}`\n\n18. Do not apply any automatic parallelization for this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L5}`\n\n19. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}`\n\n20. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L6}`\n\n21. Do not apply any automatic parallelization for this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L6}`\n\n22. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}`\n\n23. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L7}`\n\n24. Do not apply any automatic parallelization for this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L7}`\n\n25. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}`\n\n26. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L8}`\n\n27. Do not apply any automatic parallelization for this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L8}`\n\n28. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}`\n\n29. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L9}`\n\n30. Do not apply any automatic parallelization for this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L9}`\n\n31. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L10}`\n\n32. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L10}`\n\n33. Do not apply any automatic parallelization for this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L10}`\n\n34. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L11}`\n\n35. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L11}`\n\n36. Do not apply any automatic parallelization for this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L11}`\n\n37. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L12}`\n\n38. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L12}`\n\n39. Do not apply any automatic parallelization for this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L12}`\n\n40. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L13}`\n\n41. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L13}`\n\n42. Do not apply any automatic parallelization for this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L13}`\n\n43. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L14}`\n\n44. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L14}`\n\n45. Do not apply any automatic parallelization for this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L14}`\n\n46. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L15}`\n\n47. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L15}`\n\n48. Do not apply any automatic parallelization for this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L15}`\n\n49. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L16}`\n\n50. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L16}`\n\n51. Do not apply any automatic parallelization for this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L16}`\n\n52. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L17}`\n\n53. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L17}`\n\n54. Do not apply any automatic parallelization for this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L17}`\n\n55. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L18}`\n\n56. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L18}`\n\n57. Do not apply any automatic parallelization for this loop: `#pragma ACCEL TILE FACTOR=auto{__TILE__L18}`\n\n58. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L19}`\n\n59. Do not apply any automatic parallelization for this loop: `#pragma ACCEL PIPELINE auto{__PIPE__L19}`\n\n60. Do not apply any automatic parallelization for this loop: `#pragma", "1": "\n\n5. Don't automatically distribute this loop: `#pragma ACCEL DISTRIBUTE FACTOR=1`\n\n6. Do not target a particular device. The default target is the CPU:\n```\n #pragma ACCEL device\n\n```\n", "2": "\n\n5. Automatically pick loop transformation: \n\n   #pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n\n6. Automatically pick loop transformation: \n\n   #pragma ACCEL PIPELINE auto{__PIPE__L1}\n\n7. Automatically pick arithmetics transformation: \n\n   #pragma ACCEL ARITHMETIC auto{__ARITH__L2}\n\n8. Automatically pick arithmetics transformation: \n\n   #pragma ACCEL ARITHMETIC auto{__ARITH__L3}\n\n9. Automatically pick arithmetics transformation: \n\n   #pragma ACCEL ARITHMETIC auto{__ARITH__P0}\n\n10. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P1}\n\n11. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P2}\n\n12. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P3}\n\n13. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P4}\n\n14. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P5}\n\n15. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P6}\n\n16. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P7}\n\n17. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P8}\n\n18. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P9}\n\n19. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P10}\n\n20. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P11}\n\n21. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P12}\n\n22. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P13}\n\n23. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P14}\n\n24. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P15}\n\n25. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P16}\n\n26. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P17}\n\n27. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P18}\n\n28. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P19}\n\n29. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P20}\n\n30. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P21}\n\n31. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P22}\n\n32. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P23}\n\n33. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P24}\n\n34. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P25}\n\n35. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P26}\n\n36. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P27}\n\n37. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P28}\n\n38. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P29}\n\n39. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P30}\n\n40. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P31}\n\n41. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P32}\n\n42. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P33}\n\n43. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P34}\n\n44. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P35}\n\n45. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P36}\n\n46. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P37}\n\n47. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P38}\n\n48. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P39}\n\n49. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P40}\n\n50. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P41}\n\n51. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P42}\n\n52. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P43}\n\n53. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P44}\n\n54. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P45}\n\n55. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P46}\n\n56. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P47}\n\n57. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P48}\n\n58. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P49}\n\n59. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__P50}\n\n60. Automatically pick arithmetics transformation: \n\n     #pragma ACCEL ARITHMETIC auto{__ARITH__", "3": "\n\n5. Do not pipeline the loop below: #pragma ACCEL PIPELINE auto{off}\n  \n6. Do not parallelize the loop below: #pragma ACCEL PARALLEL auto{1}\n  \n7. #pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n8. #pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n9. #pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (tiled_index = 0; tiled_index < 8; tiled_index++) {\n    int _in_j = 0;\n    int _in_j_col = (((int )tiled_index) * 64) + 1;\n    int _in_j_row = 1;\n    int _out_j = 0;\n    int _out_j_col = (((int )tiled_index) * 64) + 1;\n    int _out_j_row = 1;\n    for (j_col = 1; j_col <= 60; j_col += 64) {\n      if (j_col + 64 - 1 < 60) {\n        _in_j_col = j_col + 64 - 1;\n      }\n      else {\n        _in_j_col = 60;\n      }\n      for (j_row = 1; j_row <= 60; j_row += 64) {\n        if (j_row + 64 - 1 < 60) {\n          _in_j_row = j_row + 64 - 1;\n        }\n        else {\n          _in_j_row = 60;\n        }\n//#pragma ACCEL PIPELINE auto{off}\n        for (in_j = 0; in_j <= 79; in_j++) {\n          _in = in[in_j][_in_j_row][_in_j_col];\n//#pragma ACCEL PARALLEL reduction=out FACTOR=auto{__PARA__L2}\n          for (out_j = 0; out_j <= 79; out_j++) {\n            out[out_j][_out_j_row][_out_j_col] += _in * A[out_j][in_j];\n          }\n        }\n//#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      }\n//#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    }\n//#pragma ACCEL PIPELINE auto{__PIPE__L1}\n  }\n//#pragma ACCEL PIPELINE auto{off}\n\n  }\n", "4": "\n\n5. Don't automatically distribute this loop: `#pragma ACCEL DISTRIBUTE FACTOR=1`\n\n6. Don't automatically parallelize this loop: `#pragma ACCEL PARALLEL FACTOR=auto{1}`\n\n7. Don't automatically parallelize this loop: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}`\n//#pragma ACCEL PIPELINE auto{flatten}\n\n//#pragma ACCEL TILE FACTOR=auto{4}\n\n//#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n/* Configurations */\n#define TILE_FACTOR 4\n#define PARA_L2 1\n#define PARA_L1 16\n#define PARA_L0 1\n#define PARA_INPUT_L 1\n#define PARA_OUTPUT_L 1\n\n#include <math.h>\n#include <stdio.h>\n#ifdef _OPENMP\n#include <omp.h>\n#endif\n\nstruct lp_struct_t {\n  double A[120][120];\n  double x[120];\n  double b[120];\n  double b_orig[120];\n  double b_error[120];\n};\n\nvoid kernel_gemm(double m1[120][120],double m2[120][120],double prod[120][120])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 120; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 120; j++) {\n      lp_1:\n      double sum = (double )0;\n      \n#pragma ACCEL PARALLEL reduction=sum FACTOR=auto{__PARA__L2}\n      for (k = 0; k < 120; k++) {\n        lp_2:\n        sum += m1[i][k] * m2[k][j];\n      }\n      prod[i][j] = sum;\n    }\n  }\n//#pragma endscop\n}\n\nvoid kernel_gemm_orig(double m1[120][120],double m2[120][120],double prod[120][120])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 120; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 120; j++) {\n      lp_3:\n      double sum = (double )0;\n      \n#pragma ACCEL PARALLEL reduction=sum FACTOR=auto{__PARA__L0}\n      for (k = 0; k < 120; k++) {\n        lp_4:\n        sum += m1[i][k] * m2[k][j];\n      }\n      prod[i][j] = sum;\n    }\n  }\n//#pragma endscop\n}\n\nint main(int argc,char **argv)\n{\n  double (*A)[120][120]) = ((double (*)[120][120])((double *)malloc(480000 * sizeof(double ))));\n  double (*x)[120][120]) = ((double (*)[120][120])((double *)malloc(480000 * sizeof(double ))));\n  double (*b)[120]) = ((double (*)[120])((double *)malloc(120 * sizeof(double ))));\n  double (*b_orig)[120]) = ((double (*)[120])((double *)malloc(120 * sizeof(double ))));\n  double (*b_error)[120]) = ((double (*)[120])((double *)malloc(120 * sizeof(double ))));\n  double _in_A[120][120];\n  double _in_x[120][120];\n  double _in_b[120];\n  double _out_b[120];\n  double _out_b_orig[120];\n  double _out_b_error[120];\n  double _result;\n  struct lp_struct_t _lp;\n  int i;\n  int j;\n  int k;\n//#pragma ACCEL kernel\n\n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  kernel_gemm(_in_A,_in_x,_out_b);\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n  kernel_gemm_orig(_in_A,_in_x,_out_b_orig);\n//Section0:\n//  Original from: gemm.c:30\n//  A[i][k] * x[k][j] => sum[i][j]\n  \n#pragma ACCEL PIPELINE auto{off}\n  for (i = 0; i < 120; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n    for (j = 0; j < 120; j++) {\n      sum:\n      _lp.b[i] = 0.0;\n      for (k = 0; k < 120; k++) {\n        _lp.b[i] += _lp.A[i][k] * _lp.x[k][j];\n      }\n      _lp.b_error[i] = _lp.b[i] - _lp.b_orig[i];\n    }\n  }\n//Section1:\n//  Original from: gemm.c:44\n//  A[i][k] * x[k][j] => sum[i][j]\n//  Function: gemm\n//  Args:\n//  Return: double\n//  Requirements:\n//    All data must be aligned.\n//    A and x must be private.\n//    sum must be local.\n//    b must be local.\n//    b_error must be reduction.\n//    depend(2) sum -> b\n//    depend(2) b -> b_error\n//    depend(1) A => sum\n//    depend(1) x => sum\n//    gemm_orig\n//    \n//#pragma ACCEL PIPELINE auto{flatten}\n//#pragma ACCEL TILE FACTOR=auto{4}\n//#pragma ACCEL PARALLEL FACTOR=auto{1}\n//  for (i = 0; i < 120; i++) {\n//    \n//#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n//    for (j = 0; j < 120; j++) {\n//      sum:\n//      double sum = (double )0;\n//      \n//#pragma ACCEL PARALLEL reduction=sum FACTOR=auto{__PARA__L3}\n//      for (k = 0; k < 120; k++) {\n//        double _in_val = _in_A[i][k];\n//        double _in_ptr = _in_x[k][j];\n//        sum += _in_val * _in_ptr;\n//      }\n//      _out_b[i] = sum;"}}
{"input": "To generate the given HLS codes, use the following natural language instructions:\n\n1. Mark the function as a hardware kernel for acceleration.\n   Use: 'Treat the following function as a hardware kernel for acceleration'\n\n2. Don't automatically pipeline the outer loop.\n   Use: '#pragma ACCEL PIPELINE \"off\"'\n\n3. Ensure the loop is processed in its original, full form without breaking it into smaller chunks.\n   Use: '#pragma ACCEL TILE FACTOR=1'\n\n4. Run the iterations of the outer loop one after the other, not in parallel.\n   Use: '#pragma ACCEL PARALLEL FACTOR=1'\n\n5. Optionally, specify the auto factor value for the pipeline, tile, and parallel pragma directives.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L0}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L0}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L1}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L1}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L2}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L2}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L3}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L3}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L4}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L4}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L5}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L5}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L6}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L6}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L7}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L7}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L8}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L8}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L9}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L9}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L10}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L10}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L10}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L11}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L11}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L11}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L12}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L12}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L12}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L13}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L13}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L13}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L14}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L14}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L14}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L15}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L15}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L15}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L16}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L16}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L16}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L17}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L17}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L17}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L18}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L18}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L18}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L19}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L19}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L19}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L20}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L20}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L20}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L21}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L21}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L21}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L22}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L22}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L22}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L23}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L23}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L23}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L24}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L24}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L24}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L25}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L25}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L25}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L26}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L26}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L26", "1": "\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L0}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L0}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L1}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L1}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L2}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L2}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L3}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L3}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L4}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L4}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L5}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L5}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L6}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L6}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L7}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L7}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L8}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L8}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L9}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L9}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L10}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L10}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L10}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L11}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L11}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L11}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L12}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L12}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L12}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L13}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L13}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L13}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L14}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L14}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L14}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L15}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L15}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L15}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L16}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L16}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L16}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L17}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L17}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L17}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L18}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L18}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L18}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L19}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L19}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L19}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L20}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L20}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L20}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L21}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L21}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L21}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L22}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L22}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L22}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L23}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L23}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L23}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L24}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L24}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L24}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L25}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L25}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L25}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L26}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L26}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L26", "2": "\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L0}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L0}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L1}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L1}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L2}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L2}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L3}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L3}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L4}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L4}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L5}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L5}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L6}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L6}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L7}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L7}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L8}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L8}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L9}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L9}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L10}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L10}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L10}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L11}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L11}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L11}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L12}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L12}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L12}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L13}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L13}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L13}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L14}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L14}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L14}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L15}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L15}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L15}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L16}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L16}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L16}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L17}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L17}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L17}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L18}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L18}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L18}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L19}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L19}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L19}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L20}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L20}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L20}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L21}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L21}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L21}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L22}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L22}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L22}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L23}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L23}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L23}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L24}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L24}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L24}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L25}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L25}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L25}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L26}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L26}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L26", "3": "\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L0}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L0}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L2}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L2}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L3}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L3}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L4}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L4}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L5}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L5}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L6}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L6}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L7}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L7}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L8}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L8}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L9}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L9}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L10}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L10}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L10}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L11}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L11}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L11}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L12}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L12}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L12}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L13}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L13}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L13}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L14}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L14}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L14}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L15}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L15}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L15}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L16}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L16}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L16}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L17}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L17}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L17}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L18}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L18}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L18}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L19}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L19}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L19}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L20}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L20}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L20}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L21}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L21}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L21}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L22}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L22}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L22}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L23}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L23}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L23}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L24}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L24}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L24}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L25}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L25}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L25}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L26}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L26}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L26}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L27}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L27}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__", "4": "\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L0}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L0}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L2}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L2}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L3}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L3}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L4}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L4}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L5}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L5}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L6}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L6}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L7}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L7}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L8}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L8}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L9}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L9}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L10}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L10}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L10}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L11}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L11}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L11}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L12}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L12}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L12}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L13}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L13}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L13}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L14}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L14}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L14}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L15}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L15}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L15}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L16}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L16}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L16}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L17}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L17}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L17}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L18}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L18}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L18}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L19}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L19}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L19}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L20}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L20}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L20}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L21}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L21}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L21}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L22}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L22}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L22}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L23}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L23}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L23}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L24}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L24}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L24}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L25}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L25}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L25}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L26}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L26}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L26}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L27}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L27}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__"}}
{"input": "Process the kernel loop in its original, full form without breaking it into smaller chunks. Then, don't automatically pipeline this loop. Run the iterations of this loop one after the other, not in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 0 + 1L * jump_ey;\n        int _in_i = 0 + 1L * jump_ex;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": " \n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{__PARA__L2}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 30; t++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1;\n        int j_col = -1;\n        double hz_col = 0.0;\n        i_col = 200 - 1 - i;\n        j_col = 240 - 1 - j;\n        hz_col = hz[i_col][j_col];\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_col][j_col + 1] - ex[i_col][j_col] + ey[i_col + 1][j_col] - ey[i_col][j_col]);\n      }\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes in C, use the following natural language instructions:\n\n1. Treat the following function as a hardware kernel for acceleration.\n2. Don't automatically pipeline this loop and flatten it.\n3. Process this loop in its original, full form without breaking it into smaller chunks automatically.\n4. Run the iterations of this loop one after the other, not in parallel with a factor of 2.\n5. Run the iterations of this loop in parallel with a factor of 16.\n6. Run the iterations of this loop one after the other, not in parallel with a factor of 1.\n\nThe corresponding #pragma values are:\n1. #pragma ACCEL kernel\n2. #pragma ACCEL PIPELINE auto{flatten}\n3. #pragma ACCEL TILE FACTOR=auto{1}\n4. #pragma ACCEL PARALLEL FACTOR=auto{2}\n5. #pragma ACCEL PARALLEL FACTOR=auto{16}\n6. #pragma ACCEL PARALLEL FACTOR=auto{1}", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "1": "\n\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_0 = i;\n        int j_0 = j;\n        \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n        hz[i_0][j_0] = hz[i_0][j_0] - 0.7 * (ex[i_0][j_0 + 1] - ex[i_0][j_0] + ey[i_0 + 1][j_0] - ey[i_0][j_0]);\n      }\n    }\n  }\n}\n", "2": "\n\n\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1;\n        int j_col = -1;\n        double dzi = (hz[i][j] - hz[i][j + 1]);\n        double dxe = (ex[i][j] - ex[i][j + 1]);\n        double dyi = (ey[i][j] - ey[i + 1][j]);\n        hz[i][j] = hz[i][j] + 0.7 * dzi + ((*(fict_ptr + j)) * (ex[i][j] - 2.0 * ey[i][j] + hz[i][j + 1]) - 0.7 * ((ey[i][j + 1] - ey[i + 1][j + 1]) * dxi + (ex[i + 1][j] - ex[i + 1][j + 1]) * dyi));\n        ex[i][j] = ex[i][j] + 0.7 * dxi + dyi;\n        ey[i][j] = ey[i][j] + 0.7 * dyi + dzi;\n      }\n    }\n  }\n}\n", "4": "\n \n#include <math.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/time.h>\n#include <cutil_inline.h>\n \n#define N 128\n#define M 128\n#define K 128\n#define double float\n// A is NxM\ndouble A[N][M];\n// B is MxK\ndouble B[M][K];\n// C is NxK\ndouble C[N][K];\n// Threads per block\n#define BLOCK_SIZE 16\n// Total number of threads\n#define NUM_THREADS 256\n \ndouble mul(double A,double B){\n  return A * B;\n}\n \nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[64][64],double A[64][64],double B[64][64])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* Standardize from: for(i = 0;i < 64;++i) {...} */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  for (i = 0; i < 64; i++) {\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (j = 0; j < 64; j++) {\n      C[i][j] *= beta;\n    }\n  }\n/* Standardize from: for(i = 0;i < 64;++i) {...} */\n  \n#pragma ACCEL PIPELINE auto{}\n  for (i = 0; i < 64; i++) {\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (k = 0; k < 64; k++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j < 64; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n/* Standardize from: for(i = 0;i < 64;++i) {...} */\n  \n#pragma ACCEL PIPELINE auto{off}\n  for (i = 0; i < 64; i++) {\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (j = 0; j < 64; j++) {\n      C[i][j] += C[i][j];\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To generate the given HLS codes in C, you should use the following natural language instructions for the specific #pragma values:\n\n1. For the function `kernel_jacobi_1d`:\n    - Treat the following function as a hardware kernel for acceleration.\n\n2. For the first loop:\n    - Don't automatically pipeline this loop.\n\n3. For tiling:\n    - Process this loop in its original, full form without breaking it into smaller chunks.\n\n4. For parallelization with a factor of 2:\n    - Run the iterations of this loop in parallel with a parallel factor of 2.\n\n5. For the inner loop (first usage):\n    - Run the iterations of this loop one after the other, not in parallel.\n\n6. For the inner loop (second usage):\n    - Run the iterations of this loop in parallel with a parallel factor of 8.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n7. For the function `kernel_jacobi_1d`:\n    - Transform the source file to apply the transforms.\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n\n7. For the function `kernel_jacobi_1d`:\n    - Transform the auto-pipeline transforms: off\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n\n7. For the function `kernel_jacobi_1d`:\n    - Transform the source file to a new file.\n    - Use the automatic kernel processor to implement the kernel.\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n\n7. For the second loop:\n    - Don't automatically pipeline this loop.\n\n8. For tiling:\n    - Process this loop in its original, full form without breaking it into smaller chunks.\n\n9. For parallelization with a factor of 2:\n    - Run the iterations of this loop in parallel with a parallel factor of 2.\n\n10. For the inner loop (first usage):\n    - Run the iterations of this loop one after the other, not in parallel.\n\n11. For the inner loop (second usage):\n    - Run the iterations of this loop in parallel with a parallel factor of 2.\n\n12. For the third loop:\n    - Don't automatically pipeline this loop.\n\n13. For tiling:\n    - Process this loop in its original, full form without breaking it into smaller chunks.\n\n14. For parallelization with a factor of 2:\n    - Run the iterations of this loop in parallel with a parallel factor of 2.\n\n15. For the fourth loop:\n    - Don't automatically pipeline this loop.\n\n16. For tiling:\n    - Process this loop in full form with a tile size of 128.\n\n17. For parallelization with a factor of 2:\n    - Run the iterations of this loop in parallel with a parallel factor of 2.\n\n18. For the fifth loop:\n    - Don't automatically pipeline this loop.\n\n19. For tiling:\n    - Process this loop in full form with a tile size of 4.\n\n20. For parallelization with a auto-parallel factor:\n    - Automatically parallelize this loop with a parallel factor of 2.\n\n21. For the sixth loop:\n    - Don't automatically pipeline this loop.\n\n22. For tiling:\n    - Process this loop in full form with a tile size of 4.\n\n23. For parallelization with a auto-parallel factor:\n    - Automatically parallelize this loop with a parallel factor of 2.\n\n24. For the seventh loop:\n    - Don't automatically pipeline this loop.\n\n25. For tiling:\n    - Process this loop in full form with a tile size of 4.\n\n26. For parallelization with a auto-parallel factor:\n    - Automatically parallelize this loop with a parallel factor of 2.\n\n27. For the eighth loop:\n    - Don't automatically pipeline this loop.\n\n28. For tiling:\n    - Process this loop in full form with a tile size of 4.\n\n29. For parallelization with a auto-parallel factor:\n    - Automatically parallelize this loop with a parallel factor of 2.\n\n30. For the ninth loop:\n    - Don't automatically pipeline this loop.\n\n31. For tiling:\n    - Process this loop in full form with a tile size of 4.\n\n32. For parallelization with a auto-parallel factor:\n    - Automatically parallelize this loop with a parallel factor of 2.\n\n33. For the function `kernel_jacobi_1d`:\n    - Automatically pipeline this kernel.\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n\n7. For the function `kernel_jacobi_1d`:\n    - Transform this kernel from a sequential kernel to a data-parallel kernel.\n\n8. For the second loop:\n    - Automatically pipeline this loop.\n\n9. For the first loop:\n    - Partition L1:complete\n\n10. For the first loop:\n    - Parallelize sequentially\n\n11. For the second loop:\n    - Parallelize with B4 (4)\n\n12. For the first loop:\n    - Parallelize with FACTOR=auto{1}\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To generate the given HLS codes in C, you can use the following concise natural language instruction for the process and pragma values:\n\n\"Designate the following function as a hardware kernel for acceleration\" - this describes the pragma value '#pragma ACCEL kernel'\n\n\"Automatically pipeline this loop without flattening\" - this maps to the pragma value '#pragma ACCEL PIPELINE auto{flatten}'\n\n\"Set the tile factor for loop tiling to be automatically determined as 1\" - this corresponds to the pragma value '#pragma ACCEL TILE FACTOR=auto{1}'\n\n\"Run the iterations of the following loops in parallel with a factor to be automatically determined as 2\" - for both loops, the pragma value is '#pragma ACCEL PARALLEL FACTOR=auto{2}'\n\nFor the provided code snippet, using these natural language instructions will generate the corresponding HLS codes in C with the specified pragma values.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 119; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 119; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 119; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 119; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "Apply pipeline optimization to the outer loop, disable automatic pipelining for the middle loop, and flatten the inner loop for parallelization using suitable HLS pragma directives.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 90; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n//#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 90; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = A[i][j] - 0.5 * (A[i][j] - A[i][j - 1]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n// Xilinx XRT kernel\n#pragma ACCEL kernel\n\nvoid kernel_2mm(double m1[4096],double m2[4096],double m3[4096],double prod[32768])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (i = 0; i < 32; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    for (j = 0; j < 32; j++) {\n      m3[i * 32 + j] = ((double )0);\n      for (k = 0; k < 32; k++) {\n        m3[i * 32 + j] += m1[i * 32 + k] * m2[k * 32 + j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n  for (i = 0; i < 32; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    for (j = 0; j < 32; j++) {\n      double sum = (double )0;\n      for (k = 0; k < 32; k++) {\n        sum += m1[i * 32 + k] * m3[k * 32 + j];\n      }\n      prod[i * 32 + j] = sum;\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n// This version has been generated by the AutoPipemizer tool.\n// The original code is: #pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PARALLEL reduction=E FACTOR=auto{2}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PARALLEL reduction=F FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[k][i] * D[k][j];\n      }\n    }\n  }\n/* G */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PARALLEL reduction=G FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "Process the loop in its original, full form without breaking it into smaller chunks. Treat the loop iterations as if they are a pipeline, automatically determining the optimal settings. Run two iterations of this loop in parallel. Within this loop, process 24 iterations in parallel, and then process the remaining iterations two at a time in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{24}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL reduction=u FACTOR=auto{__PARA__L2}\n    for (i = 1; i < 39; i++) {\n      b = 0.16666666666666666666666666L * f(i - 1);\n      u[i] = u[i] + su[i] * (h * (p[i] - b - u[i] - q[i]));\n    }\n    \n#pragma ACCEL PARALLEL reduction=q FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 39; i++) {\n      q[i] = g[i] * u[i + 1] + h * (p[i] - q[i]);\n    }\n  }\n}\n", "1": "\n #pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL reduction=u FACTOR=auto{__PARA__L2}\n    for (i = 1; i < 92; i++) {\n      b = sin(a);\n      u[i] = u[i] + b * v[i] + p[i];\n    }\n    \n#pragma ACCEL PARALLEL reduction=v FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 92; i++) {\n      b = u[i] - v[i];\n      y = i * (i - 1) * (i - 2);\n      v[i] = v[i] + b * a * y;\n    }\n    \n#pragma ACCEL PARALLEL reduction=p FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 92; i++) {\n      d = 1.0 + a * (y - v[i]) - b * u[i];\n      p[i] = d * p[i];\n    }\n  }\n}\n", "2": "\n #pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 1; i < 39; i++) {\n      b[i] = 0.0;\n      s[i] = 0.0;\n      q[i] = 0.0;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 0; i < 39; i++) {\n      y = _in_[i];\n      s[i] = y;\n      for (j = 1; j <= 39; j++) {\n        b[j] += y * d[i * 39 + j];\n      }\n      q[i] = b[i] / b[i * 39 + i];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n    for (i = 0; i < 39; i++) {\n      y = s[i];\n      q_1m_1 = q[i - 1];\n      x = y - q[i] * (b[i] - (q_1m_1) * b[i - 1]);\n      d[i] = x;\n    }\n  }\n}\n", "3": "\n #pragma ACCEL PIPELINE auto{__PIPE__L0}\n \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n for (t = 0; t < 40; t++) {\n  tmp = dt * DX;\n \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 1; i < 39; i++) {\n    sb = s[0] - e[i];\n    bb = b[i] - 2 * a[i] + a[0];\n    aa = a[i] - a[0];\n    cc = e[i] - d[i] - aa * dp[i] / dx;\n    dd = d[i] - d[0] - aa / dx * (fp[i] - fp[0] - sb * (d[0] - b[0]) / bb);\n    cp[i] = cp[i] - dd * cc / (bb * dd + eps);\n    dp[i] = dd + cc * cp[i] / dd;\n    fp[i] = fp[i] + cc * dp[i] / dd + sb * cp[i];\n    d[i] = d[i] + g[i] * tmp;\n    g[i] = g[i] + aa * tmp;\n    a[i] = a[i] + dp[i] * tmp;\n    b[i] = b[i] + cp[i] * tmp;\n    e[i] = e[i] + dd * tmp;\n  }\n  d[0] = 1.0;\n  e[0] = 0.0;\n  f[0] = 0.0;\n  g[0] = 0.0;\n  a[0] = 1.0;\n  b[0] = 0.0;\n}\n", "4": "\n #pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n  for (tj = 1;tj < 42;tj++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (tk = 1;tk < 42;tk++) {\n      \n#pragma ACCEL PARALLEL reduction=tmp2 FACTOR=auto{__PARA__L4}\n      for (i = 1;i < 240;i++) {\n        bv = dt * (xr[i] - x[tj]);\n        bw = dt * (xr[i] - x[tk]);\n        tmp2 = bv * bw;\n        a = A[i][j][tk] + A[i][j][tj];\n        tmp1 = A[i][j][tk] * bw + A[i][j][tj] * bv;\n        C[i][j] += tmp2 * a;\n        D[i][j] += tmp2 * tmp1;\n        F[i][j] += tmp1 * bv;\n        G[i][j] += tmp1 * bw;\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{24}\n    for (i = 1;i < 240;i++) {\n      b = B[i][j];\n      tmp1 = B[i][j] * F[i][j];\n      e = E[i][j] + G[i][j];\n      f = F[i][j] + B[i][j] * G[i][j];\n      \n#pragma ACCEL PARALLEL reduction=C[i][j] FACTOR=auto{__PARA__L5}\n      for (ii = 1;ii < 240;ii++) {\n        C[i][j] += B[i][ii] * E[i][ii];\n      }\n      D[i][j] = D[i][j] + tmp1 + e;\n      C[i][j] = C[i][j] + b * e;\n      F[i][j] = F[i][j] * b;\n      G[i][j] = G[i][j] * b;\n      E[i][j] = b * e;\n      B[i][j] = b * f;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n  for (i = 1;i < 240;i++) {\n    for (j = 1;j < 240;j++) {\n      q[i][j] = ((double )0);\n    }\n  }\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n  for (i = 1;i < 240;i++) {\n    for (j = 1;j < 240;j++) {\n      P[i][j] = C[i][j] - D[i][j];\n      Q[i][j] = P[i][j] / ((double )(2.0 * 41));\n      r[i][j] = Q[i][j] - G[i][j];\n      s[i][j] = F[i][j] - B[i][j] * r[i][j];\n      double _tmp_ = s[i][j];\n      for (k = 1;k < 240;k++) {\n        q[i][k] += _tmp_ * B[k][j];\n      }\n    }\n    double _tmp_ = 1.0e-4;\n    for (k = 1;k < 240;k++) {\n      q[i][k] = q[i][k] * _tmp_;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L8}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n  for (i = 1;i < 240;i++) {\n    for (j = 1;j < 240;j++) {\n      xr[i] += (( q[i][j] + r[i][j]) * x[j]);\n    }\n  }\n}\n"}}
{"input": "Define a hardware kernel for acceleration. Use parallel and pipeline optimizations for the nested loops. Ensure the outer loop runs in full form without breaking into smaller chunks, and the inner loops process iterations one after another, not in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{__PARA__L2}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction=D FACTOR=auto{__PARA__L3}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{2}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 0 + 1L * 2L * 7L;\n        int _in_i = 0 + 1L * 2L * 7L;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int ii = i + 1;\n        int jj = j + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes written in C, use the following natural language instruction for the specific #pragma values:\n\n1. To automatically pipeline the loop:\n   Use: \"Automatically pipeline this loop\"\n   Code: `#pragma ACCEL PIPELINE auto{}`\n\n2. To tile the loop with a factor determined automatically:\n   Use: \"Automatically determine the tiling factor for this loop\"\n   Code: `#pragma ACCEL TILE FACTOR=auto{1}`\n\n3. To run iterations of the loop in parallel with an automatically determined factor:\n   Use: \"Automatically determine the parallelization factor for this loop\"\n   Code: `#pragma ACCEL PARALLEL FACTOR=auto{2}`\n\n4. To set a specific parallelization factor for the inner loop:\n   Use: \"Set the parallelization factor for the inner loop to 15\"\n   Code: `#pragma ACCEL PARALLEL FACTOR=auto{15}`\n\n5. To set a specific parallelization factor for another inner loop:\n   Use: \"Set the parallelization factor for the inner loop to 3\"\n   Code: `#pragma ACCEL PARALLEL FACTOR=auto{3}`\n\nBy following these natural language instructions, the given HLS codes can be generated in C with the appropriate #pragma values.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L8}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L8}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L8}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "Process the iterations of the following loop in parallel, utilizing automatic factor calculation.\nDon't automatically pipeline this loop.\nProcess this loop in its original, full form without breaking it into smaller chunks.\nRun the iterations of this loop one after the other, not in parallel. Also, treat the following function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}\n", "2": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1 * i;\n        int j_col = j + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_col][j] - ex[i][j_col]) - 0.7 * (ey[i][j_col] - ey[i_col][j]);\n      }\n    }\n  }\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_gemver(int n,double alpha,double beta,double A[120][120],double u1[120],double v1[120],double u2[120],double v2[120],double w[120],double x[120],double y[120],double z[120])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 120; i++) {\n    x[i] = ((double )0);\n    y[i] = 0.0;\n    z[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 120; i++) {\n    double tmp_x = 0.0;\n    double tmp_y = 0.0;\n    double tmp_z = 0.0;\n    double u_entry = u1[i];\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 120; j++) {\n      double A_entry = A[i][j];\n      double v_entry = v1[j];\n      tmp_x += A_entry * v_entry;\n      tmp_y += A_entry * u_entry;\n      tmp_z += A_entry * v_entry * u_entry;\n    }\n    x[i] = alpha * tmp_x;\n    y[i] = alpha * tmp_y;\n    z[i] = beta * tmp_z + y[i];\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 120; i++) {\n    double tmp_x = ((double )0);\n    double tmp_y = ((double )0);\n    double u_entry = u2[i];\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 120; j++) {\n      double A_entry = A[j][i];\n      double v_entry = v2[j];\n      tmp_x += A_entry * v_entry;\n      tmp_y += A_entry * u_entry;\n    }\n    x[i] += tmp_x;\n    y[i] += alpha * 2.0 * u_entry * v2[i] + tmp_y;\n  }\n}\n"}}
{"input": "To generate the following HLS codes in C:\n```c\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps, int n, double A[120], double B[120])\n{\n  int t;\n  int i;\n#pragma ACCEL PIPELINE auto{flatten}\n#pragma ACCEL TILE FACTOR=auto{1}\n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n}\n```\n\nYou can use the following concise natural language instructions for each #pragma directive:\n\n1. \"Treat the following function as a hardware kernel for acceleration\"\n   - `#pragma ACCEL kernel`\n\n2. \"Don't automatically pipeline this loop, maintain original structure\"\n   - `#pragma ACCEL PIPELINE auto{flatten}` \n\n3. \"Process this loop in its original, full form without breaking it into smaller chunks\"\n   - `#pragma ACCEL TILE FACTOR=auto{1}`\n\n4. \"Run the iterations of this loop in parallel with the specified factor\"\n   - `#pragma ACCEL PARALLEL FACTOR=auto{2}` for the outer loop\n   - `#pragma ACCEL PARALLEL FACTOR=auto{15}` for the first inner loop\n   - `#pragma ACCEL PARALLEL FACTOR=auto{1}` for the second inner loop", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n5. \"Automatic parallelization enabled\"\n  ", "1": "\n\n5. \"Automatic parallelization enabled\"\n   - ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n\n6. \"Automatic tiling enabled\"\n   - ACCEL TILE FACTOR=auto{__TILE__L0}\n\n", "2": "\n\n5. \"Transform this for loop into a parallelized reduction loop\"\n   - `#pragma ACCEL PIPELINE auto{off}`\n   - `#pragma ACCEL TILE FACTOR=auto{1}`\n   - `#pragma ACCEL PARALLEL FACTOR=auto{15} reduction=A`\n", "3": "\n\n5. \"Set the target region array A to have a parallel storage\"\n   - `#pragma ACCEL PARALLEL FACTOR=auto{1} PARALLEL_FACTOR=A`\n\n6. \"Set the target region array B to have a parallel storage\"\n   - `#pragma ACCEL PARALLEL FACTOR=auto{1} PARALLEL_FACTOR=B`\n", "4": "\n\n5. \"Use the following space-time transform for the outer-most loop\"\n   - `#pragma ACCEL PIPELINE auto{__PIPE__L1}`\n   - `#pragma ACCEL TILE FACTOR=auto{__TILE__L1}`\n   - `#pragma ACCEL REGISTER FACTOR=auto{__REGISTER__L1}`\n  \n6. \"Use the following space-time transform for the middle-most loop\"\n   - `#pragma ACCEL PIPELINE auto{__PIPE__L2}`\n   - `#pragma ACCEL TILE FACTOR=auto{__TILE__L2}`\n   - `#pragma ACCEL REGISTER FACTOR=auto{__REGISTER__L2}`\n  \n7. \"Use the following space-time transform for the inner-most loop\"\n   - `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}`\n  \n8. \"Use the following space-time transform for the inner-most loop\"\n   - `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}`\n  \n"}}
{"input": "Process the following function as a hardware kernel for acceleration.\nEnsure the loop iterations run in parallel, each with an auto-determined factor.\nDisable automatic loop pipelining.\nSet the loop tiling factor to be determined automatically.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "1": "\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1*i;\n        int j_col = j + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_col][j] - ex[i][j_col]) - 0.7 * (ey[i][j_col] - ey[i_col][j]);\n      }\n    }\n  }\n}\n", "2": "\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "3": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int s = i * 240 + j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 0 + 1L * 240L;\n        int _in_i = 0 + 1L * 200L;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n"}}
{"input": "To generate the given HLS codes in C, use the following natural language instruction:\n\n\"Designate the following function as a hardware kernel for acceleration. Sequentially process the iterations of the outer loop, and parallelize the inner loop with a factor of 15. Automatically pipeline the loops and use a tiling factor of 1. Additionally, parallelize the second inner loop with a factor of 1.\"\n\nThis instruction encompasses the use of the following #pragma values:\n- '#pragma ACCEL kernel' to designate the function as a hardware kernel\n- '#pragma ACCEL PIPELINE auto{flatten}' to automatically pipeline the loops\n- '#pragma ACCEL TILE FACTOR=auto{1}' to apply a tiling factor of 1\n- '#pragma ACCEL PARALLEL FACTOR=auto{2}' to parallelize the outer loop\n- '#pragma ACCEL PARALLEL FACTOR=auto{15}' to parallelize the first inner loop with a factor of 15\n- '#pragma ACCEL PARALLEL FACTOR=auto{1}' to parallelize the second inner loop with a factor of 1", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n\n #pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n\n#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n\n#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction=D FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
{"input": "To generate the given C code with HLS pragmas, you should follow the natural language instructions below:\n\n- Apply automatic pipelining to the loop: '#pragma ACCEL PIPELINE auto{}'\n- Tile the loop with a factor determined automatically: '#pragma ACCEL TILE FACTOR=auto{1}'\n- Parallelize the loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{2}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{3}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{10}'", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}'\n\n #pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n", "1": "\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{_1}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L2}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L4}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L5}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L6}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "2": "\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{4}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{1}'", "3": "\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}'\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}\n", "4": "\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}'\n- Parallelize this nested loop with a factor of 2: '#pragma ACCEL PARALLEL FACTOR=auto{2}'\n \n#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}\n"}}
