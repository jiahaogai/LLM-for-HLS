{"input": "To generate the described HLS C code, please use the following natural language instruction:\n\n\"Define a function as a hardware acceleration kernel to optimize matrix calculations. Within this function, disable automatic pipelining and do not partition the first two loops, but allow the compiler to choose the amount of parallelism for the innermost loops. Specifically, use the maximum available parallelism for the loop that accumulates `tmp` but limit parallelism to pairs for its outer loop, and completely unroll the innermost loop for updating `D` while maximizing parallelism for its outer loop.\"", "output": "#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{8}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": " function kernel_atax_D(int nr,int nc,int nk,double A[40][40],double B[40][40],double C[40][40],double D[40][40],double tmp[40][40],double a,double b,double c,double d,double e,double f,double g,double h,double i,double j,double n,double x,double y,double z,double u,double v,double w,double A0,double B0,double C0,double D0,double tmp0,double a0,double b0,double c0,double d0,double e0,double f0,double g0,double h0,double i0,double n0,double x0,double y0,double z0,double u0,double v0,double w0,double A00,double B00,double C00,double D00,double tmp00,double a00,double b00,double c00,double d00,double e00,double f00,double g00,double h00,double i00,double n00,double x00,double y00,double z00,double u00,double v00,double w00,double A000,double B000,double C000,double D000,double tmp000,double a000,double b000,double c000,double d000,double e000,double f000,double g000,double h000,double i000,double n000,double x000,double y000,double z000,double u000,double v000,double w000,double A0000,double B0000,double C0000,double D0000,double tmp0000,double a0000,double b0000,double c0000,double d0000,double e0000,double f0000,double g0000,double h0000,double i0000,double n0000,double x0000,double y0000,double z0000,double u0000,double v0000,double w0000,double A00000,double B00000,double C00000,double D00000,double tmp00000,double a00000,double b00000,double c00000,double d00000,double e00000,double f00000,double g00000,double h00000,double i00000,double n00000,double x00000,double y00000,double z00000,double u00000,double v00000,double w00000,double A000000,double B000000,double C000000,double D000000,double tmp000000,double a000000,double b000000,double c000000,double d000000,double e000000,double f000000,double g000000,double h000000,double i000000,double n000000,double x000000,double y000000,double z000000,double u000000,double v000000,double w000000,double A0000000,double B0000000,double C0000000,double D0000000,double tmp0000000,double a0000000,double b0000000,double c0000000,double d000000", "1": " #pragma ACCEL kernel\n\nvoid kernel_2mm_2D_D(int ni,int nj,int nk,int nl,double alpha,double beta,doubletmp[40][40],double A[40][40],double B[40][40],double C[40][40],doubleD[40][40])\n{\n  int i;\n  int j;\n  int k;\n  for (i = 0; i < 40; i++) \n    for (j = 0; j < 40; j++) \n     tmp[i][j] = 0.0;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) \n    for (k = 0; k < 40; k++) \n     tmp[i][k] = 0.0;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (j = 0; j < 40; j++) \n    for (k = 0; k < 40; k++) \n     tmp[j][k] = 0.0;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) \n    for (j = 0; j < 40; j++) \n     D[i][j] = 0.0;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) \n    for (j = 0; j < 40; j++) \n     D[i][j] = 0.0;\n  \n#pragma ACCEL PARALLEL FACTOR=auto{40}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{40}\n  for (i = 0; i < 40; i++) \n    for (j = 0; j < 40; j++) \n      B[i][j] = alpha * (tmp[i][j] + A[i][k] * B[k][j]);\n  \n#pragma ACCEL PARALLEL FACTOR=auto{40}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{40}\n  for (i = 0; i < 40; i++) \n    for (j = 0; j < 40; j++) \n      C[i][j] = alpha * (tmp[i][j] + A[i][k] * C[k][j]);\n  \n#pragma ACCEL PARALLEL FACTOR=auto{40}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{40}\n  for (i = 0; i < 40; i++) \n    for (j = 0; j < 40; j++) \n      D[i][j] = beta * D[i][j] + B[i][k] * C[k][j];\n}\n", "2": " Tags: for, parallel, matrix, unroll, partition, kernel, function, disable, innermost, loop, outer, maximum, pairs, accumulates, updating, automatic, unroll\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "3": " \n\n#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,doubletmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  for (i = 0; i < 40; i++) \n    for (j = 0; j < 50; j++) \n     tmp[i][j] = 0.0;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) \n    for (k = 0; k < 70; k++) \n     tmp[i][k] = alpha * A[i][k] * B[k][j];\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) \n    for (j = 0; j < 80; j++) \n      D[i][j] *= beta;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) \n    for (j = 0; j < 50; j++) \n      D[i][j] += 0.0;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) \n    for (j = 0; j < 80; j++) \n      D[i][j] += 0.0;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) \n    for (k = 0; k < 50; k++) \n      C[i][k] *= 2.0;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) \n    for (j = 0; j < 50; j++) \n      B[i][j] *= 2.0;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) \n    for (j = 0; j < 70; j++) \n      A[i][j] *= 2.0;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) \n    for (j = 0; j < 80; j++) \n      D[i][j", "4": " //#pragma ACCEL kernel\n\nvoid kernel_atax(double A[3900][3900],double x[3900],double y[3900],double tmp[3900],double D[3900],double alpha,double beta,double outer_prod,double inn_prod)\n{\n  int i;\n  int j;\n  for (i = 0; i < 3900; i++) \n    y[i] = 0.0;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{3900}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{3900}\n  for (i = 0; i < 3900; i++) \n    tmp[i] = 0.0;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{3900}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{3900}\n  for (i = 0; i < 3900; i++) \n    D[i] = 0.0;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{3900}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{3900}\n  for (i = 0; i < 3900; i++) \n    for (j = 0; j < 3900; j++) \n      tmp[i] += A[i][j] * x[j];\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{3900}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{3900}\n  for (i = 0; i < 3900; i++) \n    y[i] = beta * y[i];\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{3900}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{3900}\n  for (i = 0; i < 3900; i++) \n    y[i] += alpha * (tmp[i] * inn_prod + outer_prod * D[i]);\n}\n"}}
{"input": "Instructions to generate the described HLS pragmas for the `kernel_2mm` function:\n\n1. Declare the function as a hardware kernel for acceleration.\n2. Prevent the outermost loop (over `i`) from being automatically pipelined, and ensure that it runs with no tiling and no parallelization. Treat it as an uninterrupted, sequential loop.\n3. In the inner loop (over `j`), for the multiplication of matrices A and B, enable complete flattening of the loop by the compiler for potentially enhanced pipelining, but ensure no tiling is applied and execute two iterations concurrently.\n4. For the loop over `k` inside the inner loop, enable parallel computation of the matrix multiplication with reduction on 'tmp', but ensure that while reducing, the operations are not run concurrently but in sequence.\n5. For evaluating the matrix multiplication with matrix C and updating matrix D, revert the outermost loop (over `i`) back to default pipelining behavior determined by the compiler, continue with no tiling and no parallelization.\n6. In the subsequent inner loop (over `j`), disable automatic pipelining, tile this loop in chunks of eight iterations for better data locality, and ensure it runs without any parallel execution.\n7. For the loop over `k` inside the last inner loop, allow the execution of eight concurrent iterations during the reduction process on 'D' to potentially speed up the computation. \n\nTo translate these instructions into #pragma statements while maintaining their respective configurations, use the following guidance:\n\n- `#pragma ACCEL kernel` to mark the function for acceleration.\n- `#pragma ACCEL PIPELINE auto{off}` to disable loop pipelining.\n- `#pragma ACCEL TILE FACTOR=auto{1}` to prevent loop tiling.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}` to disable loop parallelization.\n- `#pragma ACCEL PIPELINE auto{flatten}` to request the compiler to flatten the loop if possible.\n- `#pragma ACCEL PIPELINE auto{}` to allow the compiler to decide on the pipelining strategy.\n- `#pragma ACCEL TILE FACTOR=auto{8}` to tile the loop by a factor of eight.\n- `#pragma ACCEL PARALLEL FACTOR=auto{2}` or `#pragma ACCEL PARALLEL FACTOR=auto{8}` to specify the desired concurrency level (2 or 8) during the execution of a loop.\n- `#pragma ACCEL PARALLEL reduction = variable FACTOR=auto{1}` or `#pragma ACCEL PARALLEL reduction = variable FACTOR=auto{8}` to enable parallel reduction on 'tmp' or 'D' with specified factors of concurrency. \n\nApply these annotations directly before the loops or scopes they are intended to influence.", "output": "#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{8}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "\n\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,doubletmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n  for (i = 0; i < 40; i++) \n    for (j = 0; j < 50; j++) \n     tmp[i][j] = 0.0;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) \n    for (k = 0; k < 70; k++) \n     tmp[i][k] = 0.0;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) \n    for (j = 0; j < 50; j++) \n      A[i][j] = 0.0;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) \n    for (k = 0; k < 50; k++) \n      B[i][k] = 0.0;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) \n    for (j = 0; j < 80; j++) \n      C[i][j] = 0.0;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) \n    for (j = 0; j < 80; j++) \n      D[i][j] = 0.0;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) \n    for (j = 0; j < 80; j++) \n      D[i][j] = 0.0;\n  \n#pragma ACCEL PARALLEL reduction = variable FACTOR=auto{1}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) \n    for (j = 0; j < 50; j++) \n      D[i][j] = 0.0;\n  \n#pragma ACCEL PARALLEL reduction = variable FACTOR=auto{8}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n  for (i = 0; i < 40; i++) \n    for (j = 0; j < 50; j++) \n      A[i][j] = (double )0;\n  \n#pragma ACCEL PARAL", "1": "\n\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,doubletmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; k++) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{8}\n      for (k = 0; k < 50; k++) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "2": "\n\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,doubletmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{8}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "3": "\n\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{8}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "4": "\n\n #pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,doubletmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 50; j++) {\n     tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = variable FACTOR=auto{1}\n      for (k = 0; k < 70; k++) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = variable FACTOR=auto{8}\n      for (k = 0; k < 50; k++) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma end scop\n}\n"}}
