{"instruction": "Generate HLS code with the following instructions:", "input": "This code describes a function \"bicg\" which performs Bi-Conjugate Gradient calculations. The function takes five inputs: a matrix 'A', and vectors 'p', 'r', 's_out', 'q_out', all of type float. The function starts with copying the inputs to local buffers 'buff_A', 'buff_p', 'buff_r', 'buff_s_out' and 'buff_q_out' in the \"lprd_1\" and \"lprd_2\" labelled loops. After that in \"lp1\" and \"lp2\" labelled loops, it runs a nested loop to calculate the sum of multiplication of elements of 'buff_A' and 'buff_r', storing the result in 'buff_s_out'. Another pair of nested loops \"lp3\" and \"lp4\" calculates the sum of multiplication of elements of 'buff_A' and 'buff_p', storing the result in 'buff_q_out'. Finally, in the \"lpwr\" labelled loop, it writes back the results to 's_out' and 'q_out'.", "output": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n#define N 64\n\n#define DATA_TYPE float\n#define SCALAR_VAL(x) x##f\n#define SQRT_FUN(x) sqrtf(x)\n#define EXP_FUN(x) expf(x)\n#define POW_FUN(x,y) powf(x,y)\n\nvoid bicg(DATA_TYPE A[N][N], DATA_TYPE p[N], DATA_TYPE r[N], DATA_TYPE s_out[N], DATA_TYPE q_out[N]);\n\nvoid bicg(DATA_TYPE A[N][N], DATA_TYPE p[N], DATA_TYPE r[N], DATA_TYPE s_out[N], DATA_TYPE q_out[N])\n{\n    int i, j;\n\n\tDATA_TYPE buff_A[N][N];\n\tDATA_TYPE buff_p[N];\n\tDATA_TYPE buff_r[N];\n\tDATA_TYPE buff_s_out[N];\n\tDATA_TYPE buff_q_out[N];\n\n\tlprd_1: for (i = 0; i < N; i++) {\n\t\tbuff_p[i] = p[i];\n\t\tbuff_r[i] = r[i];\n\t\tbuff_s_out[i] = 0;\n\t\tbuff_q_out[i] = 0;\n\t\tlprd_2: for (j = 0; j < N; j++) {\n\t\t\tbuff_A[i][j] = A[i][j];\n\t\t}\n\t}\n\n    lp1: for (i = 0; i < N; i++) {\n        lp2: for (j = 0; j < N; j++) {\n\t        buff_s_out[j] = buff_s_out[j] + buff_A[i][j] * buff_r[i];\n\t\t}\n\t}\n\n\tlp3: for (i = 0; i < N; i++) {\n        lp4: for (j = 0; j < N; j++) {\n\t        buff_q_out[i] = buff_q_out[i] + buff_A[i][j] * buff_p[j];\n\t    }\n    }\n\n\tlpwr: for (i = 0; i < N; i++) {\n\t\ts_out[i] = buff_s_out[i];\n\t\tq_out[i] = buff_q_out[i];\n\t}\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "This C code defines a function named `mvt` that performs Matrix Vector Transform on input arrays using the defined macros. The function accepts six parameters - five 1-dimensional `DATA_TYPE` arrays and a 2d `DATA_TYPE` array. \n\nIn the function, five buffer arrays `buff_x1`, `buff_x2`, `buff_y1`, `buff_y2`, and `buff_A` of `DATA_TYPE` are declared. The first loop labeled `lprd_1`, copies the data from the original arrays `x1`, `x2`, `y1`, `y2`, and `A` into the buffer arrays. For `buff_A` the copying is done in nested loops labeled `lprd_2`.\n\nNext, two sets of nested loops labeled `lp1`, `lp2`, `lp3`, and `lp4` perform multiplication and addition operations on these buffer arrays. The first set (the loops labeled `lp1` and `lp2`) loops through each element i of the `buff_x1` array, and for each i, it loops through each element j of the `buff_A` and `buff_y1` arrays and adds the product of `buff_A[i][j]` and `buff_y1[j]` to `buff_x1[i]`.\n\nThe second set of nested loops (the loops labeled `lp3` and `lp4`) perform similar operations but for elements i of the `buff_x2` array. It adds the product `buff_A[j][i]` and `buff_y2[j]` to `buff_x2[i]`.\n\nAnd finally, in the loop labelled `lpwr`, it writes the results back into the output arrays `x1_out` and `x2_out`.\n\nFor HLS optimization, the #pragma directives can be applied on these loops to control the loop scheduling and optimize for execution parallelism or pipelining depending on the specific computational requirement.", "output": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n#define N 64\n\n#define DATA_TYPE float\n#define SCALAR_VAL(x) x##f\n#define SQRT_FUN(x) sqrtf(x)\n#define EXP_FUN(x) expf(x)\n#define POW_FUN(x,y) powf(x,y)\n\nvoid mvt(DATA_TYPE A[N][N], DATA_TYPE x1[N], DATA_TYPE x2[N], DATA_TYPE y1[N], DATA_TYPE y2[N], DATA_TYPE x1_out[N], DATA_TYPE x2_out[N]);\n\n\nvoid mvt(DATA_TYPE A[N][N], DATA_TYPE x1[N], DATA_TYPE x2[N], DATA_TYPE y1[N], DATA_TYPE y2[N], DATA_TYPE x1_out[N], DATA_TYPE x2_out[N])\n{\n\tint i, j;\n\tDATA_TYPE buff_A[N][N];\n\tDATA_TYPE buff_x1[N];\n\tDATA_TYPE buff_x2[N];\n\tDATA_TYPE buff_y1[N];\n\tDATA_TYPE buff_y2[N];\n\n\tlprd_1: for (i = 0; i < N; i++) {\n\t\tbuff_x1[i] = x1[i];\n\t\tbuff_x2[i] = x2[i];\n\t\tbuff_y1[i] = y1[i];\n\t\tbuff_y2[i] = y2[i];\n    \tlprd_2: for (j = 0; j < N; j++) {\n\t\t\tbuff_A[i][j] = A[i][j];\n\t\t}\n\t}\n\n\tlp1: for (i = 0; i < N; i++) {\n    \tlp2: for (j = 0; j < N; j++) {\n      \t\tbuff_x1[i] = buff_x1[i] + buff_A[i][j] * buff_y1[j];\n\t\t}\n\t}\n\n\tlp3: for (i = 0; i < N; i++) {\n\t\tlp4: for (j = 0; j < N; j++) {\n    \t\tbuff_x2[i] = buff_x2[i] + buff_A[j][i] * buff_y2[j];\n\t\t}\n\t}\n\t\n\tlpwr: for (i = 0; i < N; i++) {\n\t\tx1_out[i] = buff_x1[i];\n\t\tx2_out[i] = buff_x2[i];\n\t}\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "This code is implementing an Optical Flow algorithm to estimate motion vectors in videos. The whole process is organized into multiple stages with each stage doing a specific part of the calculation:\n1. First, the frames are read from a 2D array and particular contributing frames are separated out.\n2. The function 'gradient_xy_calc' is called that calculates the x and y gradients of the image using a windowed operation.\n3. Following this, the 'gradient_z_calc' function computes the gradient in the z direction (time) by applying a simple filter across the frames of the images.\n4. After the x, y, and z gradients are calculated, the 'gradient_weight_y' and 'gradient_weight_x' functions apply a 2D gaussian filter to them.\n5. The 'outer_product' function subsequently calculates the outer product of the gradients, producing a structure tensor for every pixel.\n6. 'tensor_weight_y' and 'tensor_weight_x' act as another level of smoothing, specifically applying a gaussian filter to the structure tensor in the x and y directions.\n7. Finally, 'flow_calc' evaluates and stores the output flow or motion vector for each pixel using the resultant tensors.\n8. The 'optical_flow' function at the top incorporates all these functions and transmits data between them.\n\nFor HLS #pragma directives:\n1. '#pragma HLS array_partition' is used to implement array partitioning in HLS, which improves the parallelism in the loop by allowing multiple array elements to be accessed simultaneously.\n2. The loops have a '#pragma HLS pipeline II=1' instruction which enables pipelining of these loops with an initiation interval of 1, hence accelerating the computation.\n3. The '#pragma HLS data_pack variable' directive is used to remove the inter-field gaps in the structs, essentially 'packing' the data.\n4. The 'HLS dataflow' can take the parallelism to the next level by overlapping the execution of different functions called from the top-level function. However, the loop order still needs to be maintained due to the data dependencies.\n5. The '#pragma HLS DATAFLOW' enables the Data Flow optimization directive/region, allowing concurrent execution of the function calls and loops for overall latency reduction.", "output": "/*===============================================================*/\n/*                                                               */\n/*                      optical_flow.cpp                         */\n/*                                                               */\n/*             Hardware function for optical flow                */\n/*                                                               */\n/*===============================================================*/\n\nconst int MAX_HEIGHT = 436;\nconst int MAX_WIDTH = 1024;\n\n// basic typedefs\n\n#include \"ap_fixed.h\"\n#include <hls_video.h>\ntypedef ap_fixed<17,9> input_t;\ntypedef ap_fixed<32,13> pixel_t;\ntypedef ap_fixed<32,27> outer_pixel_t;\ntypedef ap_fixed<64,56> calc_pixel_t;\ntypedef ap_fixed<32,13> vel_pixel_t;\n\ntypedef float pixel_t;\ntypedef float outer_pixel_t;\ntypedef float vel_pixel_t;\n\ntypedef struct{\n\tpixel_t x;\n\tpixel_t y;\n\tpixel_t z;\n}gradient_t;\n\ntypedef struct{\n    outer_pixel_t val[6];\n}outer_t; \n\ntypedef struct{\n    outer_pixel_t val[6];\n}tensor_t;\n\ntypedef struct{\n    vel_pixel_t x;\n    vel_pixel_t y;\n}velocity_t;\n\n\ntypedef ap_uint<64> frames_t;\n\n#include \"optical_flow.h\"\n// use HLS video library\n\n\n// use HLS fixed point\n// convolution filters\nconst int GRAD_WEIGHTS[] =  {1,-8,0,8,-1};\nconst pixel_t GRAD_FILTER[] = {0.0755, 0.133, 0.1869, 0.2903, 0.1869, 0.133, 0.0755};\nconst pixel_t TENSOR_FILTER[] = {0.3243, 0.3513, 0.3243};\n\n// top-level function \n#pragma SDS data access_pattern(frames:SEQUENTIAL, outputs:SEQUENTIAL)\nvoid optical_flow(frames_t   frames[MAX_HEIGHT][MAX_WIDTH],\n                  velocity_t outputs[MAX_HEIGHT][MAX_WIDTH]);\n\n// define these constants so they can be used in pragma\nconst int max_width = MAX_WIDTH; \nconst int default_depth = MAX_WIDTH;\n// calculate gradient in x and y directions\nvoid gradient_xy_calc(input_t frame[MAX_HEIGHT][MAX_WIDTH],\n    pixel_t gradient_x[MAX_HEIGHT][MAX_WIDTH],\n    pixel_t gradient_y[MAX_HEIGHT][MAX_WIDTH])\n{\n  // our own line buffer\n  static pixel_t buf[5][MAX_WIDTH];\n  #pragma HLS array_partition variable=buf complete dim=1\n\n  // small buffer\n  pixel_t smallbuf[5];\n  #pragma HLS array_partition variable=smallbuf complete dim=0\n  \n  // window buffer\n  hls::Window<5,5,input_t> window;\n\n  const int GRAD_WEIGHTS[] =  {1,-8,0,8,-1};\n\n  GRAD_XY_OUTER: for(int r=0; r<MAX_HEIGHT+2; r++)\n  {\n    GRAD_XY_INNER: for(int c=0; c<MAX_WIDTH+2; c++)\n    {\n      #pragma HLS pipeline II=1\n      // read out values from current line buffer\n      for (int i = 0; i < 4; i ++ )\n        smallbuf[i] = buf[i+1][c];\n      // the new value is either 0 or read from frame\n      if (r<MAX_HEIGHT && c<MAX_WIDTH)\n        smallbuf[4] = (pixel_t)(frame[r][c]);\n      else if (c < MAX_WIDTH)\n        smallbuf[4] = 0;\n      // update line buffer\n      if(r<MAX_HEIGHT && c<MAX_WIDTH)\n      {\n        for (int i = 0; i < 4; i ++ )\n          buf[i][c] = smallbuf[i];\n        buf[4][c] = smallbuf[4];\n      }\n      else if(c<MAX_WIDTH)\n      {\n        for (int i = 0; i < 4; i ++ )\n          buf[i][c] = smallbuf[i];\n        buf[4][c] = smallbuf[4];\n      }\n\n      // manage window buffer\n      if(r<MAX_HEIGHT && c<MAX_WIDTH)\n      {\n        window.shift_pixels_left();\n        \n        for (int i = 0; i < 5; i ++ )\n          window.insert_pixel(smallbuf[i],i,4);\n      }\n      else\n      {\n        window.shift_pixels_left();\n        window.insert_pixel(0,0,4);\n        window.insert_pixel(0,1,4);\n        window.insert_pixel(0,2,4);\n        window.insert_pixel(0,3,4);\n        window.insert_pixel(0,4,4);\n      }\n\n      // compute gradient\n      pixel_t x_grad = 0;\n      pixel_t y_grad = 0;\n      if(r>=4 && r<MAX_HEIGHT && c>=4 && c<MAX_WIDTH)\n      {\n        GRAD_XY_XYGRAD: for(int i=0; i<5; i++)\n        {\n          x_grad += window.getval(2,i)*GRAD_WEIGHTS[i];\n          y_grad += window.getval(i,2)*GRAD_WEIGHTS[i];\n        }\n        gradient_x[r-2][c-2] = x_grad/12;\n        gradient_y[r-2][c-2] = y_grad/12;\n      }\n      else if(r>=2 && c>=2)\n      {\n        gradient_x[r-2][c-2] = 0;\n        gradient_y[r-2][c-2] = 0;\n      }\n    }\n  }\n}\n\n// calculate gradient in the z direction\nvoid gradient_z_calc(input_t frame1[MAX_HEIGHT][MAX_WIDTH], \n    input_t frame2[MAX_HEIGHT][MAX_WIDTH], \n    input_t frame3[MAX_HEIGHT][MAX_WIDTH], \n    input_t frame4[MAX_HEIGHT][MAX_WIDTH], \n    input_t frame5[MAX_HEIGHT][MAX_WIDTH], \n    pixel_t gradient_z[MAX_HEIGHT][MAX_WIDTH])\n{\n  const int GRAD_WEIGHTS[] =  {1,-8,0,8,-1};\n  GRAD_Z_OUTER: for(int r=0; r<MAX_HEIGHT; r++)\n  {\n    GRAD_Z_INNER: for(int c=0; c<MAX_WIDTH; c++)\n    {\n      #pragma HLS pipeline II=1\n      gradient_z[r][c] =((pixel_t)(frame1[r][c]*GRAD_WEIGHTS[0] \n                        + frame2[r][c]*GRAD_WEIGHTS[1]\n                        + frame3[r][c]*GRAD_WEIGHTS[2]\n                        + frame4[r][c]*GRAD_WEIGHTS[3]\n                        + frame5[r][c]*GRAD_WEIGHTS[4]))/12;\n    }\n  }\n}\n\n// average the gradient in y direction\nvoid gradient_weight_y(pixel_t gradient_x[MAX_HEIGHT][MAX_WIDTH],\n    pixel_t gradient_y[MAX_HEIGHT][MAX_WIDTH],\n    pixel_t gradient_z[MAX_HEIGHT][MAX_WIDTH],\n    gradient_t filt_grad[MAX_HEIGHT][MAX_WIDTH])\n{\n  hls::LineBuffer<7,MAX_WIDTH,gradient_t> buf;\n\n  const pixel_t GRAD_FILTER[] = {0.0755, 0.133, 0.1869, 0.2903, 0.1869, 0.133, 0.0755};\n  GRAD_WEIGHT_Y_OUTER: for(int r=0; r<MAX_HEIGHT+3; r++)\n  {\n    GRAD_WEIGHT_Y_INNER: for(int c=0; c<MAX_WIDTH; c++)\n    {\n      #pragma HLS pipeline II=1\n      #pragma HLS dependence variable=buf inter false\n\n      if(r<MAX_HEIGHT)\n      {\n        buf.shift_pixels_up(c);\n        gradient_t tmp;\n        tmp.x = gradient_x[r][c];\n        tmp.y = gradient_y[r][c];\n        tmp.z = gradient_z[r][c];\n        buf.insert_bottom_row(tmp,c);\n      }\n      else\n      {\n        buf.shift_pixels_up(c);\n        gradient_t tmp;\n        tmp.x = 0;\n        tmp.y = 0;\n        tmp.z = 0;\n        buf.insert_bottom_row(tmp,c);\n      }     \n\n      gradient_t acc;\n      acc.x = 0;\n      acc.y = 0;\n      acc.z = 0;\n      if(r >= 6 && r<MAX_HEIGHT)\n      { \n        GRAD_WEIGHT_Y_ACC: for(int i=0; i<7; i++)\n        {\n          acc.x += buf.getval(i,c).x*GRAD_FILTER[i];\n          acc.y += buf.getval(i,c).y*GRAD_FILTER[i];\n          acc.z += buf.getval(i,c).z*GRAD_FILTER[i];\n        }\n        filt_grad[r-3][c] = acc;\n      }\n      else if(r>=3)\n      {\n        filt_grad[r-3][c] = acc;\n      }\n    }\n  }\n}\n\n// average gradient in the x direction\nvoid gradient_weight_x(gradient_t y_filt[MAX_HEIGHT][MAX_WIDTH],\n                       gradient_t filt_grad[MAX_HEIGHT][MAX_WIDTH])\n{\n  hls::Window<1,7,gradient_t> buf;\n  const pixel_t GRAD_FILTER[] = {0.0755, 0.133, 0.1869, 0.2903, 0.1869, 0.133, 0.0755};\n  GRAD_WEIGHT_X_OUTER: for(int r=0; r<MAX_HEIGHT; r++)\n  {\n    GRAD_WEIGHT_X_INNER: for(int c=0; c<MAX_WIDTH+3; c++)\n    {\n      #pragma HLS pipeline II=1\n      buf.shift_pixels_left();\n      gradient_t tmp;\n      if(c<MAX_WIDTH)\n      {\n        tmp = y_filt[r][c];\n      }\n      else\n      {\n        tmp.x = 0;\n        tmp.y = 0;\n        tmp.z = 0;  \n      }\n      buf.insert_pixel(tmp,0,6);\n\n      gradient_t acc;\n      acc.x = 0;\n      acc.y = 0;\n      acc.z = 0;\n      if(c >= 6 && c<MAX_WIDTH) \n      {\n        GRAD_WEIGHT_X_ACC: for(int i=0; i<7; i++)\n        {\n          acc.x += buf.getval(0,i).x*GRAD_FILTER[i];\n          acc.y += buf.getval(0,i).y*GRAD_FILTER[i];\n          acc.z += buf.getval(0,i).z*GRAD_FILTER[i];\n        }\n        filt_grad[r][c-3] = acc;\n      }\n      else if(c>=3)\n      {\n        filt_grad[r][c-3] = acc;\n      }\n    }\n  }\n}\n\n// outer product \nvoid outer_product(gradient_t gradient[MAX_HEIGHT][MAX_WIDTH],\n     outer_t outer_product[MAX_HEIGHT][MAX_WIDTH])\n{\n  OUTER_OUTER: for(int r=0; r<MAX_HEIGHT; r++)\n  {\n    OUTER_INNER: for(int c=0; c<MAX_WIDTH; c++)\n    {\n      #pragma HLS pipeline II=1\n      gradient_t grad = gradient[r][c];\n      outer_pixel_t x = (outer_pixel_t) grad.x;\n      outer_pixel_t y = (outer_pixel_t) grad.y;\n      outer_pixel_t z = (outer_pixel_t) grad.z;\n      outer_t out;\n      out.val[0] = (x*x);\n      out.val[1] = (y*y);\n      out.val[2] = (z*z);\n      out.val[3] = (x*y);\n      out.val[4] = (x*z);\n      out.val[5] = (y*z);\n      outer_product[r][c] = out;\n    }\n  }\n}\n\n// tensor weight\nvoid tensor_weight_y(outer_t outer[MAX_HEIGHT][MAX_WIDTH],\n                     tensor_t tensor_y[MAX_HEIGHT][MAX_WIDTH])\n{\n  hls::LineBuffer<3,MAX_WIDTH,outer_t> buf;\n  const pixel_t TENSOR_FILTER[] = {0.3243, 0.3513, 0.3243};\n  TENSOR_WEIGHT_Y_OUTER: for(int r=0; r<MAX_HEIGHT+1; r++)\n  {\n    TENSOR_WEIGHT_Y_INNER: for(int c=0; c<MAX_WIDTH; c++)\n    {\n      #pragma HLS pipeline II=1\n      \n      outer_t tmp;\n      #pragma HLS data_pack variable=tmp\n      #pragma HLS data_pack variable=buf.val[0]\n      buf.shift_pixels_up(c);\n      if(r<MAX_HEIGHT)\n      {\n        tmp = outer[r][c];\n      }\n      else\n      {\n        TENSOR_WEIGHT_Y_TMP_INIT: for(int i=0; i<6; i++)\n          tmp.val[i] = 0;\n      }   \n      buf.insert_bottom_row(tmp,c);\n\n      tensor_t acc;\n      TENSOR_WEIGHT_Y_ACC_INIT: for(int k =0; k<6; k++)\n        acc.val[k] = 0;\n     \n      if (r >= 2 && r < MAX_HEIGHT) \n      {\n        TENSOR_WEIGHT_Y_TMP_OUTER: for(int i=0; i<3; i++)\n        {\n          tmp = buf.getval(i,c);\n          pixel_t k = TENSOR_FILTER[i];\n          TENSOR_WEIGHT_Y_TMP_INNER: for(int component=0; component<6; component++)\n          {\n            acc.val[component] += tmp.val[component]*k;\n          }\n        }\n      }\n      if(r >= 1)\n      { \n        tensor_y[r-1][c] = acc;      \n      }\n    }\n  }\n}\n\nvoid tensor_weight_x(tensor_t tensor_y[MAX_HEIGHT][MAX_WIDTH],\n                     tensor_t tensor[MAX_HEIGHT][MAX_WIDTH])\n{\n  hls::Window<1,3,tensor_t> buf;\n  const pixel_t TENSOR_FILTER[] = {0.3243, 0.3513, 0.3243};\n  //const float TENSOR_FILTER[] = {0.3243, 0.3513, 0.3243};\n  TENSOR_WEIGHT_X_OUTER: for(int r=0; r<MAX_HEIGHT; r++)\n  {\n    TENSOR_WEIGHT_X_INNER: for(int c=0; c<MAX_WIDTH+1; c++)\n    {\n      #pragma HLS pipeline II=1\n      buf.shift_pixels_left();\n      tensor_t tmp;\n      if(c<MAX_WIDTH)\n      {\n        tmp = tensor_y[r][c];\n      }\n      else\n      {\n        TENSOR_WEIGHT_X_TMP_INIT: for(int i=0; i<6; i++)\n          tmp.val[i] = 0;\n      }\n      buf.insert_pixel(tmp,0,2);\n\n      tensor_t acc;\n      TENSOR_WEIGHT_X_ACC_INIT: for(int k =0; k<6; k++)\n        acc.val[k] = 0;\n      if (c >= 2 && c < MAX_WIDTH) \n      {\n        TENSOR_WEIGHT_X_TMP_OUTER: for(int i=0; i<3; i++)\n        {\n          tmp = buf.getval(0,i);\n          TENSOR_WEIGHT_X_TMP_INNER: for(int component=0; component<6; component++)\n          {\n            acc.val[component] += tmp.val[component]*TENSOR_FILTER[i];\n          }\n        }\n      }\n      if(c>=1)\n      {\n        tensor[r][c-1] = acc;\n      }\n    }\n  }\n}\n\n// compute output flow\nvoid flow_calc(tensor_t tensors[MAX_HEIGHT][MAX_WIDTH],\n               velocity_t outputs[MAX_HEIGHT][MAX_WIDTH])\n{\n  static outer_pixel_t buf[2];\n  FLOW_OUTER: for(int r=0; r<MAX_HEIGHT; r++)\n  {\n    FLOW_INNER: for(int c=0; c<MAX_WIDTH; c++)\n    {\n      #pragma HLS pipeline II=1\n      tensor_t tmp_tensor = tensors[r][c];\n      if(r>=2 && r<MAX_HEIGHT-2 && c>=2 && c<MAX_WIDTH-2)\n      {\n\t      calc_pixel_t t1 = (calc_pixel_t) tmp_tensor.val[0];\n\t      calc_pixel_t t2 = (calc_pixel_t) tmp_tensor.val[1];\n\t      calc_pixel_t t3 = (calc_pixel_t) tmp_tensor.val[2];\n\t      calc_pixel_t t4 = (calc_pixel_t) tmp_tensor.val[3];\n\t      calc_pixel_t t5 = (calc_pixel_t) tmp_tensor.val[4];\n\t      calc_pixel_t t6 = (calc_pixel_t) tmp_tensor.val[5];\n\n        calc_pixel_t denom = t1*t2-t4*t4;\n\t      calc_pixel_t numer0 = t6*t4-t5*t2;\n\t      calc_pixel_t numer1 = t5*t4-t6*t1;\n\n\t      if(denom != 0)\n        {\n          buf[0] = numer0 / denom;\n          buf[1] = numer1 / denom;\n\t      } \n\t      else\n\t      {\n\t\t      buf[0] = 0;\n\t\t      buf[1] = 0;\n\t      }\n      }\n      else\n      {\n        buf[0] = buf[1] = 0;\n      }\n\n      outputs[r][c].x = (vel_pixel_t)buf[0];\n      outputs[r][c].y = (vel_pixel_t)buf[1];\n\n    }\n  }\n}\n\n// top-level kernel function\nvoid optical_flow(frames_t   frames[MAX_HEIGHT][MAX_WIDTH],\n                  velocity_t outputs[MAX_HEIGHT][MAX_WIDTH])\n{\n  #pragma HLS data_pack variable=outputs\n\n  #pragma HLS DATAFLOW\n\n  // FIFOs connecting the stages\n  static pixel_t gradient_x[MAX_HEIGHT][MAX_WIDTH];\n  //#pragma HLS STREAM variable=gradient_x depth=default_depth\n  static pixel_t gradient_y[MAX_HEIGHT][MAX_WIDTH];\n  //#pragma HLS STREAM variable=gradient_y depth=default_depth\n  static pixel_t gradient_z[MAX_HEIGHT][MAX_WIDTH];\n  //#pragma HLS STREAM variable=gradient_z depth=max_width*4\n  static gradient_t y_filtered[MAX_HEIGHT][MAX_WIDTH];\n  //#pragma HLS STREAM variable=y_filtered depth=default_depth\n  static gradient_t filtered_gradient[MAX_HEIGHT][MAX_WIDTH];\n  //#pragma HLS STREAM variable=filtered_gradient depth=default_depth\n  static outer_t out_product[MAX_HEIGHT][MAX_WIDTH];\n  //#pragma HLS STREAM variable=out_product depth=default_depth\n  #pragma HLS data_pack variable=out_product\n  static tensor_t tensor_y[MAX_HEIGHT][MAX_WIDTH];\n  //#pragma HLS STREAM variable=tensor_y depth=default_depth\n  #pragma HLS data_pack variable=tensor_y\n  static tensor_t tensor[MAX_HEIGHT][MAX_WIDTH];\n  //#pragma HLS STREAM variable=tensor depth=default_depth\n  #pragma HLS data_pack variable=tensor\n\n  // FIFOs for streaming in, just for clarity\n  static input_t frame1_a[MAX_HEIGHT][MAX_WIDTH];\n  //#pragma HLS STREAM variable=frame1_a depth=default_depth\n  static input_t frame2_a[MAX_HEIGHT][MAX_WIDTH];\n  //#pragma HLS STREAM variable=frame2_a depth=default_depth\n  static input_t frame4_a[MAX_HEIGHT][MAX_WIDTH];\n  //#pragma HLS STREAM variable=frame4_a depth=default_depth\n  static input_t frame5_a[MAX_HEIGHT][MAX_WIDTH];\n  //#pragma HLS STREAM variable=frame5_a depth=default_depth\n\n  //Need to duplicate frame3 for the two calculations\n  static input_t frame3_a[MAX_HEIGHT][MAX_WIDTH];\n  //#pragma HLS STREAM variable=frame3_a depth=default_depth\n  static input_t frame3_b[MAX_HEIGHT][MAX_WIDTH];\n  //#pragma HLS STREAM variable=frame3_b depth=default_depth\n\n  // stream in and organize the inputs\n  static frames_t buf;\n  FRAMES_CP_OUTER: for (int r=0; r<MAX_HEIGHT; r++) \n  {\n    FRAMES_CP_INNER: for (int c=0; c<MAX_WIDTH; c++) \n    {\n      #pragma HLS pipeline II=1\n\n      // one wide read\n      buf = frames[r][c];\n      // assign values to the FIFOs\n      frame1_a[r][c] = ((input_t)(buf(7 ,  0)) >> 8);\n      frame2_a[r][c] = ((input_t)(buf(15,  8)) >> 8);\n      frame3_a[r][c] = ((input_t)(buf(23, 16)) >> 8);\n      frame3_b[r][c] = ((input_t)(buf(23, 16)) >> 8);\n      frame4_a[r][c] = ((input_t)(buf(31, 24)) >> 8);\n      frame5_a[r][c] = ((input_t)(buf(39, 32)) >> 8);\n    }\n  }\n  //\n  // compute\n  gradient_xy_calc(frame3_a, gradient_x, gradient_y);\n  gradient_z_calc(frame1_a, frame2_a, frame3_b, frame4_a, frame5_a, gradient_z);\n  gradient_weight_y(gradient_x, gradient_y, gradient_z, y_filtered);\n  gradient_weight_x(y_filtered, filtered_gradient);\n  outer_product(filtered_gradient, out_product);\n  tensor_weight_y(out_product, tensor_y);\n  tensor_weight_x(tensor_y, tensor);\n  flow_calc(tensor, outputs);\n\n}\n"}
