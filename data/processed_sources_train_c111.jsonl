{"instruction": "Generate HLS code with the following instructions:", "input": "Write a C function named \"kernel_3mm\" for a hardware kernel to accelerate the matrix multiplication operations E=A*B, F=C*D, and G=E*F. The function needs int parameters ni, nj, nk, nl, nm, and double matrices A, B, C, D, E, F, G with varying dimensions. For each nested loop, do not automatically pipeline or break the iterations into smaller chunks and run the iterations one after the other instead of parallel, except for the innermost loop where iterations should be processed automatically in parallel, with a factor of 32 for the first two matrix multiplications and 50 for the final one.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function called 'kernel_3mm' with integer parameters 'ni', 'nj', 'nk', 'nl', and 'nm', and double matrix parameters 'E', 'A', 'B', 'F', 'C', 'D', 'G'. This function acts as a hardware kernel for acceleration and performs three matrix multiplications: 'E' is the result of 'A' and 'B', 'F' is the result of 'C' and 'D', and 'G' is the result of 'E' and 'F'. For each matrix multiplication, implement three nested loops where the outer and middle loops will not be pipelined or broken down into smaller chunks for parallel processing. However, the innermost loop in the first matrix multiplication can be processed in 60 parallel iterations.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function called `kernel_3mm`, which takes in the dimensions of matrices `ni`, `nj`, `nk`, `nl`, `nm`, and matrices `E`, `A`, `B`, `F`, `C`, `D`, `G`. Designate this function as a hardware kernel for acceleration. Then perform the calculations as follows: matrix `E` is equals `A` multiplied by `B`; matrix `F` equals `C` multiplied by `D`; and matrix `G` equals `E` times `F`. While executing the multiplication operations, use nested loops with pipeline pragma off, tile factor, and parallel factor set to 1, except in the innermost loops, set the parallel factor to auto{32} when calculating matrices `E` and `F`, and to auto{50} when calculating `G` respectively.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a function called 'kernel_3mm' that performs matrix multiplication on various double array. The function accepts five indexing integers and seven 2D arrays as arguments. The function treats as a hardware kernel for acceleration according to pragma directive. Generate multi-dimensional arrays 'E', 'F', and 'G' with dimensions distinguished by the input parameters. For 'E', 'A', loops through the number of rows and columns, initializing 'E' to zero, then implementing matrix multiplication between 'A' and 'B', ensuring that these tasks are not automatically pipelined or broken into smaller fragments, and the iterations are executed serially. Repeat similar process for 'F', 'C', and 'D' arrays. Further generate array 'G' from 'E' and 'F' arrays in the same manner, but running the inner loop in batches of 4.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Prompt:\nCreate a kernel function called 'kernel_3mm' for hardware acceleration which takes nine parameters; five integer numbers 'ni', 'nj', 'nk', 'nl', 'nm' and four two-dimensional double arrays 'A', 'B', 'C', 'D'. The function calculates matrix multiplications among these arrays in the following sequence: 'E' equals 'A' times 'B', 'F' equals 'C' times 'D', finally, 'G' equals 'E' times 'F'. For each of the loops, apply automatic pipelining but don't split the loops into smaller parts, and iterate sequentially instead of parallelly for the outermost loops. For the innermost loops, run the iterations parallelly at a factor level of 'auto{1}', except for the last inner loop - parallelize it at 'auto{10}'.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Implement a HLS C function 'kernel_3mm' where we perform three 2D matrix multiplications. Firstly, define the function as a hardware acceleration kernel. Thereafter, in the first part of the function, perform matrix multiplication of 'A' and 'B' to form 'E' with loops that are not auto-pipelined, are not broken down into smaller chunks (Tile factor = 1) and are not grouped in parallel execution (Parallel factor = 1). The nested loops inside should be flattened. The same procedure follows when you perform matrix multiplication of 'C' and 'D' to form 'F' but in this case, ensure innermost nested loop is grouped into a minimum of 20 parallel executions. Finally, perform matrix multiplication of 'E' and 'F' to form 'G' with the inner most loop grouped into a minimum of 2 parallel executions.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware-accelerated kernel function named 'kernel_3mm' that takes two-dimensional arrays E, A, B, F, C, D, G and integer arguments ni, nj, nk, nl, nm as inputs. This function will perform three separate matrix multiplications. First, it will calculate E as the product of matrix A and B without automatic pipelining, handling this loop in its original form one iteration at a time and not breaking it into smaller chunks. Then, it will calculate F as the product of matrix C and D with the same directives as the first loop, but this time fully flatten the loop execution. Finally, it will calculate G as the product of the newly calculated matrices E and F with the same directives as the first loop. In all matrix calculations, the specific number of iterations to execute in parallel will vary according to the inner loop iterations in each calculation.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Implement a kernel function 'kernel_3mm' which performs matrix calculations on E, A, B, F, C, D, and G with given sizes. The function should contain three parts of matrix calculations: E = A*B, F = C*D, and G = E*F. In each matrix calculation, iterate the rows and columns and calculate the cells by multiplying and adding up the corresponding cells in input matrices. Use pragma directives to guide the HLS compiler: '#pragma ACCEL kernel' to treat the function as a hardware kernel; '#pragma ACCEL PIPELINE' to set automatic loop pipelining either on or off; '#pragma ACCEL TILE FACTOR' to control loop unrolling with the factor set automatically; '#pragma ACCEL PARALLEL FACTOR' to decide the parallelism degree of loop iterations. Use these directives properly before and inside the loops according to the given parameters in the code chunks.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Design a hardware-accelerated HLS kernel function named 'kernel_3mm'. This function accepts seven parameters: five integers 'ni', 'nj', 'nk', 'nl', 'nm' and seven 2D double-precision floating-point arrays 'E', 'A', 'B', 'F', 'C', 'D', 'G'. The function includes three nested loop blocks, each block responsible for matrix multiplication. The loop block calculates 'E = A*B', 'F = C*D', and 'G = E*F' respectively. \n\nBefore every loop block,prevent the automatic pipelining, maintain the loop's full form without slicing it, and ensure that its iterations don't run in parallel. Inside the first two inner loops retain the same properties. However, inside the last innermost loop of each block, allow the parallel execution of the loop iterations based on the respective third dimension of each matrix multiplication.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware acceleration kernel function titled \"kernel_3mm\" with the listed parameters to perform three large scale matrix multiplies. Begin by declaring the necessary loop variables 'i', 'j', and 'k'. The matrix multiplication processes are: A multiplied by B and result stored in E; C multiplied by D and result stored in F; and E multiplied by F and result stored in G. All matrix multiplications should be conducted via a set of three nested for-loops. You must use the respectively stated '#pragma' values to dictate how these loops are ran: '#pragma ACCEL PIPELINE' value \"off\" to not automatically pipeline the loops; '#pragma ACCEL TILE FACTOR' equal to 1 to not break the loops down into smaller parts; and '#pragma ACCEL PARALLEL FACTOR' equal to 1 to run loop iterations one after the other instead of in parallel. For the innermost loop in the third matrix multiplication, \"#pragma ACCEL PARALLEL FACTOR\" must be set to 2. The code must be enclosed in the '#pragma ACCEL kernel' directive, which treats the function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function 'kernel_3mm' using HLS pragmas indicating the function is a hardware acceleration kernel. The function takes the int parameters 'ni', 'nj', 'nk', 'nl', 'nm', and matrices 'E', 'A', 'B', 'F', 'C', 'D' and 'G'. It performs three matrix multiplications respectively, denoted by \"E := A*B\", \"F := C*D\", and \"G := E*F\". During the iteration of multiplying matrices, apply pre-processing pragmas of ACCLE PIPELINE auto{off}, TILE FACTOR=auto{1} and PARALLEL FACTOR=auto{1}. However, for the final step of each matrix multiplication which involve adding product of two corresponding elements, apply pragma 'ACCEL PARALLEL FACTOR=auto{32}, ACCEL PARALLEL FACTOR=auto{20}, ACCEL PARALLEL FACTOR=auto{50}' respectively to enable parallel execution of 32, 20 and 50 iterations at once.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Treat the function 'kernel_3mm' as a hardware kernel for acceleration. The function takes as parameters the following integer variables: 'ni', 'nj', 'nk', 'nl', 'nm' and 2-dimensional array variables: 'E', 'A', 'B', 'F', 'C', 'D', and 'G'. \n\nInside the function, implement three main calculations. \n\n1. Calculate 'E' by multiplying 'A' and 'B' which is done through nested loops. For each loop, specify directives such that: the loop should not be automatically pipelined, iterations should be executed sequentially and not in parallel, also retain the loop in its original form by not breaking it into smaller pieces.\n2. Similarly, calculate 'F' by multiplying 'C' and 'D'. Use the same directives as previously but for the innermost loop increase the number of iterations that can run in parallel up to 32.\n3. Finally, calculate 'G' by multiplying 'E' and 'F'. Use directives identical to the first calculation but allow two iterations in the second loop to run in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware kernel function named 'kernel_3mm' for acceleration. This function will take nine parameters: five integers named 'ni', 'nj', 'nk', 'nl', 'nm', and four double-pointer arrays 'E', 'A', 'B', 'F', 'C', 'D', and 'G'. Implement three major calculation procedures.\n\nFirst, calculate E as the product of A and B. Structure the loop in its full form, without breaking into smaller chunks with pragma ACCEL TILE FACTOR set at 1, and avoid automatic pipeline with pragma ACCEL PIPELINE off. Run the iterations sequentially, not in parallel with pragma ACCEL PARALLEL FACTOR set at 1. Only, for the innermost loop, increase the parallel factor to 30 to perform multiple iterations simultaneously.\n\nNext, perform a similar operation to calculate F as the product of C and D. Again, turn off the pipeline and keep the tile factor at 1. However, for the innermost loop, set the parallel factor to 32 to allow for parallel computation of the loop iterations.\n\nFinally, perform the third calculation to derive G as a product of E and F. Similar to the previous operations, turn off the pipeline, set tile factor at 1 and for the inner loop, increase the parallel factor to 50 to enhance computation speed.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function called 'kernel_3mm' followed by the integer parameters 'ni', 'nj', 'nk', 'nl', 'nm' and six two-dimensional double arrays 'E', 'A', 'B', 'F', 'C', 'D' and 'G'. Using the 'pragma ACCEL kernel' command, mark this function for hardware acceleration. Employ three different matrix multiplication operations: 'E = A * B', 'F = C * D', and 'G = E * F'. For each operation, initiate three nested loops with 'ACCEL PIPELINE' set to 'auto{off}', 'ACCEL TILE' set to 'auto{1}', and 'ACCEL PARALLEL' set to 'auto{1}' for undivided, sequenced execution. Inside the secondary loops, implement 'ACCEL PIPELINE' at 'auto{flatten}', keeping both 'ACCEL TILE' and 'ACCEL PARALLEL' at 'auto{1}' for full, sequential execution. In the final 'G = E * F' operation, assign 'ACCEL PARALLEL' to 'auto{2}' in the secondary loop for higher parallelization. All innermost loops should initialize matrix elements to zero and subsequently perform multiplication-addition operations.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a HLS C function that uses hardware kernel acceleration to perform \"3mm\" or \"Three-Matrix Multiplication\", as per the following process: initially, matrix 'E' is computed as the product of matrices 'A' and 'B'; secondly, matrix 'F' is computed as the product of matrices 'C' and 'D'; finally, matrix 'G' is computed as the product of matrices 'E' and 'F'. Throughout this function, ensure that:\n\n1. The process is not automatically pipelined using '#pragma ACCEL PIPELINE auto{off}', meaning that the iterations of the loops are intended to be executed in sequential order.\n\n2. Each loop is processed in its original full form, without being broken down into smaller chunks, using '#pragma ACCEL TILE FACTOR=auto{1}'.\n\n3. The iterations of the majority of loops are run one after the other, not parallelly, using '#pragma ACCEL PARALLEL FACTOR=auto{1}'.\n\nHowever, within the innermost loops where the actual matrix multiplications occur, allow a certain degree of parallel execution using '#pragma ACCEL PARALLEL FACTOR=auto{32}' for the 'E' and 'F' computation, and '#pragma ACCEL PARALLEL FACTOR=auto{50}' for the final 'G' computation. This indicates that up to 32 and 50 iterations respectively can potentially be executed concurrently depending on the hardware resources availability.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Define a hardware acceleration kernel function called 'kernel_3mm'. The function should take nine parameters: five integer parameters 'ni', 'nj', 'nk', 'nl', 'nm' and four double 2D array parameters 'E', 'A', 'B', 'F', 'C', 'D' and 'G'. Perform three operations following this order: start by finding the product of matrix 'A' and 'B' and storing the result in matrix 'E', then find the product of matrix 'C' and 'D' and store the result in matrix 'F', and finally find the product of matrix 'E' and 'F' and store the result in matrix 'G'. Each operation should include nested for-loops with specific #pragma pipelining, tiling, and parallelizing directives. For the first and second operation, disallow automatic pipelining, set the tile and parallel factor to 1 for the outer loops, and handle the innermost loop iterations in parallel with auto{32} and auto{1} factors respectively. For the third operation, disallow automatic pipelining in the outermost loop and handle the innermost loop iterations in parallel with an auto{50} factor.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a hardware-accelerated kernel function in C named 'kernel_3mm' which takes eight parameters: five integer arguments ('ni', 'nj', 'nk', 'nl', and 'nm') and three 2D double array arguments (E, A, B, F, C, D, G). The function should perform three steps: firstly, it multiplies matrices 'A' and 'B' and stores result in 'E'; then, it multiplies matrices 'C' and 'D', saving result in 'F'; eventually, it multiplies 'E' and 'F' matrices resulting in 'G'. For each of these steps, use three nested for-loops, and don't pipeline these parent loops, but run them in their original, non-tiled format without breaking them into smaller chunks, and one after the other, not in parallel. For the nested child loops, flatten their execution, but also run them in their original, non-tiled format and with reduced level of parallelism. The third nested set of loops should have variation in its degree of parallelism, with the outer loop running two iterations concurrently, and the inner loop set to run up to 50 iterations at the same time.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a C function under the name 'kernel_3mm', which will be treated as a hardware kernel for acceleration processes. The function takes nine input parameters: five integers representing the dimensions of the arrays, and six two-dimensional arrays. We will be focusing on three major operations: 'E := A*B', 'F := C*D', and 'G := E*F'. For each operation, prioritize processing loops in their original full form without dividing into smaller pieces and execute the loops sequentially, not parallely. However, when calculating E[i][j] and F[i][j] ensure to run the last loops with factors of 32 and 80 respectively in parallel for optimized computation. Finally, flatten the pipeline in the last operation which is to calculate G[i][j], but ensure not to execute the last loop in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create an HLS-accelerated kernel function named 'kernel_3mm' which takes in five int parameters: ni, nj, nk, nl, nm and seven 2D arrays: E[40][50], A[40][60], B[60][50], F[50][70], C[50][80], D[80][70], G[40][70]. This function accomplishes three key matrix operations:\n\nFirstly, it calculates the product of matrices 'A' and 'B' and stores the result in 'E'. You should automate the pipeline optimization for the outer loop but manually preserve the structure and run iterations one by one for inner loops in regards to both tiling and parallelism. \n\nThe next calculation is the product of matrices 'C' and 'D' with the result stored in 'F'. For this operation, all optimizations are deliberately switched off using pragma directives ACCEL PIPELINE off, ACCEL TILE FACTOR and ACCEL PARALLEL '1'. \n\nLastly, it calculates the product of 'E' and 'F' with the result stored in 'G'. Again, pipeline optimization should be automated for the outer loop and no tiling or parallelism should be applied to the inner loops. Here, set pragma directive ACCEL PARALLEL to 50. \n\nThe pragma scopes delineated with //#pragma scop and //#pragma endscop should be ignored in this context.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a function named 'kernel_3mm' in C, using the HLS kernel pragma to indicate that this function should be treated as an acceleration kernel. This function should take nine parameters: five integer dimensions (ni,nj,nk,nl,nm) and four 2D double arrays E, A, B, F, C, D, and G.\n\nAll loops should be processed in the full original form, not breaking them into smaller parts (TILE FACTOR=1) and iterations should be ran one after another, not in parallel (PARALLEL FACTOR=1). The outer loops shouldn't be automatically pipelined (PIPELINE off), while the inner loops for matrix multiplication should flatten iterations to a single large loop (PIPELINE flatten).\n\nThe function performs matrix multiplications in batches: E = A * B, F = C * D, and G = E * F. For this, you should create a triple-nested loop using indices i, j, and k. Initiate E[i][j] and F[i][j] with 0.0, then within their respective innermost loops, increment them with the product of A[i][k] * B[k][j] and C[i][k] * D[k][j] respectively. Finally, for G, initiate it with 0.0 and within the innermost loop, increment it with the product of E[i][k] * F[k][j].", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "This instruction demands the generation of an HLS accelerated kernel function named 'kernel_3mm'. The function includes five input integer parameters: 'ni', 'nj', 'nk', 'nl', and 'nm', with six 2D array parameters: 'A', 'B', 'C', 'D', 'E', 'F', and 'G'. \n\nThe code is divided into three main parts: 1) First part conducts matrix multiplication between 'A' and 'B' allocating the result to 'E', setting the pipeline, tile, and parallel factor values as non-automatic (not pipelined), unpartitioned, serially computed, then executes the iterations in parallel to improve performance. \n\n2) The second part, ensures computation of matrix multiplication between 'C' and 'D' storing the result to 'F', this time setting the pipeline to flatten for combining loops, preceding #pragma values remain identical as first part, and the loops are not computed in parallel due to their dependence sequentially. \n\n3) The third part multiplies matrix 'E' & 'F' allocating the result to 'G'. This part involves auto pipelining, unpartitioned tile factor, serial computation, then parallel computation of the loops with dependence for performance enhancement. \n\nAll loops are required to iterate across the full range of their respective matrices' dimensions.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a hardware accelerated kernel function called 'kernel_3mm' taking in parameters of integer variables ('ni', 'nj', 'nk', 'nl', 'nm') and double arrays ('E', 'A', 'B', 'F', 'C', 'D', 'G'). There are three main steps: \n1) Calculate matrix E from matrix multiplication of A and B using three nested loops. Do not pipeline these loops, keep their iterations sequential, and do not break them into smaller chunks.\n2) Calculate matrix F from matrix multiplication of C and D using three nested loops. Do not pipeline outer loops and keep their iterations sequential, but allow innermost loop to run 20 iterations at once. \n3) Lastly, calculate matrix G from matrix multiplication of E and F using three nested loops. Do not pipeline outer loops, but allow their iterations to run in parallel by a factor of 2 and allow the innermost loop to execute 32 iterations concurrently.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a HLS C code with a function called 'kernel_3mm'. This function would be treated as a hardware kernel for acceleration. The function takes nine arguments: five integers (ni, nj, nk, nl, nm) and four different two-dimensional arrays of double (E[40][50], A[40][60], B[60][50], F[50][70], C[50][80], D[80][70], G[40][70]). Then, follow the given process: \n\n1. Calculate E as the product of A and B matrices. Perform this in a loop for all elements of E, with the loop not pipelined. It should be in its original form and the iterations are processed one after the other (not in parallel). \n\n2. Perform a similar process for the calculation of F as the product of the C and D matrices. \n\n3. Finally, compute G as the product of E and F matrices again with the same conditions as in previous steps.\n\nUse different pragma ACCEL values: Treat kernel_3mm function as a hardware kernel for acceleration, don't automatically pipeline the main loops for the calculations of E, F, and G; have the loops in their original form without breaking them down (pragma ACCEL TILE FACTOR=auto{1}) and iterate over these loops one at a time, not in parallel (pragma ACCEL PARALLEL FACTOR=auto{1}). For inner loops processing the specific calculations, set the automation of parallel factor to match the respective matrix dimension.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a 'C' based HLS code for a function titled 'kernel_3mm' which accepts arguments: five integers (ni, nj, nk, nl, nm) and seven 2D matrices of double precision (E[40][50], A[40][60], B[60][50], F[50][70], C[50][80], D[80][70], G[40][70]). With the use of '#pragma ACCEL kernel', treat this function as a hardware-accelerated kernel.\n\nIn the function, initially, declare two integers, i and j, as loop variables.\n\nThen, for matrix multiplication of A and B to get E, use three nested loops, with outer and middle loops directed by '#pragma ACCEL PIPELINE auto{off}', '#pragma ACCEL TILE FACTOR=auto{1}' and '#pragma ACCEL PARALLEL FACTOR=auto{1}' to ensure the loops aren't autopipelined, not divided and ran sequentially; whereas the innermost loop runs in parallel with factor 32 dictated by '#pragma ACCEL PARALLEL FACTOR=auto{32}'.\n\nRepeat this process with the necessary modifications for the matrices C and D to result in F with a parallel factor of 20.\n\nFinally, perform matrix multiplication of E and F to get G with a parallel factor of 50. Again, the outer and middle loops are dictated by the same pragma instructions as before. Ensure each section of matrix multiplication is separated by comments for clear distinction.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function named \"kernel_3mm\" with integer parameters of ni, nj, nk, nl, nm and six 2D double arrays E, A, B, F, C, D and G. Mark this function as a hardware kernel for acceleration. \n\nFirst, implement a matrix multiplication operation (A*B) and store the result in E. For the loops implementing this operation, ensure the outer and inner loops are currently not pipelined (\"PIPELINE\" set to 'off') and are not divided into smaller chunks (\"TILE FACTOR\" set to 1). Also, ensure their iterations to run sequentially, not in parallel (\"PARALLEL FACTOR\" set to 1). In the innermost loop, parallelize the iterations with a factor of 32.\n\nNext, perform another matrix multiplication operation (C*D) and store the result in F. For the loops implementing this operation, also ensure the outer and inner loops are not pipelined and they are not divided into smaller chunks with their iterations to run sequentially. However, for the PIPELINE pragma in the internal loop, use 'flatten' to combine all nested loops into a single, one-dimensional iteration space to promote loop pipelining. Within the innermost loop, keep the iterations to run sequentially.\n\nFinally, perform a third matrix multiplication operation (E*F) and store the result in G. For the loops implementing this operation, also ensure the outer and inner loops are not pipelined and they are not divided into smaller chunks with iterations to run sequentially. In the innermost loop, parallelize the iterations with a factor of 50.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function named 'kernel_3mm' that is treated as a hardware kernel for acceleration, takes 7 parameters, five 2D arrays (E, A, B, F, C, & D) and 5 integers (ni, nj, nk, nl, nm). The function will handle 3 matrix multiplications. For each operation, turn automatic pipelining off, prevent breaking the loop into smaller chunks, and put a limit on the parallel loop iterations. More specifically:\n\n1) For the first matrix multiplication (E := A*B) involving 2 nested for loops, do not automatically pipeline the loops in a flattened manner. Also, for the innermost loop where the multiplication and addition happen, limit the parallel factor to 1.\n\n2) For the second matrix multiplication (F := C*D), repeat the same pragma parameters as with the first multiplication. \n\n3) For the final multiplication where the output is stored in G(E*F), prevent the outer loop from being pipelined but allow the inner one to have a parallel factor of 5 and the outer one to have a parallel factor of 2.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a hardware accelerated function titled 'kernel_3mm' with specified inputs that executes three matrix multiplications: E=A*B, F=C*D, and G=E*F. Within each of these matrix multiplications, there are nested for-loops which implement the mathematical operation. For each loop and nested loop, turn off automatic pipeline, do not break the loop into smaller chunks, and run iterations sequentially, not in parallel. However, when performing the actual operations for E, F, and G respectively, allow parallelism up to factors of 60, 80, and 50.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function named 'kernel_3mm' that treats as a hardware kernel for acceleration. This function has parameters for five integer values and seven double pointer arrays. In the function body, define three nested loops for each of the matrix multiplication operations: E = A*B, F = C*D, and G = E*F. Achieve these multiplications by not allowing loop pipelining and processing the loops in their original full form. Make sure that loop iterations are run one after the other, not in parallel. For the third matrix multiplication operation, adjust the parallel factor to 2 for the last two loops.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Define a hardware kernel function called 'kernel_3mm' with parameters of five integer sizes ni, nj, nk, nl, nm and six 2D array inputs E, A, B, F, C, D, and G. Firstly, you'll need to calculate the matrix multiplication of A and B, and store the result in E. For this operation, ensure the loops aren't pipelined, but processed in its original form without breaking it into smaller chunks and have its iterations run one after the other, not in parallel except for innermost loop where its iterations run in parallel. Follow the same instructions to perform matrix multiplication for C and D, storing the result in F. Lastly, calculate the matrix multiplication of E and F with the resulting output in G under the same conditions as the first operation but with innermost loop in parallel too.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a function 'kernel_3mm' with the specified function header that is treated as a hardware kernel for acceleration. The function should perform 3 matrix multiplications i.e. E = A*B, F = C*D, G = E*F. Do not automatically pipeline the iterations and process the outer loops in their original form without breaking them into smaller chunks, running their iterations one after the other, not in parallel. Also, flatten the pipeline for inner loops but maintain their original form as well. Run the iterations of the last inner loop in parallel with a parallel factor of 'auto{1}' for the first matrix multiplication, 'auto{5}' for the second and 'auto{1}' for the third, while applying a parallel factor of 'auto{2}' for the outer loop during the third multiplication.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a kernel function titled 'kernel_3mm' with input parameters being five integers and seven 2D matrices represented as double arrays. This function will calculate three matrix multiplications. For each matrix multiplication, use three nested for-loops. For the first loop, prevent automatic pipelining, do not break loop into smaller chunks, and specify the iterations to run sequentially, not in parallel. For the second and third inner loops, allow the second for-loop to be flattened and the third to be run with a parallel factor of 1. The first multiplication is A*B stored in E, the second is C*D stored in F, and the last is E*F stored in G. On the second matrix multiplication, adjust the parallel factor to 80 for the innermost loop. For the third matrix multiplication, adjust the parallel factor of the second loop to 2.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a kernel function in C named 'kernel_3mm'. The function accepts integers ni, nj, nk, nl, and nm as parameters, along with 2-dimensional double arrays E, A, B, F, C, D, and G. The function calculates three matrix multiplications. \n\nStart with the multiplication of matrix A and B and store the result in E. For that, use two for-loops with 'i' traversing from 0 to 40 and 'j' from 0 to 50 and initialize E[i][j] to 0.0. Then, include another for-loop, which traverses 'k' from 0 to 60, and in each iteration, calculates E[i][j] += A[i][k] * B[k][j]. Instruct the HLS compiler to not pipeline the primary loops automatically, not to break them into smaller chunks, and run their iterations one after the other, not in parallel, but for the innermost loop, process 60 iterations in parallel.\n\nIn the next phase of computation, multiply matrices C and D and store the result in F. This operation follows the same principle as before but changes in dimensions. The outer loops run 'i 'from 0 to 50 and 'j' from 0 to 70. The inner loop traverses 'k' from 0 to 80 with 10 iterations to be processed in parallel.\n\nLastly, multiply matrices E and F and store the result in G, with 'i' ranging from 0 to 40 and 'j' from 0 to 70. The inner loop traverses 'k' from 0 to 50 and they are processed one after the other.\n\nIn all phases, pipeline, tile and parallel factor pragmas have been specified at the start of each major computation block which can be modified according to latency and resources.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware-accelerated kernel function called 'kernel_3mm' that performs matrix multiplication over various matrices. The function should take in matrix sizes as parameters and the actual matrices 'E', 'A', 'B', 'F', 'C', 'D', and 'G'. The kernel performs three stages of matrix multiplication, i.e., 'E = A*B', 'F = C*D', 'G = E*F'. \n\nFor each multiplication, use nested loops iterating over distinct indices to perform the operation. For the loops, don't automatically pipeline and process iterations one after the other without breaking them into smaller chunks or running in parallel. \n\nHowever, in the most inner loop of each multiplication operation, increase the parallel factor to 30 while multiplying 'A' and 'B' and 80 for multiplication of 'C' and 'D'. When multiplying 'E' and 'F', keep parallel factor as 1 and flatten the loop processing using ACCEL PIPELINE.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create an accelerated kernel function, 'kernel_3mm', accepting 7 input parameters: 5 integer dimensions (ni, nj, nk, nl, nm) and 6 two-dimensional arrays (E[40][50], A[40][60], B[60][50], F[50][70], C[50][80], D[80][70], G[40][70]). Begin by calculating the product of arrays A and B and store it in array E. In this step, implement 3 nested loops cycling through the dimensions of arrays A and B to perform matrix multiplication where every loop iteration is not parallelized nor pipelined. Next, compute the product of arrays C and D and save it in array F following the same directives as earlier but parallel factor for the innermost loop is set to auto. Lastly, multiply arrays E and F to get array G using same pragma directives as in the calculation of array F. All these should not break down each loop into chunks.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function called 'kernel_3mm' that takes in seven 2D matrix arrays and five integer parameters. The function is marked as a hardware kernel for acceleration. The computations are divided into three parts: computing E by multiplying A and B; computing F by multiplying C and D; and finally computing G by multiplying E and F. By 'not automatically pipeline this loop', 'process this loop in its original and full form without breaking down into smaller chunks,' and 'run the iterations of this loop one after the other, not in parallel,' the loops in each part are executed and pipelined in a non-optimal and manual way. Furthermore, use flatten pragma in the inner loop of each part to allow all iterations to be performed in parallel with a parallel factor of one. The only exception is the loop for calculating F in the second part, where the parallel factor is explicitly set to 80 for the innermost loop.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Compose a C language HLS kernel named 'kernel_3mm' with parameters ni, nj, nk, nl, nm, and 2D arrays E, A, B, F, C, D, G. This kernel achieves three matrix multiplications. \n\nIn the first step, all the threads should process the loops in a serial manner without parallelism nor pipelining, where the product of A[i][k] and B[k][j] is accumulated into E[i][j] for varying dimensions i, j, and k. \n\nNext, compute matrix F by multiplying matrices C and D. Start with F[i][j] at 0.0 and incrementally add the product of C[i][k] and D[k][j], using a parallel factor of 4 for the innermost loop. \n\nFinally, calculate matrix G by multiplying matrices E and F. The computation should be similar to the previous stage but with a parallel factor of 2 for the intermediate loop. \n\nApply all the appropriate pragma values for each of these segments. Don't pipeline the outermost loops, let the second loop be flatten pipelined, and don't split any loop into smaller segments (use a tile factor of 1).", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create an HLS code in C under the hardware kernel pragma. The code creates a function, \"kernel_3mm\", with integer parameters ni, nj, nk, nl, and nm, and six multidimensional arrays (E, A, B, F, C, D, G). \n\nFirst, the code computes the matrix multiplication of matrices A and B and stores the result in matrix E. This computation process uses three nested loops and specifies that the loops should not be broken into smaller chunks (pragma TILE FACTOR=1), not automatically pipelined (pragma PIPELINE off), and iterations should be run serially instead of parallelly (pragma PARALLEL FACTOR=1). \n\nSecond, it computes the matrix multiplication of matrices C and D and stores the result in matrix F. Again, this computation process uses three nested loops and sets the same pragma values as the first computation with the exception of the innermost loop where the computation is going to run in 32 parallel iterations (pragma PARALLEL FACTOR=32).\n\nFinally, it computes the matrix multiplication of matrices E and F and stores the result in matrix G, setting similar pragma values as in previous computations except that in the second loop where iterations will run two at the time (pragma PARALLEL FACTOR=2) and the inner loop is set to run 25 parallel iterations (pragma PARALLEL FACTOR=25).", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{25}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a hardware-accelerated kernel function named 'kernel_3mm', which performs a series of matrix operations. The input parameters are five integers indicating the dimensions of the matrices respectively; and seven 2D arrays will be operated. The function performs three successive matrix multiplications: E = A*B, F = C*D and G = E*F. \n\nFor the three 'for' loops involved in each operation respectively, use an ACCEL PIPELINE pragma with 'auto{off}' to prevent automatic loop pipelining, an ACCEL TILE pragma with an auto factor of '1' to ensure the loop is processed in its original form, and an ACCEL PARALLEL pragma with an auto factor of '1' to execute iterations serially. \n\nHowever, within the 'k' loops, the ACCEL PARALLEL pragma should have an auto factor of '32', indicating that the loop iterations can be executed concurrently in 32 parallel threads. This allows for concurrent operations when calculating the element-wise multiplications within these loops.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware accelerated function named 'kernel_3mm' which accepts five integers and seven two-dimensional arrays of doubles. Inside this function, there will be three main sections corresponding to the three matrix multiplications: E = A * B, F = C * D and G = E * F. \n\nIn each section, use a nested loop structure to perform the multiplication. This section will begin with the pragmas ACCEL PIPELINE, TILE FACTOR, and PARALLEL FACTOR with respective auto-off, auto-1 and auto-1 values. Then, create a loop that iterates from 0 to the dimension of the first matrix of multiplication operation. Inside this loop, again use the similar pragmas with their auto-off, auto-1 and auto-1 values. Then, create another loop that iterates from 0 to the second dimension of the multiplication operation and includes the ACCEL PARALLEL FACTOR pragma with auto-value equal to the number of columns of the first matrix used for multiplication.\n\nThe first loop should calculate E = A * B with auto{60} parallel factor in the most inner loop. The second one should calculate F = C * D with auto{80} parallel factor in the most inner loop. For the final loop, which calculates G = E * F, use the PIPELINE pragma with 'flatten' option, and in the innermost loop, let the PARALLEL FACTOR have an auto{1} value.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware-accelerated kernel function with the name 'kernel_3mm' that takes integer parameters ni, nj, nk, nl, nm and six 2D arrays of doubles - E, A, B, F, C, D, G. Inside this function, do matrix multiplication in three parts; first part being multiplication of arrays A and B, second part being multiplication of arrays C and D and the last part being multiplication of the results from the previous parts. Each part involves separate nested loops for which no auto-pipelining should be scheduled, no chunks should be made, and their iterations should not be parallelized but processed one after another, except in the case of the inner loop during the multiplication of arrays C and D where the factor for parallel processing is set to 20, and during the multiplication of the first and second results where the factor for the outer loop is set to 2 and for the inner loop is set to 32.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Your instruction is to write a function named 'kernel_3mm' with nine arguments that would perform three operations which are matrix multiplication: \"A times B, C times D, and then, E times F\". This function should be treated as a hardware kernel for acceleration. The loops employed in the function should not be automatically pipelined and processed in their original, full form without breaking them in smaller chunks, they shouldn't run in parallel but one after the other. However parallel factor should be 16, 1 and 32 for the three respective loop blocks to run iteration in parallel for specific chunks.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function called 'kernel_3mm' with listed parameters and array inputs. This function will perform a series of matrix multiplications. The entire function will be treated as a hardware kernel for acceleration as indicated by '#pragma ACCEL kernel'. The process begins by setting E as the product of A and B, with each step in the calculation pipelined automatically, not divided into smaller chunks, and with their iterations executed sequentially. Then, using the same directives, F is set as the product of C and D. Finally, G is set as the product of E and F, with the inner-most loop iterations being processed in parallel as indicated by '#pragma ACCEL PARALLEL FACTOR=auto{16}'.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create an HLS function named 'kernel_3mm' that treats the function as a hardware kernel for acceleration (#pragma ACCEL kernel). This function takes in nine parameters - five integers: ni, nj, nk, nl, and nm; and six 2D double arrays: E[40][50], A[40][60], B[60][50], F[50][70], C[50][80], D[80][70], and G[40][70]. \n\nThe function first executes a loop that doesn't auto-pipeline, isn't broken down into smaller pieces, and runs iteratively not in parallel, to perform matrix multiplication between A and B and store the result in E. \n\nThen, a similar loop process is conducted between matrices C and D and the result is stored in F, with one change that it's pipelined in a flatten manner.\n\nLastly, the function calculates the matrix multiplication of E and F to produce G. The outer loops remain the same as previously, but the innermost loop uses a parallel factor of 32 to run iterations in parallel for performance enhancement.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a void function named 'kernel_3mm'. The function has seven parameters: five integer variables (ni, nj, nk, nl, and nm) and two-dimensional arrays of double variable types (E, A, B, F, C, D, G). Declare the function as a hardware kernel for acceleration. Proceed with three matrix multiplication operations: E = A * B, F = C * D, and G = E * F. For each matrix multiplication, execute three nested for-loops. \n\nThe outer and middle loops should process the iterations in its original, full form without breaking them into smaller chunks. Run the iterations one after the other, making sure they do not proceed parallel. Pipeline the outer loop using the default recommendation from the compiler. However, the inner-most loop that performs the core multiplication should run the iterations of this loop one after the other as well, without any pipelining. \n\nIn the final multiplication (G = E * F), allow the middle loop to run in parallel up to a factor of 2, while keeping all other conditions the same. Make sure all constructs, loops, and pragma statements are properly closed.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a function named 'kernel_3mm' with the specified arguments. Make this function a hardware kernel for acceleration, calculate the multiplication of two-dimensional arrays in three steps: first, A * B is stored in E, then C * D is stored in F, and finally, E * F is stored in G. For each operation, create three nested loops by FIFO approach where each loop is not processed in parallel, but rather each iteration runs one after the other. For the innermost loop of the second operation, adjust the parallelization factor to 32 for the iterations. For the innermost loop of the third operation, adjust the parallelization factor to 25 for the iterations. Regardless of the automatic decision by the compiler, ensure that these loops are not pipelined and that these loops are processed without dividing them into smaller chunks.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{25}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware acceleration kernel named 'kernel_3mm', taking in nine parameters: five integers 'ni', 'nj', 'nk', 'nl', 'nm' for the dimensions and four double 2D arrays, 'E', 'A', 'B', 'F', 'C', 'D', 'G'. This kernel performs three matrix multiplications: 'A*B', 'C*D', and 'E*F' and store the results to 'E', 'F', and 'G' respectively. For each multiplication operation, ensure no automatic pipeline optimization, keep the loop to be processed in its original, full form without breaking it into smaller chunks and the iterations of the top loops should run one after the other, not in parallel, but the internal iterations (3rd level loop) should be run in parallel, with parallelization factor automatically set to '60' for the first multiplication, '80' for the second, and '1' for the third.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a kernel function called 'kernel_3mm' that takes in nine parameters - five integers 'ni', 'nj', 'nk', 'nl', 'nm' and four double 2D arrays 'A', 'B', 'C', 'D', 'E', 'F', 'G'. In this function, do not pipeline the loop or break into smaller chunks with the help of pragma directives. Run the iterations of the loop one after the other, not in parallel. The function operates in three stages. First, it calculates the multiplication of arrays 'A' and 'B' and stores the result in array 'E'. Then, it calculates the multiplication of arrays 'C' and 'D' and stores the result in array 'F'. Finally, it multiplies arrays 'E' and 'F' and the result is stored in array 'G'. In the multiplication process, for each matrix multiplication, use nested for loops where the outer loops are not pipelined nor tiled, and are not to be run in parallel, whereas the innermost loop that performs the addition and multiplication should be run with 30 iterations in parallel for the first multiplication, 32 iterations for the second multiplication and third multiplication.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Design a function named 'kernel_3mm', treating it as a hardware kernel for acceleration. This function has nine parameters, the first five are integers which are 'ni', 'nj', 'nk', 'nl', 'nm' and the remaining four are two-dimensional arrays of type double which are 'E', 'A', 'B', 'F', 'C', 'D', 'G'. Please don't pipeline the outer loops in this function. Process these loops in their full form without breaking them into smaller chunks. Run the iterations of these outer loops one after the other, not in parallel. Inside each outer loop, there are inner loops where we should flatten each of these loops. Inside each inner loop, calculate the dot matrix multiplication between the respective arrays. Treat the first nested loop for E as 'E:= A*B'. Then, calculate 'F:= C*D' in the second nested loop. Finally, calculate 'G:= E*F' in the last nested loop. For all three steps, please do not automatically pipeline the loops, keep the process as a whole, but run iterations in parallel where possible. Furthermore, for the final calculation 'G:= E*F', double the parallelism for the outer loop and increase parallelism by a factor of fifty for the inner loop.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Develop a HLS kernel function named 'kernel_3mm' that takes in parameters for dimensions of the matrices (ni, nj, nk, nl, nm), and six 2D arrays represented as double precision floating point matrices (E, A, B, F, C, D, G). The kernel should first calculate the value of E as the matrix product of A and B. Note that, during this computation, do not automatically pipeline the loop, process the loop in its original form rather than subdividing it, and do not parallelize the iterations. \n\nThen, the kernel computes the value of F as the matrix product of C and D. During this calculation, the iterations of one of the blocked nested loops are to be run in parallel up to 8 times. \n\nLastly, the kernel calculates the value of G as the matrix product of E and F. In this section, regulate pipelining of the loop, process the loop in its unchanged form, and ensure that iterations of one of the blocked nested loops are run in parallel twice. \n\nRemember, the calculation of each matrix is to be undertaken in a triple-nested loop and iterations within these subloops should not be run in parallel. \n\nFor all these three matrix computations, use directives to ensure that the loop with the 'auto' property is completely flattened, meaning that all the nested loops in the pipeline are merged into one loop. This subsequently decreases the amount of control logic required in the output hardware.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware-accelerated kernel function named 'kernel_3mm'. This function takes in five integers which represent the dimensions of the multi-dimensional arrays being passed, along with six two-dimensional arrays for operations. The function first calculates the matrix multiplication of arrays A and B, resulting in the array E. It then calculates the matrix multiplication of arrays C and D, resulting in array F. Finally, it calculates the matrix multiplication of arrays E and F, outputting the result in array G. For each operation, ensure the loop isn't automatically pipelined and is processed in its full form, not broken into smaller chunks. All iterations should run in sequence, not in parallel. Also, make sure that the inner loops are completely linear and flatten their iterations for pipelining, except for the last inner loop of G calculation which should use a parallel factor of 16. The outermost loops of each operation should have a parallel factor of 1, except for the last loop for G calculation which should have a parallel factor of 2.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function 'kernel_3mm' with the provided header that accepts parameters for matrix dimensions and matrices 'E', 'A', 'B', 'F', 'C', 'D', 'G'. This function will perform 3 consecutive matrix multiplies, 'E=A*B', 'F=C*D', and 'G=E*F'. Each matrix multiplication operation contains 3 nested loops. For each loop, disable automatic pipelining, prevent the loop from breaking into smaller chunks, and ensure iterations run one after another, not in parallel using the respective '#pragma' directives: ACCEL PIPELINE auto{off}, ACCEL TILE FACTOR=auto{1}, and ACCEL PARALLEL FACTOR=auto{1} respectively. Treat this function as a hardware kernel for acceleration using the '#pragma ACCEL kernel' directive.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write an HLS kernel function named 'kernel_3mm'. The function will accept nine parameters which are 'ni', 'nj', 'nk', 'nl', 'nm' and five 2D arrays 'E', 'A', 'B', 'F', 'C', 'D' and 'G'. The function mainly performs three parts of operations, each comprises a nested two-level loop structure.\n\nIn the first part, set the 'ACCEL PIPELINE', 'ACCEL TILE FACTOR', 'ACCEL PARALLEL FACTOR' to disallow automatic pipelining, prevent breaking the loop into smaller chunks and run the loop iterations serially for the outer loop of the matrices 'E', 'A' and 'B'. Similarly apply these settings to the inner loop, with a change in 'ACCEL PARALLEL FACTOR' setting to run 30 iterations in parallel for matrix 'B'.\n\nIn the second part, similar 'pragma' settings will be applied to the outer loop of the matrices 'F', 'C' and 'D'. For the inner loop, change the 'ACCEL PARALLEL FACTOR' to process 80 loop iterations running simultaneously for matrix 'D'.\n\nIn the final part, apply the same 'pragma' settings as the first and second parts for the outer loop of the matrices 'G', 'E' and 'F'. Use 'ACCEL PIPELINE' pragma with a flatten option for the inner loop to flatten its nested loop structure and maintain the rest pragma settings.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function named 'kernel_3mm' treating it as a hardware kernel for acceleration. This function takes in integers ni, nj, nk, nl, nm and two-dimensional arrays E, A, B, F, C, D, G. Initiate a 'for loop' to iterate through a specific range, disallowing automatic pipelining and running the iterations one after the other and in their full form. Inside this loop, launch another 'for loop' with the same settings, where you initialize array E at location [i][j] to 0.0 and then iterate through a subsequent range to update E[i][j] by multiplying items from arrays A and B at specified indices. Repeat this process with no pipelining, full iterations executed one after the other for arrays F, C, and D. For the final process, repeat the above routine one more time, but this time for arrays G, E, and F, however allowing the final chunk of iterations to execute in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a C function named 'kernel_3mm' with the defined parameters and matrices. This function should be treated as a hardware kernel for acceleration. The task is divided into three parts. \n\nFirst, you will perform matrix multiplication between matrices A and B, storing the result in matrix E. For this part, ensure iterations of matrices A and B are not processed in parallel and are not automatically pipelined. \n\nSecond, you will do matrix multiplication between matrices C and D and store the result in matrix F, keeping the same pragma settings as earlier. \n\nLastly, you will multiply matrices E and F, storing the result in matrix G. In this step, the iterations can be done in parallel 16 at a time which contrasts the previous pragma settings. \n\nThroughout all these processes, the original loops should not be broken up into smaller chunks.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function named 'kernel_3mm' that takes integer arguments 'ni', 'nj', 'nk', 'nl', 'nm' and 2-dimensional double arrays 'E', 'A', 'B', 'F', 'C', 'D', 'G'. This function is to be treated as a hardware acceleration kernel. Inside this kernel, there are three main matrix multiplication processes: E=A*B, F=C*D and G=E*F.\n\nFor each of these processes, start by disabling automatic pipelining, ensure that the loop is processed in its original form without being split into small parts, and run loop iterations sequentially with the specified #pragma values for 'PIPELINE', 'TILE FACTOR', and 'PARALLEL FACTOR', respectively. \n\nIn each of the nested loops, initialize the resulting 2D array element to 0.0, then execute the sum of product calculation sequentially, but parallelize the innermost loop with a PARALLEL FACTOR of the number of iterations this loop will perform (60 for E=A*B, 80 for F=C*D, and 1 for G=E*F).\n\nFor the third process, instead of disabling automatic pipelining, flatten the loop hierarchy for parallelism and optimize for the hardware implementation. Remain using the same 'TILE FACTOR' and 'PARALLEL FACTOR' pragmas.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a kernel function named `kernel_3mm` taking various integer parameters (`ni`, `nj`, `nk`, `nl`, `nm`) representing array dimensions and several array parameters (`E`, `A`, `B`, `F`, `C`, `D`, `G`). Consider this function as a hardware kernel for acceleration. First, calculate the product of matrix `A` and `B` and store it in matrix `E`. Turn off automatic pipelining, process this loop in its original form without breaking it into smaller chunks, and run the iterations of this loop sequentially for this computation. Then, compute the matrix product of `C` and `D`, storing the result in `F` with parallel iterations flattened in the loop. Again, no automatic pipelining and the loop should not be divided into smaller chunks. Finally, calculate the matrix product of `E` and `F`, storing the result in `G`. For this, let iterations run in parallel automatically for a factor of 10 and do not activate automatic pipelining or break the task into smaller pieces.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function called 'kernel_3mm' which takes parameters ni, nj, nk, nl, nm and arrays E, A, B, F, C, D, G. Start by treating this function as a hardware acceleration kernel. \n\nIn the three main loops of the function, \n\nFor the first loop, calculate the matrix multiplication of A and B, assign the result to E. Automate the pipelining, tiling and parallel execution settings for this loop. \n\nFor the second loop, calculate the product of matrices C and D, and assign it to F. Turn off automatic pipelining, set tiling and parallel execution to its original, full form.\n\nLastly, for the third loop, compute the product of matrices E and F and assign the result to G. Also, disable automatic pipelining, perform the loop iterations one after the other (not in parallel) for k loop iterations when calculating G[i][j]. Make sure to use the tiling mechanism in its complete form without partitioning it into smaller chunks.\n\nOverall, make sure that the loops are processed in their original, full form without being broken down into smaller chunks, and that iterations are carried out one after the other, not in parallel, except for the last k loop iteration in G[i][j] calculation where parallel factor is automatically set to 2.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function named 'kernel_3mm' that takes integer parameters 'ni', 'nj', 'nk', 'nl', 'nm' along with six 2-dimensional arrays 'E', 'A', 'B', 'F', 'C', 'D', 'G'. The function is treated as a hardware kernel for acceleration. In this function, we have three different sets of calculations 'E := A*B', 'F := C*D', and 'G := E*F'. For each calculation, three nested 'for' loops are used, and various pragma directives are applied for different purposes. In the outer loops, the directives turn off the automatic pipelining, process the loop in its original form without breaking it into chunks, and run iterations one after the other, not in parallel. For the inner loops, the directives flatten the pipeline, again process the loop in original form, but change the parallel factor according to the demands of different set of calculations.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function named 'kernel_3mm' that takes in several parameters: five integers ni, nj, nk, nl, nm, and seven 2D arrays E, A, B, F, C, D, G. Mark the function as an acceleration kernel with the pragma 'ACCEL kernel'. \n\nWithin this function, first, execute matrix multiplication of A and B to form E. Make sure not to automatically pipeline the loops, process them in their original form without splitting it into smaller parts, and run iterations one after another, not in parallel. Then, parallelize the innermost loop for 30 iterations automatically.\n\nSimilarly, conduct the matrix multiplication of C and D to form F with the same conditions applied to the outer loops. For the innermost loop, allow it to run 32 iterations in parallel automatically.\n\nLastly, multiply E and F to form G. Again, apply the same conditions on outer loops but run the innermost loop for 50 iterations automatically. Output all the results.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function named 'kernel_3mm' which will perform three matrix multiplications in sequence in hardware. Treat the function as a hardware kernel for acceleration and set all your loops not to be automatically pipelined, to run in their original, full form without breaking them into smaller chunks and run the iterations of the loops one after the other, not in parallel for the first two matrix multiplications i.e. A*B and C*D. For the last matrix multiplication E*F, perform the same but automatically flatten the second order loop. Use 'ACCEL KERNEL', 'ACCEL PIPELINE auto{off}', 'ACCEL TILE FACTOR=auto{1}' and 'ACCEL PARALLEL FACTOR=auto{1}' pragmas respectively. The dimensions of the matrices are determined by the integer parameters ni,nj,nk,nl,nm. Initialize the resulting matrices to zero then accumulate the results of the multiplication in a nested three-level loop structure.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function named \"kernel_3mm\" that receives integer values 'ni', 'nj', 'nk', 'nl', 'nm', along with six bidimensional arrays of double type 'E', 'A', 'B', 'F', 'C', 'D', and 'G'. This function will be treated as a hardware kernel for acceleration. The function includes three main multiplications done in nested loops. In the first double-nested loop process, disallow pipeline optimization, don't split the loop into smaller chunks and don't parallelize the loop's iterations. This process multiplies the 'A' matrix by the 'B' matrix, storing the result on the 'E' matrix. Repeat a similar process for the 'C' and 'D' matrices, results to be stored on the 'F' matrix.Except for the final matrix multiplication done in the third nested loop, where we multiply the 'E' matrix by the 'F' matrix and store the result on the 'G' matrix. Disallow pipeline optimization again, don't split the loop into smaller chunks, but this time parallelize the outer loop iterations with a factor of 2 and for nested inner loop, increase the parallel factor to 10.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function named `kernel_3mm` with integer parameters `ni`, `nj`, `nk`, `nl`, `nm` and 2D double array parameters `E`, `A`, `B`, `F`, `C`, `D`, `G`, this function has been treated as a hardware kernel for acceleration. The function facilitates matrix multiplications where three matrices `A`, `B`, `C`, and `D` are multiplied in the following order `E=A*B`,` F=C*D`, `G=E*F`. \n\nInside each of the multiplication for-loops, disable automatic pipeline optimization and instruct it not to break loops into smaller chunks and iteratively run calculations using `#pragma ACCEL PIPELINE auto{off}` `#pragma ACCEL TILE FACTOR=auto{1}`, `#pragma ACCEL PARALLEL FACTOR=auto{1}` for the first and second multiplications. In the final multiplication, apply a parallel factor of 2 to the outer loop and a parallel factor of 8 to the inner loop using `#pragma ACCEL PARALLEL FACTOR=auto{2}` and `#pragma ACCEL PARALLEL FACTOR=auto{8}` respectively, running more iterations in parallel which improved the performance.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Generate an HLS C-content in a kernel function named \"kernel_3mm\", which takes the parameters ni, nj, nk, nl, nm, and arrays E, A, B, F, C, D, and G; and implements three matrix multiplications (E:=A*B, F:=C*D, G:=E*F). Process the loops for each multiplication in a serialized, non-pipelined manner without partitioning, by using pragmas ACCEL PIPELINE 'off', ACCEL TILE FACTOR 1, and ACCEL PARALLEL FACTOR 1. For the innermost loops, allow parallel factor of 3, 80 and 8 respectively for each multiplication operation.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function named 'kernel_3mm', designed to be optimized for hardware acceleration by FPGA with the '#pragma ACCEL kernel' directive. This function will perform matrix multiplication on arrays E, A, and B; F, C, and D; and lastly G, E, and F. There are three-part calculations - for each part, set the loop pipeline options to 'off' by '#pragma ACCEL PIPELINE auto{off}', and enforce the loops to iterate in their original form without splitting by the 'TILE FACTOR' of 1, '#pragma ACCEL TILE FACTOR=auto{1}', and specify iterations to be executed in sequence not parallel by the 'PARALLEL FACTOR' of 1, '#pragma ACCEL PARALLEL FACTOR=auto{1}'.\n\nSub-processes, looped within the main loop, will have pipeline directive as 'auto{flatten}' and similar 'TILE FACTOR' and initial 'PARALLEL FACTOR'. However, the final parallel factor used inside the innermost loop is different for each calculation: the first process has its final loop's 'PARALLEL FACTOR' as 1, the second one as 16 within the calculation F := C*D, and the last one as 2 within the calculation G := E*F.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function called 'kernel_3mm'. Declare the function with a kernel pragma for hardware acceleration. The function should take in dimensions ni, nj, nk, nl, and nm and 2D double arrays E, A, B, F, C, D, G as its parameters. Inside the function, declare integer variables i, j, and k for looping. Three steps are involved in this function: \n\n1. Firstly, E is calculated as the product of A and B. Start a loop iteration for i ranging from 0 to 40, inside which start another loop for j ranging from 0 to 50. In each iteration, initialize E[i][j] to 0, then start a third loop for k from 0 to 60 and for each k, increase E[i][j] by the product of A[i][k] and B[k][j]. The iterations in these loops are not pipelined and executed in parallel, and the loops are processed in their full form. \n\n2. Secondly, F is calculated as the product of C and D. Use loops similar to the first process, but this time for i from 0 to 50 and j from 0 to 70, and k ranges from 0 to 80. Also, unlike the first process, the third loop iterations are processed in parallel with a factor of 80. \n\n3. Lastly, G is calculated from E and F. Once again, the loops here are similar to the first process, but, unlike the first process, the inner loop for j is flattened and third loop iterations are executed parallelly with a factor of 2. \n\nThese steps serve to multiply three pairs of matrices respectively.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a HLS kernel function called kernel_3mm that takes in integer inputs ni, nj, nk, nl, and nm and double arrays E, A, B, F, C, D, and G. This function will implement matrix multiplication operations with three main parts: multiplying A and B store to E, multiplying C and D store to F, and finally multiplying E and F store to G. In depth, for the first part, create a loop structure with the outer loop iteration from 0 to 39, and the inner loop from 0 to 49. Each loop needs to be processed without pipelining, in its full form, and not in parallel. For each pair of i and j, default E[i][j] to 0.0, and add up the multiplication of A[i][k] and B[k][j] for k from 0 to 59 in parallel with a factor of 1. For second part, create a similar loop structure with ranges of 0-49(i) and 0-69(j). Default F[i][j] to 0.0 with parallelism on the nested loop from k=0 to 79 with a factor of 80. For the final part, iterate through 0-39(i) and 0-69(j) with a similar setup to the first part but with parallelism in the nested loop from k=0 to 49 with a factor of 50.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Design a function named 'kernel_3mm' where you'll use a hardware kernel for acceleration. This function will take in 7 parameters: five integers denoting dimensions (ni, nj, nk, nl, nm), and 6 double arrays (E, A, B, F, C, D, G). The function will have three main parts, which describe matrix multiplications (E := A*B, F := C*D, and G := E*F). \n\nAll loops are to be processed in their original form, without pipelining or breaking into smaller chunks. Every loop's iterations will run one after the other, not simultaneously. So, for each process, include the pragma commands PIPELINE as \"off\", TILE FACTOR and PARALLEL FACTOR as \"1\". \n\nHere are the three parts in detail:\nIn the first part, for matrix E, initiate a loop for 'i' from 0 to 39 where inside it, another loop for 'j' from 0 to 49 begins. Set E[i][j] to 0.0 and multiply corresponding values in A and B.\n\nIn the second part, for matrix F, you'll do a similar process, but with different range, specifically the 'i' loop from 0 to 49 and 'j' loop from 0 to 69. Set F[i][j] to 0.0 and perform multiplication of corresponding values in C and D.\n\nIn last part, for matrix G, the similar process will be repeated with new values for the looping construct - 'i' from 0 to 39 and 'j' from 0 to 69. Set G[i][j] to 0.0 and incorporate multiplication of corresponding values in E and F.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Generate a HLS code in C for a function called 'kernel_3mm' that takes nine parameters: five integers (ni, nj, nk, nl, nm) and four 2D arrays of doubles (E 40x50, A 40x60, B 60x50, F 50x70, C 50x80, D 80x70, G 40x70). \n\nThe function should be treated as a hardware kernel for acceleration with the directive '#pragma ACCEL kernel'. \n\nThe function should do three operations: first, compute the matrix multiplication of A and B and store it in E, and then do the same with C and D storing result in F and finally calculate E and F to store in G. \n\nFor each of these three operations, use three nested loops. All loops should be processed in their original, full form without breaking them into smaller chunks using the directive '#pragma ACCEL TILE FACTOR=auto{1}' and iterations should be run one after the other, not in parallel using the directive '#pragma ACCEL PARALLEL FACTOR=auto{1} or auto{80} or auto{50} depending on the case'. \n\nThe loop for E should not automatically be pipelined with the directive '#pragma ACCEL PIPELINE auto{off}', however the inner loop can be flattened to run in parallel using the directive '#pragma ACCEL PIPELINE auto{flatten}'. The loops for F and G should not be pipelined using the same directive '#pragma ACCEL PIPELINE auto{off}'.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a hardware accelerated function with the prototype \"void kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\". The function will perform three major matrix operations. \n\nFirst, it will calculate A multiplied by B and store the result in E with the loop being flattened to a single level whenever possible and not pipelined nor parallelized. Each matrix element of E will be set to 0 initially, and then its value will be updated according to the multiplication results of corresponding elements in the A and B matrices, which will be executed one by one.\n\nNext, the function will calculate C multiplied by D and store the results in F with loop iterations running simultaneously whenever possible and it will be pipelined in its full form without breaking down into smaller chunks.\n\nFinally, the function will calculate E multiplied by F and store the result in G with the loop again being flattened to a single level whenever possible and not pipelined. It will start each matrix element of G at 0, and then update its value according to the multiplication results of corresponding elements from the E and F matrices, executed one by one. The outer loop for this calculation will also have a parallelization factor of 2, allowing two iterations to run simultaneously whenever it is feasible.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware acceleration kernel for matrix multiplication with the function declaration `void kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])`. The kernel must perform 3 separate matrix multiplications: A*B, C*D, and E*Ftored in E, F, and G respectively. For all these operations, the outer two loops should not be pipelined, and the iterations should be run sequentially without being distributed into distinct functional units. However, the innermost loop of the first calculation should be parallelized with a factor of 8, of the second calculation with a factor of 32, and of the third calculation with a factor of 50.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a HLS-C function that multiplies matrix E by A and B, F by C and D, and then G by E and F. Set the kernel up as a hardware device accelerator. The function has two nested loops, which should not be automatically pipelined, and should be processed in their original form without dividing into smaller chunks. The iterations should not be run in parallel. Repeat this for three sections with different matrices. For the final loop under the section multiplying G by E and F, allow this loop to execute four iterations simultaneously.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write an accelerated HLS kernel function named \"kernel_3mm\" that takes as input nine parameters (five integers and four 2D arrays of doubles) and performs three matrix multiplication operations. Do not automatically pipeline any of the loops in the function and keep them in their original form without dividing them into smaller units using the 'ACCEL PIPELINE \"off\"' and 'ACCEL TILE FACTOR=1' pragmas. Also, ensure that the loop iterations are not executed in parallel but one after the other with 'ACCEL PARALLEL FACTOR=1'. The first operation is to multiply matrices A and B and store the result in matrix E. After initializing matrix E with 0, perform the operation for each value of E[i][j]; the parallel factor for this operation is set as 'ACCEL PARALLEL FACTOR=3'. Carry out a similar operation for matrices C and D storing the result in matrix F with 'ACCEL PARALLEL FACTOR=80' for this particular operation. Finally, multiply matrices E and F and store the result in matrix G, the parallel factor for this operation is set as 'ACCEL PARALLEL FACTOR=8'.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function 'kernel_3mm' which is treated as a hardware kernel for acceleration, taking in integer parameters 'ni', 'nj', 'nk', 'nl', 'nm' and six 2D double arrays 'E', 'A', 'B', 'F', 'C', 'D', 'G'. Within this function, apply three set of calculations. In each, ensure that the loops are processed in their original form, not broken into smaller parts. Also, perform these loops one after the other, not in parallel, with exceptions in the innermost loops which employs a varying degree of parallelism. The calculations involve firstly computing 'E' as a result of the matrix multiplication of 'A' and 'B', next computing 'F' as the product of 'C' and 'D', and finally calculating 'G' from multiplying 'E' and 'F'.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware accelerated kernel function, called `kernel_3mm`, with parameters for the dimensions ni, nj, nk, nl, nm, and multiple 2D arrays E, A, B, F, C, D, G. This function should execute three sets of nested loop operations. The first set calculates the product of arrays A and B, storing the result in array E. The second set does the same for arrays C and D, with the result stored in F. The final set multiplies arrays E and F, storing the result in G. Do not automatically pipeline any loops but rather execute iterations sequentially and keep the entire operation intact without subdividing it using pragmas ACCEL PIPELINE auto{off}, ACCEL TILE FACTOR=auto{1} and ACCEL PARALLEL FACTOR=auto{1} respectively. However, the final inner loop should execute 25 iterations simultaneously using pragma ACCEL PARALLEL FACTOR=auto{25}.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{25}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a hardware-accelerated HLS function called 'kernel_3mm' with the given header, which performs matrix multiplications in three steps. Initialize the function as an accelerated kernel using #pragma ACCEL kernel. Start with the matrix multiplication of A and B matrices to obtain the E matrix. For each upper-level loop, prevent automatic pipelining of the loop, execute each iteration fully without tiling, and disable parallel execution. However, integrate 32 parallel iterations for the innermost loop where the multiplication operations are carried out. Follow the same process for the multiplication of C and D to produce the F matrix but the parallel factor is set to 1 for all loops. Lastly, multiply matrices E and F to get matrix G. Here, parallelize two iterations for the second loop and ten iterations for the innermost loop while maintaining previous pragma constraints.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a function named 'kernel_3mm' with return type 'void'. It will accept several integers as a parameter including 'ni', 'nj', 'nk', 'nl', 'nm' and six 2D arrays of type 'double' namely 'E', 'A', 'B', 'F', 'C', 'D', 'G'. \n\nAssume this function as a hardware kernel for acceleration. The function works by first multiplying matrix 'A' with 'B' and storing the result in 'E'. Then, multiply matrix 'C' with 'D' and store the result in 'F'. Lastly, multiply matrix 'E' with 'F' and store the result in 'G'.\n\nDuring this process, do not apply any automatic pipelining optimization to these loops, but do process them in their original full form without breaking them into smaller chunks. Also, make sure that the iterations of these loops are not run in parallel but one after the other.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a HLS hardware kernel function called 'kernel_3mm'. The function should take several inputs, including five integers (ni, nj, nk, nl, nm), six 2D arrays of doubles (E, A, B, F, C, D) with dimensions as shown in the code, and a resulting 2D double array (G). The function has three nested loop structures, each performing matrix multiplication with different element sizes (40x60, 60x50, 50x80) forming matrices E, F, and G. \n\nFor each loop, it should follow specific #pragma instructions. In general, apply the entire execution of each loop without pipelining it automatically (i.e., keeping the order of loop iterations the same). Also, do not divide the loop into smaller chunks and do not execute iterations of the loops in parallel by setting '#pragma ACCEL PIPELINE auto{off}', '#pragma ACCEL TILE FACTOR=auto{1}', and '#pragma ACCEL PARALLEL FACTOR=auto{1}' respectively.\n\nInternally, each loop also contains nested loops. Except for the last outer loop, these should not be pipelined automatically and keep the original loop structure without dividing it. The iterations of these loops should be executed sequentially, not in parallel using the respective #pragma instructions above. However, for the internalloops performing the actual multiplication (k loops), allow parallel processing of 60 or 80 iterations for the first and second main loop respectively.\n\nFor the last outer loop, use the '#pragma ACCEL PIPELINE auto{flatten} instruction to instruct the compiler to merge all nested loop levels into a single level if possible. The rest instructions in this loop are similar to those mentioned earlier.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a function called 'kernel_3mm' that takes nine parameters: five integers named ni, nj, nk, nl, nm, and four bidimensional double arrays named E, A, B, F, C, D, G, all with different dimensions. This function will be treated as a hardware kernel for acceleration. To calculate the matrices E and F, it employs three nested loops with separate iterations. The innermost loop of each is responsible for the multiplication and the addition of the matrix elements. While processing these loops, do not automatically pipeline them, do not break each loop down into smaller chunks, and don't process the iterations in parallel. However, in the last nested loop of the matrix G, allow the iterations to run 32 at a time in parallel. Despite all this, handle the rest of the compliance to hardware restrictions and specific optimizations automatically.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a function named 'kernel_3mm' specified in C language which takes in parameters including five integers, 'ni', 'nj', 'nk', 'nl', 'nm' and seven 2-D arrays 'E', 'A', 'B', 'F', 'C', 'D' and 'G'. The objective is to perform 3 matrix multiplications using these values. The task should be specified as accelerable hardware kernel function. Start with the multiplication of the matrices 'A' and 'B' to form matrix 'E', whereupon turning off automatic pipelining, preventing the processing loop being isolated into smaller chunks and making sure the iterations run sequentially, not concurrently. Following the same process, multiply matrices 'C' and 'D' to form matrix 'F'. Finally, multiply matrices 'E' and 'F' to produce matrix 'G', but the third inner loop runs 25 iterations concurrently unlike previous process.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{25}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a HLS function named 'kernel_3mm' that takes in 7 two-dimensional arrays 'E', 'A', 'B', 'F', 'C', 'D', and 'G' with respective dimensions as arguments along with 5 integer parameters 'ni', 'nj', 'nk', 'nl', 'nm'. The function should be treated as a hardware kernel for acceleration.\n\nInside the function, we will first compute the matrix multiplication of 'A' and 'B' and store it in 'E'. In this code block, we will use the pipeline directive with automation and flatten set to default, tile the loop with the factor as default of size 1 and iterate over the loops in sequence and not parallel. Inside the inner loop, we turn off automatic pipelining, tile the loop with factor size of 1 and perform the calculations in sequential order.\n\nThe process repeats for matrices 'C' and 'D', the result stored in 'F', with similar pragma directives for pipelining, tiling and parallelism.\n\nFinally, we perform matrix multiplication of 'E' and 'F', storing the result in 'G' with similar settings except for the outer loop where parallel factor is set to a system optimal value. The inner loop runs sequentially with parallel factor of 1. Make sure not to automatically pipeline these loops and they should be processed in their original, full form.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{14}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a HLS C code to define a function 'kernel_3mm' that accepts nine parameters: five integer variables 'ni', 'nj', 'nk', 'nl', 'nm' and four 2D double arrays 'E', 'A', 'B', 'F', 'C', 'D', 'G'. Begin with a '#pragma ACCEL kernel' to indicate this function is a hardware kernel for acceleration. \n\nThe function should perform three matrix multiplication operations: \"E = A*B,\" \"F = C*D,\" and \"G = E*F\". During these operations, use several '#pragma ACCEL' directives. \n\nUse '#pragma ACCEL PIPELINE auto{off}' to prevent automatic pipelining. Make use of '#pragma ACCEL TILE FACTOR=auto{1}' to ensure the loop is processed in its original, full form without breaking it into smaller chunks. Implement '#pragma ACCEL PARALLEL FACTOR=auto{1}' to run the iterations of the loop one after another, not in parallel. \n\nFor loops involving the calculations of matrices 'E', 'F' and 'G', besides '#pragma ACCEL PIPELINE auto{off}' and '#pragma ACCEL TILE FACTOR=auto{1}', use different values of '#pragma ACCEL PARALLEL FACTOR'. This should be set to 'auto{1}' for the loop computations of matrices 'E' and 'F', 'auto{2}' for the outer loop computation of matrix 'G', and 'auto{25}' for the inner loop computation of matrix 'G'. The different values aid in managing the parallelism of the for loop iterations.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{25}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Develop a function named 'kernel_3mm' with parameters 'ni', 'nj', 'nk', 'nl', 'nm' and matrices 'E', 'A', 'B', 'F', 'C', 'D' and 'G'. The function will perform three matrix multiply operations in the form 'E:=A*B', 'F:=C*D' and 'G:=E*F'. Treat this function as a hardware kernel for parallel processing. \n\nEach operation involves nested loops. For all loops, ensure they are processed in original form, 'ACCEL TILE FACTOR' set to 'auto{1}', and are run serially, 'ACCEL PARALLEL FACTOR' set to 'auto{1}'. \n\nDuring the operation 'E:=A*B' and 'F:=C*D' automate pipelining of loops with 'ACCEL PIPELINE' set to 'auto{flatten}', and ensure loops are run serially. While for 'G:=E*F' operation, disable pipelining with 'ACCEL PIPELINE' set to 'auto{off}' and ensure the innermost loop runs in parallel with 'ACCEL PARALLEL FACTOR' set to 'auto{25}'.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{25}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware kernel acceleration function named 'kernel_3mm' with parameters of five integer variables and seven 2D double arrays. The function's main purpose is to compute the matrices multiplication of 'A*B', 'C*D' and 'E*F' in several parallel loops. For the first operation of 'A*B', do not automatically pipeline it, process it in its original full form without breaking into smaller chunks, run iterations one after the other and not in parallel, and enable an auto-parallelism of a factor of 32 for the innermost loop. For the second operation of 'C*D', again prevent auto pipelining, parallelism is not applied, and the iterations are run in flattened pipeline manner meaning that the pipeline schedules the iterations in order of preset preferences. For the final operation 'E*F', do not automatically pipeline it, process it in its original full form and implement a parallelism factor of 50 for the innermost loop.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a function called kernel_3mm, of which the primary task includes multiplication of matrices. Before each matrix multiplication loop, deactivate automatic pipeline (pragma ACCEL PIPELINE auto{off}), ensure the loop doesn't get split into smaller pieces (pragma ACCEL TILE FACTOR=auto{1}), and avoid parallel execution (pragma ACCEL PARALLEL FACTOR=auto{1}). Then multiply matrix A[40][60] with B[60][50], storing your result in matrix E[40][50]. Perform a similar operation for matrices C[50][80] and D[80][70], storing the result in F[50][70], but with the innermost loop allowing parallel execution of one iteration (pragma ACCEL PARALLEL FACTOR=auto{1}). Finally, multiply E[40][50] with F[50][70] and store the result in G[40][70] with the innermost loop allowing 32 parallel iterations (pragma ACCEL PARALLEL FACTOR=auto{32}).", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function 'kernel_3mm' for hardware kernel-based acceleration that performs matrix multiplication operations on 3 pairs of matrices (A x B = E, C x D = F, E x F = G). Within each successive operation, set pragma configurations to: \n\n1. Prevent automatic pipelining of the loop by using '#pragma ACCEL PIPELINE auto{off}'.\n2. Ensure that each loop iteration is processed as a whole by using '#pragma ACCEL TILE FACTOR=auto{1}', and \n3. Sequentially execute loop iterations without parallelism via '#pragma ACCEL PARALLEL FACTOR=auto{1}'.\n\nAs exceptions, within each nested loop applying multiplication, allow certain degree of parallel execution by adjusting the 'PARALLEL FACTOR' to '60', '1' and '50' respectively. Set 'PARALLEL FACTOR=auto{2}' for the outer loop under operation 'G := E*F'.\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware-accelerated kernel function called 'kernel_3mm' with several input parameters and 2D arrays. This kernel will perform matrix-multiplication on 6 different 2D arrays; First, perform multiplication on A and B and store the result in E. For this part, use dynamic pipelining, tiling and parallel processing factors derived from the compiler. Then, perform the multiplication on C and D and store the result in F. For this part as well, disable the automatic pipelining and use tiling and parallel factor as per compiler's suggestion. Finally, perform multiplication on E and F and store the result in G. Again, turn off the automatic pipelining, use tiling and parallel factor as per compiler's suggestion, but this time, explicitly set the parallel factor to 5 for the innermost loop.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a C program with a kernel named 'kernel_3mm'. The kernel should take several integer parameters (ni, nj, nk, nl, nm) and 7 two dimensional arrays as arguments. The function should first compute the matrix multiplication of A and B, assign the result to E. Then compute the matrix multiplication of C and D, assign the result to F. Finally compute the multiplication of E and F, assign the result to G. For loop optimizations, do not automatically pipeline any loops, do not break the loops into smaller pieces, and don't run the loops in parallel. However, run the innermost loop of the first and the last matrix multiplication in parallel with a factor of 60 and 50 respectively.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Using the function header 'void kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])', write a HLS code snippet implementing the hardware kernel that follows the next steps. Disable automatic loop parallelism ('off') for the calculation of the matrix multiplication of A and B, assigning the result to E. Then perform a similar action for calculating F from the matrix multiplication of C and D. Finally, do the same for obtaining G from the matrix multiplication of E and F. However, this last step should allow for some degree of parallelism ('16'). Throughout all these steps, the loop iterations should be processed fully and sequentially (FACTOR=1), without splitting them into smaller chunks.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Develop a function named 'kernel_3mm'. It receives nine arguments, among them, the first five are integer variables 'ni', 'nj', 'nk', 'nl', 'nm' and the last four are 2D array variables of double data type, 'A', 'B', 'C', 'D', 'E', 'F', 'G'. This function is treated as a hardware kernel for acceleration.\n\nIn the function, firstly, calculate the product of matrices 'A' and 'B' and store the result in matrix 'E'. The initial value of 'E' at each index will be zero. Process this loop in its original, full form without breaking it into smaller chunks, do not automatically pipeline its iterations and perform them concurrently with a factor of two only for the most nested loop. \n\nSecondly, similar to the above step, find out the product of 'C' and 'D' arrays and save that in 'F'. Here, additionally, flatten the pipeline of the second loop, while keeping other settings the same as in the first step.\n\nThirdly, get the multiplied value for 'E' and 'F', keep it in 'G'. Run iterations of the first and second loop one after the other, not in parallel. For the third loop, the iterations are to be executed in four separate or simultaneous runs. These steps are depicted using 'ACCEL PIPELINE', 'ACCEL TILE FACTOR', and 'ACCEL PARALLEL FACTOR' pragma directives respectively. \n\nAll processing stages are enclosed within an 'ACCEL kernel' to indicate that the function should be compiled into a block of hardware executable instructions for speeding up the tasks.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function called 'kernel_3mm', with integer inputs 'ni', 'nj', 'nk', 'nl', 'nm' and double arrays 'E', 'A', 'B', 'F', 'C', 'D', 'G', to be treated as a hardware acceleration kernel. This function will perform three matrix multiplication operations. First, it will compute matrix 'E' as the product of matrices 'A' and 'B', by looping through each element, initializing to 0.0 and then adding the product of corresponding elements from 'A' and 'B', with no pipeline optimization, not breaking it into smaller chunks and processing the iterations serially, besides, the innermost loop should be performed in an auto parallel factor of 60. Second, it will do a similar operation for matrices 'C' and 'D' to yield matrix 'F', with slightly different dimensions, but still no pipeline optimization, not breaking it into smaller chunks and processing the iterations serially, besides, the innermost loop should be performed in an auto parallel factor of 80. Finally, it computes matrix 'G' as the product of the newly created matrices 'E' and 'F', implementing the whole pipeline operation in one go with the innermost performed in an auto parallel factor of 1, with all the other policies kept the same.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Develop a function called 'kernel_3mm' that is treated as a hardware kernel for acceleration. This function should accept nine parameters, five of which are integers and the rest are double 2D arrays of different sizes. The process requires you to compute the matrix multiplication for three sets of matrices- 'A' * 'B', 'C' * 'D' and 'E' * 'F'. Each matrix multiplication operation is separated into three nested loops with i, j and k as the iterators. \n\nFor each calculation, ensure the loop does not automatically pipeline, and is processed in its original form without being split into smaller chunks, and its iterations run sequentially, one after the other rather than in parallel. The pragma values to be used are '#pragma ACCEL kernel' to declare the function as a kernel, '#pragma ACCEL PIPELINE auto{off}' to prevent automatic pipelining, '#pragma ACCEL TILE FACTOR=auto{1}' to process the loop without breaking it down, and '#pragma ACCEL PARALLEL FACTOR=auto{1}' to run iterations one after the other.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware accelerated HLS kernel named 'kernel_3mm' which takes in matrix dimensions (ni, nj, nk, nl, nm) and matrices A, B, C, D, E, F, and G of double precision floating point numbers. The function executes three main matrix operations. For the first and second matrix operation, set autopipeline, autotile and autoparallelism as off, 1 and 1, respectively. The first operation is Matrix E=A*B where first two loops compute per each element in Matrix E where autopipeline, autotile and autoparallelism are off, 1 and 1, respectively and the third loop multiplies corresponding elements of Matrix A and B with parallel factor of 2 then add them in element of matrix E. Then comes the second operation which is Matrix F=C*D computed with same conditions as first operation except pipeline is flattened for second loop. In the last operation, compute Matrix G=E*F with autopipeline off for first loop where autoparallelism and autotile are 1, the second loop will auto pipeline and the third loop runs with parallel factor 32 to finalize the computation of Matrix G.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a HLS C code function named \"kernel_3mm\" which takes integers ni, nj, nk, nl, nm and six 2D double arrays E, A, B, F, C, D, G as inputs. This function should be treated as a hardware kernel for acceleration. Within this function, perform three sets of nested loop operations, each having their iterations run one after the other, not in parallel and processed in their original, full form without breaking them into smaller chunks.\n\nThe first operation calculates the product of matrix A and B and stores the result in matrix E. The second operation computes the product of matrix C and D, storing the result in matrix F. The final operation then calculates product of matrix E and F which is saved in matrix G. Although the iterations of these loops are run sequentially, the deepest nested loop in the final operation can be iterated in parallel five times at once.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function named \"kernel_3mm\" with input parameters: five integers (ni, nj, nk, nl, nm) and seven two-dimensional arrays of double (A, B, C, D, E, F, G). This function should be treated as a hardware kernel for acceleration. Start iteratively processing by using three main matrix multiplication operations: the multiplication of matrices A and B to produce a matrix E, the multiplication of matrices C and D to produce a matrix F, and finally the multiplication of matrices E and F to compute the matrix G. \n\nFor each pair of matrices being multiplied, follow these steps: \n\n1. Set the pipeline for the loop to run sequentially without breaking into smaller chunks, not in parallel.\n2. Initialize the resulting matrix by setting all its elements to 0.0.\n3. Multiply the corresponding row of the first matrix with the corresponding column of the second matrix and add the results, preserving the sequential form of the loop; Don't pipeline the respective iterations and ensure it is not split into smaller parts, and process its iterations in serial manner.\n\nTake note that for each outer loop, we neither want to chunk the iterations into smaller parts nor auto pipeline them. For the inner loop, we want to maintain the original full form of all the computations, and all iterations should run in sequence except the final multiplication for G in which we want to distribute the workload for up to 32 iterations in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function called `kernel_3mm` with the specified parameters and matrices that will be treated as a hardware kernel for acceleration. In this function, first, you need to calculate the product of matrix A and B and store the result in matrix E. For this, disable automatic pipeline, process the associated loop in its full form without breaking it into smaller chunks and run the iterations sequentially, not in parallel. For each iteration in matrices A and B, you should then manually manage the pipelining, tiling, and parallelism of the loops. Second, repeat the same steps for calculating the product of matrix C and D, and storing the result in matrix F. Lastly, compute the product of matrices E and F and save the result in matrix G, this time adjust the parallelism factor to 2.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create an accelerated C HLS function 'kernel_3mm' with specified parameters which consists of three main blocks to compute matrix multiplication. The function begins by multiplying matrix A and B, storing result in matrix E. After this, matrix C and D are multiplied with result held in matrix F. Finally, the results from the first two calculations (E and F) are multiplied, outputting the final result in matrix G. For each division, use three nested loops with specific code attributes set. Do not automatically pipeline these loops, and process these loops fully without breaking them into smaller chunks. Run the iterations of these loops sequentially, except for the final calculation (G) where the loop should be parallelized up to a factor of 16.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function in C named \"kernel_3mm\" that takes as arguments five integer parameters (ni, nj, nk, nl, nm) and seven 2D double arrays (E, A, B, F, C, D, G). The function will be treated as a hardware kernel for acceleration. Inside the function, the code conducts three main matrix multiplication operations (E:=A*B, F:=C*D, G:=E*F) on these arrays, with loops iterating over different dimensions of each array to perform the operations. Each of these operations is controlled by specific pragma directives. Especially, the matrix multiplication operations E:=A*B and F:=C*D are done sequentially, not in parallel. The iteration of these loops should not be pipelined or broken into smaller chunks automatically. The last multiplication operation G:=E*F is almost the same except that some iterations are performed parallelly.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function named 'kernel_3mm' with various integer parameters ni, nj, nk, nl, and nm, and 2D double arrays E, A, B, F, C, D, and G. Treat this entire function as a hardware kernel for acceleration. This function performs three distinct matrix multiplications operations. \n\nFirstly, the function computes E=A*B using two nested loops. Apply the following pragmas before and inside these loops: don't automatically pipeline this loop, process this loop in its original, full form without breaking it into smaller chunks, and run the iterations of this loop one after the other, not in parallel. The innermost loop with the multiplication operation can be run 60 iterations in parallel.\n\nNext, perform similar operations for the multiplication F=C*D, but with 80 parallel iterations in the innermost loop.\n\nLastly, calculate G=E*F. Don't pipeline the first two loops automatically. However, for the innermost loop, flatten it into a single loop iteration to allow for better performance and/or resource optimization. This loop should not be run parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Generate a C function titled 'kernel_3mm' where the loop values will not be automatically pipelined and the loops will be processed without breaking into smaller chunks. The iterations will be run sequentially, one after another, not in parallel. This function shall perform matrix multiplication operations on arrays A, B, C, D, E, F, and G in three stages. In the first stage, multiply matrix A by B and store the result in matrix E, the second stage involves multiplying matrix C by D, storing that result in F. Finally in the third stage, multiply matrix E by F and store the result in matrix G. Each stage involves looping through the arrays sequentially, so specify '#pragma ACCEL PIPELINE auto{off}', '#pragma ACCEL TILE FACTOR=auto{1}', and '#pragma ACCEL PARALLEL FACTOR' respectively. However, the last loop of the last stage is allowed to run in parallel for five threads specified by '#pragma ACCEL PARALLEL FACTOR=auto{5}'.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a HLS C code with a function named 'kernel_3mm' that accepts several integer parameters and six 2D double arrays. It has to be treated as an acceleration hardware kernel. In this function, you will do three different matrix multiplications. \n\nFirstly, you need to multiply 'A' and 'B' matr-rices and place the result in the 'E' matrix where loop factors for pipelining, tile, and parallelism need to be turned off initially but then automatically determined during runtime. The parallel iterations factor must be automatically set to 30 in the most inner loop.\n\nSecondly, you have to multiply 'C' and 'D' matrices and store the product in the 'F' matrix. The pragma pipeline, tile, and parallel factors need to be switched off at first, but the parallel factor within the deepest loop should be set dynamically to 32.\n\nLastly, do the multiplication of 'E' and 'F' and put the result into the 'G' matrix. Again, the pipeline, tile, and parallel factors should be off initially but then determined during execution. The auto parallel factor in the most inner loop should be set up to be automatic with a maximum of 50.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function in the C language named 'kernel_3mm'. This function will act as a hardware kernel for acceleration and takes in these parameters: five integers (ni, nj, nk, nl, and nm) and seven two-dimensional arrays of type double (E, A, B, F, C, D, and G). Within this function, prohibit the pipeline, avoid breaking the loop into smaller chunks, and don't parallelize the iterations for each loop to process the multiplication of matrices A & B, C & D, and E & F. However, allow parallelism with a factor of 60 for the third nested loop when processing A * B, while still disabling pipeline and not splitting it. Keep the parallel factor as 1 for the third nested loop while calculating C * D. While calculating E * F, set the parallel factor for the outer loop as 2 and for the inner loop as 50, in both cases don't pipeline and don't divide the loop. The outputs are matrices E, F, and G.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a comprehensive C function named 'kernel_3mm'. The main purpose of this function is to perform three matrix multiplication operations: E = A*B, F = C*D, and G = E*F. The function will use 7 arguments representing five integers (ni, nj, nk, nl, nm) and 7 two dimensional arrays (E[40][50], A[40][60], B[60][50], F[50][70], C[50][80], D[80][70], G[40][70]). \nThis function must be treated as a hardware kernel for acceleration. \n\nInside the function:\nFirstly, initialize i, j, k as the loop variable. \n\nSecondly, Calculate E = A*B. This process will use 3 nested loops, and declare them to run the iterations one after the other, not in parallel. The process will not be pipelined and will be taken in its original complete form. For the innermost loop process the current iteration in parallel with a factor of 30 chunks.\n\nThirdly, calculate F = C*D. This step should also use 3 nested loops declared to run the iterations one after the other and should not be broken down into smaller chunks. The innermost loop should be processed in parallel and be divided into 32 chunks.\n\nLastly, calculate G = E*F. These calculations will use 3 nested loops that should be run one after the other, but not in parallel for the major loops.\nFor the inner loop only, enable automatic pipelining, and parse the loop in parallel with a factor of 50 chunks.\n\nRemember to treat this function as a hardware kernel for acceleration. \n\nThe operation kernel_3mm is completed in the above way for all stipulated items.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function named `kernel_3mm` which acts as a hardware kernel for acceleration. The function takes in 7 parameters: 5 integers (ni, nj, nk, nl, nm), which define the dimension limits of matrices, and 6 double 2D arrays representing matrices (E, A, B, F, C, D, G). \n\nWithin the function, three matrix multiplication operations are performed: A*B, C*D, and E*F. Each computation loops over specific indices of matrices. First loop computes multiplication of A and B matrices and stores result in matrix E. Second loop computes multiplication of matrix C and D and stores result in matrix F. Lastly, the third loop computes multiplication of now calculated matrices E and F, storing the result in G. \n\nIn each operation loop, three HLS pragmas are used, namely ACCEL PIPELINE, ACCEL TILE, and ACCEL PARALLEL. Pragma ACCEL PIPELINE with various parameters ('off', 'flatten' or none) is used to control the pipelining of iterations in specific loops. Pragma ACCEL TILE with a factor of 1 is used to process each loop in its original full form without breaking it into smaller chunks. Pragma ACCEL PARALLEL with different factors (1, 2, 80, or 50) is used to control the extent of parallelism in the for loops, influencing how many iterations are executed concurrently.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware kernel-accelerated function named 'kernel_3mm' that processes two-matrix multiplication tasks and one final matrix multiplication to yield three resultant matrices. The function takes nine arguments: five integers, ni, nj, nk, nl, nm, which represent the dimensions of the matrices, and four double-type 2D arrays, A, B, C, D, E, F, G respectively. The kernels in this function disable automatic pipelining for the loops, process the loops in their full form without breaking them into smaller chunks, and run the iterations of these loops sequentially. However, the third multiplication task allows parallel iterations with a factor of 16. \n\nPrimarily the function performs the multiplication of matrix A and matrix B to yield a resultant matrix E. The function then multiplies matrix C and matrix D to yield another resultant matrix F. Lastly, the function will do a final multiplication operation of the previously obtained resultant matrices, E and F, to yield the final resulting matrix G. All values in resultant matrices are initialized to 0.0 before multiplication operations take place.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Develop a HLS function named kernel_3mm with the specified parameters and double array type inputs. Make this function a kernel for hardware acceleration. Create two nested loops, the outer runs 40 times and the inner 50 times in the body of the function. Don't pipeline or parallelize these loops and process them without any tiling or division into other blocks. In each iteration of the inner loop initialize the value of E[i][j] to 0.0, then create another inner loop inside these loops that runs 60 times, where parallelization factor is set to 60, to multiply values from A and B arrays being stored in E. \n\nNext create two another nested loops, the outer runs 50 times and the inner 70 times. Without pipeline or parallelizing these loops and processing them without any tiling or division into other blocks, initialize the value of F[i][j] to 0.0 in each iteration, then create another inner loop inside these loops that runs 80 times to multiply values from C and D arrays and summing up the value in F.\n\nFinally, create two nested loops, the outer runs 40 times and the inner 70 times. Without pipeline and processing without any tiling or division into other blocks, initialize the value of G[i][j] to 0.0 in each iteration and implement another inner loop that runs 50 times inside these loops with a parallelization factor of 50 to multiply values from E and F arrays and accumulate the value in G. Set the parallel factor of the second nested loop to 2.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a HLS kernel function with the given function header \"kernel_3mm\". You will be performing the operation \"E = A*B\", \"F = C*D\", and \"G = E*F\". Use double nested loops for all these operations. Bypass the automatic PIPELINE pragma choice, and use the auto-off pragma directive. Each loop should not be divided into smaller parts and iterations to be run sequentially (in original order and not in parallel). This is described by using the TILE and PARALLEL factors of auto-1. Perform matrix multiplication inside the innermost loop and use the PARALLEL factor of auto-60 for \"E = A*B\", auto-80 for \"F = C*D\", auto-1 for \"G = E*F\". In the final loop block, allow the PIPELINE pragma to flatten the loop nest if possible by using auto-flatten directive and use auto-2 for the PARALLEL loop factor of the second loop for optimal performance.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware-accelerated kernel named 'kernel_3mm' which takes in seven 2D matrices and five integers as parameters. The kernel performs three matrix multiplications. The kernel executes each loop in the order they are written, without trying to parallelize or pipeline them, and does not try to tile the loops into sub-tiles. First, multiply matrix 'A' with 'B' and store the result in 'E', following an element-wise multiplication where a value in 'E' is obtained by summing the product of corresponding elements from 'A' and 'B'. Repeat a similar process to multiply matrices 'C' and 'D' and storing the resulting values in 'F'. Finally, multiply 'E' and 'F', storing the result in 'G'. The only exception to the parallel factor is in the last loop where 'G' is computed, where we want to have 50 iterations running concurrently.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Instruct the code generator to output a kernel function called 'kernel_3mm'. This function must receive nine parameters, which are five integers (ni, nj, nk, nl, nm) and four 2D arrays of double (E, A, B, F, C, D, G). It should contain 3 sections dedicated to matrix multiplications (E:=A*B, F:=C*D, G:=E*F) with three nested loops in each section, for the rows i, columns j, and the product's adding indices k, of the matrices. \n\nIn each section, the pragma# ACCEL PIPELINE should be set to 'off', the pragma# ACCEL TILE FACTOR should be to '1', and the pragma# ACCEL PARALLEL FACTOR should be set to '1' for the outermost loops. For the innermost loops in the first and third sections, the PIPELINE pragma should be set to 'flatten' and 'off' respectively and in the second section should be set to 'auto', while the PARALLEL FACTOR pragmas should be set to '1', '80' and '50' respectively. The TILE FACTOR pragma should be set to '1' for these loops in each section.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a C-based HLS function entitled \"kernel_3mm\" with specific input parameters (int ni, int nj, int nk, int nl, int nm, and 2D arrays E, A, B, F, C, D, G). The function must be treated as a kernel for acceleration with the #pragma ACCEL kernel at the start. It should initiate matrices multiplication using three nested loops per operation. \n\nDo not pipeline the outer loops and process these loops in their original form (no tiling) and in sequence (no parallelism). This is obtained by setting PIPELINE and TILE to 'off' and FACTOR=1, respectively for the 'i' and 'j' loops.\n\nIn the innermost loop (the 'k' iteration) where the actual operation takes place, set the PARALLEL FACTOR to 2 for the first multiplication (E:=A*B) and 1 for the second multiplication (F:=C*D). \n\nFor the final multiplication step (G:=E*F), set the PARALLEL FACTOR for the 'k' loop to 32. This should maximize parallel computing during this phase. \n\nAll #pragma directives should be followed by 'auto' for flexibility in the hardware accelerator.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a C code under HLS kernel pragma, named 'kernel_3mm' taking input parameters int 'ni', 'nj', 'nk', 'nl', 'nm' and 2D double arrays E, A, B, F, C, D, G. Firstly, calculate and store values of the product of matrix A and B in E, don't automatically pipeline this loop, process it in its original state without chunking, and run the iterations one after the another. Also, parallelize the innermost loop with a factor of 32. Secondly, compute and store the product of matrix C and D in F using the same specifications as in the first calculation step but run the innermost loop in a parallel manner. Finally, calculate and store the product of matrix E and F in G. The outermost loop should be processed in its original state and run with a parallel factor of 2, but the innermost loop should be executed in parallel with a factor of 50.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create an accelerated hardware kernel function named 'kernel_3mm' which takes in five integer parameters representing dimensions, and six double precision 2D arrays. This function does three matrix multiplications. The first loop computes the multiplication of matrices A and B to populate matrix E. The second loop multiplies matrices C and D to give matrix F. The final loop multiplies matrices E and F to populate matrix G. \n\nIn each loop, the pragma directives are used as follows: \n\n- The 'ACCEL PIPELINE auto{off}' prevents automatic pipelining. \n- The 'ACCEL TILE FACTOR=auto{1}' processes the loop in its original, full form without breaking it into smaller chunks. \n- The 'ACCEL PARALLEL FACTOR=auto{1}' runs the iterations of the loop one after the other, not in parallel. \n\nThis is done for the outer and middle loops. For the innermost loop of the final matrix multiplication (matrix G population), the 'ACCEL PARALLEL FACTOR' is set to 'auto{50}' to perform 50 iterations simultaneously.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function called 'kernel_3mm' with parameters: five integer values 'ni', 'nj', 'nk', 'nl', 'nm' and seven 2D arrays 'E', 'A', 'B', 'F', 'C', 'D', 'G'. This function should be treated as a hardware kernel for acceleration. Inside this function, firstly calculate the product of two matrices 'A' and 'B' and store it to matrix 'E'. For each cell of the result matrix 'E', disable automatic pipelining, don't divide the task into smaller tasks and don't parallelize the operations of the task. Also, for the calculations inside the loop where 'E' is assigned, run them in parallel with a limit of 60 processes concurrently.  \nNext, calculate the product of two matrices 'C' and 'D' and store it to matrix 'F' following the same process steps and restrictions in 'E'. However, run the calculations inside the loop where 'F' is assigned in parallel with a limit of 80 processes concurrently instead.  \nFinally, calculate the product of 'E' and 'F' and store it to matrix 'G'. Similarly, disable automatic pipelining, don't divide the task into smaller tasks and don't parallelize the operations of the task for the calculations in 'G'.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a HLS C code for the kernel function named \"kernel_3mm\". The function has nine parameters: five integers (ni, nj, nk, nl, nm), and four 2D double arrays (E, A, B, F, C, D, G). The function should be treated as a hardware kernel for acceleration. The function performs three primary steps: \n1. Multiplies matrices A and B and assigns the result to matrix E. This step is performed without pipelining using a nested loop structure that isn't divided into smaller chunks and does not execute in parallel. Inside the nested loop, compute the row-column product for each element of the results. The computations should not be pipelined, divide, or parallelized.\n2. Multiplies matrices C and D and assigns the result to matrix F. This step is performed without pipelining using a nested loop structure that isn't divided into smaller chunks and does not execute in parallel. Inside, compute the row-column product for each element of the results. The computations should not be pipelined, divide, or parallelized.\n3. Multiplies matrices E and F and assigns the result to matrix G. This step is performed without pipelining using a nested loop structure that isn't divided into smaller chunks and computations do not execute all at once. Instead, only two of them are allowed to run concurrently. Inside, compute the row-column product for each element of the results. The computations should not be pipelined, divide, or parallelized.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a 'kernel_3mm' function that operates on five 2D arrays ('A', 'B', 'C', 'D', and 'E') and three 1D arrays ('ni', 'nj', 'nk'); all of these are input arguments. The function should perform three stages of matrix multiplication operations with different sizes as indicated by the provided integer parameters. It must be treated as a hardware kernel for code acceleration. \n\nIn all stages, process the loops without breaking them into smaller chunks and run their iterations one after the other, providing no parallel acceleration of loop iterations by default. \n\nIn the first stage, compute the result of the multiplication of matrix 'A' and 'B', assigning the result to 'E'. Allow parallel acceleration for the innermost loop with a factor equivalent to the size of 'nk'.\n\nFor the second stage, compute the result of the multiplication of matrix 'C' and 'D', assigning the result to 'F'. Allow parallel acceleration for the innermost looping with a factor equivalent to the size of 'nl'. \n\nFor the final stage, compute the result of the multiplication of matrix 'E' and 'F', assigning the result to 'G'. Allow parallel acceleration for the innermost loop with a factor equivalent to the size of 'nj'. Don't use any pipelining for all stages.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function called 'kernel_3mm' with parameters 'ni', 'nj', 'nk', 'nl', 'nm' and 7 matrices 'E', 'A', 'B', 'F', 'C', 'D', and 'G'. This function will be recognized as a hardware kernel for acceleration. \n\nThe function will execute three separate matrix multiplication operations. For each operation, ensure that iterations of outer and middle loop are run sequentially but not parallelized or broken into smaller chunks by using pragma statements. However, the innermost loops can be parallelized with factors 60, 80 and 1 respectively. \n\nFor the last matrix multiplication operation, also flatten the sequence of the computations in the outer loop to optimize scheduling.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write an HLS C function named \"kernel_3mm\" that has the format '#pragma ACCEL kernel', signifying that it's to be treated as a hardware kernel for acceleration. This function should take as inputs integer variables: \"ni\", \"nj\", \"nk\", \"nl\", \"nm\" and double arrays \"E[40][50]\", \"A[40][60]\", \"B[60][50]\", \"F[50][70]\", \"C[50][80]\", \"D[80][70]\", \"G[40][70]\". Inside this function, define integer variables \"i\", \"j\", and \"k\". Then, compute the matrix multiplication of \"A\" and \"B\" to get \"E\", \"C\" and \"D\" to get \"F\", and \"E\" and \"F\" to get \"G\". For each loop, use '#pragma ACCEL PIPELINE auto{off}' to indicate that they should not be automatically pipelined, '#pragma ACCEL TILE FACTOR=auto{1}' to keep loops in their original form and '#pragma ACCEL PARALLEL FACTOR=auto{1}' to run iterations one after another, not in parallel. Use '#pragma ACCEL PARALLEL FACTOR=auto{8}' to allow eight concurrent iterations of the innermost loop for the last matrix multiplication.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Implement a function named 'kernel_3mm' that performs operations on several 2-dimensional arrays. The function should take 5 integer parameters 'ni', 'nj', 'nk', 'nl', 'nm' and 6 double 2-dimensional arrays 'E', 'A', 'B', 'F', 'C', 'D', 'G'. Treat this function as a hardware kernel for acceleration. Inside the function, you'll perform three matrix-multiplication operations: 'E' equal to 'A' times 'B', 'F' equal to 'C' times 'D', and 'G' equal to 'E' times 'F'. \n\nFor each operation, you'll use 3 nested loops where the iteration of outer loops shouldn't be pipelined or parallelized, and should run in its original, full form without breaking it into smaller chunks. For the innermost loop while calculating 'E' and 'F', run iterations of the loop in parallel with an auto factor of '60' and '80' respectively, but for 'G' use an auto factor of '50'.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function that executes three nested loops for matrix multiplications. You will name the function 'kernel_3mm' and set it for hardware acceleration using the '#pragma ACCEL kernel' tag. \n\nThe body of the function will explicitly execute three procedures:\n\n1. The first procedure multiplies matrix A and B to form matrix E. Run these iterations in their full form without breaking them into smaller chunks and adjust loop tiling and parallelism factors to 1. Also, ensure that each iteration is processed serially, not in parallel.\n\n2. The second procedure multiplies matrix C and D to give matrix F. Follow the same scenario as with the previous procedure, but for the innermost loop, set parallelism factor to 10 to allow parallel execution of each iteration.\n\n3. The last procedure multiplies matrix E and F to provide G. Set the parallelism factor and tiling factor to 1 to ensure that each iteration is run in its full form and in a sequential manner. Use '#pragma ACCEL PIPELINE auto{flatten}' to execute these loops in a one-dimensional, flat structure.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware accelerated kernel function named 'kernel_3mm'. The function takes in nine parameters: five integers (ni, nj, nk, nl, nm), and four two-dimensional double arrays (E[40][50], A[40][60], B[60][50], F[50][70], C[50][80], D[80][70], G[40][70]). \n\nFirst, turn off the default dataflow optimization strategy using '#pragma ACCEL PIPELINE auto{off}', and ensure that the loops process data in their original form and sequentially (not in parallel) using '#pragma ACCEL TILE FACTOR=auto{1}' and '#pragma ACCEL PARALLEL FACTOR=auto{1}' before every loop.\n\nFor each loop, calculate the multiplication of two arrays in the third loop with flattening the loop structure with '#pragma ACCEL PIPELINE auto{flatten}'. \n\nApply the same process for calculating the matrices E, F, and G. For the last kernel, increase the parallelism factor to '32' to speed up the computation of matrix G. Don't forget to turn off automatic pipeline for a higher optimization level using '#pragma ACCEL PIPELINE auto{off}' before each loop starts.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a hardware-accelerated function named 'kernel_3mm' that takes nine arguments: five integers (ni, nj, nk, nl, nm), and four 2D arrays of doubles (E, A, B, F), which perform the 3 matrix multiplications (A*B = E, C*D = F, E*F = G). The loops shouldn't be automatically pipelined, i.e., '#pragma ACCEL PIPELINE auto{off}', and should be processed in their original form without breaking into smaller chunks, i.e., '#pragma ACCEL TILE FACTOR=auto{1}'. \n\nThe outer and mid loops perform iterations one after the other, not in parallel i.e., '#pragma ACCEL PARALLEL FACTOR=auto{1}', while the inner loops for E, F, G perform in parallel with factors 60, 80, and 50 respectively i.e., \"#pragma ACCEL PARALLEL FACTOR=auto{60}\", \"#pragma ACCEL PARALLEL FACTOR=auto{80}\", and \"#pragma ACCEL PARALLEL FACTOR=auto{50}\".", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a HLS C function named 'kernel_3mm' with the function parameters as given, which will be treated as a hardware kernel for acceleration. In this function, you are going to have three separate blocks of for-loops for different computations, all of which should be pipelined and processed in its original form without breaking them into smaller parts. For the first two blocks using three nested loops for matrix multiplication, ensure the loops run the iterations one after another, not in parallel. While in the third block, run the innermost loop's iterations in parallel by a factor of 8. The computations are as such: First, compute the product of A and B and store the result in E. Secondly, multiply C with D, storing the result in F. Finally, calculate the product of E and F, saving the final result in G.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function with the name 'kernel_3mm' that takes as inputs integers 'ni', 'nj', 'nk', 'nl', and 'nm' alongside six multi-dimensional double arrays 'E', 'A', 'B', 'F', 'C', 'D', and 'G'. This function will serve as a hardware kernel for acceleration. For matrix multiplication, use conventional nested-loops that become multipliers and accumulators without any pipelined optimization or breaking into smaller chunks for parallel running. The outer loops iterate without any optimizations for each process (A*B, C*D, and E*F). In the inner loops, the E[i][j] and F[i][j] will be zeroed, and they will be updated with the result of the matrix multiplication by adding the product of A[i][k] and B[k][j] or C[i][k] and D[k][j], respectively. The operations of these inner-most loops will run in a one-after-the-other manner. For the last process (E*F = G), the same process is followed, but in the deepest nested loop, the operations will be parallelized in hardware with a factor of 32 for enhanced performance.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function called kernel_3mm using the function header provided. This function performs three matrix-matrix multiplications: A and B, C and D and E and F. \n\nThis function will be treated as a hardware kernel for acceleration using '#pragma ACCEL kernel'. Within this function, use '#pragma ACCEL PIPELINE auto{off}' to disable automatic pipelining of the for loops, and '#pragma ACCEL TILE FACTOR=auto{1}' to process for loops fully without breaking them into smaller pieces. \n\nFor the for loops that multiply matrices A and B, and also C and D, use '#pragma ACCEL PARALLEL FACTOR=auto{1}' to run iterations of these loops one after the other, not in parallel. However, when multiplying matrices E and F, set '#pragma ACCEL PARALLEL FACTOR=auto{4}' for the innermost loop for some optimizations.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a function named \"kernel_3mm\" that takes several integer parameters and multi-dimensional array parameters for matrix calculations. The function should be defined as a hardware kernel for acceleration. The function calculates the product of two matrices (A*B and C*D), followed by the final matrix product (E*F). In for-loop sections, disable automatic code pipelining initially, only process the loop in its original, unbroken form, and run the iterations one after another, not in parallel. The nested loops should have auto Pipeline, Factor of 1 for tiling and parallelism except for the innermost loop where parallel factor should be equivalent to the upper bound of the loop. Remember to set all elements of resulting matrices to 0 before performing calculations.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function called \"kernel_3mm\" with parameters ni, nj, nk, nl, nm and six 2D array parameters E, A, B, F, C, D, G of varying dimensions. This function is meant to be accelerated using HLS pragma for computational optimization. The inputs A and B get multiplied to give E, C and D get multiplied to give F, and the products E and F get multiplies to yield G. Process each loop in its original full form without subdividing it into smaller chunks and turn off automatic pipelining. For the first two calculations (E := A*B and F := C*D), run the iterations of the innermost loops in parallel with a parallel factor of 60 and 80 respectively. For the final calculation(G := E*F), flatten the iterations of the outermost loop to improve performance but still run the innermost loop serially without parallel computations.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a C language HLS code with the function header 'void kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])'. First, declare this function as a hardware kernel for acceleration using '#pragma ACCEL kernel'. Then, specify a series of nested loops to perform matrix multiplication operations to calculate elements of matrices E, F and G. Throughout the code, use '#pragma ACCEL PIPELINE auto', '#pragma ACCEL TILE FACTOR=auto{1}', and '#pragma ACCEL PARALLEL FACTOR=auto{1}' to prevent automatic pipelining of loops, make sure the loops are processed in their original form, and to run the iterations of loops consecutively, not in parallel. In the innermost loops use '#pragma ACCEL PARALLEL FACTOR=auto{60}', '#pragma ACCEL PARALLEL FACTOR=auto{80}' and '#pragma ACCEL PARALLEL FACTOR=auto{50}' respectively  during matrix multiplication to run elements calculations in parallel. The ACCEL PARALLEL command with values of 60, 80, and 50 parallelizes the respective inner loops for computing matrix elements.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a function named 'kernel_3mm' in HLS C that takes in 5 dimensions, 'ni', 'nj', 'nk', 'nl', 'nm', and 7 two-dimensional arrays: 'E', 'A', 'B', 'F', 'C', 'D' and 'G'. This function should be treated as a hardware kernel for acceleration. The function will first calculate the product of matrices 'A' & 'B' and store the result in 'E'. The iterations of the loops should be executed one after the other and not in parallel. Additionally, each loop should be processed in its original form without breaking it into smaller parts. Also, loops should not be automatically pipelined.\n\nNext, the function will calculate the product of matrices 'C' & 'D' and store the result in 'F'. The iterations of outer two loops should be run in sequence and without automatic pipelining, but the innermost loop is to be parallelized with a factor of 10.\n\nFinally, the function performs the multiplication of matrices 'E' & 'F' and stores the results in 'G', following the same rules as the first set of loops.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Generate a HLS code for a function header named \"kernel_3mm\" with parameters ni, nj, nk, nl, nm, and six 2D arrays, E, A, B, F, C, D, and G. This function should be accelerated as a hardware kernel. It performs three operations: \"E := A*B\", \"F := C*D\", and \"G := E*F\". For each operation, an outer loop will iterate over one of the dimensions with 'off' pipeline, tiling factor of 1, and parallel factor of 1 implemented. These loops enclose an inner loop with same '#pragma' values except that the parallel factor for the nestedmost loop(s), which performs actual multiplication and accumulation operations on each step, should be auto or generated automatically by the compiler. The parallel factor for calculation of 'E' should be 8, for 'F' should be 1, and for 'G' should be 32. Also use parallel factor of 2 for G's parent inner loop.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Generate C code for a Kernel function called 'kernel_3mm' with integer inputs ni, nj, nk, nl, nm and several double-type 2D matrix inputs E, A, B, F, C, D, and G. The code first calculates matrix multiplication of A and B which is stored in E. For the initialization of E matrix, pipeline the matrix elements, set tile factor to the smallest possible size and allow iterations of the loop to not run in parallel. However, in the nested loop for the multiplication of A and B elements, the parallelization factor should be automatically placed around 30. \n\nNext, perform the matrix multiplication of C and D, storing in F. For F's initialization, like E, set tile factor to the smallest possible size and disable parallel execution of the loop. However, in the nested loop for the multiplication of C and D elements, the parallelization factor should be automatically placed around 20. \n\nFinally, multiply the result matrices E and F and store the product in G. For initializing G set tile factor to the smallest possible size and allow at most two iterations of the loops to run in parallel. However, in the nested loop for the multiplication of E and F elements, a parallelization factor should be automatically placed around 50. \n\nPlease note, the pipelining for outer loops are turned off while the inner loop for the third matrix multiplication is pipelined automatically.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a HLS C function titled \"kernel_3mm\" that performs a 3-matrix multiplication (E = A*B, F = C*D, and G = E*F) where matrix sizes are defined by parameters ni, nj, nk, nl, and nm. This function should be treated as a hardware kernel for acceleration. The loop iterations should not be automatically pipelined, the loops are to be processed without being partitioned into smaller chunks, and the loop iterations are to be run one after the other, not in parallel. For each iteration, calculate the cell values of E, F, and G by multiplying the corresponding cell values of the input matrices (A, B, C, D, E and F respectively) and sum all of the product values to their corresponding positions in the output matrices. Use the respective '#pragma' statements to indicate that the inner loops are to be pipelined, tiles and elements can be executed in parallel but only up to parallel factor of 1, apart from the elements of G matrix where parallel factor can go up to 4.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a HLS C code for a function named 'kernel_3mm' with integer parameters 'ni', 'nj', 'nk', 'nl', 'nm' and 2D array parameters 'E', 'A', 'B', 'F', 'C', 'D', and 'G' which will be used as kernel for hardware acceleration. This function has three stages process. In the first stage, two matrices 'A' and 'B' are multiplied and the result is stored into matrix 'E'. Secondly, matrices 'C' and 'D' are multiplied and stored into matrix 'F'. Finally, matrices 'E' and 'F' are multiplied and the result is saved into 'G'. \n\nIn each stage, use a set of three nested loop where for each loop, pipeline is turned off, the loop is processed in its original form without transforming into smaller chunks utilizing #pragma ACCEL TILE FACTOR=1, and iterations will be run one after the other, not in parallel using #pragma ACCEL PARALLEL FACTOR=1, except in the second stage, where the pipeline is set to flatten meaning to merge loop levels into one pipeline loop for optimisation.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a function named 'kernel_3mm' which takes in nine parameters: five integers namely 'ni', 'nj', 'nk', 'nl', 'nm' and four multidimensional arrays of double 'E', 'A', 'B', 'F', 'C', 'D', 'G' of sizes [40][50], [40][60], [60][50], [50][70], [50][80], [80][70], [40][70] respectively. The function is identified as a hardware kernel for acceleration using '#pragma ACCEL kernel'. Inside the function, initialize integer variables 'i', 'j', 'k'. The function should compute 'E' as a product of 'A' and 'B', 'F' as a product of 'C' and 'D', and 'G' as a product of 'E' and 'F'. Each 'for' loop should not be automatically pipelined using '#pragma ACCEL PIPELINE auto{off}', should be processed in its full form using '#pragma ACCEL TILE FACTOR=auto{1}' and the iterations should run sequentially using '#pragma ACCEL PARALLEL FACTOR=auto{1}'. For the innermost 'for' loop in 'E' and 'F' computations, allow parallel factor of 60 and 80 respectively using '#pragma ACCEL PARALLEL FACTOR=auto{60}' and '#pragma ACCEL PARALLEL FACTOR=auto{80}'. Lastly, in computing 'G', hint the tool to analyze and flatten the nested loop using '#pragma ACCEL PIPELINE auto{flatten}' and allow parallelism of factor two for the second 'for' loop using '#pragma ACCEL PARALLEL FACTOR=auto{2}'.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create the function `kernel_3mm` which accepts nine arguments: five integers (`ni`,`nj`,`nk`,`nl`, and `nm`) and four two-dimensional double arrays (`E`,`A`,`B`,`F`,`C`,`D`, and `G`). This function will perform three matrix multiplications (`E=A*B`, `F=C*D`, `G=E*F`) in succession. For each loop employed in the matrix multiplication do not pipeline the loop automatically, execute each iteration one after the other, and keep the loop in its original form without division. Apply these constraints using the `#pragma ACCEL` directives with the properties `PIPELINE`, `TILE FACTOR` and `PARALLEL FACTOR` set to `auto{off}, auto{1} and auto{1}` respectively. However, for the last k-loops in calculating G, let the iterations run 50 at a time concurrently. Make sure to denote the function as a hardware acceleration kernel with `#pragma ACCEL kernel`.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Provide instructions to write a C function named 'kernel_3mm'. The function should be denoted as a hardware kernel for acceleration, taking nine parameters: five integers 'ni','nj','nk','nl','nm', and four double 2D arrays 'E', 'A', 'B', 'F', 'C', 'D', 'G'. Implement three matrix multiplications with nested for-loops: E = A * B, F = C * D, G = E * F where E, A, B, F, C, D, G are matrices. For all loops, instruct the hardware accelerator not to pipeline loops, process the loops in their original form, and run the iterations sequentially. The only exception is the last k-loop for G[i][j] which should have parallelism factor 50 applied for simultaneous iterations. Variable 'E' should be calculated first by multiplying 'A' and 'B', followed by 'F' which is calculated by multiplying 'C' and 'D'. Variable 'G' is calculated lastly by multiplying the results obtained from 'E' and 'F'.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function named 'kernel_3mm' treating as a hardware kernel for acceleration in which three main operations E := A*B, F := C*D, and G := E*F are performed on specified input arrays. In each operation, loops are used to go through the arrays and multiply the elements. For each loop process, ensure they are not automatically pipelined, run consecutively on the complete array rather than breaking it into smaller chunks ('#pragma ACCEL PIPELINE auto{off}', '#pragma ACCEL TILE FACTOR=auto{1}', '#pragma ACCEL PARALLEL FACTOR=auto{1}') respectively. Also, note that in the parallel factors for the nested loops in F := C*D and G := E*F, 10 and 2 respectively are used.\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a HLS C function called 'kernel_3mm' which will take as input two sets of integer parameters, namely 'ni', 'nj', 'nk', 'nl', and 'nm', and also six 2D arrays of double type: 'E', 'A', 'B', 'F', 'C', 'D', and 'G'. This function should be treated as a hardware kernel for FPGA acceleration. The function should perform three primary matrix multiplications: E = A*B, F = C*D, and G = E*F. Each of these operations should be encapsulated within three separate for-loop structures respectively. \n\nFor the matrix multiplication E = A*B: The outer loops should not be pipelined, should be processed in their original form, and their iterations should be run one after the other, not in parallel, both implemented by using #pragma ACCEL PIPELINE auto{off}, #pragma ACCEL TILE FACTOR=auto{1} and #pragma ACCEL PARALLEL FACTOR=auto{1} respectively. The innermost loop should be run in parallel with a factor of 32 by using #pragma ACCEL PARALLEL FACTOR=auto{32}.\n\nFor the second matrix multiplication F = C*D: Similar to the previous case, the outer loops should use #pragma ACCEL PIPELINE auto{off}, #pragma ACCEL TILE FACTOR=auto{1} and #pragma ACCEL PARALLEL FACTOR=auto{1} to prevent pipeline, breaking into smaller chunks, and parallel execution. However, the innermost loop should be run in parallel with a factor of 80 by using #pragma ACCEL PARALLEL FACTOR=auto{80}.\n\nFor the final matrix multiplication G = E*F: The outer loops should not be pipelined and processed in their original form, and their iterations should be run one after the other, not in parallel, implemented by using #pragma ACCEL PIPELINE auto{off}, #pragma ACCEL TILE FACTOR=auto{1} and #pragma ACCEL PARALLEL FACTOR=auto{1} respectively. In this case, despite the pipeline instruction given at the outermost loop level is not to pipeline, the second level of nested loops should be flattened out to broaden the potential for parallelism, implemented by using #pragma ACCEL PIPELINE auto{flatten}. However, iterations of the innermost loop should be run one after the other, not in parallel by using #pragma ACCEL PARALLEL FACTOR=auto{1}.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware-accelerated function named \"kernel_3mm\" that takes in seven parameters: five integers (ni, nj, nk, nl, nm) and six two-dimensional arrays (E[40][50], A[40][60], B[60][50], F[50][70], C[50][80], D[80][70], G[40][70]). \n\nStart by processing the multiplication of array A with array B and store the result in array E. Run the outer loop iterations in sequential order (not in parallel). Make sure to process each of these outer loops in their original, full form without breaking into smaller chunks. \n\nSubsequently inside the loop initialize the array E indices with zero and for each of these zeroed indices, run a parallel loop (with parallel factor as 60) to multiply elements of array A and B and accumulate the result back to these indices of array E. Follow a similar processing pattern for the multiplication of arrays C and D with the result stored in array F.\n\nFinally, for the multiplication of array E with array F whose result is stored in array G, make sure to process each of these outer loops in their original, full form without breaking into smaller chunks and run the iterations of these outer loops not fully in parallel. \n\nFor each of these zeroed indices of array G, run a parallel loop (with parallel factor as 50) to multiply elements of arrays E and F and accumulate it back to these indices of array G.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function designed for hardware acceleration named 'kernel_3mm' with the arguments as five integers: ni, nj, nk, nl, nm and seven double 2D arrays: E, A, B, F, C, D, G. The function should follow the pattern: not pipeline the loop automatically, process the loop in original without breaking it into chunks, and run the loop iterations one after the other not parallel. Iterate through the loop for calculating the matrix multiplication of A and B and store the result in E without breaking the loops into smaller sections. Continue to another loop calculating the matrix multiplication of C and D, storing the result in F with less parallelization than the previous loop. Finally, implement a third loop calculating the matrix multiplication of E and F, storing the result in G but reducing parallelization further.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware acceleration kernel function 'kernel_3mm' with input parameters indicating the dimensions of multi-dimensional arrays E, A, B, F, C, D, and G. \n\nThere are three major cycles: E = A*B, F= C*D and G= E*F. *Do not pipeline these cycles.*\n\nIn each cycle, start iterations sequentially, without dividing the loop into smaller parts utilizing 'TILE' and 'PARALLEL' pragmas with factor being 1. \n\nIn the second section, pipeline the nested loop versions, but disable pipelining for the outer loops.\n\nIn the third section, execute parallel iterations for the innermost loop with a maximum parallelization factor of 5. However, disallow pipelining of the outer loops and do not break them down into smaller chunks.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a C function named 'kernel_3mm' that is treated as a hardware kernel for acceleration. This function should take nine arguments: five integers named ni, nj, nk, nl, nm, and four 2D double arrays, E, A, B, F, C, D, G. Within this function, perform three major operations: \"E := A*B\", \"F := C*D\", and \"G := E*F\". For each operation, process the loop in its original, full form without breaking it into smaller chunks, and run the iterations of the loop one after the other, not in parallel. Don't automatically pipeline these loops. For \"E := A*B\" multiplication, loop through i from 0 to 40, through j from 0 to 50 and through k from 0 to 60. For \"F := C*D\", loop through i from 0 to 50, through j from 0 to 70 and through k from 0 to 80. Lastly for \"G := E*F\" multiplication, loop through i from 0 to 40, through j from 0 to 70 and through k from 0 to 50. Use the specific #pragma values as indicated in the code snippet.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function named 'kernel_3mm' which is treated as a hardware kernel for acceleration. This takes as parameters several integer variables (ni, nj, nk, nl, nm) and multiple 2D arrays (E, A, B, F, C, D, G). Inside this function, there are three main operations: first, E as the product matrix of matrix A and B, then F as the product matrix of C and D, and finally, G as the product matrix of E and F. Use \"#pragma ACCEL PIPELINE auto{off}\", \"#pragma ACCEL TILE FACTOR=auto{1}\", and \"#pragma ACCEL PARALLEL FACTOR=auto{1}\" before the outer loops and also inside each outer loop to prevent automatic pipeline, not allowing the loop to be broken into smaller chunks and to run iterations one after the other, not in parallel respectively. Lastly, use \"#pragma ACCEL PARALLEL FACTOR=auto{60}\", \"#pragma ACCEL PARALLEL FACTOR=auto{80}\", and \"#pragma ACCEL PARALLEL FACTOR=auto{50}\" in the third layers of loops to allow iterations to be done concurrently in the respective loop blocks.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a HLS C function called 'kernel_3mm' that will be treated as a hardware acceleration kernel. The function takes in several integer arguments (ni,nj,nk,nl,nm) and multiple double arrays (E, A, B, F, C, D and G). The function will primarily perform three operations; E=A*B, F=C*D, and G=E*F. For all three cases, the outermost two loops should not be automatically pipelined, should run in their original form without being broken into smaller chunks and should have their iterations run one after the other, meaning their pipeline, tile factor, and parallel factor pragmas will be off, 1, and 1, respectively. On the other hand, the innermost loop in the 'E=A*B', 'F=C*D' parts should have 32 iterations running in parallel whereas for the 'G=E*F' part, the immediate inner loop and the innermost loop should have 4 and 10 parallel iterations respectively.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware-accelerated kernel function named 'kernel_3mm' with nine parameters- five integers representing matrix sizes (ni, nj, nk, nl, nm) and four two-dimensional arrays of double numerical types (E, A, B, F, C, D, G). The function performs the operations A*B and C*D storing the intermediate results in two-dimensional array E and F respectively. Lastly, it performs E*F and stores the result in two-dimensional array G. All loops should not be automatically pipelined and they should be processed in their original, full form without breaking them into smaller chunks by using '#pragma ACCEL TILE FACTOR=auto{1}'. In the inner loops, the third inner loop is treated differently. For the first loop E[i][j] += A[i][k] * B[k][j], the iterations should run parallel for 60 times at once, for the second loop F[i][j] += C[i][k] * D[k][j] the iterations should not run in parallel as indicated by '#pragma ACCEL PARALLEL FACTOR=auto{1}', and for the third loop G[i][j] += E[i][k] * F[k][j] the iterations should run parallel for 50 times at once. These '#pragma ACCEL PARALLEL FACTOR' values indicate how parallel the loop should be processed.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Define a hardware acceleration kernel `kernel_3mm` taking dimensions `ni, nj, nk, nl, nm` and matrices `E, A, B, F, C, D, G` as parameters. The function accomplishes triple matrix multiplication. First, it calculates `E` by multiplying `A` and `B`. Second, it calculates `F` by multiplying `C` and `D`. Lastly, it calculates `G` by multiplying `E` and `F`. For each step of multiplication, do not pipeline the outermost loop automatically, avoid breaking it into smaller chunks, and also do not run its iterations in parallel. Within the inner loop, calculate each cell's value, where on the innermost loop (for calculating `E` & `F` cells' value), parallelize it with auto depth, and for `G` cells, parallelize it with a dynamic depth based on the runtime environment.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Design a HLS kernel function called `kernel_3mm` that takes as inputs integer parameters ni, nj, nk, nl, nm and six 2D arrays of doubles (E, A, B, F, C, D, G), which will be used to perform three matrix multiplications (E=A*B, F=C*D, G=E*F). For each individual multiplication operation (each of the three loops), apply the following #pragma directives: don't automatically pipeline this loop (ACCEL PIPELINE auto{off}), process this loop in its original, full form without breaking it into smaller chunks (ACCEL TILE FACTOR=auto{1} ), run the iterations of this loop one after the other, not in parallel (ACCEL PARALLEL FACTOR=auto{1} for first and second operation, and auto{2} for third operation). Do change the parallel factor in the innermost sub-loop according to the dimension of outer loop's iterating variable (ACCEL PARALLEL FACTOR=auto{60} for E=A*B, ACCEL PARALLEL FACTOR=auto{80} for F=C*D and ACCEL PARALLEL FACTOR=auto{50} for G=E*F).", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function called 'kernel_3mm', which is recognized as a hardware acceleration kernel by '#pragma ACCEL kernel'. This function takes in 7 parameters: 5 integer parameters ni, nj, nk, nl, nm, and 2 two-dimensional arrays 'E' and 'A' with sizes [40][50] and [40][60]. The function also inputs a [60][50] array 'B', the matrices 'F' [50][70], 'C' [50][80], 'D' [80][70] and 'G' [40][70]. It performs 3 matrix multiplications: 'E = A * B', 'F = C * D' and 'G = E * F', in that order. Within the loops for these matrix multiplications, use '#pragma ACCEL PIPELINE auto{off}', '#pragma ACCEL TILE FACTOR=auto{1}', and '#pragma ACCEL PARALLEL FACTOR=auto{1}' to instruct the compiler not to automatically pipeline this loop and process this loop in its original, full form without breaking it into smaller chunks and run the iterations one after the other, not in parallel. Use '#pragma ACCEL PARALLEL FACTOR=auto{60}', '#pragma ACCEL PARALLEL FACTOR=auto{1}', and '#pragma ACCEL PARALLEL FACTOR=auto{50}' for parallel processing within specific loops depending on required conditions.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function named 'kernel_3mm' with specific parameters such as ni, nj, nk, nl, nm and six arrays as input. This function will be treated as a hardware kernel for acceleration. Inside the function, there are three major tasks representing matrix multiplications: E equals A times B, F equals C times D, and G equals E times F. For each task, use 'ACCEL PIPELINE auto flatten', 'ACCEL TILE FACTOR auto 1', and 'ACCEL PARALLEL FACTOR auto 1' declarations at start, turn off automatic pipelining and set the 'ACCEL TILE FACTOR' and 'ACCEL PARALLEL FACTOR' to auto 1 again before entering nested loops. Inside the nested loops, initialize each element of the resulting matrices E, F, G to zero and then compute the element's value in a third nested loop, for the third nested loop use 'ACCEL PARALLEL FACTOR auto 1' in the first and third major task and 'ACCEL PARALLEL FACTOR auto 10' in the second major task.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a high-level synthesis code in C, inside a function named 'kernel_3mm' with integer parameters 'ni', 'nj', 'nk', 'nl', 'nm', and matrix parameters 'E', 'A', 'B', 'F', 'C', 'D', 'G'.  The function should be treated as a hardware kernel for acceleration, and include three computation sections: section one multiplies matrices 'A' and 'B' and assigns the result to matrix 'E'; section two multiplies matrices 'C' and 'D' and assigns the result to matrix 'F'; section three multiplies matrices 'E' and 'F' and assigns the result to matrix 'G'. \n\nFor each section, the outer loops should not be auto-pipelined or auto-tiled, and not run in parallel. For innermost computations, enforce a parallelism factor of 32 for the first two sections, and 10 for the third one.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a C code for a function called 'kernel_3mm', which will perform operations on multiple two-dimensional arrays. This function will take seven parameters: five integers (ni, nj, nk, nl, nm) and seven 2D double arrays (A, B, E, C, D, F, G). Declare this function as a hardware kernel for acceleration with '#pragma ACCEL kernel'. \n\nThis function consists of three major sections where matrix multiplications are performed. Each section needs to be executed in the auto flatten mode with no pipelining to ensure correct sequential order of calculations, and the parallel factor with the value specified in each section.\n\n1) Use '#pragma ACCEL PIPELINE auto{flatten}', '#pragma ACCEL TILE FACTOR=auto{1}', and '#pragma ACCEL PARALLEL FACTOR=auto{1}' before the for loop starting with 'for (i = 0; i < 40; i++)'. This for loop goes through matrix multiplication between matrices A and B to result in E.\n\n2) Before the for loop starting with 'for (i = 0; i < 50; i++)', use the same pragma statements with the same values as step 1. This for loop conducts matrix multiplication between matrices C and D to result in F.\n\n3) Just like previous parts, before the for loop starting with 'for (i = 0; i < 40; i++)', use the pragma statements with the same values as step 1 and 2. This loop calculates the matrix multiplication between matrices E and F to result in G. However, for the innermost loop, set the parallel factor as '#pragma ACCEL PARALLEL FACTOR=auto{4}' to allow parallel computation of four iterations at a time.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function named 'kernel_3mm' that will act as a hardware kernel for acceleration. The function will have nine parameters: five integer parameters 'ni', 'nj', 'nk', 'nl', 'nm' and four double 2D array parameters 'E', 'A', 'B', 'F', 'C', 'D', 'G'. Inside the function, you will have to create three loops to perform matrix operations. \n\nFor the first loop, disable automatic pipelining and treat the loop as if it was to be processed in its original form, also make sure that the iterations don't execute in parallel. In the nested loop, follow the same process. However, the innermost loop should have iterations running in parallel.\n\nThe same pattern is used for the second loop as the first, but also implement flatten pipelining for the nested loop.\n\nFor the final loop, disable automatic pipelining and process the loop in its original form but allow the iterations to execute in parallel by two. In the nested loop, again execute the iterations in parallel by thirty-two.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The task is to generate a C function named 'kernel_3mm' which is handled as a hardware kernel for acceleration. The function accepts as parameters 5 integer values ni, nj, nk, nl, nm and 7 double 2D arrays E, A, B, F, C, D, G. \nInside the function, set loop pipelines to be evaluated in their full form sequentially, not in parallel nor in smaller, broken down parts, using '#pragma ACCEL PIPELINE auto{off}', '#pragma ACCEL TILE FACTOR=auto{1}', and '#pragma ACCEL PARALLEL FACTOR=auto{1}' respectively.\nPerform matrix multiplications A*B, C*D, E*F and store each result in E, F, G respectively. However, for the last iterations inside the two inner loops of each multiplication, run them in parallel with factors of 1, 10, and 16 for E, F, G calculations respectively.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Implement a C function titled 'kernel_3mm' with the specified parameters and matrix variables that will be treated as a hardware kernel for acceleration with the pragma directive 'ACCEL kernel'. This function performs three distinct matrix multiplication operations: E = A*B, F= C*D, and G = E*F. These operations are executed in three controlled loops where the outer loops are not automatically pipelined and are processed in their original iterations one after the other without breaking them into smaller chunks as denoted by 'PIPELINE auto{off}', 'TILE FACTOR=auto{1}', and 'PARALLEL FACTOR=auto{1}'. For each operation, establish an inner loop that: sets every resulting matrix (E,F,G) element to 0.0; then performs the multiplication operation for each corresponding element in the input matrices. In the inner loop for the multiplication operations, allow parallel computing up to iteration factors of 60, 80, and 50, respectively.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a kernel function 'kernel_3mm' with input parameters of 5 integers 'ni', 'nj', 'nk', 'nl', 'nm' and six 2D arrays 'E', 'A', 'B', 'F', 'C', 'D', 'G'. The function includes three main operations: computing 'E' as the product of 'A' and 'B', 'F' as the product of 'C' and 'D', and 'G' as the product of 'E' and 'F'. Ensure that these loops are not automatically pipelined and that iterations of these loops run one after the other, not in parallel by using '#pragma ACCEL PIPELINE auto{off}', '#pragma ACCEL TILE FACTOR=auto{1}', and '#pragma ACCEL PARALLEL FACTOR=auto{1}'. Also, in loops where 'k' is the iterator, use '#pragma ACCEL PARALLEL FACTOR' for running iterations of these loops in parallel and set the factor to be the last dimension of the array used in the calculation, 'auto{60}', 'auto{80}' and 'auto{50}', respectively in the 3 operations.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware acceleration kernel function named 'kernel_3mm' with specified parameters integer types ni, nj, nk, nl, nm, and double 2D arrays E, A, B, F, C, D, and G. There are three main blocks of code in this function that involve performing matrix multiplications. \n\nFor the first block 'E := A*B', run it in its original form, not separated into smaller chunks or parallelized. Initiate a nested loop structure, denoting all loop variables by 'i' and 'j'. Set 'E[i][j]' to 0.0 before another loop with 'k' as the variable to accumulate the multiplication results of 'A[i][k]' and 'B[k][j]' to 'E[i][j]'.  \n\nSimilarly, for the second block 'F := C*D', copy the same format and operations as in the first block using the arrays C and D and storing the result in F. \n\nFinally, for the third block 'G := E*F, repeat the same process but use a parallel factor of 50 in the end inner loop. This will cause different iterations of the loop to be executed in parallel, allowing for multiple 'G[i][j]' updates to be computed at a time for different values of 'k'. The result in G is simultaneously dependent on 50 other results that are being calculated in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write an HLS kernel function called 'kernel_3mm', passing 7 matrices E, A, B, F, C, D, G and five integers ni, nj, nk, nl, nm as parameters. Inside the function, define integer variables i, j, k. This function follows three main processes: calculating matrix A*B and storing the result in matrix E, calculating matrix C*D and storing the result in matrix F, and finally calculating E*F and storing the result in matrix G. Use two levels of for-loops for each calculation and add the #pragma directives to manage the execution of the code in the hardware, such as disabling pipelining for the outer for-loop using 'ACCEL PIPELINE off' and leaving it on automatic mode for the inner loop using 'ACCEL PIPELINE auto'. Also, include directives for the execution of the loops to be done one iteration at a time using 'ACCEL TILE FACTOR=1' and 'ACCEL PARALLEL FACTOR=1', allow maximum parallelism for the calculation of A*B and C*D update in the innermost for-loop using 'ACCEL PARALLEL FACTOR=60' and 'ACCEL PARALLEL FACTOR=80' respectively. For the last calculation set 'ACCEL PIPELINE auto{flatten}' to combine the nested loops together at the hardware level for efficient pipelining and 'ACCEL PARALLEL FACTOR=4' to achieve some level of parallelism.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create an accelerated hardware kernel called kernel_3mm, which takes in integers 'ni', 'nj', 'nk', 'nl' and 'nm' and multidimensional arrays 'E', 'A', 'B', 'F', 'C', 'D' and 'G'. The kernel will perform a series of matrix multiplication operations. First, disable the automatic pipelining and parallel execution, and don't break the loops into smaller chunks. Then, a nested loop is run to multiply matrices 'A' and 'B' and store the result in 'E'. Do the same operation for matrices 'C' and 'D', storing the result in 'F'. Finally, perform the same operation for matrices 'E' and 'F', storing the result in 'G', but in this case, you'll change the #pragma ACCEL PARALLEL FACTOR value to auto{50} in order to adjust the parallelisation of the third and last loop.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a C function named `kernel_3mm` that performs matrix manipulations on six 2D double arrays and uses HLS pragmas for optimization. The function should accept seven parameters: five integers `ni`, `nj`, `nk`, `nl` and `nm`, and six 2D double arrays `E`, `A`, `B`, `F`, `C`, `D` and `G`. \n\nFirst, the function should compute the product of matrices `A` and `B` storing the result in matrix `E`. During this computation, ensure the associated loops do not run in parallel or get pipelined and should be processed in its original form without breaking it into smaller chunks. Furthermore, the inner-most loop iterating for the matrix multiplication should process in parallel with a factor of `60`.\n\nThen, the function should compute the product of matrices `C` and `D`, storing the result in matrix `F`. Similar to the previous computation, ensure the loops do not get pipelined, processed in its original form and do not run in parallel. The inner-most loop for matrix multiplication should run in parallel with a factor of `80`.\n\nLastly, the product of matrices `E` and `F` should be calculated and stored in matrix `G`. During this computation, the loops should not be automatically pipelined and should not be broken into smaller chunks. The outer loop should not run in parallel, while the inner loop should process in parallel with a factor of `50`.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a block of HLS C code that declares a function called kernel_3mm with the following parameters: int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70]. The function will be treated as a hardware kernel, which is expressed using '#pragma ACCEL kernel'. The function executes three matrix multiplication operations: E = A*B, F = C*D, and G = E*F. For each operation, use loops to iterate through each index, with the ACCEL PIPELINE set to 'off' to avoid automatic pipelining and the TILE FACTOR set to 1 to process the loop as a whole. Also, set the PARALLEL FACTOR to 1 to prevent parallel execution of loop iterations, except in the third operation where it should be 5 for the outer loop and 8 for the inner loop. These pragma directives optimize the hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a HLS code for an accelerator kernel function named 'kernel_3mm'. This function should take nine parameters: five integers (ni, nj, nk, nl, nm) and four 2D arrays of doubles (E[40][50],A[40][60],B[60][50],F[50][70],C[50][80],D[80][70],G[40][70]). The function process includes three main parts: calculating E as the product of A and B, calculating F as the product of C and D, and calculating G as the product of E and F.\n\nIn each part, use '#pragma ACCEL PIPELINE' to manage the code execution pipeline. Initially, turn off automatic pipelining with '#pragma ACCEL PIPELINE auto{off}' and then use '#pragma ACCEL PIPELINE auto{}' in the inner loop for E and F, and '#pragma ACCEL PIPELINE auto{flatten}' for G. Use '#pragma ACCEL TILE FACTOR=auto{1}' to process the loop in its original form without breaking it into smaller chunks.\n\nAdditionally, use '#pragma ACCEL PARALLEL FACTOR' to manage the parallel execution of iterations. Initially, run the iterations one after the other, not in parallel, with '#pragma ACCEL PARALLEL FACTOR=auto{1}' and then increase parallelism on the innermost loop of each part with '#pragma ACCEL PARALLEL FACTOR=auto{60}' for E, '#pragma ACCEL PARALLEL FACTOR=auto{16}' for F, and '#pragma ACCEL PARALLEL FACTOR=auto{1}' for G.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware-accelerated kernel function named 'kernel_3mm'. This function receives several 2D arrays and integer values as parameters. The function contains multiple loops intended for matrix multiplication. Firstly, declare the function as a hardware-accelerated kernel using '#pragma ACCEL kernel'. Within the function, we have multiple loops. Each loop's goal is to perform a matrix multiplication operation and update the elements of a matrix. The loops are preceded by the pragma directives '#pragma ACCEL PIPELINE auto{off}', '#pragma ACCEL TILE FACTOR=auto{1}', and '#pragma ACCEL PARALLEL FACTOR=auto{1}' to signify that we don't want automatic pipeline, that we want to process loops in their original forms and run the iterations of the loops sequentially instead of parallelly. Later, inside the loop for calculating each element of the new matrix, we use '#pragma ACCEL PARALLEL FACTOR=auto{32}' to run 32 iterations of this innermost loop in parallel. Apply the same series of acts for each matrix multiplication operation i.e., 'E := A*B', 'F := C*D' and 'G := E*F', changing the parallel factors as desired. At the end, all the results of the multiplications are stored respectively in the arrays E, F, and G.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Generate a function named `kernel_3mm` that accepts five 2D arrays `E`, `A`, `B`, `F`, `C`, `D`, `G` and five integers, `ni`, `nj`, `nk`, `nl`, `nm` as parameters. Designate this function as a hardware kernel for acceleration. In this function, there are three matrix multiplication operations. In the first and second, do not automatically pipeline the loop, avoid breaking them into smaller parts, and run their iterations one after another, not in parallel. Specially in the innermost loop, allow 60 and 80 iterations to run in parallel for the first and second multiplication operation respectively. \n\nFor the third matrix multiplication operation, again do not automatically pipeline and tile the outermost loop. Conduct up to four iterations of the second loop in parallel but the last loop should be run in sequential order. Additionally, flatten the pipeline of the second loop to execute the iterations concurrently where possible.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function named 'kernel_3mm' designated as a hardware acceleration kernel. This function should receive nine parameters: five integers, and four 2D arrays. The function should be composed of three major loops: the first loop calculates the matrix multiplication of A and B and stores the result in E. The second loop computes the multiplication of C and D and stores the final value in F. Lastly, the third loop calculates the multiplication of E and F and stores the outcome in G.\n\nFor each of these loops, set the corresponding pragma values as below: \n\n- Switch off the automatic pipelining process with '#pragma ACCEL PIPELINE auto{off}', \n- Process each loop in its original form without breaking it into smaller chunks with '#pragma ACCEL TILE FACTOR=auto{1}',\n- Run all iterations of this loop one after the other, not in parallel (unless specified otherwise for sub-loops), with '#pragma ACCEL PARALLEL FACTOR=auto{1}'. \n\nFor the sub-loops where the calculation of matrices E, F and G are made, the parallel factor value vary: it's 60 for the computation of E, 80 for F and 50 for G respectively. Make sure you update these values correctly in the corresponding sub-loops with '#pragma ACCEL PARALLEL FACTOR=auto{value}' directive.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a HLS C code structured as a kernel function named 'kernel_3mm' that accepts the dimensions (ni, nj, nk, nl, nm) and double type 2D arrays (E, A, B, F, C, D, G). It performs three matrix multiplications: A*B into E, C*D into F, and E*F into G. For each matrix multiplication process, three nested for-loops are coded with i,j,k as loop variables. Instruct the compiler not to automatically pipeline these loops, to process the loops in their original form without dividing them into smaller parts, and to run the iterations of the loops one after another not in parallel, by using pragma values ACCEL PIPELINE auto{off}, ACCEL TILE FACTOR=auto{1}, ACCEL PARALLEL FACTOR=auto{1} respectively. The intermediate arrays E and F are first initialized to 0.0 before the multiplication sum is accumulated. In the final multiplication of E*F into G, the innermost loop (k-loop) is allowed to have some degree of parallelism with ACCEL PARALLEL FACTOR=auto{2}.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a HLS C code that treats the function \"kernel_3mm\" as a hardware kernel for acceleration. This function takes nine parameters: five integers ni, nj, nk, nl, nm, and four 2-dimensional double arrays E, A, B, F, C, D, G. The function performs three matrix multiplications step-by-step: AxB, CxD, and ExF, and stores the results in E, F, and G respectively. Each step uses three nested for loops for computation, and the process of each step will be separated using pipeline pragmas to optimize operation sequence, tile pragmas to partition data in memory, and parallel pragmas to allow parallel execution. The specific pragmas used should be as follows: for outer loop iterations optimize operation sequences automatically, tile data blocks automatically favoring a block size of 40, and execute loop iterations sequentially, but should process inner loop iterations one after the other without pipelining, breaking them into smaller chunks, or parallelising. Lastly, make sure the pragmas apply to the nested loops to execute the matrix multiplications.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{40}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a kernel function named 'kernel_3mm'. Define as per the function signature including arrays E, A, B, F, C, D, G of specified sizes. Then, perform matrix multiplication A*B and store it in E. During this process, make sure loops are not pipelined automatically, run in their original form, and process iterations sequentially, not in parallel. Similarly, perform matrix multiplication C*D and store the result in F, here while executing second innermost loop use parallel factor as 2. Lastly, perform matrix multiplication E*F and store it in G. Again, ensure that loops aren't pipelined automatically, they run in the original form, and their iterations are processed one after the other. In each case, respective #pragma values must be used for proper execution.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function called 'kernel_3mm' that takes in a set of dimensions (ni,nj,nk,nl,nm) and 2D arrays (E,A,B,F,C,D,G), designated for computation in an FPGA environment. The function is to carry out a sequence of matrix multiplications.\n\nFor the first task, perform matrix multiplication operation between A and B to produce E. Request the HLS compiler to process this loop using the pragma factors \"PIPELINE off\", \"TILE FACTOR=1\", and \"PARALLEL FACTOR=1\", which means the loop won't be auto-pipelined, it won't be partitioned, and its iterations will not run in parallel. These steps should be repeated for each inner loop.\n\nIn the second task, you should multiply matrix C with matrix D to produce matrix F, repeating the same pragma directives used in the first task. \n\nThe third task involves another matrix multiplication generating matrix G from E and F. However, in this stage, you should use \"PARALLEL FACTOR=auto{5}\" for the second loop to allow for limited parallelization, and \"PARALLEL FACTOR=auto{16}\" for the innermost loop to allow for even more parallelization of the computation.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Construct a HLS kernel function referred to as 'kernel_3mm' with the given parameters and array arguments. The function's main duty is to execute the process of E = A*B, F = C*D, and G = E*F, in that order. Begin by setting up three 'for' nested loops for each operation, without automatic pipelining, and set to process the loops in their unaltered form (#pragma ACCEL PIPELINE auto{off}, #pragma ACCEL TILE FACTOR=auto{1}). The iterations should not run in parallel for E = A*B and G = E*F calculations (#pragma ACCEL PARALLEL FACTOR=auto{1}), while for F = C*D calculation set parallel factor to 32 (#pragma ACCEL PARALLEL FACTOR=auto{32}), offering a compromise of throughput and latency for larger compute-bound kernels.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function named 'kernel_3mm' that takes 7 parameters: five integers 'ni', 'nj', 'nk', 'nl', 'nm' and six 2D double arrays 'E', 'A', 'B', 'F', 'C', 'D', 'G'. This function will be treated as a hardware kernel. This kernel function is divided into three parts where each part computes matrix multiplication in the initial form. The first part multiplies matrices 'A' and 'B' and stores the result in 'E'. The second part multiplies 'C' and 'D' and puts the result in 'F'. The third part multiplies 'E' and 'F' and saves the result in 'G'. \n\nThe main steps for this operation encoded in prama expression chained way in code are as below:\n1. For matrix multiplication of 'A' and 'B', set hardware accelerator pipeline off, treat the loop as a whole (no tile decomposition), and enforce sequential execution (no auto-parallelization). Use two nested loops to traverse rows and columns of 'E', initializing 'E' to zero, followed by another 'auto parallel' constrained loop to multiply corresponding elements of 'A' and 'B' and accumulate them in 'E'.\n2. Similarly, for multiplication of 'C' and 'D', apply the same settings as in the first part, but the last inner loop will auto parallelize 10 iterations.\n3. For multiplication of 'E' and 'F', again apply the previous settings, but in this case, auto parallelize 50 iterations in the third nested loop. \n\nIn all cases, the pragma attributes ensure that the loops would not be diminished into smaller clusters, threads will not run in parallel, and the loop iterations will run in their original sequential form without turning on pipeline.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function called `kernel_3mm` which receives the following parameters as input: five integers `ni`, `nj`, `nk`, `nl`, `nm` and six double 2D arrays `E[40][50]`, `A[40][60]`, `B[60][50]`, `F[50][70]`, `C[50][80]`, `D[80][70]`, `G[40][70]`. This function should be treated as a hardware kernel for acceleration. Inside the function, implement three matrix multiplications: `E := A*B`, `F := C*D` and `G := E*F`. For each of these matrix multiplications, disable automatic pipelining of the main loop, process it in its original form, and don't execute iterations in parallel by setting #pragma ACCEL PIPELINE, TILE, and PARALLEL FACTOR values to 'auto{off}', 'auto{1}', and 'auto{1}' respectively. For sub-loops with matrix operations, retain the automatic pipeline setting but set the Tile factor to 1. Use parallel factor of 60 for the inner most loop in the `E := A*B` operation, use parallel factor of 80 in the `F := C*D` operation, and use parallel factor of 50 in the `G := E*F` operation.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a HLS function called 'kernel_3mm' which accepts 7 parameters: 5 integers namely, ni, nj, nk, nl, nm and 2 two-dimensional arrays namely E[40][50], and F[50][70]. The function also accepts A[40][60], B[60][50], C[50][80], D[80][70], G[40][70] as large two-dimensional arrays for matrix operations. \n\nThe function will treat each section of code as a loop and they are not broken down into smaller elements because of the '#pragma ACCEL TILE FACTOR=auto{1}' directive. The codes for each loop will not be pipelined due to the '#pragma ACCEL PIPELINE auto{off}' directive. The iterations of these loops are not performed in parallel due to the '#pragma ACCEL PARALLEL FACTOR=auto{1}' directive. However, the iterations of the inner most loop of the last section (G := E*F) are performed in parallel streams due to the '#pragma ACCEL PARALLEL FACTOR=auto{10}' directive. \n\nThe function performs matrix operations in three steps: \n1. Multiply matrices A and B and store the result in E \n2. Multiply matrices C and D and store the result in F \n3. Multiply matrices E and F and store the result in G. \n\nAfter each step, the function initializes the resulting matrix to zero before executing the addition and multiplication operations. The '#pragma ACCEL kernel' directive at the beginning indicates that this function will be used as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create an HLS accelerated kernel named 'kernel_3mm'. The kernel accepts ints 'ni', 'nj', 'nk', 'nl', 'nm', and six double arrays 'E', 'A', 'B', 'F', 'C', 'D', 'G' with different dimensions. Inside the function, make use of 3 nested loops for each block of matrix multiplication operations i.e 'E := A*B', 'F := C*D', 'G := E*F'. For each major outer loop and the immediate inner loop, prevent automatic pipelining, and ensure all iterations of the loop are run serially not in parallel and without breaking them down into smaller fragments by using '#pragma ACCEL PIPELINE auto{off}', '#pragma ACCEL TILE FACTOR=auto{1}', and '#pragma ACCEL PARALLEL FACTOR=auto{1}' respectively. For the innermost loop in the 'F := C*D' block and 'G := E*F' block, increase the parallelization factor to 16 and 50 respectively, optimized for 'auto' implementation.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function named 'kernel_3mm' that takes in nine parameters: five integers named ni, nj, nk, nl, nm; and four two-dimensional arrays of doubles named E, A, B, F, C, D and G. Designate this function as a hardware kernel for acceleration.\n\nInside the function, initialize the indices i, j, k for the loops.\n\nThen compute the matrix multiplication of A and B arrays, and store the result in the E array. Do not pipeline or parallelise these loops, process them in their full form and run their iterations one after the other. However, for the innermost loop that performs the actual multiplication, allow up to 60 iterations to run in parallel.\n\nNext, compute the matrix multiplication of C and D arrays, and store the result in the F array. Similar to the previous computation, do not pipeline or parallelise these loops and run their iterations in sequence. In the most inner loop, allow as many as 80 parallel iterations.\n\nThen compute the multiplication of obtained matrices E and F, and store the result in G array. Unlike the previous computations, flatten the pipeline for the outer loop but still run iterations one after another for the other loops. Allow the next loop to perform four parallel iterations, but only permit the most inner loop to perform sequential iterations.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create an accelerated hardware kernel function named `kernel_3mm` with a variety of integer parameters (`ni`, `nj`, `nk`, `nl`, `nm`) and double type 2D arrays (`E`, `A`, `B`, `F`, `C`, `D` and `G`). Follow these steps:\n\n1. Compute the product of arrays `A` and `B`, storing the result in array `E`. Disable automatic pipeline optimization and process each loop in its full form without splitting it into smaller chunks. Make sure the loop iterations are run sequentially and not in parallel. Repeat these configurations for the inner loops as well.\n\n2. Similarly, calculate the product of arrays `C` and `D` with the result in `F`. All optimizations are also disabled for this section, with the innermost loop having parallel factor set to auto-16 to process 16 data elements at once.\n\n3. Lastly, multiply array `E` and `F`, place the result in array `G`, following the same pipeline and tiling configurations as above. However, set the innermost loop's parallel factor to auto-32 for executing 32 operations simultaneously.\n\nEnsure all #pragma values are correctly stated as described.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create an accelerated kernel function named `kernel_3mm` using `#pragma ACCEL kernel`. This function should take as input the integer values `ni`,`nj`,`nk`,`nl`,`nm`, and a series of 2D arrays: `E`, `A`, `B`, `F`, `C`, `D`, and `G`.\n\nWithin this function, write a set of three nested for-loops to multiply matrices `A` and `B`, storing the result in matrix `E`. Configure these for-loops using the directives `#pragma ACCEL PIPELINE auto{off}`, `#pragma ACCEL TILE FACTOR=auto{1}` and `#pragma ACCEL PARALLEL FACTOR=auto{1}`, which imply that these loops are not to be automatically pipelined, their iterations are to be processed consecutively, and they should not be split into smaller chunks.\n\nNext, write a second higher-level set of nests to multiply matrices `C` and `D`, storing the result in matrix `F`. Apply similar HLS pragmas as before on the outer and middle loops but for the inner loop, turn the automatic pipeline optimization off using `#pragma ACCEL PIPELINE auto{flatten}`. \n\nFinally, in the third set of for loops, the matrices `E` and `F` are multiplied and the result stored in matrix `G`. At the outer level, use the same pragmas as before, but at the middle level, let the compiler determine the optimal pipeline strategy using `#pragma ACCEL PIPELINE auto{}`, and allow for slightly more parallel computation at a factor of 2 by using `#pragma ACCEL PARALLEL FACTOR=auto{2}`. In the innermost loop, allow for the maximum possible parallel computation by setting the parallel factor to 32 using `#pragma ACCEL PARALLEL FACTOR=auto{32}`.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write an HLS accelerated function with the prototype 'kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])'. In this function, you will perform three large matrix multiplications (A*B, C*D, and E*F) using three nested loops for each multiplication. The outer two loops of all multiplications should not be automatically pipelined or parallelized (using '#pragma ACCEL PIPELINE auto{off}' and '#pragma ACCEL PARALLEL FACTOR=auto{1}'). Furthermore, these loops should be processed in their original, full form, without splitting them into smaller chunks ('#pragma ACCEL TILE FACTOR=auto{1}'). For the inner loops, process their iterations with different degrees of parallelization, increasing the parallelization factor (auto{3} for A*B, auto{8} for C*D, auto{5} for outer loop of E*F, and auto{8} for inner loop of E*F) respectively.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create an HLS-compatible C function named 'kernel_3mm' that performs matrix multiplications on given matrices. The function should take three pairs of matrices (A, B), (C, D), and (E, F) each with appropriate dimensions for multiplication, and store the results in matrices E, F, and G. Define the acceleration kernel with '#pragma ACCEL kernel'. Run all loop iterations in succession rather than in parallel by applying '#pragma ACCEL PARALLEL FACTOR=auto{1}' to each loop. Process each loop in its entirety (without splitting it into smaller pieces) by applying '#pragma ACCEL TILE FACTOR=auto{1}' to each loop. To prevent automated pipelining of loop iterations, use '#pragma ACCEL PIPELINE auto{off}'. When processing the last loop pair, flatten the pipeline with '#pragma ACCEL PIPELINE auto{flatten}' for maximizing parallelism. The loop operations must involve initializing the result matrices to 0, and then performing the dot product of relevant row and column for each corresponding element in the result matrix. Note that the PARALLEL FACTOR for the third inner loop dealing with matrix F changes to auto{16}.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a 'kernel_3mm' function with parameters 'ni', 'nj', 'nk', 'nl', 'nm' and matrices 'E', 'A', 'B', 'F', 'C', 'D', 'G'. Treat the function as a hardware kernel for acceleration. Inside the function, perform the matrix multiplication in three steps: 'E = A*B', 'F = C*D', 'G = E*F'.\n\nEach step has nested 'for' loops. For these loops, don't automatically pipeline them, process them in their original form without breaking into smaller chunks, and run their iterations one after the other, not in parallel. For the innermost loops processing matrix elements, run them in parallel.\n\nEnsure for each of 'E = A*B', 'F = C*D', the number of parallel iterations is equal to the numbers of columns of matrix B (60) and D (80) respectively. In 'G = E*F' process, set the number of parallel iterations to the number of columns of matrix E (50).", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware-accelerated kernel function named 'kernel_3mm' that accepts nine parameters: five integers 'ni' through 'nm' followed by five 2D arrays 'E' to 'G'. The first piece of major operation to be done by the function is the dot product calculation of 'A' and 'B' 2D arrays, storing the result in array 'E'. This operation will not be automatically pipelined, not be broken down to smaller chunks, and its iterations will not run in parallel. Also, note that the nested 'j' loop and even further nested 'k' loop use the same directives. After this, a similar operation is performed on arrays 'C' and 'D' with the result stored in 'F', under the same directive conditions. Lastly, the function will execute another operation of similar nature, this time applying the calculation on arrays 'E' and 'F' to produce array 'G'. Just like before, the outer 'i' loop will not be automatically pipelined, broken down into smaller chunks, or executed in consecutive iterations. But do note, the outer 'j' loop is set to auto-pipeline while the two inner loops are configured to process multiple iterations simultaneously.\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create an accelerated kernel function named 'kernel_3mm' that accepts integers ni, nj, nk, nl, nm, and six 2D arrays E, A, B, F, C, D, and G as inputs. Use '#pragma ACCEL KERNEL' to designate this function. This function should initially perform the operation E = A * B using for loops. Within the for loops, use '#pragma ACCEL PIPELINE auto{flatten}', '#pragma ACCEL TILE FACTOR=auto{1}' and '#pragma ACCEL PARALLEL FACTOR=auto{1}' to instruct the compiler to automatically decide to pipeline the loops, not to break the loop into smaller chunks, and to sequentially run the iterations respectively. For the second operation, F = C * D, use '#pragma ACCEL PIPELINE auto{off}' to prevent automatic loop pipelining. For the third operation, G = E * F, use '#pragma ACCEL PARALLEL FACTOR=auto{10}' to run 10 iterations of the loop concurrently.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Generate an HLS C code that defines the Accelerated kernel function 'kernel_3mm'. This function has nine parameters: five int variables for matrix dimensions and four 2D arrays of type double for input matrices A, B, C, D and output matrices E, F, G. Inside this kernel function, create three nested loops. The first and third loops iterate over each set of two matrices to calculate matrix multiplication, with loop pipeline disabled, the inner loops being processed sequentially and in their unbroken original form. In contrast, the second loop also iterates to multiply two matrices but runs in parallel in the innermost loop with a parallelism factor of 16 instead of 1.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a kernel function named 'kernel_3mm' which will be treated as a hardware kernel for acceleration. The function takes ten parameters including five integers and five double-precision two-dimensional arrays.\n\nThe function contains three main parts.\n\nIn the first part, matrix E is obtained by multiplying matrix A and matrix B. To do this, do not pipeline the loop automatically and also do not break the loop into smaller chunks. Run every iteration of the loops in sequence. The loop control variable ranges from zero to less than 40 and less than 50 respectively. A nested loop goes with control variable ranges from zero to less than 60, in which matrix E is updated by multiplying and adding corresponding elements in matrix A and matrix B.\n\nThe second part of the function is very similar to the first part. It gets matrix F from the multiplication of matrix C and matrix D with the same rules of pipelining, tiling, and parallel process. However, the matrix's dimensions are different.\n\nThe third part of the function finds matrix G by multiplying matrix E and F with again similar loops' rules, but a different range of control variables. At each step of the nested loop, matrix G is updated by corresponding element multiplication and addition of matrix E and F.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a function named 'kernel_3mm' that performs three matrix multiplications (A*B, C*D, and E*F and assigns them to E, F, and G respectively) using the specified HLS pragmas to control the acceleration directives. The function takes as input parameters five integers (ni,nj,nk,nl,nm) and six 2D arrays (E, A, B, F, C, D, G). Set the function as a hardware kernel for acceleration using '#pragma ACCEL kernel'. \n\nFor the computation of each matrix, create a nested for loop structure running from 0 to the size of the matrix being calculated. For the loops, specify that they run iteration by iteration rather than in parallel, and that the loop processing should not be broken into chunks nor pipelined automatically, done so by using '#pragma ACCEL PIPELINE auto{off}', '#pragma ACCEL TILE FACTOR=auto{1}' and '#pragma ACCEL PARALLEL FACTOR=auto{1}'.\n\nThe innermost loop of each matrix computation should have a different parallel factor (auto{32} for E and F, and auto{10} for G) that allows up to 32 or 10 iterations to be processed in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a HLS code in C that declares an accelerated kernel function named 'kernel_3mm' which takes in integers ni, nj, nk, nl, nm and double arrays E, A, B, F, C, D, G. Prohibit automatic pipelining, tiling and parallelism of loop iterations through #pragma ACCEL options set to 'auto{off}', 'auto{1}', 'auto{1}' respectively. Inside the kernel function, perform three matrix multiplications: First, assign the product of matrices 'A' and 'B' to 'E'. Then assign the product of 'C' and 'D' to 'F' with distinct inner loop parallel factor 'auto{16}'. Lastly, assign 'E' and 'F' multiplication result to 'G' using distinct inner loop parallel factor 'auto{5}'. All matrix multiplication operations should be encapsulated in nested for-loops with initial assignments to elements for correct accumulation of results.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Please write an HLS function named 'kernel_3mm' that implements a 3-Matrix Multiply (3MM) operation by doing the following:\n\n1. Treat the function as a hardware kernel for acceleration.\n2. The function takes in several parameters such as 5 integers values: 'ni', 'nj', 'nk', 'nl', 'nm', and multiple two-dimensional array of doubles named 'E', 'A', 'B', 'F', 'C', 'D', 'G'.\n3. Inside the function, declare the two counter variables 'i', 'j', 'k'.\n4. Then perform the following operations sequentially:\n   - Compute the product of matrices 'A' and 'B', then store the result in matrix 'E'.\n     Specific Instruction: Process each loop in its original, full form (don't break it into chunks) and run the iterations of these loops one after the other, (not in parallel)\n   - Compute the product of matrices 'C' and 'D', then store the result in matrix 'F'.\n     Specific Instruction: Run the innermost loop iterations in parallel by a factor of 10.\n   - Compute the product of matrices 'E' and 'F', then store the result in matrix 'G'.\n     Specific Instruction: Run the innermost loop iterations in parallel by a factor of 25. \n5. Ensure that all 'for loops' for multiplication are processed without automatic pipelining. Remember, for all these operations, we are using 'pragma ACCEL' HLS directives.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{25}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware-accelerated function 'kernel_3mm' that accepts nine parameters: 'ni', 'nj', 'nk', 'nl', 'nm' and five arrays of different sizes 'E', 'A', 'B', 'F', 'C', 'D', 'G'. Define your loop variables 'i', 'j', and 'k'. \n\nFor three sections of your function: calculating 'E' from 'A' and 'B', 'F' from 'C' and 'D', and 'G' from 'E' and 'F', each section should have three levels of nested for-loops, with the outermost loops having their automatic pipelining, tile factor, and parallel factor set to 'off', '1', and '1' respectively.\n\nFor the second level of loops, set the automatic pipelining to 'flatten', and tile factor, parallel factor to '1',\nand for the innermost loops, set the automatic parallel factor to '1', with the exception of the last innermost loop where it should be set to '50'. \n\nThis would ensure each section of your function is processed in its full form without being pipelined or paralleled unnecessarily, while maintaining a 50-factor parallelism in the last computation of 'G'.\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a helpful hardware kernel function called 'kernel_3mm' in C that receives nine parameters: five integer parameters (ni,nj,nk,nl,nm), four 2D double arrays (E[40][50], A[40][60], B[60][50], G[40][70]) and two double 2D arrays that correspond to double F[50][70] and double D[80][70]. This function essentially performs three matrix multiplications:\n1. It calculates matrix product of A and B to update E, \n2. It calculates matrix product of C and D to update F, and \n3. It calculates matrix product of E and F to update G. \nFor each multiplication, create a loop structure where first and second loops don't run in parallel and are not pipelined. The innermost loop in the first two multiplications is not parallelized at all, it iterates one at a time. In the third multiplication, the innermost loop iterates eight times at once. Also, indicate with appropriate #pragma that the loop iterations should not be divided for execution.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a HLS kernel named \"kernel_3mm\" with several integer and 2D double array parameters. The kernel should have three distinct major sections. In the first, you're multiplying matrices A and B and storing the result in matrix E. In the second part, you're performing matrix multiplication of C and D and storing the result in F. The last MATRIX multiplication is between E and F, the result stored in G. In each section, use three parallelizable loops with '#pragma ACCEL PARALLEL FACTOR' set to 1 for each loop except the last nested 'k' loop in the second section where it's 16. Also use '#pragma ACCEL PIPELINE' and '#pragma ACCEL TILE FACTOR' with the 'auto{off}' and 'auto{1}' values respectively on each outer loop. Remember that the multiplications involve a lot of additions and multiplications between corresponding elements in the given matrices.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function called 'kernel_3mm' that takes in nine parameters; five integers namely 'ni', 'nj', 'nk', 'nl', 'nm' and four two-dimensional arrays 'E', 'A', 'B', 'F', 'C', 'D', 'G'. Use the '#pragma ACCEL kernel' directive to specify that this function should be predefined as a hardware kernel for acceleration.\n\nYour code will perform three major computations: \n\n1. Matrix multiplication of two two-dimensional input arrays 'A' and 'B' resulting in the 'E' array. Apply the directives '#pragma ACCEL PIPELINE auto{off}', '#pragma ACCEL TILE FACTOR=auto{1}', and '#pragma ACCEL PARALLEL FACTOR=auto{1}' to this computation ensuring that we don't automatically pipeline this loop, it gets processed in its original form without splitting and the loop iterations are run sequentially, not parallelly.\n\n2. Matrix multiplication of another two input arrays 'C' and 'D' that results in the 'F' array. Follow the same directive pattern just like in step one but let the last loop of this computation run parallelly with a factor of '10' using '#pragma ACCEL PARALLEL FACTOR=auto{10}'. \n\n3. Matrix multiplication of the two resulting arrays 'E' and 'F' from steps 1 and 2 that results in the final array 'G'. Follow the same directive pattern, but this time run the last loop in parallel with a factor of '32' using the '#pragma ACCEL PARALLEL FACTOR=auto{32}'. \n\nRemember that the first two loops are run one after the other, they are not split into smaller chunks and they are not pipelined.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function named 'kernel_3mm' that is treated as a hardware kernel for acceleration, takes in eight arguments: five integers named 'ni', 'nj', 'nk', 'nl', 'nm' and six two-dimensional arrays of doubles named 'E', 'A', 'B', 'F', 'C', 'D', and 'G'. Continue with initializing local variables 'i', 'j', and 'k' for iteration purposes. Calculate the dot product of matrices 'A' and 'B', and store the result in matrix 'E'. While performing these calculations, do not automatically pipeline these loops and process the loops in their original, full form, running the iterations one after the other, not in parallel. Repeat this process for the matrices 'C', and 'D', storing the result in matrix 'F'. Finally, calculate the dot product of matrices 'E', and 'F', and store the result in matrix 'G'. Also for these iterations, don't auto pipeline, maintain the original loop form and run the iterations sequentially rather than in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Generate a function called 'kernel_3mm' that treats the following function as a hardware kernel for acceleration. This function calculates the multiplication of matrix A and B, resulting in E, the multiplication of matrix C and D, resulting in F, and the multiplication of E and F, resulting in G. In each of the three for-loops, disable the automatic pipelining, don't break the loop into smaller chunks, and run the loop iterations one after the other, not in parallel. In the third nested loop of each major loop, allow parallelization. For the first two major loops, only one iteration is processed at a time. However, for the third major loop, 16 operations can run in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The prompt instruction for this C code task is: Implement a hardware function called 'kernel_3mm', which requires parameters of several integers and 2D array matrices. The first process involves calculating the product of matrices 'A' and 'B', in which elements of the matrix 'E' are the sums of the products of corresponding elements in 'A' and 'B'. Do not pipeline this loop automatically, execute the iterations in a none-roken and non-parallelized way. In the second process, perform a similar operation as the first but with matrices 'C' and 'D' and storing the result in matrix 'F'. Lastly, compute the product of matrices 'E' and 'F', storing the result in matrix 'G'. Like before, don't automatically apply pipeline to this loop and run the iterations without breaking them into smaller section and without parallelization. Use #pragma ACCEL commands for the matrix processing. Do process the innermost loop significantly faster by running 16 iterations at once.\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a C program function named `kernel_3mm` with parameters of 5 integers (ni,nj,nk,nl,nm) and seven multi-dimensional arrays (e[40][50],a[40][60],b[60][50],f[50][70],c[50][80],d[80][70],g[40][70]). This function will be processed as a hardware kernel for acceleration. It includes three main parts - E := A*B, F := C*D, G := E*F. \n\nFor each part, you need to iterate over certain dimensions of arrays, make sure to not pipeline, tile, and parallelize the loops automatically by setting 'off' for '#pragma ACCEL PIPELINE', '1' for '#pragma ACCEL TILE FACTOR' , and '1' for '#pragma ACCEL PARALLEL FACTOR' respectively. \n\nHowever, for the innermost loop in the 'F := C*D' and 'G := E*F' parts, set the '#pragma ACCEL PARALLEL FACTOR' to 'auto{10}' and 'auto{50}' respectively to execute respective loop iterations in parallel thus accelerating execution. \n\nFor each loop iteration, you need to perform specific calculations using the arrays, such as multiplying elements from two arrays and adding the result to a element in another array. This calculation is performed for specified indices in the arrays based on the loop variables. \n\nThe '#pragma scop' and '#pragma endscop' are no need to be considered here since they are commented out.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a HLS C code for a function called 'kernel_3mm'. This function takes in 7 arguments: 5 integers (ni, nj, nk, nl, and nm) and 6 two-dimensional double arrays (E[40][50], A[40][60], B[60][50], F[50][70], C[50][80], D[80][70], and G[40][70]). \n\nThis function will perform three separate matrix multiplications: E = A * B, F = C * D, and G = E * F.\n\nYou should treat this function as a hardware kernel for acceleration, denoted by '#pragma ACCEL kernel'. \n\nFor each of the matrix multiplication operations, you should write three nested for loops to iterate over the matrix rows and columns. You should use the values 'off', '1', and '1' for the ACCEL PIPELINE, ACCEL TILE FACTOR, and ACCEL PARALLEL FACTOR #pragma directives at the start of each outermost for loop, respectively. This directs the compiler to not automatically pipeline this loop, process the loop in its original, full form without breaking it into smaller chunks, and run the iterations of this loop one after the other, not in parallel. \n\nRepeat these same #pragma directives again at the start of each middle-level for loop, but with different values for ACCEL PARALLEL FACTOR ('12' for E = A * B, '5' for F = C * D, and '1' for G = E * F) to change the level of parallelization in the innermost loop.\n\nThen, in the G = E * F operation, use 'flatten' for the ACCEL PIPELINE directive to enable loop flattening within interior loops.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Design a hardware acceleration kernel function 'kernel_3mm' that takes nine parameters, five being integer values 'ni', 'nj', 'nk', 'nl', 'nm' and four being 2D double arrays 'E', 'A', 'B', 'F', 'C', 'D', 'G'. \n\nInside the function, first initialize three integer variables 'i', 'j', 'k'. Then, using nested for-loops, perform matrix multiplication operations where 'E' is the product of 'A' and 'B', 'F' is the product of 'C' and 'D', and 'G' is the product of 'E' and 'F'.\n\nUse pragma directives for optimization of the operations. Specifically, use 'PIPELINE auto{flatten}', 'TILE FACTOR=auto{1}', and 'PARALLEL FACTOR=auto{1}' on the main for-loops, apply 'PIPELINE auto{off}', 'TILE FACTOR=auto{1}', and 'PARALLEL FACTOR=auto{2}' on the inner loops to specify parallelism level and execution order. \n\n'PIPELINE auto{flatten}' automaticallly manage pipeline of your loops, 'TILE FACTOR=auto{1}' process the loop in its original full form without breaking it to small chunks. 'PARALLEL FACTOR' controls parallelism level, with 'auto{1}' meaning to run iterations one after the other and 'auto{2}' meaning to allow two iterations (if possible) to run simultaneously. 'PIPELINE auto{off}' is used to not automatically pipeline the inner loops.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function called 'kernel_3mm' that multiplies three pairs of multi-dimensional arrays: A*B, C*D and E*F. This function should leverage a hardware acceleration pragma at the kernel level. Dedicate each of the calculations E:=A*B, F:=C*D, G:=E*F to specific for-loops respectively where for each calculation, the outer two for-loops should not be automatically pipelined, should be executed in its original, full form instead of being broken down, and iterations should be executed one after another instead of in parallel. For the innermost for-loop in the first two calculations, allow only sequential execution, while for the last calculation, allow parallel execution of 8 iterations.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function called `kernel_3mm` with a set of parameters defined for the size of several 2D arrays `E`, `A`, `B`, `F`, `C`, `D`, `G`. Inside this function, implement three different matrix multiplications: `E = A * B`, `F = C * D`, and `G = E * F`. \n\nThis function should treat the computation as a hardware kernel for acceleration. For the matrix multiplication process, ensure each sequence of nested loops is fully processed in its original form without breaking them into smaller chunks. \n\nDuring the first and second multiplication, run the iterations of the loops one after the other, not in parallel. However, during the third multiplication, process the outer loop for '`G`' in parallel with a specific '#pragma' accelerator factor of 'auto{7}' in the outermost loop. But, the inner loop iterations must not be run in parallel. \n\nWhen considering memory optimization, use the pragma value auto for pipeline and tile factor for all the loop bodies consistently.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a function called 'kernel_3mm' which takes nine parameters: five integers 'ni', 'nj', 'nk', 'nl', 'nm' and four two-dimensional arrays 'E', 'A', 'B', 'C', 'D', 'F', 'G'. Mark this function as a hardware kernel for acceleration. This function should do the following:\n\n1. Multiply the matrices 'A' and 'B' and store the result in 'E'. For each iteration of the outer loops should be processed sequentially in its original, full form without breaking it into smaller chunks and should not be automatically pipelined. The innermost loop should have a parallel factor of 5. \n\n2. Multiply the matrices 'C' and 'D' and store the result in 'F'. Like before, each iteration of the outer loops should be processed in a sequential manner in its original, full form and should not be automatically pipelined. The innermost loop should have a parallel factor of 8. \n\n3. Multiply the newly computed 'E' and 'F' matrices and store the result in 'G'. Each iteration of the outer loops should be again processed one after the other without breaking it into smaller chunks and should not be automatically pipelined. The innermost loop should have a parallel factor of 2. \n\nFor each of these steps, enable automatic detection for the pipeline and the tile factor parameters.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function named `kernel_3mm` that takes in nine parameters. The parameters are five integer values 'ni', 'nj', 'nk', 'nl', 'nm' and four 2D arrays 'E', 'A', 'B', 'F', 'C', 'D', 'G'. The function should be treated as a hardware kernel for acceleration. The function should accomplish three main tasks. First, It should perform a matrix multiplication between arrays 'A' and 'B' and store the output into array 'E'. Second, It should do a matrix multiplication between arrays 'C' and 'D' and store the output into array 'F'. Third, It will perform a matrix multiplication between arrays 'E' and 'F' and store the output in array 'G'. Each of the three matrix multiplications have their own set of nested loops. For all loops, prevent automatic pipelining, process the loop in its original full form rather than dividing it into smaller chunks, and run the loop iterations one after the other, not in parallel by using '#pragma ACCEL PIPELINE auto{off}', '#pragma ACCEL TILE FACTOR=auto{1}', and '#pragma ACCEL PARALLEL FACTOR=auto{1}' respectively. However, in the second part of the function while performing multiplication between arrays 'C' and 'D', use '#pragma ACCEL PARALLEL FACTOR=auto{2}' to run two iterations of the innermost loop in parallel. Lastly, in the third part of the function while multiplying arrays 'E' and 'F', flatten the loop by using '#pragma ACCEL PIPELINE auto{flatten}' to promote parallelization by allowing loop interchange in order to maximize throughput.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a C function named 'kernel_3mm' acting as a hardware kernel for acceleration, which takes five integer parameters 'ni,' 'nj,' 'nk,' 'nl,' 'nm,' and seven 2D array parameters 'E,' 'A,' 'B,' 'F,' 'C,' 'D,' 'G.' The function begins with three matrix multiplication operations: 'E = A*B,' 'F = C*D,' and 'G = E*F.' For each matrix multiplication, you should incorporate three for-loops nested within each other. Apply the commands to process each of these loops with an automatically determined level of optimization, without breaking them into smaller chunks, and running the iterations one after the other, not in parallel. For the innermost for loops, set the value of '#pragma ACCEL PARALLEL FACTOR' to auto{1} for 'E = A*B' and to auto{2} for 'F = C*D,' and 'G = E*F.' Lastly, prevent automatic pipelining for each of these three nested loop sets.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function named `kernel_3mm` which takes in ,5 integers namely `ni`, `nj`, `nk`, `nl`, `nm` and seven 2D arrays `E`, `A`, `B`, `F`, `C`, `D`, `G` with dimensions benchmarked at 40x50, 40x60,60x50,50x70,50x80,80x70 and 40x70 respectively. This function should be treated as a hardware kernel using `#pragma ACCEL kernel`. The main purpose of this function is to perform three separate matrix multiplications: first, matrix `A` is multiplied by matrix `B` to get matrix `E`, second, matrix `C` is multiplied by matrix `D` to get matrix `F` and third, matrix `E` is multiplied by matrix `F` to get matrix `G`. For all computations, the pipeline should not be automated, the loop-breaking factor should be 1, and the loops should run sequentially to maintain data integrity. However, the last loop for calculating `G` from `E` and `F` can have 4 iterations processed in parallel. Make sure that computations for `E`, `F` and `G` are initiated at 0 with `E[i][j] = 0.0;`, `F[i][j] = 0.0;` and `G[i][j] = 0.0;` respectively before adding the multiplication result for each element.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a kernel function called 'kernel_3mm' which takes ni, nj, nk, nl, nm integers, and double arrays E, A, B, F, C, D, G as parameters. This function will compute the matrix multiplication of A and B and store the result in E, then compute the multiplication of C and D and store the result in F, before finally computing the multiplication of E and F and storing the result in G. \nIn this function, there are three nested for-loops. The outer-most loop will be auto flatten pipelined, auto tiled with a factor of 1, and run in parallel with a factor of 1. The two inner loops will not be pipelined, will each be tiled with a factor of 1, and run in parallel with the factor of 1. After the FLATENING, TILING and PARALLELIZATION of the intermediate, the processing of computation E, F, and G will be the result of multiplying arrays A * B, C * D, and E * F respectively.\nPlease note that the code for calculating G will have a tile factor of 40 instead of 1.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{40}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a kernel function named 'kernel_3mm', that takes 'ni', 'nj', 'nk', 'nl', 'nm' integers, and E, A, B, F, C, D, and G 2D double arrays as parameters. The function should do three main multiplications: First, each element of E is calculated by multiplying corresponding elements from A and B, with nested for loops for i and j, and a deeper loop for k that iterates over columns; do not automatically pipeline, tile, or parallelize these loops. Second, each element of F is calculated in the same way as E, but by using arrays C and D. Lastly, each element of G is calculated by multiplying corresponding elements from E and F, with nested for loops for i and j, and a deeper loop for k that iterates over columns; allow this deeper loop to be flattened into a single loop with 'pragma ACCEL PIPELINE auto{flatten}'. It is essential to treat kernel_3mm as a hardware kernel for acceleration, and specifically run the iterations of the loops one after the other, not in parallel for the main multiplications of these arrays. For the deepest loop, use the 'ACCEL PARALLEL FACTOR' with the respective values for parallelization of 60, 80, and 1 times respectively for loops E, F, and G.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write an accelerator kernel function named kernel_3mm in C, that takes nine arguments - five integer inputs 'ni', 'nj', 'nk', 'nl', 'nm' and four 2-dimensional array inputs E, A, B, F, C, D and G. Inside the function, define three loops. Set the pragma directives for pipelining, tiling and parallel processing. For pipelining, turn off automatic pipelining. For tiling and parallel factors, treat the loops in their complete, original form, not breaking them into smaller chunks and run the loop iterations in sequence for the first two loops. However, for the third loop, allow parallel process of seven iterations at once in the outer loop and ten iterations in the inner loop. Within the loops, perform matrix multiplication operations - the first loop calculates E = A*B, the second loop calculates F = C*D, and third loop calculates G = E*F.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function named 'kernel_3mm' that accepts nine parameters: five integers 'ni', 'nj', 'nk', 'nl', 'nm', and four 2D double arrays 'E', 'A', 'B', 'F', 'C', 'D', 'G'. Declare this function as a hardware acceleration kernel with directive '#pragma ACCEL kernel'. Inside the function, define three integer variables 'i', 'j', and 'k'. The function will perform matrix multiplication in three steps: E = A*B, F = C*D, G = E*F.\n\nIn each step, make a nested loop for traversal and another loop for calculation, applying the \"#pragma ACCEL PIPELINE auto{off}\", \"#pragma ACCEL TILE FACTOR=auto{1}\", and \"#pragma ACCEL PARALLEL FACTOR=auto{1}\" directives to disable automatic pipeline, ensure original form without splitting and perform iterations serially, not in parallel for the traversal loops.\n\nOn the calculation loop for F = C*D, use \"#pragma ACCEL PARALLEL FACTOR=auto{16}\" to enable possible parallelism on 16 iterations, and for G = E*F, use \"#pragma ACCEL PARALLEL FACTOR=auto{4}\" to enable possible parallelism on 4 iterations. The chosen parallel factor values imply that the innermost loop's iterations can potentially be done concurrently, speeding up computation.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function called 'kernel_3mm' with integers 'ni', 'nj', 'nk', 'nl', 'nm' and double arrays 'E', 'A', 'B', 'F', 'C', 'D', 'G' as arguments, and treat it as a kernel for hardware acceleration. Inside the function, the processes involve computing the product of matrices 'A' and 'B', 'C' and 'D', then the product of the results; specifically, matrix 'E' is computed as 'A * B', 'F' as 'C * D', and 'G' as 'E * F'.\n\n\n\nFor each part of the computation, we will not pipeline the loops and will handle them in their full form without partitioning these into small chunks. We will run each loop iterations one after another, not in parallel, with some differences; for the loop that computes 'E' and 'G', we will flatten the pipeline, and for the second loop computing 'F', we will use two threads to execute the iterations of the innermost loop in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a HLS C code with a function named 'kernel_3mm'. The function should take nine parameters: five integer inputs 'ni', 'nj', 'nk', 'nl', 'nm'; and four two-dimensional double arrays 'E', 'A', 'B', 'F', 'C', 'D', 'G'. The function will be treated as a hardware kernel for acceleration. Within the function, there are three main matrix multiplication operations: 'A' * 'B', 'C' * 'D', and 'E' * 'F'. Initialize both inner loop iterations 'j' and 'k' in serial, don't automatically pipeline them and do not divide them into smaller pieces. For the outermost loop iteration 'i', turn off automatic pipelining, but for the final matrix multiplication, allow a parallel factor of 7 for the 'i' loop iteration and 2 for the 'k' loop iteration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function called 'kernel_3mm' which is processed as a hardware kernel for acceleration. Given the number of elements in different dimensions as int ni, nj, nk, nl, and nm, and double arrays E, A, B, F, C, D, and G. \n\nFirstly, calculate the values of array E by performing matrix multiplication between A and B, by iterating sequentially over all elements without breaking the loops into smaller parts and not pipelining.\n\nThen, calculate array F, which results from multiplying arrays C and D. Perform this operation similarly but for the innermost loop, execute two iterations in parallel.\n\nLastly, calculate array G by multiplying arrays E and F. Iterate normally for this operation, but perform 32 iterations simultaneously in the innermost loop.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function named \"kernel_3mm\". Set it up as a hardware kernel to accelerate computation. The function will receive several parameters: five integers representing dimensions (ni, nj, nk, nl, nm), and seven 2D arrays of doubles (E, A, B, F, C, D, G). Inside the function, declare three variables i, j, and k for loop control. We will perform three sets of matrix calculations consecutively: E = A*B, F = C*D, and G = E*F. \n\nFor each calculation, create a nested loop with three levels. Flatten the first level with 'auto' tiling and parallel factors, but turn off the automatic pipeline. Maintain the same settings for the second level of the loop, but switch the parallel factor to 1 for the third level when calculating E and F, and 25 when calculating G.\n\nIn the innermost loop, calculate the dot product of relevant rows and columns from the two matrix operands, storing the result in the corresponding cell of the resulting matrix. Return to the original level after each calculation, then proceed to the next.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{25}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function in C using HLS primitives, and provide it with the title \"kernel_3mm\". It should accept integers ni, nj, nk, nl, nm, and five 2-dimensional arrays (E, A, B, F, C, D, G) as input. This function accomplishes three main multiply-add operations on the arrays.\n\nThe first operation is \"E := A * B\" where elements of E are set by the multiplication of corresponding elements from A and B.\nThe second operation is \"F := C * D\" where elements of F are reset by the multiplication of corresponding elements from C and D.\nThe third operation is \"G := E * F\" where elements of G are reset by the multiplication of corresponding elements from E and F.\n\nAll these operations should be performed on a fully sequential process where the pipeline is turned off and iterations are run one after the other, not in parallel. It should process the loops in their original, full forms without breaking them into smaller chunks and without automated pipelining, and this is specified by the respective pragma values: '#pragma ACCEL PIPELINE auto{off}', '#pragma ACCEL TILE FACTOR=auto{1}', and '#pragma ACCEL PARALLEL FACTOR=auto{1}'. The very first pragma command '#pragma ACCEL kernel' directs the subsequent function to be treated as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a HLS C function called 'kernel_3mm' which acts as a hardware kernel for acceleration. Treat the loops within this function in their original form, maintaining the iterations in sequential order, not parallel or broken into smaller chunks. Create the function with input parameters ni, nj, nk, nl, nm, and six 2D matrices: E, A, B, F, C, D and G of appropriate dimensionalities - E[40][50], A[40][60], B[60][50], F[50][70], C[50][80], D[80][70], G[40][70]. This function will perform three operations: \n\n1) It computes matrix multiplication of A and B storing the result in E using nested loop. It ensures parallel execution of outer loop is turned off, focusing on sequential execution by setting the pipeline off, tiling and parallel factors to 1.\n\n2) It computes the multiplication of C and D matrices storing the result in F using nested loop. The parallel factor for the innermost loop in this section is set to 16.\n\n3) Finally, it multiplies matrices E and F together and stores the result in G using nested loop. It ensures parallel execution of outer loop is off, by using the pragma directives as in first operation.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write an accelerator kernel function named 'kernel_3mm' with several 2D arrays (E, A, B, F, C, D, G) and five integer parameters (ni, nj, nk, nl, nm). Begin by calculating the product of arrays A and B, storing the result in array E. Do this by running three nested for-loops where the outermost loop iterates over the rows of A, the second loop iterates over the columns of B, and the innermost loop performs the multiplication and addition. Next, calculate the product of arrays C and D, storing the result in array F, similarly with three nested for-loops procedure. Then, calculate the product of arrays E and F, storing the result in array G, also similarly with three nested for-loops procedure. With each of these loop operations, do not automatically pipeline this loop, process this loop in its original, full form without breaking it into smaller chunks, run the iterations of this loop one after the other, not in parallel. The parallel factor for the inner loop of the E and F calculations are 1 and 2 respectively, whereas the parallel factor of the innermost loop for the G calculation is 25.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{25}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware accelerated kernel function named kernel_3mm which takes in 5 dimensions and 7 arrays E, A, B, F, C, D, G as input. The kernel calculates the matrix multiplication of A and B and stores it in E, multiplies C and D storing it in F. After that, it multiplies E with F and places the result in G. In each of these processes, instruct the accelerator to not pipelines the loops automatically. Also, ensure all the loops are processed in their original form, without breaking them into smaller chunks, and loop iterations should take place in sequence, not in parallel. Also, for each innermost loop that performs the multiplication, increase the parallel factor progressively from 1 to 2 to 4.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create an HLS kernel function called 'kernel_3mm'. Inside this, perform matrix multiplications on matrices A, B, C, D, E, F and G. For the first multiplication of A and B to form E, don't automatically pipeline this loop and process this loop in its original, full form without breaking it into smaller chunks, and run the iterations one after the other, not in parallel. For the second multiplication of C and D to form F, the same properties apply, but with a different parallel factor to accommodate the larger matrix dimension. The third multiplication of E and F to form G should also not be automatically pipelined and process this loop in its original, full form without breaking it into smaller chunks. Flatten the second pipeline for even distribution of operations across hardware resources and the outer parallel factor should not be 1 for the increased dimension, but the inner parallel factor should still be 1.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a function named \"kernel_3mm\" that performs three successive matrix multiplications (A*B, C*D, and E*F) in a way that is optimized for hardware acceleration. The function takes in nine arguments, five of those are matrices (A, B, C, D, E, F, G) and the rest are integers representing matrix dimensions (ni, nj, nk, nl, nm). The function must make use of pragma directives to control the way the loops are processed. Specifically, the loops should not be automatically pipelined, use \"#pragma ACCEL PIPELINE auto{off}\", the loops should not be broken up into smaller elements, use \"#pragma ACCEL TILE FACTOR=auto{1}\", and the iterations of the loops should be processed sequentially, not in parallel, use \"#pragma ACCEL PARALLEL FACTOR=auto{1}\".", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a C function named `kernel_3mm` which is treated as a hardware kernel for acceleration. This function takes several parameters including matrix dimensions as integers and six arrays representing matrices `E`, `A`, `B`, `F`, `C`, `D`, `G` including their dimensions respectively. This function comprises three sections: 'E := A*B', 'F := C*D', and 'G := E*F'. In each section, three nested loops are used to perform matrix multiplication. Keep loops in their original form, and ensure they run sequentially without pipelining or parallel execution ('#pragma ACCEL PIPELINE auto{off},  #pragma ACCEL TILE FACTOR=auto{1},  #pragma ACCEL PARALLEL FACTOR=auto{1})'. The last level loops in the second and third section ('F := C*D', 'G := E*F') have parallel iterations with factors of 16 and 50 respectively ('#pragma ACCEL PARALLEL FACTOR=auto{16},  #pragma ACCEL PARALLEL FACTOR=auto{50})'.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a function named 'kernel_3mm' that performs three matrix multiplications (A*B, C*D, E*F), and saves the product into the matrices E, F, and G respectively. Your function will be treated as a hardware kernel for acceleration in the hardware system. Prior to the matrix multiplications, your code will need to include commands to control how these loops are executed. For each of the matrix multiplications, set the commands as follows: the compiler should not automatically pipeline the loop, it should process the loops in their original form without breaking them into smaller chunks, and each iteration of the loops should be run one after another, not in parallel. For the nested loops within each matrix multiplication, 'unroll' these loops with a factor of 1, process them in their original size without breaking into smaller chunks, and run its iterations one after another. There are exceptions for the innermost loops in the last two set of nested loops, parallelize them with a factor of 2 and 25 respectively to improve the efficiency of your HLS code.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{25}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a HLS kernel function named 'kernel_3mm' with the given set of integer and double array parameters. The function sequentially performs three matrix multiplications: A*B, C*D, and E*F with iterations not running in parallel. For each of the three multiplication operations, set the pipeline to 'off' meaning don't automatically pipeline this loop; instruct to process each loop in its full form without breaking it into smaller chunks by tagging TILE FACTOR=1, and perform iterations sequentially, not in parallel, by tagging PARALLEL FACTOR=1. In the final multiplication step, set the PARALLEL FACTOR to auto{7} for the outer loop, and auto{25} for the  innermost loop, denoting different handling of parallelism across these loops.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{25}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a HLS C function named \"kernel_3mm\" that takes multiple integer parameters (ni, nj, nk, nl, nm), and seven 2D double arrays (E, A, B, F, C, D, G). Mark this function to be treated as a hardware kernel for acceleration. Your code should consist of three main sections responsible for computing two matrix multiplications (E = A*B and F = C*D) and setting the result of the multiplication of these two results in G (G = E*F).\n\nDuring these calculations:\n\n1) Prevent automatic pipelining for the outermost loops of each section.\n\n2) Do not break the full form of these loops into smaller chunks, and handle their iterations one after the other, not in parallel.\n\n3) In the second nested loop of each section, allow pipelining, keep the loop in its original full form and run its iterations sequentially, but,\n\n4) When executing the innermost loop, allow the iterations to be run in parallel. The parallel factor of each innermost loop should be 6, 8, and 5 respectively. \n\nEnsure to declare all the necessary integer variables. Each 2D array multiplication should initialize the resulting array elements to zero before starting the multiplication.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Design a hardware kernel function named 'kernel_3mm' which performs matrix multiplication for 3 different sets of matrices. Begin with matrices A[40][60] and B[60][50] to calculate matrix E[40][50], followed by matrices C[50][80] and D[80][70] to calculate F[50][70], and finally, use the calculated matrices E and F to obtain the result stored in G[40][70]. For each multiplication process, apply three nested for loops to conduct element-wise multiplication and accumulation. Don't automatically parallelize or pipeline these loops and process each loop in their full form. The innermost loop in the second and the third multiplication process should allow simultaneous iterations. Update the values in the result matrices E, F, and G at each iteration of the innermost loop.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware kernel function called 'kernel_3mm' using '#pragma ACCEL kernel' that takes the parameters 'int ni,int nj,int nk,int nl,int nm', 2D arrays 'double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70]', and 3 integers 'i, j, k'. \n\nFirst, conduct matrix multiplication between 'A' and 'B' to get 'E'. Ensure this 'for' loop isn't auto-pipelined, is not broken into smaller chunks, and its iterations aren't done in parallel as dictated by the pragma values 'ACCEL PIPELINE auto{off}', 'ACCEL TILE FACTOR=auto{1}', and 'ACCEL PARALLEL FACTOR=auto{1}' respectively.\n\nThen, conduct matrix multiplication between 'C' and 'D' to get 'F', with the same pragma statements and settings.\n\nLastly, carry out matrix multiplication between 'E' and 'F' to get 'G'. In this step, allow the original 'for' loop to be flattened by implementing 'ACCEL PIPELINE auto{}' and ensure iterations follow the same non-parallel order with 'ACCEL PARALLEL FACTOR=auto{7}'. Within this loop, the nested loop iterations should be done in parallel by '16' times with 'ACCEL PARALLEL FACTOR=auto{16}'.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function named 'kernel_3mm' that is treated as a hardware kernel for acceleration. The function accepts multiple integer parameters (namely ni,nj,nk,nl, and nm) and six 2D arrays namely E,A,B,F,C,D and G. Three matrix multiplications are computed in the function. The first multiplication is between matrices A and B, stored in E. The second one is between C and D, stored in F. Lastly, the third one is between E and F, stored in G. Each matrix multiplication loop isn't automatically pipelined and is processed in its original, full form without breaking it into smaller chunks. The iterations of the outer loops run one after the other, not in parallel. However, the iterations of the innermost loops for the first and second multiplications also run one after the other, not in parallel, while for the third multiplication, iterations can run in parallel with a factor of 50.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create an HLS C code using a kernel function called 'kernel_3mm'. Inside this function, structure three nested for-loop operations. In the first operation, calculate the matrix product of 'A' and 'B', and assign it to 'E'. Use pragma values to turn off the automatic pipelining, process the loop in its original form, and run the iterations one after another without splitting them in parallel. Apply the same configurations while iterating through every element of the matrix. In the second operation, compute the matrix product of 'C' and 'D', store it in 'F' with similar pragma configurations as the first one, but run two iterations in parallel. Lastly, compute the matrix multiplication of 'E' and 'F', store it in 'G' with similar configurations as the first operation, but run five iterations in parallel this time. Use these pragma configurations to optimize the hardware performance.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a function named 'kernel_3mm' that treats the following actions as a hardware kernel for acceleration. It will take in variables ni, nj, nk, nl, and nm of type int as well as six two-dimensional double arrays E, A, B, F, C, D,  and G of varying dimensions. Create three loops inside this function.\n\nThe first loop encompasses matrix multiplication E = A*B. Start the loop iterating 'i' from 0 to 40. Inside this loop, create a nested loop iterating 'j' from 0 to 50. In this nested loop, set E[i][j] to 0.0 and create a sub-nested loop from 'k' 0 to 60. This sub-nested loop calculates the product of A[i][k] and B[k][j] and adds it to E[i][j]. Do not automatically pipeline any of these loops, run their iterations one after the other not in parallel, and process them in their original, full form without breaking them into smaller chunks.\n\nThe second loop performs the same operation for matrices F = C*D, the process being alike to the first loop with changes in iteration values and the matrices in use. As the prior, run these iterations one by one, and restrain from pipelining or dividing the loop.\n\nThe third loop is similar as well, but compute G= E*F, running 'i' from 0 to 40 and 'j' from 0 to 70. Keep 'k' from 0 to 50 and the PARALLEL FACTOR for this loop to 5, achieving a bit of parallelism. Like before, prevent it from automatic pipeline and don't break it into smaller chunks.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function named 'kernel_3mm' that accepts nine parameters including five integer variables - 'ni', 'nj', 'nk', 'nl', 'nm', and four 2D arrays - 'E', 'A', 'B', 'F', 'C', 'D' and 'G'. This function will mark the start of hardware kernel for acceleration. Inside this function, define three loops for each matrix multiplication operations - E=A*B, F=C*D, and G=E*F. \n\nFor each loop processing, don't automatically pipeline the loop and process the loop in its original, full form without breaking it into smaller chunks. Also, ensure the iterations of the loop run one after the other, not in parallel. \n\nIn the nested loops where matrix multiplication occurs, allow processing of three iterations of the loop in parallel for 'E=A*B', eight iterations for 'F=C*D', and eight iterations for 'G=E*F'. Automate the pipeline and the tiling factor of the loop for the nested loops within each matrix multiplication operation.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function named 'kernel_3mm'. The function will take in the integers 'ni', 'nj', 'nk', 'nl', and 'nm' as parameters, along with six 2D arrays 'E', 'A', 'B', 'F', 'C', 'D', and 'G'. Inside this function, three main matrix calculations will be performed. First, a two-nested loop is operated to perform the multiplication of matrices 'A' and 'B', and store the result into 'E'. During this operation, turn the pipeline off, do not break the loop into smaller chunks, and ensure the iterations are not run in parallel. Perform a similar operation for matrices 'C and 'D' storing the result into 'F', but for the innermost loop, ensure two iterations can run in parallel. Lastly, perform the multiplication for matrices 'E' and 'F' storing the result into 'G'. However, for the innermost loop, allow ten iterations to run in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a high-level synthesis compatible kernel function 'kernel_3mm'. In this function, first, define the matrices E, A, and B. The exact sizes for each matrix, two loops, and an internal operation are specified. Then, make sure that the loops are not automatically pipelined, they are processed in full form without reducing into chunks, and their iterations are handled sequentially for the matrix multiplication operation of A and B. The same conditions apply for the matrices F, C, and D. Finally, compute the multiplication of matrix E and F to obtain matrix G. However, make the outer loop iterations sequential but the inner loop has some amount of parallelization for a better trade-off between throughput and resource utilization.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a HLS kernel function named 'kernel_3mm' with its specified parameters. This function will perform matrix multiplications in three steps: E = A*B, F = C*D, and G = E*F. In each of the three stages, prevent automatic pipelining and avoid parallel processing of loop iterations using '#pragma ACCEL PIPELINE auto{off}' and '#pragma ACCEL PARALLEL FACTOR=auto{1}' pragmas respectively. Ensure that the loops are not broken into smaller chunks by using '#pragma ACCEL TILE FACTOR=auto{1}'. Change the parallel factor to 'auto{2}' in the second stage's innermost loop and to 'auto{16}' in the third stage's innermost loop to perform their iterations in parallel. Apply the '#pragma ACCEL PIPELINE auto{flatten}' and '#pragma ACCEL PARALLEL FACTOR=auto{1}' pragmas in each nested loop within the matrix multiplication stages.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware kernel function named 'kernel_3mm'. The function takes in nine arguments: five integers (ni, nj, nk, nl, nm) representing the dimensions of matrices, and four 2D arrays (E, A, B, F). Inside the function, define two integers i and j. Then, do the following operations in sequence:\n\n- Multiply matrices A and B, store the result in E. Process loops in original form (TILE FACTOR=1) without automatic pipelining (PIPELINE OFF) and without parallelizing iterations (PARALLEL FACTOR=1). The inner-most loop should be parallelized for 32 iterations automatically.\n  \n- Multiply matrices C and D, store the result in F. Follow the same #pragma instructions as the previous set of loops. The inner-most loop should be parallelized for 32 iterations automatically.\n\n- Multiply matrices E and F, store result in G. Change PARALLEL FACTOR for the second loop to auto{5} and use PARALLEL FACTOR auto{10} for the innermost loop. \n\nRemember to turn off automatic pipeline optimization (PIPELINE OFF), process the loops in their original form (TILE FACTOR=1) and control the degree of loop parallelism as specified above for each operation.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function called 'kernel_3mm' which handles kernel operations on 3 different matrices. The function takes nine arguments in total, these are five integers representing dimensions and five multi-dimensional arrays representing matrices. The function is treated as a hardware acceleration kernel using '#pragma ACCEL kernel'. After declaring integers i, j, k, the function goes through three major calculations: \n\n1. Calculation of E equals to A times B: In the loop where E is calculated from A and B, do not automatically pipeline this loop using '#pragma ACCEL PIPELINE auto{off}'. Also, process this loop in its original full form without breaking it into smaller chunks using '#pragma ACCEL TILE FACTOR=auto{1}' and run the iterations of this loop one after the other, not in parallel using '#pragma ACCEL PARALLEL FACTOR=auto{1}'.\n\n2.  Calculation of F equals to C times D: The loop for calculating F from C and D also follows the same #pragma directives as the first loop but with an iteration over the dimension 'k' that runs in two parallel processes using '#pragma ACCEL PARALLEL FACTOR=auto{2}'.\n\n3. Calculation of G equals to E times F: The loop for calculating G from E and F also follows the same #pragma directives as the first loop but with an iteration over the dimension 'k' that runs in ten parallel processes using '#pragma ACCEL PARALLEL FACTOR=auto{10}'.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Generate a C based HLS code that constructs a function labeled 'kernel_3mm'. This function takes as parameters nine variables: five integers (ni, nj, nk, nl, and nm) and four 2D double arrays (E, A, B, F, C, D, and G). The function will be processed as a hardware kernel via the '#pragma ACCEL kernel' directive.\n\nIn the function, initialize 'i', 'j', and 'k'. Then, facilitate three mathematical operations involving array manipulation, each separated by their appropriate comments: /* E := A*B */, /* F := C*D */, and /* G := E*F */. \n\nFor each operation, first, disable the automatic pipelining of the associated loop, keep the loop in its original full form, without splitting it into smaller pieces and run the iterations one after the other, not in parallel using '#pragma ACCEL PIPELINE auto{off}', '#pragma ACCEL TILE FACTOR=auto{1}', and '#pragma ACCEL PARALLEL FACTOR=auto{1}' respectively.\n\nThe first operation initializes and calculates array E using a nested loop of iteration 40 and 50, with array A and B. Use '#pragma ACCEL PIPELINE auto{off}', '#pragma ACCEL TILE FACTOR=auto{1}' and '#pragma ACCEL PARALLEL FACTOR=auto{1}' for the outer loops and '#pragma ACCEL PARALLEL FACTOR=auto{60}' for the innermost loop. \n\nRepeat a similar process for the second operation on array F with array C and D with increased loop iteration to 50 and 70, and a parallel factor of 80 for the innermost loop. \n\nOn the third operation, perform the same series of steps for the outer loops but use '#pragma ACCEL PIPELINE auto{flatten}' instead to flatten the pipeline, and using parallel factor as 5. For its innermost loop, keep the parallel factor as 1. \n\nThe general loop structure for all three operations consists of adding the product of the corresponding elements from the input arrays to the output array.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Please write a function named kernel_3mm with the following characteristics in HLS C programming language:\n- Please initialize this function to act as a hardware kernel for acceleration.\n- Accept nine parameters: five integers representing the matrix size (ni, nj, nk, nl, nm), and four 2D double arrays(E, A, B, F, C, D, G). The function will use these matrices to perform matrix multiplication operations.\n- Start by populating the E matrix with the multiplication results of matrices A and B. \n- Use loop iterations in its original, undivided form without breaking it into smaller chunks and run the loops one after the other but not in parallel. Process the loop in a non-pipelined manner.\n- Follow the same steps to populate the F matrix with the multiplication results of C and D matrices.\n- Finally, generate the G matrix by multiplying the E and F matrices. While processing the two outermost loops in this part, use the parallel factor of 7. For the inner loop, handle the iterations in parallel using a factor of 16.\n- After each matrix multiplication, reset the process flow by turning off the 'pipeline' and 'parallel factor' commands and return them to the default settings.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function titled 'kernel_3mm' that accepts integer inputs for 'ni', 'nj', 'nk', 'nl' and 'nm', along with six 2D arrays. The function will perform matrix multiplications and treat this function as a hardware kernel for acceleration. \n\nFor each multiplication, create a nested loop where the process should not be automatically pipelined, the loop should be processed in its original full form without splitting into smaller chunks, and the iterations should be run one after another, not in parallel. \n\nFirst, calculate the product of matrices A and B, and store in E. For inner loops, again ensure the loop iterations run one after the other not in parallel. \n\nNext, calculate the product of matrices C and D, storing the result in F. Again, deploy similar #pragma settings for inner loops. \n\nFinally, calculate the product of E and F, storing the result in G. Ensure that, for this process, the loop iterations for the innermost loop execute in parallel with a factor of 4 while the second inner loop can be executed in parallel with a factor of 7. \n\nIn all calculations, initialize the matrices to hold the results (E, F, and G) as zero before starting the computation. The multiplication in innermost loops should be accumulated in the respective matrix element for each calculation.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Generate a function using the name 'kernel_3mm' with nine parameters that are five integers and four 2D arrays of double. This code should be treated as a hardware kernel for acceleration. \n\n1. Firstly, multiply 2D array A[40][60] by B[60][50] to produce 2D array E[40][50]. Therefore, initialize two loops for iterating over the matrices to perform their multiplication. For each of the loops avoid automatic pipelining, process them in their original form, and run the iterations one after another and not in parallel.\n\n2. Repeat the same process by multiplying 2D array C[50][80] by D[80][70] to form a new 2D array F[50][70]. In the last inner loop of this operation, allow 16 loop iterations to be executed in parallel for performance reasons.\n\n3. Lastly, repeat the operations similar to the first one, but multiply the computed 2D array E[40][50] by F[50][70], to give the required output 2D array G[40][70]. In the last loop of these iterations, let the loop iterations be executed 10 times at once in parallel to increase logistics efficiency.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a HLS C code for matrix multiplication operation under the function `kernel_3mm`, with the indicated parameters and matrices (E, A, B, F, C, D, G). Recognize it as a hardware kernel for acceleration and initiate calculations for E as the product of A and B, F as a product of C and D, and finally G as a product of E and F. Do not automatically pipeline the loops, process the loops in their full form without tiling. Run the loop iterations one after the other. For the last calculation of G from E and F, execute loop iterations sequentially but specify [#pragma ACCEL PARALLEL FACTOR] with an 'auto' option and value of 7 for the second loop.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a HLS C function named \"kernel_3mm\" that takes as arguments five two-dimensional arrays A, B, C, D, E, and F, and three integers ni, nj, nk, nl, and nm. The function treats this as a hardware-accelerated kernel. Inside the function, perform three multiplication steps: first, perform a matrix multiplication between A and B and store the result in E. Annotate this loop so it won't automatically pipeline, it runs entirely without tiling, and iteration runs sequentially not in parallel. Repeat the same annotations but flatten the pipeline for the inner loop which performs the actual multiplication. For the second matrix multiplication between C and D, store the result in F with similar annotations but run the innermost loop iterations two at a time. Lastly, perform a matrix multiplication between E and F, store the result in G, but run the innermost loop iterations eight at a time while keeping other loops' annotations similar to previous.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a function called 'kernel_3mm', which accepts integers 'ni', 'nj', 'nk', 'nl', and 'nm' and matrices E, A, B, F, C, D, and G as parameters. Inside this function, all loops should remain in their most expanded form and run one iteration at a time without any parallelism, to be signaled with #pragma ACCEL TILE FACTOR=auto{1}, #pragma ACCEL PARALLEL FACTOR=auto{1}, and #pragma ACCEL PIPELINE auto{off}. The function should perform 3 separate operations. First, compute the matrix multiplication of A and B and store the result in matrix E; for this operation, every single loop will be processed fully without breaking it into smaller chunks or applying parallelism. Second, repeat similar steps for the multiplication of C and D matrices and store the result in matrix F, but allow the deepest loop to execute four iterations in parallel with #pragma ACCEL PARALLEL FACTOR=auto{4}. Finally, perform the multiplication of the E and F matrices and store the result in matrix G, but with 7 iterations of the second loop running in parallel while the deepest loop still runs four iterations in parallel. Treat this function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a kernel function named 'kernel_3mm' in HLS code that takes nine parameters which includes size of the matrices 'ni', 'nj', 'nk', 'nl', 'nm' and five different matrices 'E', 'A', 'B', 'F', 'C', 'D', 'G'. In this function, run three nested loops for matrix multiplication operations. The first loop calculates the product of matrices 'A' and 'B' and stores the result in matrix 'E'. The second loop calculates the product of matrices 'C' and 'D' and stores the result in matrix 'F'. The third loop calculates the product of matrices 'E' and 'F' and stores the result in matrix 'G'. For each of the loops, do not automatically pipeline them, process them in the original form without splitting them into smaller chunks, and run their iterations one after the other, not in parallel using '#pragma ACCEL PIPELINE auto{off}', '#pragma ACCEL TILE FACTOR=auto{1}', '#pragma ACCEL PARALLEL FACTOR=auto{1}' respectively. However, within the innermost loop of second and third main loop, set the parallel factor value to 10 and 8 respectively using '#pragma ACCEL PARALLEL FACTOR=auto{10}' and '#pragma ACCEL PARALLEL FACTOR=auto{8}'.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a function named 'kernel_3mm' that takes nine parameters: five integers (ni, nj, nk, nl, and nm) and four two-dimensional double arrays (E,A,B,F,C,D,G). The function computes the values for E, F, and G with the algorithm E = A * B, F = C * D, and G = E * F in given order. \n\nFor each matrix multiplication computation, use three nested 'for' loops. The outer loops should iterate sequentially without automatic pipelining and with tiling and parallel factors set to single element processing. The innermost loop in the first and third computations should also follow this principle, whereas in the second computation, the innermost loop should process 20 iterations in parallel. \n\nOn the final pass, flatten the computation into a single pass rather than the typical multi-pass pipeline. All computations are to be treated as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Direct the compiler to treat the 'kernel_3mm' function as a hardware kernel for acceleration. Inside this function, implement three matrix multiplications. The first multiplication, between matrices A and B, will result in matrix E. Then, turn off loop pipelining, set the tile factor to 1, and restrict parallelization factor to 1 for the processing of this operation. Next, conduct multiplication between matrices C and D to form matrix F, following the same pragma instructions but allowing parallelization factor to increase to 2 for the most inner loop. Lastly, multiply matrix E against F to generate matrix G. Turn off automatic optimization for the pipeline and set the tile factor to 1 for the outer loops. But for the most-inner for loop, set the factor of parallelization to auto or 50. Make sure all these operations do not carry out in parallel and the loop should not be factored into smaller parts.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a C function named 'kernel_3mm' with the parameters of five integers: 'ni', 'nj', 'nk', 'nl', 'nm', and seven double 2D arrays: 'E', 'A', 'B', 'F', 'C', 'D', 'G'. This function should be treated as a hardware kernel for acceleration. In this function, perform the following operations:\n\n1. Calculate the product of matrices 'A' & 'B' and store it in matrix 'E'. For these operations, do not pipeline the loops and process them in their original form not breaking them into smaller pieces. Run the iterations of loops one after the other instead of parallel.\n\n2. Calculate the product of matrices 'C' & 'D' and store it in matrix 'F'. Similar to the first set, do not pipeline the loops. But for the inner loop, make it happen as a flattened pipeline. The iterations of the loops will not be performed in parallel.\n\n3. Calculate the product of matrices 'E' & 'F' and store it in matrix 'G'. Here, the outer loop is not to be pipelined. For the main loop, set the parallel factor to '7' and inside this loop, set the parallel factor to '16'.\n\nFor each of the '#pragma ACCEL' attributes used, enable auto selection for optimal values.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Build a hardware-accelerated kernel function named 'kernel_3mm' that takes 7 arrays and 5 integers as parameters. Start with array multiplication E:=A*B. Make sure this loop isn't automatically pipelined and process the loop iteration sequentially instead of in parallel, maintain this loop in its original form instead of subdividing it. Then do the same process for multiplication F:=C*D but this time parallel the inner process into 20 smaller processes. Then finally, do it again for G:=E*F but now parallelize the inner loop into 10 smaller processes. In each inner loop, initialize the targeted array's element to 0.0 before accumulating the product of corresponding elements from two used arrays. The functions, iterations, and other processes need to follow in the specific order of the provided HLS C codes.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a C function called `kernel_3mm` that operates as a hardware kernel for acceleration. It should accept nine parameters: five integers `ni`, `nj`, `nk`, `nl`, `nm` and four 2D double arrays `E`, `A`, `B`, `F`, `C`, `D`, `G`. The function should perform three main operations: First, calculate the matrix multiplication of `A` and `B` and store it in `E`. Second, calculate the product of `C` and `D` and store it into `F`. Third, perform a matrix multiplication of `E` and `F`, storing the result in `G`. In each step of computation, specify different #pragma values: prevent automatic pipelining of the loops, generate the loop in its original form without splitting into smaller parts, run the iterations of each loop one after the other, not in parallel. The innermost loop of each operation, however, should run in parallel by a factor of 12 for the first operation, 32 for the second, and 50 for the third operation.\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function called `kernel_3mm` where two intermediate matrices `E` and `F` and a resultant matrix `G` are computed from two matrix multiplications. First, `E` is the product of matrices `A` and `B`, then `F` is the product of matrices `C` and `D`, and lastly, `G` is the product of `E` and `F`. This function will treat as a hardware kernel for acceleration. In each nested loop, set the pipeline and tile factor attributes to the automatic, \"off\", or \"flatten\" states and set the parallel factor to auto, indicating each loop will not automatically pipeline, the iterations will not break into smaller chunks, and will run one after the other, not in parallel. However, in the final nested loop for computing `G`, the parallel factor will be set to 7 and 50 respectively, to allow for parallel execution of certain elements.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware accelerated kernel function named \"kernel_3mm\". This function should take in array values E, A, B, F, C, D, G and five integers ni, nj, nk, nl, nm. Inside this function, initialize two integer variables i and j. \n\nCompute the matrix multiplication of A and B, store it in array E but prevent its automatic pipelining, force it to run in its original form without breaking into smaller chunks, and ensure its loop iterations run sequentially rather than in parallel. The same conditions should also apply when calculating the two inner loops. But for the third inner loop, run its iterations in groups of 10 in parallel.\n\nSimilarly, perform the matrix multiplication of arrays C and D, and store the result in array F. All outer and immediate inner loops should not be automatically pipelined, neither should they be broken into smaller chunks and should execute sequentially. However, the third inner loop iterations should run in groups of 32 simultaneously.\n\nFinally, multiply the arrays E and F together and store the result in the array G. Similar to the previous computations, prevent automatic pipelining and chunk breaking of the outer loop and adjacent loop, and run their iterations in a sequential manner. Yet, in the third loop, allow its iterations to execute in groups of 50 concurrently.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware-accelerated function called 'kernel_3mm'. As input the function takes integer values 'ni', 'nj', 'nk', 'nl', 'nm' and 2D double arrays E[40][50], A[40][60], B[60][50], F[50][70], C[50][80], D[80][70], G[40][70]. The function starts by declaring indices i, j, k.\n\nIn the first for-loop, set directives that don't automatically pipeline this loop, process it in its original form without breaking it into smaller chunks and run iterations one after the other, not in parallel. In the second-level for-loop, for each [i][j] element of array E, initialize it to 0.0 and then add the product of corresponding elements from A and B (outer product).\n\nIn the second main for-loop, set the same outer loop directives. For each [i][j] element of array F, initialize it to 0.0 and then add the product of corresponding elements from C and D (outer product). \n\nIn the third main for-loop, follow the same initial directive for outer loop but for the second level for-loop, set the directive to allow iterations to run up to 5 times in parallel. For each [i][j] element of array G, initialize it to 0.0 then add the product of corresponding elements from E and F (outer product). Throughout, use appropriate #pragma values indicated.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a new hardware accelerated kernel function named \"kernel_3mm\" with nine parameters: five integers (ni, nj, nk, nl, nm), and four 2-D arrays (E[40][50], A[40][60], B[60][50], F[50][70]), and two other 2D matrices C[50][80] , D[80][70] and G[40][70]. The code should execute 3 separate operations: a matrix multiplication of A and B, storing the result in E; another matrix multiplication of C and D, storing the result in F; and finally, a matrix multiplication of E and F, storing the result in G. \n\nFor each loop, do not automatically pipeline, process the loop without breaking into smaller chunks, and run the loop iterations one after the other, not in parallel (use 'off', '1', '1' as the factors respectively for PIPELINE, TILE and PARALLEL pragmas. Do not run in parallel within the innermost loop (use '1' for PARALLEL Factor) for the first and second operations, but allow parallel execution up to 50 iterations for the third operation( use '50' for PARALLEL Factor).\nPlease note that the function should not return anything.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a C function named 'kernel_3mm'. This function is intended to function as a hardware kernel for acceleration. Include parameters of 5 integer variables (ni, nj, nk, nl, nm) and 7 multidimensional arrays (E, A, B, F, C, D, G). The first operation is to multiply matrices A and B. The result should be assigned to E. Consequently, prevent this loop from being automatically pipelined. The loop should not be broken into smaller parts but processed in its complete form, and all iterations of the loop should run sequentially, not in parallel. Apply the same conditions for the second operation to multiply matrices C and D and store the result in F but the third level loop can run in parallel. The last operation stores the result of multiplying E and F into matrix G with up to five loop iterations running concurrently.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Instruct the compiler to treat the function 'kernel_3mm' as a hardware kernel function for acceleration. As the function parameters, use the following: five integers labeled ni, nj, nk, nl, nm and six two-dimensional arrays E[40][50], A[40][60], B[60][50], F[50][70], C[50][80], D[80][70], and G[40][70]. Encase the entire function in three pairs of nested 'for' loops. \n\nWithin the first loop, disable automatic pipelining, do not break down the loop into chunks and run loop iterations serially. Likewise, inside the first nested loop perform the same actions but additionally, use the pipeline instruction to flatten nested loops and perform the matrix multiplication of A and B arrays and storing the result in array E.\n\nNext, within the second main loop, also disable automatic pipelining, do not break this loop into chunks and run the loop iterations serially. Additionally, inside the first nested loop, flatten the nested loops and perform the matrix multiplication of C and D arrays, saving the result to array F.\n\nFinally, within the third main loop, disable automatic pipelining, do not break this loop into pieces and execute the loop iterations parallelly by a factor of 7. In the first nested loop, flatten the nested loops and perform the matrix multiplication of E and F arrays, storing the result in array G.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a HLS C function named \"kernel_3mm\" which will take in 5 parameters: integer 'ni', 'nj', 'nk', 'nl', 'nm', and 7 matrix arrays 'E', 'A', 'B', 'F', 'C', 'D', 'G'. Treat this function as a hardware kernel for acceleration. Inside this function, there are three sequences of matrix multiplication operations: E=A*B, F=C*D, and G=E*F. For each multiplication activity, apply nested for-loops with specific pragma settings. Set each loop to not pipeline automatically, to process the loop in its original, full form without breaking it up into smaller chunks, and to run the iterations of the loop one after the other, not in parallel. For last inner loop in second and third multiplication operations, adjust ACCEL PARALLEL FACTOR to auto{20} and auto{5} respectively for potential speed-up.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware accelerated function called 'kernel_3mm' which takes as input integer parameters 'ni', 'nj', 'nk', 'nl', 'nm', as well as six bidimensional arrays 'A', 'B', 'C', 'D', 'E', 'F', and 'G'. The function should implement the following computations in three steps: first, for every [i,j] pair, calculate E[i][j] by summing up over k the product of A[i][k] and B[k][j], while not automatically pipelining this loop and processing it in its original form and in serial form; next, calculate F[i][j] by summing over k the product of C[i][k] and D[k][j], retaining the manual customization of the pipeline, tilesize and parallel factors established previously; finally, calculate G[i][j] by summing over k the product of E[i][k] and F[k][j], keeping the pipeline and tilesize customization identical but adjusting the parallel factor to 7 for this outer loop iteration and to 25 for the inner one.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{25}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "In your C program, please write a function called \"kernel_3mm\". The function should take nine input parameters: five integers (ni,nj,nk,nl,nm) and four two-dimensional double arrays (E[40][50], A[40][60], B[60][50], F[50][70], C[50][80], D[80][70], G[40][70]). Consider this function as a hardware kernel for acceleration.\n\nThe function should perform 3mm computation where the intermediary matrices are calculated as follows: The first matrix E is calculated as a product of A and B. This computation should be done in a nested loop. The outer loop will run 40 iterations and the inner loop will run 50 iterations one after the other, with no parallelization, and in their original, full form without breaking them into smaller chunks. An innermost loop is also present which runs 60 iterations one after the other, and in their original, full form without breaking them into smaller chunks. \n\nNext, the matrix F is calculated by multiplying C and D matrices with same loop factor considerations however, the innermost loops runs with parallel factor 20.\n\nFinally, the matrix G is a product of E and F. This computation is also nested with the outermost and intermediate loop running 40 and 70 iterations respectively in series and in their original, full form without breaking them into smaller chunks. The inner most loop runs 50 iterations in series and in their original, full form without breaking them into smaller chunks. The loops must not be pipelined automatically.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create an HLS hardware kernel function called \"kernel_3mm\". In the function, perform three matrix multiplications: First, multiply matrix A (of size 40x60) with matrix B (of size 60x50) to obtain matrix E; Next, multiply matrix C (of size 50x80) with matrix D (of size 80x70), storing the result in matrix F; Finally, multiply matrix E with matrix F to yield matrix G. Alternatively, run the iterations of the outer and inner loops one after the other, not in parallel - using \"#pragma ACCEL PARALLEL FACTOR=auto{1}\". However, parallelize the computation of the third loops with factors 12, 32, and 50 respectively. Also, process the loops in their original, full form without breaking them into smaller chunks - using \"#pragma ACCEL TILE FACTOR=auto{1}\". Lastly, do not automatically pipeline these loops - using \"#pragma ACCEL PIPELINE auto{off}\".", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a void function named \"kernel_3mm\" which takes as parameters two integer variables (ni, nj), three integer variables (nk, nl, nm) and seven two-dimensional arrays (E[40][50], A[40][60], B[60][50], F[50][70], C[50][80], D[80][70], G[40][70]). This function should be treated as a hardware kernel for acceleration. Inside the function, define integer variables i, j, k for looping through arrays. Perform three major matrix multiplication operations; first, multiply matrices A and B together and store in E, then multiply matrices C and D together and store in F and finally, multiply the resulting matrices E and F together and store in G. Within each of these operations, the outer loops shouldn't be automatically pipelined, they should be processed in their original, full form without breaking them into smaller chunks and run the iterations one after the other, not in parallel. In each of these operations, the innermost loop will iterate in parallel with varying factor; in the first operation it's 12, in the second operation it's 32 and in the last operation, it's 50. Other loops within these operations are to be handled similarly to the outer loops.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a HLS code in C language with the function header as 'void kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])'. The function is treated as a hardware kernel for acceleration. Remember to set these #pragma instructions: the pipelining is disabled, the execution of the loops is not divided into smaller tiles, but is executed in series, from start to finish without parallelization. \n\nThe function encapsulates three major activities: firstly, a nested loop structure multiplies matrices 'A' and 'B' and stores the result in matrix 'E'. Secondly, matrices 'C' and 'D' are multiplied in a similar way, with the result being stored in matrix 'F'. Unlike the first nested loop, set the parallelization factor for the deepest loop to 20. Lastly, matrices 'E' and 'F' are multiplied, with the result being placed in matrix 'G'. In this final pair of nested loops, run two iterations at the same time for the innermost loop.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Generate a C function named 'kernel_3mm' designated as a kernel for hardware acceleration. The function accepts 7 parameters namely 'ni', 'nj', 'nk', 'nl', 'nm', and six 2D arrays 'E', 'A', 'B', 'F', 'C', 'D', 'G'. Inside the function, disable automatic pipelining, prevent loop tiling and ensure loop iterations are not run in parallel for the overall process and for each nested loop context. Perform 3 matrix multiplications in sequence: First, multiply matrices 'A' and 'B' and store the result in matrix 'E'. Second, multiply matrices 'C' and 'D' and store the result in matrix 'F'. Lastly, multiply matrices 'E' and 'F' and store the result in matrix 'G'. Within each loop, initial sum should be set to 0.0 before summing up products of elements in matrices being multiplied. Change parallel factor to 20 and 50 in the second loops of the second and third matrix multiplications respectively.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function \"kernel_3mm\" that takes nine inputs (five integers and four 2D arrays). It will handle matrix operations in three processes (E:= A*B, F:= C*D, and G:= E*F). In all loops, disable automatic pipelining, ensure one task is processed per cycle, do not break loop iterations into smaller chunks, by implementing the '#pragma ACCEL PIPELINE', '#pragma ACCEL TILE FACTOR', and '#pragma ACCEL PARALLEL FACTOR' directives respectively. For the processes execution, use a three-layer nested loop structure ensuring parallel execution of the innermost loops at specified parallelization factors. Treat this function as a hardware kernel for acceleration by including #pragma ACCEL KERNEL at the beginning of the function.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function titled 'kernel_3mm' with the parameters (int ni, int nj, int nk, int nl, int nm, double E[40][50], double A[40][60], double B[60][50], double F[50][70], double C[50][80], double D[80][70], double G[40][70]). This function will be treated as a hardware kernel for acceleration. The function will work on matrix multiplication in three steps. \n\nFirstly, it multiplies matrix A and matrix B and stores the result in matrix E. Set automatic pipelining, tile factor, and parallel factor as 'off', '1', and '1' respectively for the outer loops and the third loop. Secondly, it multiplies matrix C and matrix D storing the results in matrix F. Again, set pipelining, tile factor, and parallel factor as 'off', '1', and '1' respectively for the outer loops while setting the parallel factor as '16' in the third loop which will make the third loop run in parallel in 16 parts.\n\nFinally, it uses the results from the first two steps (matrix E and F) and multiplies them storing the results in matrix G. Set pipelining, tile factor, and parallel factor as 'off', '1' and '1' for the outer loops, but set the parallel factor of the third loop as '16' to allow running of the loop iterations in 16 parallel parts.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware-accelerated kernel function named `kernel_3mm` that takes nine parameters: five integers (`ni`, `nj`, `nk`, `nl`, `nm`) and four 2-dimensional double arrays (`E[40][50]`, `A[40][60]`, `B[60][50]`, `F[50][70]`, `C[50][80]`, `D[80][70]`, `G[40][70]`). In this function, perform matrix multiplication of A and B to produce E, C and D to produce F, and finally E and F to produce G. Use the '#pragma ACCEL' directives to guide the performance of the function. To elaborate, disable automatic pipelining and force each loop to run in its original full form not in smaller chunks and force the iterations of inner loops to run one after the other, not in parallel, determined by the '#pragma ACCEL PIPELINE FLOFF' and '#pragma ACCEL TILE FACTOR=1' and '#pragma ACCEL PARALLEL FACTOR=1' directives respectively. Take a special note that in the final part of the function where G is being produced, use the '#pragma ACCEL PARALLEL FACTOR=4' for the inner-most loop for auto parallelization.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write an HLS kernel function named 'kernel_3mm'. The function takes nine parameters: five integer values 'ni', 'nj', 'nk', 'nl', 'nm', which represent the dimensions of the multi-dimensional arrays, and four double arrays 'E', 'A', 'B', 'F', 'C', 'D', 'G'. This function calculates the product of matrices A and B and assigns it to matrix E, then it calculates the product of matrices C and D and assigns it to matrix F, and lastly, it calculates the product of matrices E and F and assigns it to matrix G. \nAs for #pragma values, set PIPELINE to 'off' for outer loops and to 'flatten' for inner loops. Also, set both TILE and PARALLEL FACTOR to '1' for outer and inner loops, but in the end of F and G computation, set PARALLEL FACTOR to '4' and '7' respectively in the last loop.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a kernel function named 'kernel_3mm' for hardware acceleration. This function takes in nine parameters: five integers 'ni', 'nj', 'nk', 'nl', 'nm', and four 2D double arrays 'E', 'A', 'B', 'F', 'C', 'D' and 'G'.\n\nInside the function, define three integer variables 'i', 'j' and 'k'. Then, perform three sets of nested loop operations to implement matrix multiplications.\n\n1. The first set calculates E = A * B. Don't auto pipeline this loop. Process this loop in its original full form without breaking into smaller chunks and run its iterations one after the other, not in parallel. The inner loop also follows these settings, except that the last inner-most loop allows for parallel computing with a factor of 12.\n\n2. The second set calculates F = C * D. With the same settings as the first set of loops, except the parallel computing factor for the inner-most loop is 32.\n\n3. The last set calculates G = E * F. Also with similar settings, but the parallel computing factor for the outer-most loop is 7 and for the inner-most loop is 50.\n\nPlease ensure the syntax and semantics of the HLS pragmas are correctly used for each of these loop operations.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function called `kernel_3mm` that takes various matrix sizes as inputs, and five 2D arrays `E`, `A`, `B`, `F`, `C`, `D` and `G` as parameters. Indicate that this function should be treated as a hardware kernel for acceleration. In this function, implement three main loop operations. \n\nFirst, instantiate three integer variables `i`, `j`, and `k`. Then, perform the following three matrix multiplications: `E = A * B`, `F = C * D`, and `G = E * F`.\n\nFor the first operation, for each `i` in range 0 to 40, and each `j` in range 0 to 50, set `E[i][j]` to 0.0. Then for each `k` in range 0 to 60, add the product of `A[i][k]` and `B[k][j]` to `E[i][j]`. Throughout these nested loops, follow these directives: do not automatically pipeline these loops, process them in their original full form without breaking them into smaller chunks, and run their iterations one after the other, not in parallel.\n\nRepeat similar steps for the other two operation. In each, ensure that processing directives differ for the innermost loops: in the second operation, allow for 5 iterations to run in parallel, and in the third operation, allow for up to 7 iterations of the outer loop and 5 iterations of the inner loop to execute in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware-accelerated kernel function named 'kernel_3mm' with 5 rows arguments ni, nj, nk, nl, and nm, that performs matrix multiplication on matrices A, B, C, D, E, F, G. The function calculates E = A*B, F = C*D and G = E*F, for the specified sizes of these matrices. Within each nested for loop, the iterations should be performed one after the other and not in parallel. These loops should not be automatically pipelined and should be processed without breaking them into smaller chunks.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a HLS code in C language for a kernel function called \"kernel_3mm\" with input parameters: five integers (ni,nj,nk,nl,nm) and six 2D arrays (E[40][50],A[40][60],B[60][50],F[50][70],C[50][80],D[80][70],G[40][70]). This function involves three matrix multiplication operations labelled as E=A*B, F=C*D, and finally G=E*F. For each multiplication operation, each resulting element is initially set to 0.0, then is computed as a running sum, element by element, of the product of the appropriate elements of the two input matrices, looping over a specific index. Use the pragmas 'ACCEL PIPELINE off', 'ACCEL TILE FACTOR=1', 'ACCEL PARALLEL FACTOR=1' for the outermost and '#pragma ACCEL PIPELINE auto{flatten}', '#pragma ACCEL TILE FACTOR=auto{1}', '#pragma ACCEL PARALLEL FACTOR=auto{1}' for the inner loop in each matrix multiplication. However, for the final multiplication G=E*F, use 'ACCEL PIPELINE off', 'ACCEL TILE FACTOR=1', and 'ACCEL PARALLEL FACTOR=7' for the outermost and 'ACCEL PARALLEL FACTOR=auto{5}' for the inner loop.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a HLS C function with the header 'void kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])', formed as a hardware kernel to execute the matrix multiplications 'E := A*B', 'F := C*D' and 'G := E*F'. Each multiplication process contains 3 nested for-loops, with ACCEL pragmas included to control the loop behavior. In the outer two loops of each multiplication process, explicitly declare that the loops should not be auto-pipelined, should be processed in its original, full form, and iterations should run sequentially. In the innermost loop of process 'E := A*B' and 'F := C*D', run the iterations in parallel with an automatic factor of 32; while in process 'G := E*F', run the iterations in parallel with an automatic factor of 5.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a C function named `kernel_3mm` that is recognized as a hardware kernel for acceleration. This function will manage three matrix multiplications: `E = A * B`, `F = C * D`, `G = E * F`, where each matrix is passed as arguments, with their dimensions `ni, nj, nk, nl, nm` respectively. Each loop iteration for `i` and `j` will be executed sequentially and not broken into smaller chunks. The same applies for loop `k` when calculating matrix E and G. However, for matrix F calculation, allow the loop `k` to run 32 iterations in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware kernel named \"kernel_3mm\" using HLS acceleration pragma. The kernel takes as input several integers: ni, nj, nk, nl, nm and matrices E, A, B, F, C, D, G of specified dimensions. \n\nTo compute the matrix multiplication E=A*B, implement three nested for-loops with i ranging from 0 to 40, j ranging from 0 to 50, and k ranging from 0 to 60. All the computations within the loops should execute sequentially, hence disabling all the loop pipelining, tile parallelism, and loop parallelism.\n\nRepeat similar triple nested for-loop construct to compute the matrix multiplication F=C*D, with i ranging from 0 to 50, j ranging from 0 to 70, and k ranging from 0 to 80. In this case, allow twenty iterations of the innermost loop to run in parallel by setting the ACCEL PARALLEL FACTOR to auto{20}.\n\nLastly, compute the matrix multiplication G=E*F in the same manner as the first two, with i ranging from 0 to 40, j ranging from 0 to 70, and k ranging from 0 to 50, allowing eight iterations of the innermost loop to run simultaneously by setting the ACCEL PARALLEL FACTOR to auto{8}.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a function named 'kernel_3mm' with the parameters 'int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70]'. Treat the function as a hardware kernel for acceleration through '#pragma ACCEL kernel' directive. Once defined, break the process into three main areas: E := A*B, F := C*D, G := E*F. For each process, run the loop iterations sequentially (not in parallel), and process each loop in its original form, without breaking it into smaller chunks. Make sure not to automatically pipeline the loops. For specific loop processes within 'F := C*D' apply '#pragma ACCEL PARALLEL FACTOR' with a factor of 32, and within 'G := E*F', use a parallel factor of 2.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Implement a hardware kernel function named 'kernel_3mm' that takes as input 5 integers (ni, nj, nk, nl, nm), and 7 two-dimensional arrays (E, A, B, F, C, D, G) with varying dimensions. The function performs three operations: First, it multiplies matrices A and B and stores the result in matrix E. Second, it multiplies matrices C and D and stores the result in matrix F. Finally, it multiplies matrices E and F and stores the result in matrix G. Each operation is performed within a nested loop structure. For all loops, use the automatic pipeline setting except for the inner loops, which should have pipelining turned off. All loops should also be processed in their original form using the TILE FACTOR pragma set to 'auto{1}' and run iterations one after the other, not in parallel, using the PARALLEL FACTOR pragma set to 'auto{1}'. The only exceptions to the PARALLEL FACTOR setting are the deepest loops in the second operation which should take a setting of 'auto{2}' and in the final operation which should take a setting of 'auto{32}'.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a C function with the header 'void kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])'. This function is flagged as a hardware kernel for acceleration. The general process of the function is as follows:\n\nFirst, it performs the matrix multiplication of A and B, storing the result in E. The loops in this step are not to be automatically pipelined, tiled, or parallelized, which you can express using '#pragma ACCEL PIPELINE auto{off}', '#pragma ACCEL TILE FACTOR=auto{1}', and '#pragma ACCEL PARALLEL FACTOR=auto{1}' respectively.\n\nThen, it performs the matrix multiplication of C and D, storing the result in F. The outer loops for this step have the same '#pragma' directives as the first step, but the innermost loop can be parallelized with a factor of 16.\n\nFinally, it multiplies the matrices E and F, with the result stored in G. The outer loops for this step have the same '#pragma' directives as the previous steps, but the innermost loop can be parallelized with a factor of 25.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{25}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Craft a C function within a hardware acceleration kernel titled 'kernel_3mm'. Begin with integer variables i, j, and k and reinforce a loop structure for multi-dimensional matrices E, A, B, F, C, D, and G with sizes respectively. Perform a series of matrix operations as follows. Firstly, set 'E' matrix to be the product of 'A' and 'B' matrices by iterating through them and sparing no pipeline and parallelism optimizations, using pipelining factor 'off', tiling factor '1' and parallel factor '1'. Repeat the same optimizations for forming 'F' matrix with 'C' and 'D' matrices. And for the final step where 'G' matrix is the output of 'E' times 'F', adjust the parallel factor for the most outer and most inner loops to '8' and '5' respectively.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a C HLS function called 'kernel_3mm' which takes 7 parameters: five integer values 'ni', 'nj', 'nk', 'nl', and 'nm' and seven 2D double arrays 'E', 'A', 'B', 'F', 'C', 'D', and 'G' with their respective dimensions. Inside the function, define three integer variables 'i', 'j', and 'k'. In the function, you should implement three nested loops in sequence. During each loop sequence, disable automatic pipelining, don't break the loop into smaller chunks (use tiling factor of 1) and run the loop iterations one after the other, not in parallel (use parallel factor of 1). In the first loop sequence, matrix 'E' is the product of matrices 'A' and 'B'. The second loop sequence computes matrix 'F' as the product of matrices 'C' and 'D' but this time use a parallel factor of 32 for the innermost loop. The third loop sequence calculates matrix 'G' as the product of matrices 'E' and 'F'. The function should be treated as a hardware acceleration kernel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function called `kernel_3mm` that takes nine parameters: 5 integers (`ni`, `nj`, `nk`, `nl`, `nm`) and 6 two-dimensional double arrays (`E`, `A`, `B`, `F`, `C`, `D`, `G`). This function will accelerate three matrix multiplications (`A*B`, `C*D` and `E*F`) using specific pragma accelerations. Each matrix multiplication should be preceded by the pragma directives ACCEL PIPELINE, ACCEL TILE FACTOR and ACCEL PARALLEL FACTOR all set to 'off', '1' and '1' respectively. In each multiplication use nested loops such that the two outer loops also use the pragma directives ACCEL PIPELINE, ACCEL TILE FACTOR and ACCEL PARALLEL FACTOR, however set PIPELINE to 'flatten'. In the most inner loop, you only need ACCEL PARALLEL FACTOR set to '1' for `E := A*B`, '4' for `F := C*D` and '50' for `G := E*F`.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function named `kernel_3mm` which accepts nine parameters: Five integer values corresponding to `ni`, `nj`, `nk`, `nl`, 'nm' and four two-dimensional double arrays named `E`, `A`, `B`, `F`, `C`, `D`, and `G`. Ensure this HLS kernel doesn't automatically pipeline any loop and handle all loops in complete forms without decomposing, running iterations not in parallel. Initiate a nested loop expressed in this format 'for (i=0; i<40; i++)' and inside it, another loop in the format 'for (j=0; j<50; j++)'. Inside the nested loop, initialize E[i][j] as 0 and run the inner-most loop iteration 'for (k=0; k<60; k++)' in parallel with a factor of 32. Repeat this process for the loops on 'F:= C*D' but, with loop format as 'for (i=0; i<50; i++)' and nested loop as 'for (j=0; j<70; j++)'. For 'G:= E*F', repeat the process with loop format as 'for (i=0; i<40; i++)' and nested loop as 'for (j=0; j<70; j++)' but run iterations in parallel with a factor of 7 and the inner-most loop iteration 'for (k=0; k<50; k++)' with a factor of 5.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a HLS C function named kernel_3mm which accepts several integer arguments: ni,nj,nk,nl,nm and multiple 2D double arrays E,A,B,F,C,D,G. The function should perform the following tasks:\n1. Compute the matrix multiplication of A and B and store the result in E. For this, do not pipeline the main loop, process it in original form without fragmentation, and run iterations in sequence not in parallel. For the inner loop, use automatic pipelining and parallel factor of 60.\n2. Compute the matrix multiplication of C and D and store the result in F. Similar conditions for the main loop as earlier, apply a parallel factor of 16 for the operation.\n3. Matrix multiplication of E and F is calculated and stored in G. Use a similar loop strategy as earlier, however use automatic flattening for the innermost loop of the section.\nEach task should be treated as a hardware kernel for hardware acceleration using the '#pragma ACCEL kernel' directive.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a function in C language named 'kernel_3mm' to be treated as a hardware kernel for acceleration, which allows parallel processing capability for hardware. This function takes in 'ni', 'nj', 'nk', 'nl', 'nm' as integer inputs and six double type 2D array inputs 'E', 'A', 'B', 'F', 'C', 'D', 'G'. \n\nIn this function, create three separate loops sequentially. \n\nThe first loop multiplies matrices 'A' and 'B' and results are stored in 'E'. This loop should not be automatically pipelined, and should be processed in its original, full form without breaking it into smaller chunks. Run the iterations of this loop one after the other, not in parallel. \n\nFollowing similar steps, the second loop multiplies matrices 'C' and 'D' to yield the matrix 'F'. The only difference being the iterations in the innermost loop should run two at a time. \n\nFinally, the third loop multiplies matrices 'E' and 'F' to generate the matrix 'G'. Similar to the second loop, the iterations in the innermost loop should run two at a time. \n\nEach of these loops are nested, containing three layers of loops, where the outer two layers have a parallel factor of 1, meaning the iterations in the outer two loops go one by one while the innermost loop goes with a certain parallel factor. \n\nClosing the loops and function afterward, complete the kernel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a function named 'kernel_3mm' that takes nine arguments: five integers 'ni', 'nj', 'nk', 'nl' and 'nm', and four 2D arrays 'E', 'A', 'B', 'F', 'C', 'D', 'G'. This function should perform hardware acceleration on the two matrix multiplications E := A * B and F := C * D, and then perform the final matrix multiplication G := E * F. For each loop operation, disable automatic pipelining, ask the process to run in its original form without breaking down into smaller chunks, and execute iterations one after another. There is an exception for the third loop of each matrix multiplication operation, which should run parallel iterations depending on the loop size ('auto{60}' for the first, 'auto{80}' for the second and 'auto{50}' for the third). However, the outer loops of the final matrix multiplication operation should flatten the process. All of this is indicated with '#pragma ACCEL' directives accordingly.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a function named 'kernel_3mm' that takes in nine parameters: five integers (ni, nj, nk, nl, nm) and four two-dimensional double arrays (E, A, B, F, C, D, G). Mark this function as a hardware kernel that the HLS compiler will optimize.\n\nInside the function, initiate three matrices multiplication processes, and execute each using nested for-loops:\n\nFirst, instruct the HLS compiler not to automatically pipeline these loops, process these loops in their original form without breaking them into smaller chunks, and run the iterations of all these loops one after the other, not in parallel.\n\n1) Multiply matrices 'A' and 'B' to obtain matrix 'E'. Initialize each element in 'E' to 0.0 before performing the multiplication. Run the innermost loop in parallel, with a factor of auto{60}.\n\nThen, repeat the same instructions as previously mentioned for the second matrices multiplication.\n\n2) Multiply matrices 'C' and 'D' to produce 'F'. In this case, flatten nested loop iterations into a single loop level to optimize data access pattern for 'F'.\n\nLastly, repeat similar instructions for the third matrices multiplication but with different parallelism factors.\n\n3) Multiply matrices 'E' and 'F' to get 'G'. Use parallel factor auto{7} for the second level loop and auto{16} for the third level loop to allow simultaneous loop iterations.\n\nRemember to disable automatic pipelining for the outer loop of all these matrix multiplication operations.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function called 'kernel_3mm' with input parameters as integer variables 'ni', 'nj', 'nk', 'nl', 'nm' and the double arrays 'E', 'A', 'B', 'F', 'C', 'D' and 'G'. The function should perform matrix multiplication in a specific sequence. First, 'E' should be calculated as the product of 'A' and 'B'. Then, 'F' should be computed as the product of 'C' and 'D'. Lastly, 'G' should be the product of 'E' and 'F'. The function should be treated as a hardware kernel for acceleration. \n\nIn all loops, the iterations should not get automatically pipelined, they should be processed in their original form without breaking them into smaller chunks, and all iterations should run one after the other, not in parallel - denoted by the pragmas ACCEL PIPELINE off, ACCEL TILE FACTOR=1, and ACCEL PARALLEL FACTOR=1 respectively. \n\nOnly in the loop calculating 'F' and 'G', the pragma ACCEL PARALLEL FACTOR should be set to 32 and 4 respectively, which implies that the iterations in only these loops can run in parallel, improving the function's performance.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Design a 'kernel_3mm' kernel function that takes in seven parameters: five integers (ni, nj, nk, nl, nm) and six 2D double arrays E, A, B, F, C, D, and G. First, disable automatic pipelining, set the TILE and PARALLEL FACTORS to 1, and calculate the matrix multiplication of A and B, storing the result in E. Following the same directives, calculate the matrix multiplication of C and D, storing the result in F, but this time use the pipeline directive to flatten the inner loop iterations. Lastly, calculate the matrix multiplication of E and F, storing the result in G and while doing so, allow up to 8 iterations to execute concurrently for the outer loop and up to 16 iterations for the inner loop.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Please write a function named `kernel_3mm` with parameters for the dimensions of 2D arrays `E`, `A`, `B`, `F`, `C`, `D`, and `G`. The function will execute in the following three steps. In these loops, ensure that pipeline and parallel factors are set as specified. \n\n1. Calculate the matrix multiplication of `A` and `B`, and store the result in `E`. This loop iteration should maintain its original form, shouldn't be pipelined automatically, and should run sequentially, not in parallel. However, only the `k` loop iteration can run in parallel up to 60 times.\n\n2. Calculate the matrix multiplication of `C` and `D`, and store the result in `F`. This loop iteration should also maintain its original form, shouldn't be pipelined automatically, and should run sequentially, not in parallel. However, only the 'k' loop iteration can run in parallel up to 16 times.\n\n3. Calculate the matrix multiplication of `E` and `F`, and store the result in `G`. This loop iteration also should maintain its original form and should not be broken down by the compiler for pipelining. But for better latency, an auto{flatten} will be used to analyze and apply the best optimization strategy to pipeline the iterations. In addition, the iterations should run one after the other, not in parallel, but only the 'j' loop iteration can run in parallel up to 7 times.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function named \"kernel_3mm\" and it should be treated as a hardware kernel for acceleration. This function accepts integers ni, nj, nk, nl, nm, and double matrices E, A, B, F, C, D, G as arguments.\n\nFirstly, calculate the product of matrices A and B, and store the result in matrix E. Initiate a loop from i=0 till i<40, disable pipeline for this loop and set the tile factor as well as parallel factor to 1. Within this loop, initiate another loop from j=0 to j<50, and for this loop, enable pipeline, set tile and parallel factors equal to 1 and reset all E[i][j] to 0. A third, innermost loop that runs from k=0 to k<60 will calculate the product of A[i][k] and B[k][j] and increment E[i][j] with the result. Set auto parallel factor to 10 for this operation.\n\nNext, calculate the product of matrices C and D and store the result in matrix F, repeating a similar loop structure as above, but with different ranges and parallel factor- i loop's range is from 0 to 50, j loop's range is from 0 to 70, and k loop's range is from 0 to 80, with a parallel factor of 32.\n \nLastly, calculate the product of matrices E and F and store the result in matrix G, repeating similar loop structures as above but with different ranges and parallel factor- i loop's range is from 0 to 40, j loop's range is from 0 to 70, and k loop's range from 0 to 50, with a parallel factor of 50.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a 'kernel_3mm' function that takes in seven parameters: five integer values 'ni', 'nj', 'nk', 'nl' and 'nm', and seven 2D double arrays 'A', 'B', 'C', 'D', 'E', 'F' and 'G'. This function is to be treated as a hardware kernel for acceleration. In this function, perform matrix multiplication operations in three main steps.\n\n1. For the first step, execute the loop to calculate the product of matrices 'A' and 'B' and store the result in matrix 'E' sequentially without pipelining or parallelizing, and without breaking the loop into smaller parts. \n\n2. The second operation involves calculating the product of matrices 'C' and 'D' and storing the result in matrix 'F'. Similar to the first operation, execute the loop sequentially without pipelining or parallelizing, and without breaking the loop into smaller parts. However, allow the innermost loop's iterations to execute in parallel by a factor of 4.\n\n3. Lastly, compute the product of matrices 'E' and 'F' and store the result in matrix 'G'. In this case, allow the pipelining of the entire loop but disable parallelizing and tiling, ensuring the loop executes in its original, full form without being split into smaller chunks.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a new function named 'kernel_3mm' with integer parameters 'ni', 'nj', 'nk', 'nl', and 'nm' and double 2D arrays 'E', 'A', 'B', 'F', 'C', 'D', and 'G'. This function will be recognized as a hardware kernel by using '#pragma ACCEL kernel'. For the first, second, and third loop, make sure to treat them in their full, unaltered form without any automatic pipelining or parallelism, as indicated by '#pragma ACCEL PIPELINE auto{off}', '#pragma ACCEL TILE FACTOR=auto{1}', and '#pragma ACCEL PARALLEL FACTOR=auto{1}'. For the nested loops within these primary loops, allow automatic pipeline decision with '#pragma ACCEL PIPELINE auto{}', still use '#pragma ACCEL TILE FACTOR=auto{1}' and '#pragma ACCEL PARALLEL FACTOR=auto{1}', but allow a degree of automatic parallelism for the innermost loop in each of the three main loop blocks as dictated by '#pragma ACCEL PARALLEL FACTOR=auto{15}', '#pragma ACCEL PARALLEL FACTOR=auto{32}', and '#pragma ACCEL PARALLEL FACTOR=auto{50}'. These three main loop blocks are performing matrix multiplications E=A*B, F=C*D, and G=E*F respectively.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Implement a function named `kernel_3mm` in C language with parameters including five integers, `ni`,`nj`,`nk`,`nl`,`nm` and seven 2D double arrays, `E`, `A`, `B`, `F`, `C`, `D`, `G`. This function will be treated as a kernel for hardware acceleration. The function will compute matrix multiplications for `E`, `F` and `G`. For each calculation, loops should be handled as follows:\n\n- Don't automatically pipeline (turn off auto pipeline)\n- Don't break the loop into smaller chunks (set TILE FACTOR to 1)\n- Process iterations one after another (set PARALLEL FACTOR to 1)\n\nInside the first and second loop, the same pragmas apply, but while modifying `E[i][j]` and `F[i][j]`, process iterations in parallel with factors of `6` and `80` respectively. \n\nLastly, flatten the computation in the pipeline whilst computing for `G[i][j]`.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a HLS code written in C, specifically for generating a function called 'kernel_3mm'. It undergoes three operations: matrix multiplication between 'A' and 'B' forming 'E', between 'C' and 'D' forming 'F', and between newly formed 'E' and 'F' forming 'G'. Each matrix has respective sizes defined by the parameters ni,nj,nk,nl,nm. The function is a kernel and should be accelerated. For all 'for' loops, turn off automatic pipelining, do not automatically divide these loops into smaller chunks and process their iterations serially, not in parallel. Apply the same rules for all nested loops except that make their iterations run 4 at a time in parallel for the innermost loops in the second and third operations of matrix multiplications.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a HLS kernel function named 'kernel_3mm' that takes in integer inputs 'ni', 'nj', 'nk', 'nl', 'nm' and six 2D matrix inputs 'E', 'A', 'B', 'F', 'C', 'D', 'G'. This function calculates three matrix multiplications E = A*B, F = C*D and G = E*F. \n\nFor each of the three matrix multiplication blocks, use a '#pragma ACCEL' directive to automatically apply a pipeline, tile and parallel factor optimizations of 1 and turn it off later. \n\nIn the inner loop of each block, re-apply '#pragma ACCEL' for pipeline, tile and parallel factor but now the parallel factors are 30, 5, and 5 respectively. Always remember to treat the function as a hardware acceleration kernel by adding '#pragma ACCEL kernel' first.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a C function using HLS pragmas to represent hardware acceleration. Use the function header: 'void kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])'. The function performs three matrix multiplication tasks: E=A*B, F=C*D, G=E*F, where A,B,C,D,E,F, and G are the input matrices. The size of these matrices are defined by ni,nj,nk,nl and nm. For each task, run the corresponding inner loop using 'ACCEL PARALLEL FACTOR' set as 15 for E=A*B, 32 for F=C*D and 50 for G=E*F. The outer loops for these tasks should be handled sequentially ('auto{1}'), and the computation should not be broken into smaller portions ('ACCEL TILE FACTOR' and 'ACCEL PIPELINE' set as 'auto{off}').", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware acceleration function called 'kernel_3mm' which takes in integers ni, nj, nk, nl, nm, and matrices E, A, B, F, C, D, G. First, perform a matrix multiplication A*B and store into E. Do this without automatically pipelining the loop, keeping the processing of the loop in its original form and not running the iterations in parallel. The same process is repeated for F, but this time matrix multiplication is C*D and the PARALLEL FACTOR is set to 'auto{2}'. Finally, perform another parallelized multiplication operation on E and F matrices storing the result in G where the outer loop doesn't automatically pipeline but the inner loop does, however, the iterations will be parallelized with a factor 'auto{50}'.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Implement a function named 'kernel_3mm' designated as a hardware accelerating kernel. This function takes in five dimensional parameters, 'ni', 'nj', 'nk', 'nl', 'nm' and seven 2D arrays 'A', 'B', 'C', 'D', 'E', 'F', 'G'. This function's main process can be divided into three sections, for each matrix multiplication operation of 'E = A*B', 'F = C*D', and 'G = E*F'. For all the processing loops in these sections, turn off default pipeline processing by '#pragma ACCEL PIPELINE auto{off}', maintain their original form without breaking into smaller chunks '#pragma ACCEL TILE FACTOR=auto{1}', and sequentially carry out iterations '#pragma ACCEL PARALLEL FACTOR=auto{1}'. However, in the innermost loop of 'E = A*B', allow up to 60 parallel threads for the iterations. Same as above, the pipeline is flatten for the inner for-loops in 'F = C*D' and 'G = E*F', while 8 parallel threads can be used in the inner-most loop for 'G = E*F' calculation.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function called 'kernel_3mm' to perform three matrix multiplications (E=A*B, F=C*D, G=E*F). The function should take in nine arguments: five integers (ni, nj, nk, nl, nm), and four double arrays (E[40][50], A[40][60], B[60][50], F[50][70], C[50][80], D[80][70], G[40][70]). \n\nFor all three multiplication loops in the kernel, specify the function to be treated as a hardware kernel for acceleration, and ensure the loop iterations are run one after the other while processing each loop in its original full form and not in smaller chunks. Modify the parallel factor for certain nested iterations to achieve desired loop unrolling. Specifically, use '#pragma ACCEL PARALLEL FACTOR=auto{1}' for the majority of loops, use '#pragma ACCEL PARALLEL FACTOR=auto{4}' for the last nested loop when calculating F, and use '#pragma ACCEL PARALLEL FACTOR=auto{2}' for the last nested loop when calculating G.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a kernel function named 'kernel_3mm' which takes in nine parameters, five dimensions 'ni', 'nj', 'nk', 'nl', 'nm' and four 2D double arrays 'E', 'A', 'B', 'F', 'C', 'D' and 'G'. The function first calculates the product of matrices 'A' and 'B' and stores it in 'E'. This operation is processed through a nested loop iteration that doesn't allow for automatic pipelining or loop tiling and runs the iterations sequentially, not in parallel. Similarly, the product of matrices 'C' and 'D' is calculated and stored in 'F'. This operation also doesn't allow for automatic pipelining or loop tiling but the innermost loop's iterations run in parallel with a factor of 20, enhancing execution speed. Lastly, the product of the matrices 'E' and 'F' is computed and stored in 'G'. This operation doesn't allow automatic pipelining or loop tiling and its iterations are run sequentially, not in parallel. The function treats the three main operations as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a device kernel function named 'kernel_3mm' that takes integers ni, nj, nk, nl, nm, and 2-dimensional arrays of doubles E, A, B, F, C, D, G as parameters. In this function, you will perform matrix multiplication in three steps, where E = A*B, F = C*D, and G = E*F. For each series of operations, turn off automatic pipelining and keep the loop in its original full form without dividing it into smaller pieces. Moreover, ensure that the iterations of each loop are processed sequentially rather than in parallel. In the first loop, where E = A*B, set parallel factor to 1. In the second loop, where F = C*D, set parallel factor to 32 for the innermost loop. In the third loop where G = E*F, use a parallel factor of 5 for the innermost loop. After each step of matrix multiplication, ensure that the pipeline is off, and reset tile and parallel factors to 1. Make sure all loops are enclosed within the same scope.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a HLS C code for a hardware kernel function named 'kernel_3mm' with the provided parameters and two-dimensional arrays. The function performs different operations on these arrays using nested loops. Disable automatic pipelining for each loop and process each loop in its original full form without reducing it into smaller chunks. All these loops must run their iterations sequentially, not in parallel except for the third nested loop of the second main loop where parallel factor is set as 4. The operations are E = A*B, F = C*D, and G = E*F performed using three main loops respectively. For each operation, initialize the resulting matrix to zero and then, inside another nested loop, perform the matrix multiplication operation by iterating through rows and columns of the input matrices.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Implement a hardware kernel function named 'kernel_3mm' in which you should perform a series of matrix-multiplication operations with each operation happening in loops. Don't concurrently run the operations in your loops - they should go one after the other. Also, ensure each loop is viewed in its original, full form without any reductions. \n\nThe matrix multiplications are as follows: E = A*B, F = C*D, and G = E*F. Where:\n\n- For E=A*B, use 3 for-loops for variables i, j, and k, where the range of i is 40, the range of j is 50 and the range of k is 60. The multiplication result in A[i][k] * B[k][j] should be accumulated in E[i][j].\n  \n- For F=C*D, use 3 for-loops for variables i, j, and k, Where the range of i is 50, the range of j is 70 and the range of k is 80. The multiplication result in C[i][k] * D[k][j] should be accumulated in F[i][j].\n\n- For G=E*F, use 3 for-loops for variables i, j, and k, where the range of i is 40, the range of j is 70 and the range of k is 50. The multiplication result in E[i][k] * F[k][j] should be accumulated in G[i][j].\n\nNotably, all the loop operations shouldn't run in parallel except for the third loop in each of the matrix multiplications, which should carry out 60, 80 and 50 iterations simultaneously for E, F, and G operations, respectively. Furthermore, in the G=E*F multiplication operation, ensure to flatten the pipeline for better performance.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function called 'kernel_3mm' with parameters 'ni', 'nj', 'nk', 'nl', 'nm' and six double-precision 2D arrays 'E', 'A', 'B', 'F', 'C', 'D' and 'G'. This function will perform three key operations: 'E := A * B', 'F := C * D' and 'G := E * F'. For all, don't apply automatic pipelining, split the loop into its original full form, and execute the iterations one by one, not concurrently. \n\nIn the operation 'E := A * B', for each index 'i' from 0 to 40 and each index 'j' from 0 to 50, initialize 'E[i][j]' to 0.0 then add the product of 'A[i][k]' and 'B[k][j]' to 'E[i][j]' for each index 'k' from 0 to 60. \n\nSimilarly, in the operation 'F := C * D', for each index 'i' from 0 to 50 and each index 'j' from 0 to 70, initialize 'F[i][j]' to 0.0 then add the product of 'C[i][k]' and 'D[k][j]' to 'F[i][j]' for each index 'k' from 0 to 80, though this time let the 'k' loop iterations run concurrently by specifying a parallel factor of 2.\n\nFinally, in the operation 'G := E * F', for each index 'i' from 0 to 40 and each index 'j' from 0 to 70, initialize 'G[i][j]' to 0.0 then add the product of 'E[i][k]' and 'F[k][j]' to 'G[i][j]' for each index 'k' from 0 to 50. For this operation, let the 'k' loop iterations run concurrently with a parallel factor of 4. \n\nIndicate the given function as a hardware kernel for acceleration by using '#pragma ACCEL kernel' at the beginning of the function body.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a function named 'kernel_3mm' using the HLS kernel pragma to indicate that it will be used for hardware acceleration. The function takes in nine parameters: five integers 'ni', 'nj', 'nk', 'nl', 'nm' and four 2D arrays of doubles 'E', 'A', 'B', 'F', 'C', 'D', 'G'. \n\nIn this function, perform the following procedures:\n1. Compute the product of matrices 'A' and 'B', result stored in 'E'. To do this, iterate through each element of 'E' with three nested loops. All loop iterations here should be processed consecutively without pipelining or splitting into smaller chunks - use pipeline, tile, and parallel pragmas all set to OFF or factor 1.\n2. Proceed to compute the product of matrices 'C' and 'D', result stored in 'F'. Again, use three nested loops but modify the parallel pragma in the innermost loop to allow for four simultaneous iterations.\n3. Finally, compute the product of the 'E' and 'F' matrices, result stored in 'G'. Iterate through each element of 'G' with three nested loops like before. However, change the parallel pragma in the innermost loop to handle sixteen simultaneous iterations.\n\nEnd each loop with the appropriate parallel pragma factor.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a C function named 'kernel_3mm' with a hardware kernel pragma for acceleration. The function will take nine arguments: five integer parameters 'ni', 'nj', 'nk', 'nl', 'nm' and four double, 2D arrays 'E', 'A', 'B', 'F', 'C', 'D', 'G'. The function consists of three main block of codes where each block is processing matrix multiplication:\n\n1) In the first block of codes, the element at the intersection of each row of the 'A' matrix and each column of the 'B' matrix is multiplied and then added to find the equivalent element of the 'E' matrix. This calculation is performed by three nested for loops. The outside and middle loops should not be pipelined and should be processed in their actual full form with iterations running one after the other not in parallel. \n\n2) The second block of codes does a similar operation for matrices 'C' and 'D' to generate matrix 'F'. With the same configurations as the first block.\n\n3) In the last block of codes, Matrix 'E' is multiplied by Matrix 'F' to produce Matrix 'G'. The configurations for loop pipelining and parallelization are slightly different here. The inner loop is set with a pragma to run eight iterations of the loop in parallel.\n\nThe pragma \"ACCEL PIPELINE auto{off}\" ensures that the compiler does not automatically pipeline these loops. The pragma \"ACCEL TILE FACTOR=auto{1}\" ensures that the compiler processes the loop in its actual form without breaking it down into smaller chunks. The pragma \"ACCEL PARALLEL FACTOR=auto{1}\" or a higher value shows the number of loop iterations to be run in parallel.\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Design a function named \"kernel_3mm\" that takes as inputs 5 integers (ni, nj, nk, nl, nm) and 7 two-dimensional arrays of double (E, A, B, F, C, D, G). This function is meant to be treated as a hardware kernel for acceleration.\n\nIn the function, there are three main operations:\n\n- First, use a triple nested loop to perform multiplication between arrays A and B, with the output stored in array E. The outer loop of this operation should not be automatically pipelined, should be processed in its original form and its iterations should run sequentially. The inner loops should also be processed in their original form and their iterations should run sequentially. But, the iterations of the third (most inner) loop should be parallelized in blocks of 16.\n\n- Second, perform multiplication between arrays C and D, with the output stored in array F using a similar procedure to the first operation but now, the iterations of the third (most inner) loop should be parallelized in blocks of 32.\n\n- Finally, perform multiplication between arrays E and F, with the output stored in array G using a similar procedure to the previous operations but now, the outer loop should have parallelization factor of 7 and the third (most inner) loop should have parallelization factor of 50.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a kernel function named 'kernel_3mm' which accepts nine arguments: five integers named 'ni', 'nj', 'nk', 'nl', 'nm' and four 2D arrays of double named 'E', 'A', 'B', 'F', 'C', 'D', and 'G', sizes 40x50, 40x60, 60x50, 50x70, 50x80, 80x70 and 40x70 respectively. Inside the function, declare three integer variables 'i', 'j', 'k' for iteration purposes. We will execute some matrix operations inside nested loops. \n\nFor all loops, ensure to use pragmas. Disable automatic pipelining, process the loop in its original form without breaking it into smaller chunks and run iterations of the loop one after the other to ensure clearer debugging.\n\nFirstly, calculate matrix multiplication of 'A' and 'B' and assign result to 'E'. Process the last nested loop's iterations in parallel to improve performance.\n\nNext, calculate matrix multiplication of 'C' and 'D' and assign result to 'F'. Again, process the last nested loop's iterations in parallel. \n\nFinally, calculate matrix multiplication of 'E' and 'F', assign the result to 'G'. This time, however, execute only the second loop's iterations in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function called 'kernel_3mm' that receives nine parameters: five integers (ni, nj, nk, nl, nm) and four two-dimensional arrays of doubles (E, A, B, F, C, D, G). Treat this function as a hardware kernel for acceleration. \n\nFor the first loop, initialize index 'i' from 0 to 40 and process its executions in original form, without pipelining, breaking it into smaller chunks or running in parallel. Within this loop, initialize index 'j' from 0 to 50 and process its executions in the same way as of the first loop. Reset the value of 'E[i][j]' to 0.0 and calculate 'E[i][j]' as the sum of the product of 'A[i][k] * B[k][j]', with index 'k' running from 0 to 60.\n\nFor the second loop, reset the value of 'F[i][j]' to 0.0 and calculate 'F[i][j]' as sum of the product of 'C[i][k] * D[k][j]', with index 'k' running from 0 to 80 in parallel. This loop and its nested loop should also be processed without pipelining or breaking into smaller chunks, while their iterations are run parallely.\n\nFor the third loop, reset the value of 'G[i][j]' to 0.0 and calculate 'G[i][j]' as sum of the product 'E[i][k] * F[k][j]', with index 'k' running from 0 to 50 also parallely. Again, process this loop and its nested loop without pipelining or breaking it into smaller chunks, while their iterations are run one after another.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Construct an HLS kernel named 'kernel_3mm'. This kernel should feature a variety of matrix multiplications between 2-dimensional arrays. \n\nThe initial multiplication operation should be A*B, resulting in the E matrix. To achieve this, take a 'for' loop that iterates 'i' from 0 through 40; within this loop, create a nested loop that iterates 'j' from 0 through 50. Then, within the nested loop, create another loop to iterate 'k' from 0 through 60. Within this nested loop, carry out the matrix multiplication operation. Remember to control the loop behavior using pragma accelerator directives: Do not automatically pipeline the loops, process them in their original form without breaking into smaller chunks using a tile factor of 1, and ensure the loop iterations are not handled in parallel by setting a parallel factor of 1.\n\nFollowing this, perform the multiplication operation C*D, resulting in the F matrix. This process closely mirrors the prior multiplication, with similar loop modifications.\n\nFinally, perform the multiplication E*F, resulting in the G matrix, with similar loop structures and modifications as the previous operations. \n\nEnsure each loop operation does not flatten into a single loop using PIPELINE flatten pragma directive where applicable. In the final multiplication segment, the parallel factor should be set to 25 where required.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{25}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a C function named `kernel_3mm` for hardware acceleration that performs three matrix multiplications. Firstly, the function should populate E[i][j] by summing the products of corresponding elements in each ith row of matrix A[40][60] with each jth column of matrix B[60][50]. Secondly, populate F[i][j] by summing the products of corresponding elements in each ith row of matrix C[50][80] and each jth column of matrix D[80][70]. Lastly, populate G[i][j] through same way using matrices E[40][50] and F[50][70]. For all loops, disable automatic pipelining using `#pragma ACCEL PIPELINE auto{off}`, process each loop in its original, full form without breaking it into smaller chunks using `#pragma ACCEL TILE FACTOR=auto{1}`, and ensure iterations of each loop run one after the other and not in parallel using `#pragma ACCEL PARALLEL FACTOR=auto{1}`. Also, for the innermost loops calculating F[i][j] and G[i][j], use `#pragma ACCEL PARALLEL FACTOR=auto{20}` and `#pragma ACCEL PARALLEL FACTOR=auto{32}` respectively to run 20 and 32 iterations in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create an accelerated kernel function named 'kernel_3mm' with matrix dimensions and matrices E, A, B, F, C, D, G as parameters. Proceed by performing three matrix multiplications in sequence: First A*B assigned to E with no automatic pipelining, process in its original form and running iterations serially for outermost loop. Enable automatic pipelining, serial execution and smallest possible chunks for the inner loop and parallel execution set manually to 60 for the innermost loop. Then perform C*D assigned to F with automatic pipelining turned off for outermost loop, enable flattening for pipelining automatic mode and the execution in the smallest possible chunks for the inner loop, with serial execution of iterations for the innermost loop. Lastly assign E*F to G, turning off automatic pipelining and executing in the smallest possible chunks for both outer and inner loops while the parallel factor for outer loop is set manually to 7 and the innermost loop is set manually to 16b.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a HLS C function called \"kernel_3mm\" which is treated as a hardware kernel for acceleration. The function should take nine arguments, five integers and four two-dimensional arrays 'E','A','B','F','C','D','G'. \n\nFirst, turn off automatic pipeline for the three-level nested loops, process the iterations of the loop in its original, full form, and run the iterations one after the other. In the first nested loop, calculate the matrix multiplication of 'A' and 'B' and store the result in 'E'. \n\nSimilarly, compute the matrix multiplication of 'C' and 'D' in the next nested loops and store the result in 'F' but run the innermost loop's iterations automatically and partially in parallel at a factor of 4.\n\nFinally, compute the matrix multiplication of 'E' and 'F' and store the result in 'G' with the innermost loop's iterations running automatically and partially in parallel at a factor of 5. \n\nMake sure to disable automatic pipelining, process the loops in full form, and run the iterations one after the other not in parallel for outer and middle loop in all three block operations.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a C function named 'kernel_3mm' with multiple int parameters (ni, nj, nk, nl, nm) and multiple 2D double arrays (E, A, B, F, C, D, G). This function is regarded as a hardware acceleration kernel. The function calculates matrix multiplications in a series of block loops.\n\nFirst, compute the multiplication of A and B to get E. For all the iterations of each nested loop, you should not automatically pipeline, the loop should process fully without categorized into smaller parts, and the loop iterations should be operated serially. Then, inside the second nested loop, accelerate and compute its loop iterations in parallel with a degree of parallelism of 12.\n\nSecond, compute the multiplication of C and D to get F. Apply the same pragma instructions as mentioned in the first step. However, inside the second nested loop, run its iterations in parallel with a degree of 5.\n\nLastly, compute the multiplication of E and F to get G. Again, in the outermost loop, the pragma directives are the same as before. But for the second loop, ensure it runs fully with flattening its pipelining. In the innermost loop, process its iterations serially.\n\nRemember that for all iterations in each loop, initialize each E[i][j], F[i][j], and G[i][j] to 0 before adding the result of the multiplication operation.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a kernel function named 'kernel_3mm' with parameters as integers 'ni', 'nj', 'nk', 'nl', 'nm' and multiple 2d arrays 'E', 'A', 'B', 'F', 'C', 'D', 'G'. The process of the function involves three matrix multiplication operations. First operation is between matrices 'A' and 'B', the result is stored in 'E'. The second operation is between 'C' and 'D' with the result stored in 'F'. The final operation multiplies 'E' and 'F', storing the result in 'G'. The multiplication needs to be performed in 3 nested for-loops. Make sure the loops aren't automatically pipelined with pragma value 'ACCEL PIPELINE auto{off}', processed in their original form without breaking into smaller chunks with pragma value 'ACCEL TILE FACTOR=auto{1}', and run the iterations one after the other, not in parallel, using pragma value 'ACCEL PARALLEL FACTOR=auto{1}'. However, for the innermost loop of the second and third-main loop, set 'ACCEL PARALLEL FACTOR' to 'auto{20}' and 'auto{50}' respectively to allow some level of parallel execution.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Design a function named 'kernel_3mm' with parameters representing the sizes of matrices E, A, B, F, C, D, and G, and the matrices themselves. The function is to be treated as a hardware kernel for acceleration. \n\nYou will be computing 3 different approximate matrix multiplications: E = A*B, F = C*D and G = E*F - using for loops for each calculation. \n\nFor every loop, disable automatic pipelining, process the loop in its original form without breaking it into smaller chunks and run the iterations one after the other, not in parallel. \n\nHowever, for the innermost loops in the F = C*D and G = E*F calculations, choose the factor of the #pragma ACCEL PARALLEL to be 4 and 16 respectively, allowing these iterations to be processed in parallel to speed up execution.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Generate a C HLS code for a function header named 'kernel_3mm'. The code should treat the function as a hardware kernel for acceleration, not automatically pipeline any of the loops, and process these loops in their original, full form without breaking any into smaller chunks. Run the iterations of these loops one after the other, not in parallel. This code should perform the multiplication of two-dimensional arrays. In the first part, the code multiplies the matrices A and B, and stores the result in E. The second part performs the multiplication of C and D, the result being stored in F. Finally, in the third part, it multiplies E and F, the result being stored in G. The loop iterations in the first part should be sequentially flattened, i.e., run in their original form without parallelizing, and so on for other parts of the loop, but with varying degrees of parallelization.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a hardware acceleration kernel named \"kernel_3mm\" which accepts the dimensions of several 2D arrays (ni,nj, nk, nl and nm) and the arrays E, A, B, F, C, D, and G as input. Inside the function, you will implement three major sections of computation: E = A*B, F = C*D, and G = E*F. For each of these sections, you should have a nested loop construction where the outer loop should be executed using automatic hardware optimization but not in parallel or in a pipeline, as indicated by the off values for pipeline, parallel factor and tile factor pragmas respectively set to 1. The inner loop uses the same pragmas for optimization, but also includes an innermost loop where parallel factor is set to auto. The values for parallel computations can be respectively set to 60, 80, and 50 to tally with the loop ranges in the E = A*B, F = C*D, and G = E*F sections.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a HLS code for a function with the header `void kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])` where the function is identified as a hardware kernel for acceleration. The function includes three main steps which are implemented in loops: firstly, it calculates a matrix `E` from matrices `A` and `B` with a pipeline decision not set automatically, processing the loop in its original full form without division, running each iteration one after another, and processing multiple iterations in parallel. Secondly, it calculates a matrix `F` from `C` and `D` with similar #pragma values as the first loop but with the pipeline iterations set to be flattened. Lastly, it calculates a matrix `G` from `E` and `F`, similar to the first two operations but with the number of iterations processed in parallel set differently.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a HLS C code for a function named 'kernel_3mm' that conducts three matrix multiplications: E=A*B, F=C*D, and G=E*F. Start the code by applying acceleration to the function with the ACCEL kernel pragma. Then, initialize the variables for looping. For each matrix multiplication, let the compiler decide the best way to unroll the loops using the 'auto' parameter for PIPELINE, TILE FACTOR, and PARALLEL FACTOR pragmas. However, within individual loops, turn off automatic pipelining, enable loop tiling in its original form and restrict parallelism to only one concurrent iteration using the 'off' and '1' parameters respectively. The loop iterations should proceed along the order i -> j -> k. Repeat this process for each matrix multiplication within the function. Note that the parallel factor in the last nested loop of the second matrix multiplication should be 'auto{5}'. Ensure to force the compiler to respect the loop's original form and avoid parallel execution for other loops.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a HLS C code function named \"kernel_3mm\" that receives arrays A, B, C, D, E, F and G, along with integer quantities ni, nj, nk, nl and nm as parameters. Treat this function as a hardware kernel for acceleration. Inside this function, perform matrix multiplication operations three times, first, E = A*B; second, F = C*D; third, G = E*F. When iterating each loop to perform these computations, don't automatically pipeline these loops, let them run in their original full form without breaking them into smaller chunks, and ensure the iterations of these loops to run one after the other, not in parallel. Apply this setting to all loops except loops for the computation of F = C*D and G = E*F where the last inner loops can run in parallel limited by factors of 5 and 16 respectively.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function in C with the header \"void kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\", and include the directive \"#pragma ACCEL kernel\" at the top to specify this function as a hardware kernel for acceleration. \n\nThe function body consists of three nested loops that operate sequentially - the first multiplies matrices A and B and stores the result in E, the second multiplies matrices C and D and stores the result in F, and the third multiplies matrices E and F and stores the result in G. \n\nPrecede each loop with \"#pragma ACCEL PIPELINE off\", \"#pragma ACCEL TILE FACTOR=1\", and \"#pragma ACCEL PARALLEL FACTOR=1\", meaning respectively that: each loop should not be automatically pipelined, each loop should be processed in its original, full form without breaking it into smaller chunks and each iteration of each loop should be run sequentially, not in parallel. \n\nInside the third nested loop of the first and second sections, use \"#pragma ACCEL PARALLEL FACTOR=60\" and \"#pragma ACCEL PARALLEL FACTOR=80\" respectively so that iterations of these loops are carried out 60 and 80 times in parallel respectively. \n\nFor the last section, use \"#pragma ACCEL PARALLEL FACTOR=8\" twice within its nested loop so that the respective iterations are carried out 8 times in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function called 'kernel_3mm' which accepts nine parameters - five integers 'ni', 'nj', 'nk', 'nl', 'nm' and four 2D double arrays 'E', 'A', 'B', 'F', 'C', 'D', 'G'. This function is identified as a kernel for hardware acceleration. Within this function, perform matrix multiplication in three distinct steps - firstly, multiply 'A' and 'B' and assign the output to 'E', then multiply 'C' and 'D', outputting to 'F', finally, multiply 'E' and 'F' and result into 'G'. Apply pragma tags for each of these loops, specifying the pipeline, tile factor, and parallel factor. All pipeline operations should not be automatically pipelined, and should process their respective loops in their original, full forms without breaking them into smaller chunks. Maintain iterations to run one after the other, not in parallel, however, when dealing with inner multiplication loops, allow parallel factors to be automatically adjusted to 1 for E-generation, 4 for F-generation, and 10 for G-generation.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function named 'kernel_3mm' with parameters including integers ni, nj, nk, nl, nm, and 2D arrays E, A, B, F, C, D, G. Mark it with '#pragma ACCEL kernel' to treat this function as a hardware kernel for acceleration. The kernel carries out three main matrix multiplication operations \"E=i*j\", \"F=i*j\", and \"G=i*j\" enclosed in a series of loops. Each loop is characterised by '#pragma ACCEL PIPELINE auto{off}', denoting that the loops should not be automatically pipelined, and '#pragma ACCEL TILE FACTOR=auto{1}' indicates that each loop should be processed in its original form without breaking it into smaller chunks, '#pragma ACCEL PARALLEL FACTOR=auto{1}' in general stating not to run the iterations in parallel. However, for the F and G operations, the parallel factors are 4 and 10 respectively, meaning there would run in parallel with a certain degree of concurrency when deriving the F and G matrices.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create an HLS kernel function, named 'kernel_3mm', that will take nine arguments. These inputs are five integers ('ni', 'nj', 'nk', 'nl', and 'nm') and four double precision 2D-arrays ('E', 'A', 'B', 'F', 'C', 'D', and 'G'). Inside this function, declare three scalar integer variables 'i', 'j', and 'k'. We will then perform three major operations: E = A*B, F = C*D, and G = E*F.\n\nFor each operation, disable automatic pipelining, run each iteration one by one (not in parallel), and process each loop in its original unbroken form. For the nested loop of E, F, run their innermost loop with no parallel factor setting. \n\nFor the innermost loop of F, set the parallel factor to auto setting of 4. \n\nFor the innermost loop of G, set the parallel factor to auto setting of 8. \n\nThe above pragmas are denoted by '#pragma ACCEL PIPELINE auto{off}', '#pragma ACCEL TILE FACTOR=auto{1}', and '#pragma ACCEL PARALLEL FACTOR=', with appropriate values respectively.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a C language HLS code for the `kernel_3mm` function that takes in nine parameters; five variables (ni, nj, nk, nl, nm) and four 2-dimensional arrays (A, B, C, D, E, F, G). Make the function to be treated as a hardware kernel for acceleration. \n\nThe function should perform three operations on the arrays:\n\n1. Multiply arrays A and B and store the result in array E. Do not automatically pipeline each loop used in this operation and process each loop one at a time maintaining their original form without breaking them into smaller chunks. Make sure to run the iterations of each loop one after another, not in parallel.\n\n2. Multiply arrays C and D and store the result in array F. Do not automatically pipeline each loop used in this operation and process each loop one at a time maintaining their original form without breaking them into smaller chunks. Make sure to run the iterations of each loop one after another, not in parallel.\n\n3. Multiply arrays E and F and store the result in array G. \n\nIn each operation, pipeline the nested for-loops automatically, maintain their processing in their original forms without breaking them into smaller chunks, and run their iterations one after the other, not in parallel. But for the innermost loops, run some of their iterations in parallel automatically depending on a factor calculated automatically: a factor of 3 for operation 1, a factor of 5 for operation 2 and a factor of 5 for operation 3.\n\nEnsure that the array indices match the corresponding element pairs being manipulated in each operation using a for-loop iteration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a 'kernel_3mm' function which is identified as a hardware kernel by using '#pragma ACCEL kernel'. This function takes in 'ni', 'nj', 'nk', 'nl', 'nm' integers as matrix dimensions and six 2D arrays E[40][50], A[40][60], B[60][50], F[50][70], C[50][80], D[80][70], and G[40][70] as parameters. It should perform the following operations:\n\n1. Multiply matrix A[40][60] with B[60][50] and store the result in E[40][50]. For each row 'i' (ranging from 0 to 40) and column 'j' (ranging from 0 to 50), initialize E[i][j] to zero, then multiply each element in the 'i'th row of A with corresponding element in 'j'th column of B. Apply '#pragma ACCEL PIPELINE auto{off}', '#pragma ACCEL TILE FACTOR=auto{1}' and '#pragma ACCEL PARALLEL FACTOR=auto{1}' on 'i' and 'j' loop iterations to disable automatic pipelining, prevent loop tiling and run loop iterations sequentially.\n\n2. Multiply matrix C[50][80] with D[80][70] and store the result in F[50][70] in a similar way as described in step 1, but for the innermost loop set the parallel factor to '20'.\n\n3. Multiply the resulting matrices E[40][50] and F[50][70] and store the result in G[40][70] following the same process as in step one, but with parallel factor '16' for the innermost loop.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
