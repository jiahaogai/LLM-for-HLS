{"instruction": "Generate HLS code with the following instructions:", "input": "Function Header: \n```c\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n```\n\nDescription:\nThe `kernel_adi` function represents a kernel for the alternating direction implicit (ADI) method. It performs iterations to solve a specific type of partial differential equation.\n\n#pragma Directives:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function header:\nFunction Name: kernel_adi\nParameters: int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60]\n\nDescription:\nThis function implements the Alternating Direction Implicit (ADI) method for solving a two-dimensional parabolic differential equation.\n\n#pragma Directives:\n- #pragma ACCEL PIPELINE auto{off}: Do not automatically pipeline the loops.\n- #pragma ACCEL TILE FACTOR=auto{1}: Keep the loops whole, without dividing them into smaller parts.\n- #pragma ACCEL PARALLEL FACTOR=auto{1}: Execute loop iterations sequentially, not concurrently.\n- #pragma ACCEL kernel: Designate the following function for hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\nDescription:\nThis HLS C code defines a function `kernel_adi` which takes in parameters `tsteps`, `n`, `u`, `v`, `p`, and `q` and performs 2D array operations for a specific timestep calculation.\n\n#pragma Directives:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop to have more control over the loop pipelining.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts or tiles.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n- `#pragma ACCEL kernel`: Designate the following function for hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS (High-Level Synthesis) C code snippet designates the function 'kernel_adi' for hardware acceleration. This function takes in 5 parameters: 'tsteps' of type integer, 'n' of type double, and 3 arrays 'u', 'v', 'p', and 'q' all of type double[60][60]. The function's overall process involves performing the Alternating Direction Implicit (ADI) method for solving a partial differential equation.\n\nInside the function, various loop optimizations are applied using #pragma directives:\n- The outer loop is instructed to not be automatically pipelined.\n- The outer loop is kept unaltered without being divided into smaller parts.\n- The outer loop iterations are executed sequentially, not concurrently.\n- The inner loops of both column and row sweeps are optimized similarly, controlling pipelining, tiling, and parallelization.\n\nThese #pragma directives are guiding the HLS tool on how to optimize the code to achieve the desired hardware implementation, ensuring that the hardware design meets performance, resource, and other constraints.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function Header:\n```C\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nDescription:\nThe `kernel_adi` function takes in parameters `tsteps`, `n`, `u`, `v`, `p`, and `q` to perform iterative calculations for an ADI (Alternating Direction Implicit) method, used for solving partial differential equations.\n\n#pragma Directives:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function header: \n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nDescription: \nThis function `kernel_adi` performs an alternating direction implicit (ADI) computation. It initializes several variables and then iterates through 40 time steps, performing column sweeps and row sweeps. Within each sweep, sub-calculations are performed to update the arrays `u`, `v`, `p`, and `q` following specific mathematical operations.\n\nPragma Directives:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function Header:\n```C\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nDescription:\nThis HLS code defines a function `kernel_adi` which is designated for hardware acceleration. The function takes in parameters `tsteps`, `n`, and arrays `u`, `v`, `p`, and `q` and executes a set of computations using nested loops to perform an ADI (Alternating Direction Implicit) method for solving a 2D heat equation.\n\n#pragma Directives Explanation:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "## Function Header:\nThe function `kernel_adi` takes five parameters: `tsteps` (integer), `n` (integer), `u` (2D array of doubles), `v` (2D array of doubles), `p` (2D array of doubles), and `q` (2D array of doubles).\n\n## Description:\nThe function `kernel_adi` implements the Alternating Direction Implicit (ADI) method for solving a partial differential equation. It initializes various constants and then performs column sweep and row sweep computations for a specified number of time steps. The code includes pragma directives for pipeline control, loop tiling, and loop parallelization.\n\n## Pragma Directives:\n- `#pragma ACCEL PIPELINE auto{off}`: Disable automatic loop pipelining.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep the loop whole without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n- `#pragma ACCEL kernel`: Designate the following function for hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "#### Function Header\nFunction Name: kernel_adi\nParameters:\n1. int tsteps\n2. int n\n3. double u[60][60]\n4. double v[60][60]\n5. double p[60][60]\n6. double q[60][60]\n\n#### Description\nThis function implements the Alternating Direction Implicit (ADI) method to solve a set of partial differential equations. It performs column and row sweeps on the input grid, updating the values based on a specific set of calculations.\n\n#### Pragma Directives\n1. #pragma ACCEL PIPELINE auto{off}: Do not automatically pipeline the loops in order to control the initiation interval of loop iterations.\n2. #pragma ACCEL TILE FACTOR=auto{1}: Keep the loops whole without dividing them into smaller parts for optimization.\n3. #pragma ACCEL PARALLEL FACTOR=auto{1}: Execute loop iterations sequentially, not concurrently, for a specific set of calculations.\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS code represents a C function `kernel_adi` that is designated for hardware acceleration. The function takes several parameters including `tsteps`, `n`, `u[60][60]`, `v[60][60]`, `p[60][60]`, and `q[60][60]`. The overall process of the code involves solving a 2D iterative equation using the Alternating Direction Implicit (ADI) method.\n\nThe code starts by initializing various variables and parameters needed for the calculations. Then, it contains nested loops for column and row sweeps to perform the computation for each time step.\n\nThe following `#pragma` directives are used in the code:\n\n1. `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n2. `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n3. `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n\nThese directives are used to guide the HLS tool in generating the corresponding hardware implementation from the high-level code. By providing these directives, the user specifies how the loops should be handled during the high-level synthesis process, including whether to pipeline the loop, how to apply tiling, and how to parallelize the loop iterations.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nProcess Description:\nThe function `kernel_adi` represents an algorithm for solving the Alternating Direction Implicit (ADI) method. This method is used for solving a system of parabolic partial differential equations and involves column and row sweeps to approximate the solutions at each time step.\n\nExplanation of #pragma Directives:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n- `#pragma ACCEL kernel`: Designate the following function for hardware acceleration.\n\nThis HLS code is designed to optimize the performance of the algorithm when translated into hardware. Each #pragma directive serves to guide the HLS tool in generating efficient hardware description from the provided C code.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The given HLS (High-Level Synthesis) code snippet is a C function named `kernel_adi` that takes in five parameters: `tsteps` of type int, `n` of type int, `u` of type double[60][60], `v` of type double[60][60], `p` of type double[60][60], and `q` of type double[60][60]. The overall process of the function involves performing numerical computations using the Alternating Direction Implicit (ADI) method to solve a two-dimensional heat equation. The function consists of nested loops representing a 2D grid and involves various mathematical calculations, such as updates and standardizations, within the loops.\n\nRegarding the #pragma directives:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The given C function \"kernel_adi\" is designated for hardware acceleration. It takes in integer parameter \"tsteps\" and 2D array parameters \"u\", \"v\", \"p\", and \"q\", each of size 60x60. The function performs the Alternating Direction Implicit (ADI) method for solving a partial differential equation over 40 time steps.\n\nThe function utilizes several #pragma directives to guide the High-Level Synthesis compilation process:\n\n1. '#pragma ACCEL PIPELINE auto{off}': This pragma instructs the compiler not to automatically pipeline the loop, potentially allowing for more fine-grained control during synthesis.\n\n2. '#pragma ACCEL TILE FACTOR=auto{1}': This pragma indicates that the loop should be kept whole without being divided into smaller parts, optimizing it for hardware synthesis.\n\n3. '#pragma ACCEL PARALLEL FACTOR=auto{1}': This pragma specifies that loop iterations should be executed sequentially rather than concurrently, possibly to ensure correct functional behavior given the dependencies in the loop.\n\nIn summary, the provided function \"kernel_adi\" is designed for hardware acceleration and the #pragma directives serve to guide the High-Level Synthesis compilation process by controlling loop pipelining, loop tiling, and loop parallelization.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS code represents a function 'kernel_adi' to be accelerated for hardware implementation. The function takes in five parameters: an integer 'tsteps', an integer 'n', and four 2D arrays of double values 'u', 'v', 'p', and 'q'.\n\nThe overall process of the code involves solving a set of differential equations through iterative calculations for a specific number of time steps.\n\nThe '#pragma' directives in the code provide directives for the HLS tool to optimize the hardware implementation. Specifically, the following directives are used:\n\n- '#pragma ACCEL PIPELINE auto{off}' - This directive instructs the HLS tool not to automatically pipeline the loop, avoiding the automatic breaking down of the loop for concurrent execution.\n\n- '#pragma ACCEL TILE FACTOR=auto{1}' - This directive suggests keeping the loop whole without dividing it into smaller parts, allowing for better hardware utilization and efficiency.\n\n- '#pragma ACCEL PARALLEL FACTOR=auto{1}' - This directive indicates executing loop iterations sequentially, not concurrently, to ensure proper synchronization and data consistency for the hardware implementation.\n\nIn summary, the provided HLS code represents a function to be accelerated for hardware implementation, leveraging specific #pragma directives to guide the HLS tool in optimizing the resulting hardware design.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "### HLS Code Instruction:\n\nFunction Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nBrief Description:\nThe `kernel_adi` function is designed for hardware acceleration and performs the Alternating Direction Implicit (ADI) method to solve a partial differential equation. It involves nested for loops for column and row sweeps to update the `u`, `v`, `p`, and `q` arrays based on certain calculations.\n\n#pragma Directives:\n1. `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline the loops in the code.\n2. `#pragma ACCEL TILE FACTOR=auto{1}`: Keep the loop whole without dividing it into smaller parts.\n3. `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n\nThe code also includes specific pragma directives within the nested loops for column and row sweeps to control pipelining, tiling, and parallelization. These are used to optimize the hardware acceleration and parallel execution of the code.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function Header:\n```c\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n```\n\nDescription:\nThis function, `kernel_adi`, represents the kernel for the ADI (Alternating Direction Implicit) method. It is designed to solve a parabolic partial differential equation using the ADI algorithm. The code performs a series of calculations including initialization and iterations over the 2D arrays u, v, p, and q. The nested loops represent the column and row sweeps, each containing further nested iterations to compute the values of the arrays.\n\n#pragma Directives:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline the loops within the specified block.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep the loops whole, without dividing them into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "## Function Header\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\n## Description\nThe `kernel_adi` function performs an alternating-direction implicit (ADI) method for solving a partial differential equation over a space and time grid. It calculates the values of `u`, `v`, `p`, and `q` for each time step (`tsteps`) and spatial dimension (`n`) based on specified constants and boundary conditions.\n\n## #pragma Directives\n- **#pragma ACCEL PIPELINE auto{off}**: Do not automatically pipeline this loop.\n- **#pragma ACCEL TILE FACTOR=auto{1}**: Keep this loop whole, without dividing it into smaller parts.\n- **#pragma ACCEL PARALLEL FACTOR=auto{1}**: Execute loop iterations sequentially, not concurrently.\n- **#pragma ACCEL kernel**: Designate the following function for hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "#### Function Header:\n**Function Name:** `kernel_adi`  \n**Parameters:**  \n- `tsteps` (integer)  \n- `n` (double)  \n- `u[60][60]` (2D array of doubles)  \n- `v[60][60]` (2D array of doubles)  \n- `p[60][60]` (2D array of doubles)  \n- `q[60][60]` (2D array of doubles)  \n\n#### Description:\nThe function `kernel_adi` performs an iterative computation involving the arrays `u`, `v`, `p`, and `q` based on a set of provided constants and coefficients. It includes column and row sweeps with nested parallel operations and involves calculations for updating the arrays in each iteration.\n\n#### #pragma Directives:\n- `#pragma ACCEL PIPELINE auto{off}`  \n   Translate to: Do not automatically pipeline this loop.\n\n- `#pragma ACCEL TILE FACTOR=auto{1}`  \n   Translate to: Keep this loop whole, without dividing it into smaller parts.\n\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`  \n   Translate to: Execute loop iterations sequentially, not concurrently.\n\n- `#pragma ACCEL kernel`  \n   Translate to: Designate the following function for hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "### Function Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\n### Description:\nThe function `kernel_adi` performs an alternating direction implicit (ADI) method to solve a set of differential equations. It iterates over the 2D arrays `u`, `v`, `p`, and `q` to calculate their values based on the specified mathematical formulas. The process involves column and row sweeps executed over multiple time steps (`tsteps`).\n\n### #pragma Directives:\n1. `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline the loops for parallel execution.\n2. `#pragma ACCEL TILE FACTOR=auto{1}`: Keep the loops whole without dividing them into smaller parts for optimization.\n3. `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently, to ensure data dependencies are maintained.\n4. `#pragma ACCEL PIPELINE auto{}`: Automatically pipeline the inner loops for parallel execution.\n5. `#pragma ACCEL PIPELINE auto{flatten}`: Flatten the loops to facilitate pipelining for parallel execution.\n\nThe given HLS code is designed to be hardware accelerated, with specific optimizations and parallelization strategies indicated using the '#pragma' directives.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The given HLS C code is for a function named **kernel_adi** which takes five parameters: *tsteps* (integer), *n* (integer), *u* (2D array of doubles), *v* (2D array of doubles), *p* (2D array of doubles), and *q* (2D array of doubles).\n\nThe function implements an Alternating Direction Implicit (ADI) solver and computes multi-dimensional partial differential equations.\n\nThe code uses HLS pragmas to specify hardware characteristics, such as loop pipelining, loop tiling, and loop parallelization.\n\nTo translate the #pragma directives into natural language:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n- `#pragma ACCEL kernel`: Designate the following function for hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nProcess Description:\nThe `kernel_adi` function performs the ADI (Alternating Direction Implicit) method for solving a system of partial differential equations. It involves multiple iterations to compute the values of arrays `u`, `v`, `p`, and `q` based on the specified number of time steps and grid dimensions. The computation involves nested loops to perform column and row sweeps, and various mathematical operations on the input arrays.\n\nPragma Directives Explanation:\n- `#pragma ACCEL PIPELINE auto{off}`: This pragma directive disables automatic loop pipelining, indicating that the loops in the code should not be automatically pipelined for hardware acceleration.\n  \n- `#pragma ACCEL TILE FACTOR=auto{1}`: This pragma directive specifies that the loops should remain whole and not be divided into smaller parts for parallel execution.\n\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: This pragma directive indicates that the loop iterations should be executed sequentially rather than concurrently for hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "### Function Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\n### Description:\nThe function `kernel_adi` represents a 2-dimensional heat distribution computation using the Alternating Direction Implicit (ADI) method. It iterates over time steps to calculate the temperature distribution within a grid. The computation involves column and row sweeps, each with nested iterations to update the grid values based on the ADI method formulas.\n\n### #pragma Directives:\n1. `#pragma ACCEL PIPELINE auto{off}`: Disable automatic loop pipelining.\n2. `#pragma ACCEL TILE FACTOR=auto{1}`: Keep the loops whole without dividing them into smaller parts.\n3. `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n\nThese directives control the hardware synthesis optimizations for the specific loops in the code, ensuring that the code is translated effectively for hardware acceleration.\n\nThe function is designated for hardware acceleration through `#pragma ACCEL kernel`, indicating that it should be synthesized into hardware for improved performance.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS code snippet is a function called \"kernel_adi\" with the following signature: \n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\nThis function implements an ADI (Alternating Direction Implicit) algorithm for solving a partial differential equation. The process involves initializing various constants and then executing a nested loop structure to perform column and row sweeps for a specific number of time steps.\n\nThe `#pragma` directives in the code are used to provide guidance to the HLS tool when generating hardware accelerators. Here are their natural language interpretations:\n\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n- The innermost loop also has a `#pragma ACCEL PARALLEL FACTOR=auto{2}` directive, indicating that loop iterations can be executed concurrently in groups of 2.\n\nThese directives help specify how the loops should be transformed into hardware, indicating whether to pipeline them, how to partition them, and whether to execute iterations concurrently or sequentially. The `#pragma ACCEL kernel` designates the \"kernel_adi\" function for hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS (High-Level Synthesis) code snippet is a C function called \"kernel_adi\" that is designated for hardware acceleration. The function takes in five parameters: an integer 'tsteps', another integer 'n', and three 2D arrays of doubles named 'u', 'v', 'p', and 'q', each of size 60x60.\n\nThe function performs the Alternating Direction Implicit (ADI) method for solving a partial differential equation, over 40 time steps, for a 2D grid of size 60x60. This method involves column and row sweeps, where values of 'u', 'v', 'p', and 'q' are updated based on surrounding values.\n\nThe HLS directives in the code control the hardware synthesis process. The \"#pragma ACCEL PIPELINE auto{off}\" directive indicates that specific loops should not be automatically pipelined, probably because they require additional control logic. The \"#pragma ACCEL TILE FACTOR=auto{1}\" directive keeps the loop whole, without dividing it into smaller parts, and \"#pragma ACCEL PARALLEL FACTOR=auto{1}\" ensures that loop iterations are executed sequentially, not concurrently, preserving the original order of operations for this specific code. Additionally, inside some nested loops, there are directives for parallelization with different factors, indicating the degree of parallelism to achieve for those specific loop nests.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function header:\nFunction Name: kernel_adi\nParameters: \n- tsteps (integer)\n- n (integer)\n- u[60][60] (2D double array)\n- v[60][60] (2D double array)\n- p[60][60] (2D double array)\n- q[60][60] (2D double array)\n\nDescription:\nThe function `kernel_adi` takes several parameters and implements the Alternating Direction Implicit (ADI) numerical method to solve a partial differential equation iteratively over a certain number of time steps. The method involves column and row sweep processes and relies on several mathematical calculations involving the parameters, arrays, and constants.\n\n#pragma Directives:\n1. #pragma ACCEL PIPELINE auto{off}: Do not automatically pipeline the loops within the specified code block to allow for explicit control over pipelining.\n2. #pragma ACCEL TILE FACTOR=auto{1}: Keep the loops whole without dividing them into smaller parts, allowing the hardware to process entire iterations at once.\n3. #pragma ACCEL PARALLEL FACTOR=auto{1}: Execute loop iterations sequentially, not concurrently, ensuring the correct order of computations.\n\nThese directives are used to guide the synthesis process, providing instructions for loop pipelining, loop tiling, and loop parallelization to optimize the hardware acceleration of the code.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nDescription:\nThe `kernel_adi` function represents the implementation of the Alternating Direction Implicit (ADI) method for solving a system of partial differential equations representing a physical process. The function iterates over time steps to update the values of `u`, `v`, `p`, and `q` arrays according to the ADI method.\n\n#pragma Directives:\n1. `#pragma ACCEL PIPELINE auto{off}` - Disable automatic loop pipelining to maintain the original loop execution order and optimize for resource utilization and timing.\n2. `#pragma ACCEL TILE FACTOR=auto{1}` - Keep the loop whole without dividing it into smaller parts to maximize data locality and minimize memory access overhead.\n3. `#pragma ACCEL PARALLEL FACTOR=auto{1}` - Execute loop iterations sequentially, not concurrently, to ensure correct and deterministic execution order and data dependencies.\n\nThe function is designated for hardware acceleration using the `#pragma ACCEL kernel` directive, indicating that it will be targeted for synthesis to hardware accelerators.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS code is a C function named `kernel_adi` with parameters `int tsteps`, `int n`, `double u[60][60]`, `double v[60][60]`, `double p[60][60]`, and `double q[60][60]`. This function is designated for hardware acceleration. The function implements the Alternating Direction Implicit (ADI) method for solving a partial differential equation.\n\nThe #pragma directives in the code provide instructions for high-level synthesis. Specifically, the directives control loop pipelining, loop tiling, and loop parallelization to optimize the hardware design.\n\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline the loops to maximize parallelism.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep the loops whole, without dividing them into smaller parts, to maintain loop iteration dependencies.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently, to avoid synchronization overhead.\n\nThese directives guide the HLS tool in generating hardware that properly reflects the specified optimizations, ensuring efficient hardware implementation and high-performance execution.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS C code defines a function `kernel_adi` used for hardware acceleration, taking in 5 parameters: `tsteps`, `n`, `u[60][60]`, `v[60][60]`, `p[60][60]`, and `q[60][60]`. The function performs the Alternating Direction Implicit (ADI) method for solving a 2D Heat Equation over 40 time steps on a 60x60 grid.\n\nThe code uses several `#pragma` directives to guide the HLS synthesis:\n\n- `#pragma ACCEL PIPELINE auto{off}`: This pragma tells the synthesis tool not to automatically pipeline the code, meaning that loops should not be split into stages that are executed simultaneously.\n\n- `#pragma ACCEL TILE FACTOR=auto{1}`: The pragma suggests keeping whole loop iterations, without dividing them into smaller parts, allowing the tool to decide the appropriate tiling factor.\n\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: This pragma indicates that loop iterations should be executed sequentially, not concurrently. It also provides an auto value for the factor, letting the tool determine the best parallelization factor based on the code and constraints.\n\nThe function contains nested loops, each with its own set of pragma directives adjusting the parallelization and pipelining behavior. Overall, the code aims to optimize the hardware synthesis process by guiding the tool on how to parallelize and pipeline the loops for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS (High-Level Synthesis) code snippet is intended for hardware acceleration. It defines a function 'kernel_adi' with five parameters: 'tsteps' of type int, 'n' of type int, 'u' of type double [60][60], 'v' of type double [60][60], 'p' of type double [60][60], and 'q' of type double [60][60].\n\nThe function calculates a set of iterative computations using a nested loop structure to update the arrays 'u', 'v', 'p', and 'q'. It involves several mathematical operations on these arrays to simulate a physical process, with specific operations conducted sequentially across time steps.\n\nDirective translations:\n- '#pragma ACCEL PIPELINE auto{off}' - This instructs the compiler not to automatically pipeline the loop, implying that the loop should be executed sequentially instead of concurrently.\n- '#pragma ACCEL TILE FACTOR=auto{1}' - This directive indicates that the loop should remain whole, without being divided into smaller parts or tiles, potentially optimizing memory usage.\n- '#pragma ACCEL PARALLEL FACTOR=auto{1}' - This specifies that loop iterations should be executed sequentially, not concurrently.\n\nIt's important to note that the comments, '#pragma scop', and '#pragma endscop' lines are not standard HLS directives and may not have an impact on the hardware synthesis process.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "### Function Header:\nFunction Name: kernel_adi\nParameters:\n- tsteps (integer)\n- n (integer)\n- u[60][60] (2D array of doubles)\n- v[60][60] (2D array of doubles)\n- p[60][60] (2D array of doubles)\n- q[60][60] (2D array of doubles)\n\n### Process Overview:\nThe function `kernel_adi` implements the Alternating Direction Implicit (ADI) method for solving a specific set of differential equations. It involves iterative processes of column sweep and row sweep over the input data set represented by 2D arrays. The method calculates and updates values based on the specified mathematical formulae.\n\n### Pragma Directives Translations:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n- `#pragma ACCEL kernel`: Designate the following function for hardware acceleration.\n\nThis natural language interpretation should provide clear and concise guidance for someone looking to understand and modify the provided HLS code.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "### Function Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\n### Function Description:\nThe `kernel_adi` function represents a kernel for the Alternating Directions Implicit (ADI) method, a numerical technique for solving partial differential equations. It performs finite difference computations on a 2D grid using column and row sweeps for a specified number of time steps.\n\n### #pragma Directives Translation:\n- `#pragma ACCEL PIPELINE auto{off}`: This directive disables automatic pipelining for the following loop, indicating that the loop should not be parallelized automatically.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: This directive keeps the loop whole, without dividing it into smaller parts, with a tile factor of 1 indicating no tiling strategy is applied.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: This directive instructs the loop to execute iterations sequentially rather than concurrently, with a parallel factor of 1 indicating sequential execution.\n\nThe other `#pragma` directives within the code specify similar operations for nested loops, such as disabling automatic pipelining, keeping the loop whole, and executing iterations sequentially.\n\nOverall, the code aims to optimize the implementation of the ADI method, controlling loop parallelization, tiling, and pipelining to maximize hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "**Function Header:**\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\n**Description:**\nThe `kernel_adi` function performs the ADI (Alternating Direction Implicit) method for solving a partial differential equation. It iterates over the data arrays `u`, `v`, `p`, and `q` for a specified number of time steps `tsteps` and grid size `n`, and performs calculations based on the grid parameters and predefined constants.\n\n**Pragma Directives:**\n1. `#pragma ACCEL PIPELINE auto{off}` - This directive specifies that automatic pipelining for the loop should be turned off, meaning the loop should not be automatically divided into smaller stages to improve throughput.\n2. `#pragma ACCEL TILE FACTOR=auto{1}` - This directive indicates that the loop should be kept whole without dividing it into smaller parts, with the size factor being determined automatically.\n3. `#pragma ACCEL PARALLEL FACTOR=auto{1}` - This directive specifies that loop iterations should be executed sequentially, not concurrently, with the factor being determined automatically.\n\nThese pragma directives provide guidance to the high-level synthesis tool on how to optimize the hardware implementation of the specified loops, including pipelining, loop tiling, and parallelization.\n\nThe nested pragma directives within the loops provide further optimization hints for the hardware implementation, specifying how the inner loops should be parallelized, tiled, and pipelined to achieve efficient hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided code is a C function named `kernel_adi` that is designated for hardware acceleration, as indicated by the `#pragma ACCEL kernel` directive. This function takes five parameters: `tsteps` of type `int`, `n` of type `int`, `u` of type `double[60][60]`, `v` of type `double[60][60]`, `p` of type `double[60][60]`, and `q` of type `double[60][60]`.\n\nThe overall process of the function involves performing an ADI (Alternating Direction Implicit) iteration for solving a set of differential equations. The function contains nested loops for column sweep and row sweep, with various computations and assignments within these loops. The performance of these loops is optimized for hardware acceleration using various `#pragma` directives.\n\nThe `#pragma` directives used in the code can be interpreted as follows:\n\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n\nAdditionally, within the nested loops, there are further directives specific to parallelization, tiling, and pipelining to optimize the hardware acceleration of the computations at different levels within the function.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided C code contains a kernel function \"kernel_adi\" with five input parameters, namely tsteps, n, u, v, p, and q, with respective data types. The function performs an iterative computation involving various mathematical operations on input arrays u, v, p, and q, using specific constants and loop structures for column and row sweeps.\n\nThe #pragma directives are used to optimize and map the loop iterations onto hardware accelerators. The first set of #pragma directives with \"PIPELINE\", \"TILE\", and \"PARALLEL\" control the behavior of the outer loop, while the subsequent set of #pragma directives with the same keywords control the behavior of the inner loops.\n\n1. `#pragma ACCEL PIPELINE auto{off}`: This directive ensures that the loop is not automatically pipelined, meaning that the loop iterations are not processed concurrently but sequentially.\n\n2. `#pragma ACCEL TILE FACTOR=auto{1}`: This directive suggests keeping the loop whole without dividing it into smaller parts, possibly indicating that the loop should not be transformed into a tiled loop.\n\n3. `#pragma ACCEL PARALLEL FACTOR=auto{1}`: This directive implies that the loop iterations should be executed sequentially, not concurrently, which is likely to prevent parallelization.\n\nOverall, the kernel_adi function along with the provided directives aims to control loop optimizations and parallelization strategy for hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS (High-Level Synthesis) code is written in C and defines a function named `kernel_adi` with the following parameters: `tsteps` of type int, `n` of type int, `u` of type double[60][60], `v` of type double[60][60], `p` of type double[60][60], and `q` of type double[60][60].\n\nThe function encompasses a simulation of the Alternating Direction Implicit (ADI) method used for solving partial differential equations over a 2D grid. It assigns values to various double variables and then enters a series of nested loops for the ADI computation, which involve both column and row sweeps over the 2D grid.\n\nThe provided #pragma directives translate as follows:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n- The `#pragma ACCEL kernel` simply designates the following function for hardware acceleration.\n\nThese directives offer guidance to the HLS tool on how to optimize the hardware implementation of the given code, particularly in terms of loop pipelining, loop tiling, and loop parallelization.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS code is a C function named `kernel_adi` that is designated for hardware acceleration. The function takes five parameters: `tsteps` (an integer), `n` (an integer), `u` (a 60x60 2D array of doubles), `v` (a 60x60 2D array of doubles), `p` (a 60x60 2D array of doubles), and `q` (a 60x60 2D array of doubles).\n\nThe overall process of the code involves setting up and solving a set of equations for a specific mathematical model. The code performs column and row sweeps with nested loops to update the arrays `v` and `u` based on the values of other arrays `p` and `q`. This process is iterated for 40 time steps.\n\nRegarding the #pragma directives, they provide instructions for the HLS tool to optimize the hardware design. For example, `#pragma ACCEL PIPELINE auto{off}` specifies not to automatically pipeline certain loops, while `#pragma ACCEL TILE FACTOR=auto{1}` directs to keep the loops whole without dividing them into smaller parts. The `#pragma ACCEL PARALLEL FACTOR=auto{1}` indicates that loop iterations should be executed sequentially, not concurrently.\n\nIn summary, the `kernel_adi` function is designed for hardware acceleration and includes specific directives to guide the HLS tool in optimizing the hardware design for efficient execution of the mathematical model.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS (High-Level Synthesis) code is a C function named `kernel_adi` with the following parameters: `int tsteps`, `int n`, `double u[60][60]`, `double v[60][60]`, `double p[60][60]`, and `double q[60][60]`. This function implements the alternating direction implicit (ADI) method for solving a specific partial differential equation. The overall process involves initializing various constants and arrays, and then performing column and row sweeps for a number of time steps.\n\nThe `#pragma` directives in the code provide instructions for the HLS synthesis tool. Firstly, `#pragma ACCEL PIPELINE auto{off}` is used to specify that the loop should not be automatically pipelined to improve throughput. Next, `#pragma ACCEL TILE FACTOR=auto{1}` indicates that the loop should be kept whole, without dividing it into smaller parts. Additionally, `#pragma ACCEL PARALLEL FACTOR=auto{1}` specifies that loop iterations should be executed sequentially, not concurrently.\n\nThe function `kernel_adi` is designated for hardware acceleration using `#pragma ACCEL kernel`.\n\nIn summary, the `kernel_adi` function performs the ADI method for solving a partial differential equation and includes specific directives for HLS synthesis, such as pipeline control, loop tiling, parallelism, and hardware acceleration designation.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nDescription:\nThe function `kernel_adi` is designed for hardware acceleration and contains a two-dimensional iterative algorithm. It implements the Alternating Direction Implicit (ADI) method to solve a system of coupled partial differential equations. The process involves multiple iterations over a 60x60 grid for a specified number of time steps. The calculation involves updating the values of arrays `u`, `v`, `p`, and `q` based on a set of predefined formulas and coefficients.\n\n#pragma Directives:\n1. `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n\n2. `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n\n3. `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "### Function Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\n### Description:\nThe `kernel_adi` function represents the Alternating Direction Implicit (ADI) method for solving a specific type of partial differential equation. The code is written for hardware acceleration using High-Level Synthesis (HLS) in C. It performs a series of calculations and updates on the input matrices `u`, `v`, `p`, and `q` for a given number of time steps `tsteps`.\n\n### Pragmas Explanation:\n1. `#pragma ACCEL PIPELINE auto{off}` - Disable automatic pipeline optimization for the following loop.\n2. `#pragma ACCEL TILE FACTOR=auto{1}` - Keep the loop whole without dividing it into smaller parts.\n3. `#pragma ACCEL PARALLEL FACTOR=auto{1}` - Execute loop iterations sequentially, not concurrently.\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "### Function Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\n### Function Description:\nThis function `kernel_adi` performs the Alternating Direction Implicit (ADI) method to solve a 2D heat equation. It iterates through time steps and performs column-wise and row-wise sweep calculations to update the variables `u`, `v`, `p`, and `q` according to the ADI method.\n\n### #Pragma Directives Explanation:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n- `#pragma ACCEL kernel`: Designate the following function for hardware acceleration.\n\nBy translating these directives into natural language explanations, it helps clarify the intended optimizations and hardware designations for the code.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS (High-Level Synthesis) code is a C function `kernel_adi` with the following signature:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\nThe function represents an iterative simulation of a numerical algorithm called the Alternating Direction Implicit (ADI) method. The algorithm solves a system of partial differential equations using alternating implicit sweeps in the column and row directions.\n\nThe code includes several `#pragma` directives to guide the compiler in the hardware synthesis process:\n- `#pragma ACCEL PIPELINE auto{off}`: This directive instructs the compiler not to automatically pipeline the loop, meaning the iterations will not be overlapped to improve throughput.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: This directive indicates that the loop should remain whole without being divided into smaller parts, potentially improving data reuse.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: This directive specifies that loop iterations should be executed sequentially, not concurrently, possibly to prevent data dependency issues and improve accuracy in hardware execution.\n- `#pragma ACCEL kernel`: This directive designates the following function for hardware acceleration, indicating that the function should be synthesized into hardware for efficient execution.\n\nIn summary, the `kernel_adi` function represents an ADI method simulation, and the `#pragma` directives provide guidance for hardware synthesis, including pipelining, loop partitioning, parallelism, and hardware acceleration designation.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "To generate the provided HLS code snippet written in C, follow these instructions. The `kernel_adi` function should be designed for hardware acceleration.\n\nThe function header should be as follows:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nDescription of the code's process:\nThe code initializes various variables and then enters into a nested loop structure. Within this structure, it performs column and row sweeps, calculating and updating values in the multidimensional arrays `u`, `v`, `p`, and `q` based on a complex set of equations.\n\nFurthermore, to guide the synthesis tool in optimizing the hardware implementation of the function, the following `#pragma` directives should be translated into natural language explanations:\n\n1. `#pragma ACCEL PIPELINE auto{off}` : This indicates that the loop should not be automatically pipelined, meaning that the iterations should not be overlapped.\n\n2. `#pragma ACCEL TILE FACTOR=auto{1}` : This directive instructs the tool to keep this loop whole, without dividing it into smaller parts, potentially allowing for more efficient hardware resource usage.\n\n3. `#pragma ACCEL PARALLEL FACTOR=auto{1}` : This specifies that loop iterations should be executed sequentially, not concurrently, potentially simplifying the hardware design.\n\nBy following these instructions and considering the natural language explanations for the `#pragma` directives, a hardware-optimized implementation of the `kernel_adi` function can be created.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "#### Function Header:\n```C\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n```\n\n#### Description:\nThe `kernel_adi` function is designed for hardware acceleration, and it performs an alternating direction implicit (ADI) method for solving a system of partial differential equations. The code initializes various variables and then performs nested loops for column and row sweeps, updating the arrays `u`, `v`, `p`, and `q` iteratively based on the specified mathematical formulas.\n\n#### #pragma Directives:\n1. `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline the loop for `t`.\n2. `#pragma ACCEL TILE FACTOR=auto{1}`: Keep the loop whole, without dividing it into smaller parts.\n3. `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently, for the loop with variable `t`.\n4. `#pragma ACCEL PIPELINE auto{flatten}`: Automatically pipeline and flatten the loop for variable `i` in the column sweep.\n5. `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently, for the innermost loop in the column sweep.\n6. `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline the loop for variable `i` in the row sweep.\n7. `#pragma ACCEL PARALLEL FACTOR=auto{2}`: Execute loop iterations sequentially, not concurrently, for the loop with variable `i` in the row sweep.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS code is a C function named \"kernel_adi\" with the specific function header: void kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60]). This function performs the ADI (Alternating Directions Implicit) method for solving a numerical problem. It takes in several parameters including the time steps, array sizes, and 2D input and output arrays.\n\nThe code also includes several #pragma directives that are used to guide the High-Level Synthesis tool in generating hardware-friendly accelerators. Here is how to interpret the #pragma directives:\n\n1. `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n2. `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n3. `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n4. `#pragma ACCEL PARALLEL FACTOR=auto{32}`: Execute loop iterations concurrently using a parallel factor of 32.\n5. `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop (inside a nested loop).\n6. `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently (inside a nested loop).\n7. `#pragma ACCEL PARALLEL FACTOR=auto{2}`: Execute loop iterations concurrently using a parallel factor of 2 (inside a nested loop).\n8. `#pragma ACCEL PARALLEL FACTOR=auto{4}`: Execute loop iterations concurrently using a parallel factor of 4 (inside a nested loop).\n\nThese #pragma directives guide the HLS tool on how to optimize the hardware synthesis process for the given C function.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "### Function Header\nFunction: kernel_adi\nParameters: \n- tsteps (int)\n- n (int)\n- u[60][60] (double)\n- v[60][60] (double)\n- p[60][60] (double)\n- q[60][60] (double)\n\n### Description\nThis function performs the Alternating Direction Implicit (ADI) method, an iterative numerical algorithm used to solve partial differential equations. It includes column and row sweeps to update the values of arrays v and u.\n\n### Pragmas\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently\n\nThe inner loops contain additional pragmas:\n- `#pragma ACCEL PARALLEL FACTOR=auto{2}`: Execute loop iterations concurrently using a factor of 2\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently\n- `#pragma ACCEL PARALLEL FACTOR=auto{16}`: Execute loop iterations concurrently using a factor of 16\n\nBy understanding these pragmas and the overall function process, the hardware synthesis tool can appropriately map the C code to hardware implementation.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\nDescription:\nThis HLS code snippet defines a function `kernel_adi` that performs the Alternating Direction Implicit (ADI) method for solving the 2D heat equation in a 60x60 grid over `tsteps` time steps. The process involves column and row sweeps to update the grid values at each time step.\n\n#pragma directives:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n- `#pragma ACCEL kernel`: Designate the following function for hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The given HLS C code snippet defines a function `kernel_adi` that is intended for hardware acceleration. The function takes in five parameters: an integer `tsteps`, an integer `n`, and three 2D arrays of doubles - `u`, `v`, `p`, and `q` - all of size 60x60. The overall process of the code involves performing computations for the Alternating Direction Implicit (ADI) method to solve a partial differential equation.\n\nThe #pragma directives in the code provide instructions for high-level synthesis. Specifically, the `#pragma ACCEL PIPELINE \"auto{off}\"` directive specifies that a certain loop should not be automatically pipelined, the `#pragma ACCEL TILE FACTOR=\"auto{1}\"` directive indicates that a loop should not be divided into smaller parts for parallel execution, and the `#pragma ACCEL PARALLEL FACTOR=\"auto{1}\"` directive specifies that loop iterations should be executed sequentially, not concurrently.\n\nIn essence, the code is preparing the function for hardware acceleration and providing optimization hints to the HLS tool for effective synthesis.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The function `kernel_adi` takes in four parameters: `tsteps` of type `int`, `n` of type `int`, `u` of type `double[60][60]`, `v` of type `double[60][60]`, `p` of type `double[60][60]`, and `q` of type `double[60][60]`. The code performs calculations for an ADI (Alternating Direction Implicit) method, using nested loops for column and row sweeps. Additionally, the code includes a series of calculations for various variables. \n\nThe `#pragma` directives can be interpreted as follows:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n- `#pragma ACCEL PIPELINE auto{}`: Automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n- `#pragma ACCEL PARALLEL FACTOR=auto{8}`: Execute 8 iterations of the loop concurrently\n- `#pragma ACCEL PARALLEL FACTOR=auto{4}`: Execute 4 iterations of the loop concurrently\n- `#pragma ACCEL PIPELINE auto{flatten}`: Automatically pipeline this loop, and flatten inner loops into a single loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n\nThis description provides a detailed yet succinct explanation of the function header, the code's process, and the `#pragma` directives.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS code snippet is a C function called \"kernel_adi\" meant for hardware acceleration. It takes in five parameters: an integer \"tsteps\" and four 2D arrays \"u\", \"v\", \"p\", and \"q\", each with a size of 60x60. This function implements an iterative process to solve a specific type of linear equation using a technique known as alternating direction implicit (ADI) method.\n\nThe code includes multiple #pragma directives to guide high-level synthesis tools in optimizing the hardware implementation. The specific translations for the given directives are as follows:\n\n1. `#pragma ACCEL PIPELINE auto{}`: Automatically pipeline the loops to enable concurrent execution of loop iterations.\n2. `#pragma ACCEL TILE FACTOR=auto{1}`: Keep the loops whole without dividing them into smaller parts for optimization.\n3. `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially instead of concurrently.\n\nThere are also additional #pragma directives within nested loops that follow similar patterns and are intended to optimize those specific parts of the code.\n\nIt's important to note that the provided code may undergo further transformations or optimizations during the actual synthesis process based on the specific HLS tool and its configurations.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS code represents a function `kernel_adi` with several parameters, which is designated for hardware acceleration. The function contains a series of calculations and loop iterations, where the main process involves performing column and row sweeps with nested loop operations.\n\nTo break it down, the pragma directives can be interpreted as follows:\n\n1. `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n2. `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n3. `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n\nThese directives provide guidance to the HLS tool on how to process and optimize the specified loops for hardware acceleration.\n\nYou should ensure that the function, `kernel_adi`, is invoked with appropriate arguments and integrated into the larger application for hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS (High-Level Synthesis) code written in C is a function named 'kernel_adi' that is designated for hardware acceleration. It takes in five parameters: tsteps, n, u, v, p, and q. The overall process of the code involves implementing the Alternating Direction Implicit (ADI) method to solve a system of partial differential equations over a time range. This is achieved through iterative column and row sweeps for a specified number of time steps.\n\nThe relevant #pragma directives in natural language are as follows:\n- '#pragma ACCEL PIPELINE auto{off}': Do not automatically pipeline this loop.\n- '#pragma ACCEL TILE FACTOR=auto{1}': Keep this loop whole, without dividing it into smaller parts.\n- '#pragma ACCEL PARALLEL FACTOR=auto{1}': Execute loop iterations sequentially, not concurrently.\n\nThe main function 'kernel_adi' includes additional loops with the same #pragma directives, defining the behavior of each loop for hardware synthesis.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nDescription:\nThe function `kernel_adi` takes in parameters `tsteps`, `n`, `u`, `v`, `p`, and `q` and performs the Alternating Direction Implicit (ADI) method for solving a specific problem. Within this function, various calculations are performed using nested loops to update the arrays `u`, `v`, `p`, and `q` based on the specified algorithm.\n\nTranslation of #pragma directives:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "### Function Header:\n**Function Name:** kernel_adi  \n**Parameters:**  \n- tsteps (integer)  \n- n (integer)  \n- u[60][60] (2D array of double)  \n- v[60][60] (2D array of double)  \n- p[60][60] (2D array of double)  \n- q[60][60] (2D array of double)  \n\n**Description:**  \nThe kernel_adi function performs a computation using the Alternating Direction Implicit (ADI) scheme to solve a set of coupled partial differential equations over 40 time steps. The computation involves column and row sweeps on multidimensional arrays, manipulating the values according to the specified equations.\n\n**Pragma Directives:**  \n- `#pragma ACCEL PIPELINE auto{off}` - Do not automatically pipeline the loop for 't' iterations.  \n- `#pragma ACCEL TILE FACTOR=auto{1}` - Keep the loop whole without dividing it into smaller parts.  \n- `#pragma ACCEL PARALLEL FACTOR=auto{1}` - Execute loop iterations sequentially, not concurrently.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function Header:\n```\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nDescription:\nThis function `kernel_adi` is designed for hardware acceleration and takes in several parameters including `tsteps`, `n`, and arrays of doubles `u`, `v`, `p`, and `q`. The function performs a series of calculations using the given parameters and arrays within nested loops.\n\n#pragma Directives Translated:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS code defines a function 'kernel_adi' that is designated for hardware acceleration. This function takes in five parameters: 'tsteps' of type integer, 'n' of type double, and three 2D arrays of type double, 'u[60][60]', 'v[60][60]', 'p[60][60]', and 'q[60][60]'. The process involves performing the Alternating Direction Implicit (ADI) method for solving a 2D heat equation. \n\nThe code contains several #pragma directives to guide the high-level synthesis process. The '#pragma ACCEL PIPELINE auto{off}' directive indicates that the loop should not be automatically pipelined. The '#pragma ACCEL TILE FACTOR=auto{1}' directive specifies that the loop should not be divided into smaller parts and should remain whole. The '#pragma ACCEL PARALLEL FACTOR=auto{1}' directive indicates that loop iterations should be executed sequentially, not concurrently.\n\nIn summary, this HLS code aims to accelerate the computation of the ADI method by guiding the synthesis process with specific directives to optimize performance and resource utilization.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nDescription:\nThe function `kernel_adi` performs the Alternating Direction Implicit (ADI) method for solving a system of partial differential equations. The process involves iterating over a 2D grid for a given number of time steps, performing calculations on the grid elements based on neighboring values.\n\nPragma Directives:\n- `#pragma ACCEL PIPELINE auto{}`: Automatically pipeline the loop to improve throughput by allowing overlapped execution of loop iterations.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep the loop whole without dividing it into smaller parts, potentially for better memory access patterns.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently, possibly to ensure data dependencies are handled correctly.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nOverall process:\nThe function `kernel_adi` is designed for hardware acceleration. It takes in parameters `tsteps`, `n`, and arrays `u`, `v`, `p`, and `q`. Inside the function, there are calculations involving the elements of these arrays over a series of iterations, which are then subject to hardware acceleration directives.\n\n#pragma directives:\n1. `#pragma ACCEL PIPELINE auto{}` - Automatically pipeline the loop for optimized parallelism.\n2. `#pragma ACCEL TILE FACTOR=auto{1}` - Keep this loop in its entirety without dividing it into smaller parts.\n3. `#pragma ACCEL PARALLEL FACTOR=auto{1}` - Execute loop iterations sequentially, not concurrently.\n\nThe code includes nested loops and various hardware acceleration pragma directives to optimize the performance of the computation. Each pragma directive provides specific instructions for how the respective loops should be accelerated and parallelized.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "### Function Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\n### Description:\nThe function `kernel_adi` takes in several parameters including `tsteps`, `n`, and arrays `u`, `v`, `p`, and `q` of size 60x60. It applies the Alternating Direction Implicit (ADI) method to solve a partial differential equation by performing column and row sweep iterations in a computational loop. The process involves performing specific calculations for each array element over a given number of time steps.\n\n### #pragma Directives:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function Header: \n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nDescription: \nThe `kernel_adi` function performs the Alternating Direction Implicit (ADI) method to solve a partial differential equation. It iterates through time steps and uses column sweep and row sweep to update the values of arrays `u`, `v`, `p`, and `q` based on the specified equations.\n\n#pragma Directives:\n1. `#pragma ACCEL PIPELINE auto{off}` - Do not automatically pipeline the following loop.\n2. `#pragma ACCEL TILE FACTOR=auto{1}` - Keep the following loop whole, without dividing it into smaller parts.\n3. `#pragma ACCEL PARALLEL FACTOR=auto{1}` - Execute loop iterations sequentially, not concurrently.\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function Header: \n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nDescription:\nThe `kernel_adi` function represents an implementation of the Alternating Direction Implicit (ADI) method for solving a 2D heat equation. The function iterates over time steps to update the values of 2D arrays `u`, `v`, `p`, and `q` based on the ADI method.\n\n#pragma Directives Explanation:\n- `#pragma ACCEL PIPELINE auto{off}`: This pragma instructs the compiler not to automatically pipeline the loop, i.e., the iterations of the loop are not overlapped to improve throughput.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: This pragma indicates that the loop should not be divided into smaller parts (tiled) for parallel processing. It is kept whole.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Instructs the compiler to execute loop iterations sequentially, not concurrently, with a factor of 1.\n- `#pragma ACCEL kernel`: Designates the following function for hardware acceleration, indicating that the function should be targeted for synthesis to hardware.\n\nOverall, the code represents a hardware acceleration of the given ADI method by utilizing the specified pragma directives to control parallelism, tiling, and pipelining for efficient synthesis to hardware.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "### Function Header\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\nThis function `kernel_adi` takes in parameters `tsteps`, `n`, `u[60][60]`, `v[60][60]`, `p[60][60]`, and `q[60][60]`.\n\n### Description\nThis function implements the Alternating Direction Implicit (ADI) method for solving a 2D heat equation. It performs a column sweep and a row sweep iteration for a given number of time steps using various mathematical operations on the input arrays `u`, `v`, `p`, and `q`.\n\n### Pragmas Explained\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n- `#pragma ACCEL kernel`: Designate the following function for hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "### Function Header:\nFunction: `void kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])`\n\nParameters:\n- `tsteps` (integer) - number of time steps\n- `n` (integer) - size parameter\n- `u[60][60]` (2D array of doubles) - input/output array\n- `v[60][60]` (2D array of doubles) - input/output array\n- `p[60][60]` (2D array of doubles) - input/output array\n- `q[60][60]` (2D array of doubles) - input/output array\n\n### Description:\nThe provided HLS code snippet represents a function `kernel_adi` for the alternating direction implicit (ADI) method. The function performs a series of computations based on the ADI method to solve a particular problem.\n\n### Pragmas:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n\nThe code contains additional pragmas within the loops, such as `#pragma ACCEL PARALLEL` and `#pragma ACCEL PIPELINE`, which instruct the compiler on how to parallelize and pipeline specific parts of the code for hardware acceleration. Each pragma provides detailed instructions for the hardware synthesis tool to optimize and map the code to a hardware description language.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The given C code is a kernel function called 'adi' designed for hardware acceleration. It has five input parameters: an integer 'tsteps' and four 2D arrays of double data type - 'u', 'v', 'p', and 'q', each with a dimension of 60x60.\n\nThe code initializes several variables and then applies a set of computations within nested for loops. Each loop is annotated with pragma directives to optimize the code for high-level synthesis.\n\nThe '#pragma ACCEL PIPELINE auto{off}' directive instructs the tool to not automatically pipeline the loop. The '#pragma ACCEL TILE FACTOR=auto{1}' directive designates that the loop should not be divided into smaller parts. The '#pragma ACCEL PARALLEL FACTOR=auto{1}' directive specifies to execute the loop iterations sequentially rather than concurrently.\n\nWithin the for loop, the code applies further pragma directives to optimize specific sections of the code, such as pipelining, tiling, and parallelization, using similar pragma instructions as described above.\n\nOverall, the kernel_adi function contains algorithmic calculations designed to be optimized through the use of specific pragma directives, as mentioned above. These pragma directives aim to guide the high-level synthesis tool in generating efficient hardware implementation from the C code.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "### Function Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\n### Description:\nThe `kernel_adi` function is designed for hardware acceleration and takes in several parameters including `tsteps`, `n`, and multidimensional arrays `u`, `v`, `p`, and `q`. The process involves performing the Alternating Direction Implicit (ADI) scheme for solving a partial differential equation over a number of time steps. This involves column and row sweeps, each consisting of nested loops for updating various arrays based on specific formulas over the grid domain.\n\n### Pragmas:\n1. `#pragma ACCEL PIPELINE auto{off}`: This pragma specifies to turn off automatic loop pipelining for the subsequent loop, meaning that the hardware should not automatically optimize the loop by overlapping iterations.\n\n2. `#pragma ACCEL TILE FACTOR=auto{1}`: This pragma instructs to keep the subsequent loop whole, without dividing it into smaller parts, where the factor specifies the tile size.\n\n3. `#pragma ACCEL PARALLEL FACTOR=auto{1}`: This pragma directs the hardware to execute loop iterations sequentially, not concurrently, where the factor specifies the degree of parallelism.\n\nThe various instances of these pragmas are applied to control the hardware optimization and parallelism strategies for different nested loops within the function.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\nDescription:\nThe function `kernel_adi` performs the Alternating Direction Implicit (ADI) method to solve a partial differential equation over a grid. It sets up coefficients and then iteratively applies column and row sweeps to update the values of array elements `u`, `v`, `p`, and `q` based on the given time steps `tsteps` and grid size `n`.\n\n#pragma Directives:\n1. `#pragma ACCEL PIPELINE auto{off}`\n   - Do not automatically pipeline this loop.\n2. `#pragma ACCEL TILE FACTOR=auto{1}`\n   - Keep this loop whole, without dividing it into smaller parts.\n3. `#pragma ACCEL PARALLEL FACTOR=auto{1}`\n   - Execute loop iterations sequentially, not concurrently.\n   \nThe pragma ACCEL KERNEL designates the following function for hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The given HLS code is a C function named `kernel_adi` with the following parameters: `int tsteps`, `int n`, `double u[60][60]`, `double v[60][60]`, `double p[60][60]`, and `double q[60][60]`. It encompasses a set of mathematical operations related to the ADI (Alternating Direction Implicit) method, iterating over a two-dimensional grid.\n\nThe code starts by initializing various variables and then enters a series of nested loops, representing the column and row sweeps of the ADI algorithm. Within these loops, computations are performed for updating and standardizing the grid values.\n\nThe given pragma directives can be interpreted as follows:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n- `#pragma ACCEL kernel`: Designate the following function for hardware acceleration.\n\nOverall, this HLS code is designed to harness hardware acceleration for the ADI method code, ensuring efficient processing through appropriate pragma directives.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "### Function Header\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\n### Description\nThe function `kernel_adi` represents the implementation of the Alternating Direction Implicit (ADI) method, which is used for solving partial differential equations. It operates over a 60x60 grid for a specified number of time steps. The function performs column and row sweeps, calculating the values of u, v, p, and q according to the ADI method.\n\n### Pragmas Explanation\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n- Inside the loops, there are additional pragmas with similar explanations for pipeline, tile, and parallelization directives.\n\nThese pragmas provide specific instructions to the High-Level Synthesis (HLS) tool for optimizing the hardware implementation. They control how loops are parallelized, pipelined, and tiled for efficient hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "### Function Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\n### Description:\nThe `kernel_adi` function represents the implementation of the Alternating Direction Implicit (ADI) method for solving a particular set of partial differential equations. The function takes in various parameters, including the number of time steps, array sizes, and multiple 2D arrays as input. The overall process involves applying the ADI method to solve the given differential equations in a specific iterative manner.\n\n### Pragmas:\n1. `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline the following loop to allow for potential manual optimization.\n2. `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole without dividing it into smaller parts to preserve iteration dependencies.\n3. `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently, to maintain data integrity.\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Sure, here is the natural language instruction for the provided HLS code:\n\nFunction Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nDescription:\nThe `kernel_adi` function represents a simulation of the Alternating Direction Implicit (ADI) method in a 2D heat diffusion problem. The function performs a series of computations over a 2D grid for a specified number of time steps. It involves various calculations and iterations using nested loops to update the grid values.\n\n#pragma Directives Explanation:\n1. `#pragma ACCEL PIPELINE \"off\"` - Do not automatically pipeline this loop.\n2. `#pragma ACCEL TILE FACTOR=1` - Keep this loop whole, without dividing it into smaller parts.\n3. `#pragma ACCEL PARALLEL FACTOR=1` - Execute loop iterations sequentially, not concurrently.\n4. `#pragma ACCEL kernel` - Designate the following function for hardware acceleration.\n\nThe natural language explanations for the #pragma directives aim to provide a clear understanding of how the HLS tool should treat the loops and functions within the code in order to achieve the desired hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "To generate the HLS code written in C, follow these steps. First, designate the following function for hardware acceleration using the `void kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])` function header. This particular function is responsible for performing the Alternating Direction Implicit (ADI) method for solving partial differential equations.\n\nFor the loop inside the function, there are several #pragma directives to be considered:\n- The `#pragma ACCEL PIPELINE auto{off}` directive instructs to disable automatic loop pipelining, allowing the loops to be explicitly managed for optimization.\n- The `#pragma ACCEL TILE FACTOR=auto{1}` directive suggests keeping the loop whole without dividing it into smaller parts for optimization purposes.\n- The `#pragma ACCEL PARALLEL FACTOR=auto{1}` directive indicates that loop iterations should be executed sequentially instead of concurrently for optimized execution.\n\nWithin the function, there are two major loops\u2014Column Sweep and Row Sweep\u2014each containing similar #pragma directives to control loop optimization and parallelization.\n\nFollowing these instructions will enable the generation of HLS code suitable for hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nDescription:\nThe `kernel_adi` function is designated for hardware acceleration and takes in several parameters including the number of time steps (`tsteps`), the size `n`, and multiple 2D array variables `u`, `v`, `p`, and `q`. The function performs a series of calculations within nested loops to solve a 2D implicit heat conduction problem over a specified number of time steps.\n\nPragma Directives:\n- `#pragma ACCEL PIPELINE auto{}`: Automatically pipeline the following loop for parallelism.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep the following loop whole without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n\nFor the inner loops, additional pragmatic directives are included:\n- `#pragma ACCEL PIPELINE auto{flatten}`: Automatically flatten the loops to improve parallelism.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n\nOverall, the hardware directives aim to optimize parallelism and pipelining to enhance the performance of the specified nested loops within the `kernel_adi` function when synthesized to hardware.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nBrief Description:\nThe function `kernel_adi` implements the Alternating Direction Implicit (ADI) method to solve a system of partial differential equations. It iterates for a certain number of time steps to update the values in the 2D arrays `u`, `v`, `p`, and `q` based on specified computations, coefficients, and boundary conditions.\n\nTranslated #pragma Directives:\n1. `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n2. `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n3. `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n4. `#pragma ACCEL PIPELINE auto{flatten}`: Flatten the loop to facilitate parallelism and pipelining.\n\nPlease note that the `auto{off}` and `auto{1}` placeholders used in the translated directives suggest that the factor value and pipeline options are determined automatically by the synthesis tool.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS (High-Level Synthesis) code snippet entails a function named `kernel_adi` with the following parameters: `tsteps` of type int, `n` of type int, `u` 2D array of doubles, `v` 2D array of doubles, `p` 2D array of doubles, and `q` 2D array of doubles. The function serves a large numerical computation that involves several matrix operations within nested loops, aimed at solving a system of partial differential equations using an Alternating Direction Implicit (ADI) scheme.\n\nThe HLS (High-Level Synthesis) pragmas in the code primarily instruct the compiler on how to optimize hardware acceleration for the loops. The code includes '#pragma ACCEL kernel' which designates the `kernel_adi` function for hardware acceleration. Additionally, various '#pragma ACCEL PIPELINE auto{off}', '#pragma ACCEL TILE FACTOR=auto{1}', and '#pragma ACCEL PARALLEL FACTOR=auto{1}' directives have been used to guide the compiler on loop pipelining, loop partitioning, and loop parallelization, respectively.\n\nFor example, the pragma '#pragma ACCEL PIPELINE auto{off}' communicates to the compiler to not automatically pipeline the loop, while '#pragma ACCEL TILE FACTOR=auto{1}' instructs to keep the loop whole without dividing it into smaller parts. Furthermore, '#pragma ACCEL PARALLEL FACTOR=auto{1}' indicates to execute loop iterations sequentially, not concurrently.\n\nBy following these pragmas, the compiler is directed to effectively optimize the hardware acceleration of the nested loops within the `kernel_adi` function for efficient execution on FPGA or other hardware accelerators.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "### Function Header:\n#### Function:\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n- **Function Name:** kernel_adi\n- **Parameters:**\n  - tsteps (int): Number of time steps\n  - n (int): Size of the input arrays\n  - u, v, p, q (double[60][60]): Input and output arrays\n\n### Description:\nThe function kernel_adi implements the Alternating Direction Implicit (ADI) method to solve a 2D heat equation for a grid of size 60x60. The process involves iterating through the grid over a specified number of time steps, updating the values based on a set of differential equations for each time step.\n\n### Pragma Directives:\n- **#pragma ACCEL PIPELINE auto{off}:** Do not automatically pipeline this loop.\n- **#pragma ACCEL TILE FACTOR=auto{1}:** Keep this loop whole, without dividing it into smaller parts.\n- **#pragma ACCEL PARALLEL FACTOR=auto{1}:** Execute loop iterations sequentially, not concurrently.\n- **#pragma ACCEL PIPELINE auto{flatten}:** Flatten the loop to improve parallelization.\n\nThe pragma directives help in guiding the high-level synthesis tools to optimize the parallelism and resource utilization for hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS code is a C function named `kernel_adi` that takes in five parameters: `tsteps`, `n`, `u[60][60]`, `v[60][60]`, `p[60][60]`, and `q[60][60]`. The function implements an alternating-direction implicit (ADI) algorithm to solve a set of partial differential equations over a 2D grid.\n\nThe process begins by initializing various constants related to grid spacing and time steps. The algorithm then proceeds to perform column and row sweeps, each consisting of nested loops to update the values of `v`, `p`, `q`, and `u` arrays based on the ADI method.\n\nIn terms of the #pragma directives:\n\n- `#pragma ACCEL PIPELINE auto{off}`: This directive specifies to disable automatic pipelining for the subsequent loop, allowing manual pipelining optimizations.\n  \n- `#pragma ACCEL TILE FACTOR=auto{1}`: This directive indicates keeping the subsequent loop whole without dividing it into smaller parts.\n  \n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: This directive suggests executing loop iterations sequentially rather than concurrently.\n\nAdditionally, within the loops, there are specific #pragma directives for pipelining, tiling, and parallelization, which are applied to optimize the hardware design for FPGA acceleration according to the provided factors.\n\nOverall, this code aims to efficiently accelerate the ADI algorithm for hardware implementation using the specified #pragma directives for optimization, parallelization, and pipeline control.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS C code defines a function named `kernel_adi` intended for hardware acceleration. This function calculates the ADI (Alternating Direction Implicit) method for solving a particular iterative equation by performing column and row sweeps.\n\nThe function header is:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\nWhere:\n- `tsteps` is the number of time steps\n- `n` is the size parameter\n- `u`, `v`, `p`, and `q` are 2D arrays of doubles\n\nThe code starts by initializing various variables and then enters a loop for a certain number of time steps (`t`). Within this loop, it performs column and row sweeps using nested loops over the arrays `u`, `v`, `p`, and `q`.\n\nThe `#pragma` directives in the code translate to the following natural language explanations:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n- For inner loops, there are additional parallelization directives, such as `#pragma ACCEL PARALLEL FACTOR=auto{2}`, which specifies the level of loop parallelism to be used for optimization.\n\nThese directives guide the HLS tool to optimize the hardware implementation of the code to achieve better performance on FPGA or other target platforms.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS code is for a function called 'kernel_adi' with the following parameters: int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60]. This function is designated for hardware acceleration. The overall process of the code involves applying an alternating direction implicit (ADI) method to solve a differential equation.\n\nThe #pragma directives in the code can be interpreted as follows:\n\n- '#pragma ACCEL PIPELINE auto{off}': Do not automatically pipeline this loop.\n- '#pragma ACCEL TILE FACTOR=auto{1}': Keep this loop whole, without dividing it into smaller parts.\n- '#pragma ACCEL PARALLEL FACTOR=auto{1}': Execute loop iterations sequentially, not concurrently.\n- '#pragma ACCEL PIPELINE auto{flatten}': Flatten the loop and ensure that the pipeline is automatically inserted.\n- '#pragma ACCEL PARALLEL FACTOR=auto{58}': Execute loop iterations partially in parallel, with a parallel factor of 58.\n\nThese directives control the hardware synthesis process when converting the code to hardware.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS (High-Level Synthesis) code snippet is for a function named \"kernel_adi\" with the following function header:\n\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nThis function performs the Alternating Direction Implicit (ADI) method on a 60x60 grid for a specific number of time steps. It consists of nested loops for column and row sweep operations, each with their own parallel processing logic.\n\nRegarding the #pragma directives, they can be interpreted as follows:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n- `#pragma ACCEL kernel`: Designate the following function for hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function Header:\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n\nDescription:\nThe function kernel_adi represents a kernel for the Alternating Direction Implicit method. It performs a series of computations to solve a partial differential equation.\n\n#pragma Directives:\n- #pragma ACCEL PIPELINE auto{}: Automatically pipeline all loops in the code.\n- #pragma ACCEL TILE FACTOR=auto{1}: Keep each loop whole, without dividing it into smaller parts.\n- #pragma ACCEL PARALLEL FACTOR=auto{1}: Execute loop iterations sequentially, not concurrently.\n- #pragma ACCEL kernel: Designate the following function for hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "### Function Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\n### Description:\nThe `kernel_adi` function performs an iterative calculation simulating the Alternating Direction Implicit (ADI) method for solving a partial differential equation. It updates the `u`, `v`, `p`, and `q` arrays over a specified number of time steps (`tsteps`) and grid size (`n`) using a series of nested loops for column and row sweeps.\n\n### Pragmas:\n1. `#pragma ACCEL PIPELINE auto{off}` - Do not automatically pipeline the loops within the function.\n2. `#pragma ACCEL TILE FACTOR=auto{1}` - Keep the loops whole, without dividing them into smaller parts.\n3. `#pragma ACCEL PARALLEL FACTOR=auto{1}` - Execute loop iterations sequentially, not concurrently, with a parallel factor of 1 for each loop.\n\nThe function is also designated for hardware acceleration using `#pragma ACCEL kernel`.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nBrief description:\nThis HLS code represents the implementation of the ADI (Alternating Direction Implicit) method. The 'kernel_adi' function performs a simulation of a 2D dynamic system over a specific number of time steps, involving a set of equations and boundary conditions.\n\nPragma directives translated into natural language explanations:\n\n1. `#pragma ACCEL PIPELINE auto{off}`:\n   Pipelining for loop iterations is disabled. The loop is executed sequentially without overlapping computations to improve data dependency.\n\n2. `#pragma ACCEL TILE FACTOR=auto{1}`:\n   The loop is left whole without dividing it into smaller parts, maintaining the original loop structure and iteration order.\n\n3. `#pragma ACCEL PARALLEL FACTOR=auto{1}`:\n   Loop iterations are executed sequentially, not concurrently, to avoid potential data hazards and ensure correct execution order.\n\nThe pragma statements convey specific hardware synthesis directives to optimize the loop execution and data dependency, aiding efficient high-level synthesis and code optimization for hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "### Function Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\n### Description:\nThe `kernel_adi` function performs the Alternating Direction Implicit (ADI) method for solving a specific set of partial differential equations. It initializes a set of variables and performs column and row sweeps for 40 time steps, each involving multiple nested loops that perform calculations on the arrays `u`, `v`, `p`, and `q`.\n\n### Pragma Directives:\n- **Pipeline**: Do not automatically pipeline this loop.\n- **Tile**: Keep this loop whole, without dividing it into smaller parts.\n- **Parallel**: Execute loop iterations sequentially, not concurrently.\n- **ACCEL kernel**: Designate the following function for hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "### Function Header:\nFunction Name: ```kernel_adi```\nParameters: \n- ```tsteps``` (integer)\n- ```n``` (integer)\n- ```u[60][60]``` (2D Array of doubles)\n- ```v[60][60]``` (2D Array of doubles)\n- ```p[60][60]``` (2D Array of doubles)\n- ```q[60][60]``` (2D Array of doubles)\n\n### Description:\nThe ```kernel_adi``` function performs the Alternating Direction Implicit (ADI) method for solving a system of partial differential equations over a 2D grid. It iteratively sweeps over the grid and updates the elements based on neighboring values.\n\n### #pragma Directives:\n1. ```#pragma ACCEL PIPELINE auto{off}```:\n   - Do not automatically pipeline this loop.\n\n2. ```#pragma ACCEL TILE FACTOR=auto{1}```:\n   - Keep this loop whole, without dividing it into smaller parts.\n\n3. ```#pragma ACCEL PARALLEL FACTOR=auto{1}```:\n   - Execute loop iterations sequentially, not concurrently.\n\n4. ```#pragma ACCEL PIPELINE auto{flatten}```:\n   - Automatically flatten the loop for better pipeline initiation in hardware acceleration.\n\n5. Inside the loops, there are additional ```#pragma``` directives to control pipelining, loop tiling, and loop parallelization.\n\nThese directives are used to optimize the hardware acceleration of the specified loops by controlling their parallelism, tiling, and pipelining behaviors.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function: void kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n\nThis function named \"kernel_adi\" takes in six parameters: tsteps, n, u, v, p, and q. These parameters include the number of timesteps, the size of the grid, and four 2D arrays of doubles representing the variables in an iterative calculation.\n\nThe code within the function performs the Alternating Direction Implicit (ADI) method for solving partial differential equations over a grid. It involves nested loops that iterate through the grid to update the variables u, v, p, and q at each time step.\n\nThe #pragma directives included in the code provide instructions to the High-Level Synthesis (HLS) tool for hardware acceleration:\n\n1. #pragma ACCEL PIPELINE auto{off}: Do not automatically pipeline the subsequent loop to maintain its original sequence of operations.\n2. #pragma ACCEL TILE FACTOR=auto{1}: Keep the subsequent loop whole, without dividing it into smaller parts when mapped to hardware.\n3. #pragma ACCEL PARALLEL FACTOR=auto{1}: Execute the iterations of the following loop sequentially, not concurrently, during hardware synthesis.\n\nThese directives guide the HLS tool in optimizing the hardware synthesis process for the specific loops in the code, preserving their intended behavior when translated to hardware.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The given function is a High-Level Synthesis (HLS) C code for the kernel_adi function, which is intended for hardware acceleration. The function takes in parameters tsteps, n, and arrays u, v, p, and q. It performs a 2D adi solver simulation over 40 time steps on a 60x60 grid.\n\nThe process consists of initializing various variables and then executing nested loops for column sweep and row sweep operations.\n\nThe #pragma directives in the code provide guidance to the HLS tool for optimizing hardware implementation. Here's what each of these directives means in natural language:\n\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n\nBy translating the #pragma directives into natural language, the instructions help the HLS tool in deciding how to best optimize the hardware implementation of the given C code.\n\nI hope this helps! Let me know if you need further assistance!", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "#### Function Header\n```C\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\n#### Description\nThe `kernel_adi` function implements the ADI (Alternating Direction Implicit) method for solving a partial differential equation. It iterates through time steps to compute the solution of the equation in 2D space for given input arrays `u`, `v`, `p`, and `q` with the specified grid size and time step.\n\n#### Pragmas Explained\n1. `#pragma ACCEL PIPELINE auto{off}`\n   - Do not automatically pipeline this loop.\n\n2. `#pragma ACCEL TILE FACTOR=auto{1}`\n   - Keep this loop whole, without dividing it into smaller parts.\n\n3. `#pragma ACCEL PARALLEL FACTOR=auto{1}`\n   - Execute loop iterations sequentially, not concurrently.\n\n4. `#pragma ACCEL PIPELINE auto{flatten}`\n   - Automatically flatten the loop into a single pipeline stage.\n\n5. `#pragma ACCEL PIPELINE auto{}`\n   - Automatically determine the pipeline strategy for this loop.\n\n6. `#pragma ACCEL TILE FACTOR=auto{1}`\n   - Allow the tool to automatically determine the tiling strategy for this loop.\n\n7. `#pragma ACCEL PARALLEL FACTOR=auto{2}`\n   - Execute loop iterations concurrently with a factor value of 2.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "### Function Header:\n**Function Name:** kernel_adi  \n**Parameters:**  \n- **tsteps** (integer): Total number of time steps  \n- **n** (integer): Size of the 2D arrays  \n- **u[60][60]** (2D array of doubles): Input array 1  \n- **v[60][60]** (2D array of doubles): Input array 2  \n- **p[60][60]** (2D array of doubles): Input array 3  \n- **q[60][60]** (2D array of doubles): Input array 4  \n\n### Process Overview:\nThe `kernel_adi` function calculates the ADI (Alternating Direction Implicit) method for solving a 2D heat equation over multiple time steps. It performs column and row sweeps for updating the 2D arrays `u`, `v`, `p`, and `q` based on a set of coefficients and equations.\n\n### Pragmas:\n1. **#pragma ACCEL PIPELINE auto{off}**: Do not automatically pipeline this loop.\n2. **#pragma ACCEL TILE FACTOR=auto{1}**: Keep this loop whole, without dividing it into smaller parts.\n3. **#pragma ACCEL PARALLEL FACTOR=auto{1}**: Execute loop iterations sequentially, not concurrently.\n\n   - **Column Sweep Loop**\n     - **#pragma ACCEL PIPELINE auto{off}**: Do not automatically pipeline this loop.\n     - **#pragma ACCEL TILE FACTOR=auto{1}**: Keep this loop whole, without dividing it into smaller parts.\n     - **#pragma ACCEL PARALLEL FACTOR=auto{1}**: Execute loop iterations sequentially, not concurrently.\n\n   - **Row Sweep Loop**\n     - **#pragma ACCEL PIPELINE auto{off}**: Do not automatically pipeline this loop.\n     - **#pragma ACCEL TILE FACTOR=auto{1}**: Keep this loop whole, without dividing it into smaller parts.\n     - **#pragma ACCEL PARALLEL FACTOR=auto{1}**: Execute loop iterations sequentially, not concurrently.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "### Function Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\n### Description:\nThis function `kernel_adi` represents an algorithm for solving the alternating direction implicit (ADI) scheme. It calculates the values of multidimensional arrays `v`, `p`, and `q` based on the input parameters `tsteps`, `n`, and `u`. The algorithm consists of column and row sweep operations performed in a nested loop structure.\n\n### #pragma Directives:\n- `#pragma ACCEL PIPELINE auto{off}` => Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}` => Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}` => Execute loop iterations sequentially, not concurrently.\n\nThe specified pragma directives control the hardware synthesis process, providing guidance on loop pipelining, loop tiling, and loop parallelization for efficient hardware implementation.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided code snippet is a High-Level Synthesis (HLS) C function responsible for performing the Alternating Direction Implicit (ADI) method to solve a specific set of differential equations.\n\nThe function header is defined as follows:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\nWhere:\n- `tsteps` and `n` are integer parameters\n- `u`, `v`, `p`, and `q` are 2D arrays of doubles with dimensions 60x60\n\nThe overall process involves initializing various variables and then executing two nested loops, known as column sweep and row sweep, over the given 2D arrays. Each sweep involves further nested loops to perform computations for each grid point.\n\nThe key #pragma directives in the code can be translated as follows:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n- `#pragma ACCEL PIPELINE auto{flatten}`: Automatically flatten the loop to improve parallelism.\n- `#pragma ACCEL PARALLEL FACTOR=auto{2}`: Execute loop iterations with a parallel factor of 2.\n- `#pragma ACCEL PARALLEL FACTOR=auto{58}`: Execute loop iterations with a parallel factor of 58.\n- `#pragma ACCEL PARALLEL FACTOR=auto{16}`: Execute loop iterations with a parallel factor of 16.\n\nIn summary, this HLS C function is designated for hardware acceleration and includes various directives to control loop pipelining, loop tiling, and loop parallelization to optimize the implementation for the hardware target.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function Header: \nFunction Name: kernel_adi\nParameters: \n- tsteps (integer)\n- n (integer)\n- u[60][60] (2D array of double)\n- v[60][60] (2D array of double)\n- p[60][60] (2D array of double)\n- q[60][60] (2D array of double)\n\nDescription:\nThe kernel_adi function performs a set of calculations related to the Alternating Direction Implicit (ADI) method by iterating over a set of loops and updating various arrays.\n\n#pragma Directives Translation:\n- #pragma ACCEL PIPELINE \"off\": Do not automatically pipeline this loop.\n- #pragma ACCEL TILE FACTOR=1: Keep this loop whole, without dividing it into smaller parts.\n- #pragma ACCEL PARALLEL FACTOR=1: Execute loop iterations sequentially, not concurrently.\n- #pragma ACCEL kernel: Designate the following function for hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "This function is designed for hardware acceleration and represents an ADI (Alternating Direction Implicit) algorithm implemented using C code. The function takes in the number of time steps 'tsteps' and the grid size 'n', along with arrays 'u', 'v', 'p', and 'q', each of size 60x60. The function then performs a series of calculations based on the ADI algorithm.\n\nThe pragma directives in the code provide guidance for the high-level synthesis tool to optimize the hardware implementation of the loops. Specifically, the \"#pragma ACCEL PIPELINE auto{off}\" directive instructs the tool not to automatically pipeline the loop. The \"#pragma ACCEL TILE FACTOR=auto{1}\" directive indicates that the loop should be kept whole without dividing it into smaller parts. The \"#pragma ACCEL PARALLEL FACTOR=auto{1}\" directive ensures that loop iterations are executed sequentially rather than concurrently.\n\nWithin the loops, additional pragma directives provide further optimization guidance. For example, \"#pragma ACCEL PIPELINE auto{flatten}\" instructs the tool to enable pipelining with loop flattening, and \"#pragma ACCEL PARALLEL FACTOR=auto{58}\" designates a parallel factor of 58 for the inner loop.\n\nIn summary, this function is intended for hardware acceleration, and the pragma directives provide specific optimization instructions to the high-level synthesis tool for efficiently implementing the ADI algorithm on hardware.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS (High-Level Synthesis) C code defines a function called `kernel_adi` with parameters `tsteps`, `n`, `u`, `v`, `p`, and `q`. The function represents an iterative computation for the Alternating Direction Implicit (ADI) method, used to solve partial differential equations. The code includes various computations and nested loops for column and row sweeps, with pragma directives to optimize the loops for hardware acceleration.\n\nThe `kernel_adi` function is designated for hardware acceleration using the `#pragma ACCEL kernel` directive.\n\nThe specific pragma directives are used to optimize the loops for hardware acceleration:\n- `#pragma ACCEL PIPELINE auto{off}`: This directive specifies to not automatically pipeline the loop, possibly to facilitate more manual optimization.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: This directive keeps the loop whole, without dividing it into smaller parts. The `auto{1}` likely implies that the factor is determined automatically or kept as a single unit.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: This directive indicates to execute loop iterations sequentially, not concurrently, with the `auto{1}` likely indicating that the factor is automatically determined or set to 1.\n\nOverall, the code represents a key computational kernel that is optimized for hardware acceleration using HLS, with specific pragma directives to guide the implementation of the hardware design.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS code defines a function `kernel_adi` written in C, which is designated for hardware acceleration. The function takes five parameters - an integer `tsteps` and arrays `u`, `v`, `p`, and `q`, each of which is a 60x60 2D array of doubles. The function implements the Alternating Direction Implicit (ADI) method for solving a partial differential equation over 40 time steps. The computation involves various mathematical operations such as additions, subtractions, multiplications, and divisions.\n\nThe code includes several `#pragma` directives, which provide guidance to the HLS tool for optimizing the hardware implementation of the function. Specifically, the code includes directives for pipelining, tiling, and parallelizing loops, each of which is further described as follows:\n\n- `#pragma ACCEL PIPELINE auto{off}`: This directive instructs the tool not to automatically pipeline the loop, ensuring that the loop is executed without pipelining optimizations.\n\n- `#pragma ACCEL TILE FACTOR=auto{1}`: This directive advises the tool to keep the loop whole, without dividing it into smaller parts, using a specified tiling factor.\n\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: This directive indicates that loop iterations should be executed sequentially, not concurrently, and specifies a parallelization factor for the loop.\n\nFurther, within the main loop of the function, there are inner loops with similar `#pragma` directives, controlling their pipelining, tiling, and parallelization behavior.\n\nOverall, these `#pragma` directives guide the HLS tool in optimizing the implementation of the function for hardware acceleration by specifying loop behaviors and enabling parallelism where possible.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nDescription:\nThe `kernel_adi` function is designed for hardware acceleration and computes an iterative algorithm for solving a 2D problem. It performs a series of computations involving 2D arrays `u`, `v`, `p`, and `q` over a specified number of time steps using a set of constants and coefficients.\n\nPragma Directives:\n- `#pragma ACCEL PIPELINE auto{off}` - Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}` - Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}` - Execute loop iterations sequentially, not concurrently.\n\nThe function features nested loops that are annotated with pragma directives to control loop optimization, tiling, pipelining, and parallelization in the generated hardware design. These directives guide the HLS tool to optimize the hardware implementation according to the specified criteria, ensuring efficient resource utilization and performance.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function: void kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n\nDescription:\nThis function implements the Alternating Direction Implicit (ADI) method for solving a system of partial differential equations. It iterates through the system for a given number of time steps, updating the values of the arrays u, v, p, and q based on specific equations.\n\n#pragma Directives:\n- #pragma ACCEL PIPELINE auto{off}: Do not automatically pipeline the loops within the code, allowing for manual control over pipelining.\n- #pragma ACCEL TILE FACTOR=auto{1}: Keep the loops whole, without dividing them into smaller parts, to retain the original loop structure.\n- #pragma ACCEL PARALLEL FACTOR=auto{1}: Execute loop iterations sequentially, not concurrently, ensuring a deterministic order of execution.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "To generate the provided HLS code snippet, begin by creating a function named 'kernel_adi' with the following parameters: an integer 'tsteps', an integer 'n', and four 2D arrays of doubles 'u', 'v', 'p', and 'q', each with dimensions [60][60]. \n\nThe code's overall process involves solving a 2D heat equation using the Alternating Direction Implicit (ADI) method. This is achieved through iterative computations on the arrays 'u', 'v', 'p', and 'q'.\n\nThe '#pragma' directives in the code serve several purposes in the context of HLS synthesis:\n- '#pragma ACCEL PIPELINE auto{off}' instructs the system not to automatically pipeline the subsequent loop.\n- '#pragma ACCEL TILE FACTOR=auto{1}' specifies that the loop should remain whole without being divided into smaller parts.\n- '#pragma ACCEL PARALLEL FACTOR=auto{1}' directs the system to execute loop iterations sequentially, not concurrently.\n- Following the above, '#pragma ACCEL PARALLEL FACTOR=auto{58}' and '#pragma ACCEL PARALLEL FACTOR=auto{4}' specify the degree of parallelism for specific nested loops.\n\nUpon completion of this detailed, yet succinct natural language instruction, the user should be well-prepared to generate the provided HLS code snippet accurately and effectively.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "### Function Header and Description:\nFunction Name: kernel_adi  \nParameters:  \n- tsteps (integer): Number of time steps  \n- n (integer): Size of the grid  \n- u[60][60] (2D array of doubles): Grid parameter  \n- v[60][60] (2D array of doubles): Grid parameter  \n- p[60][60] (2D array of doubles): Grid parameter  \n- q[60][60] (2D array of doubles): Grid parameter  \n\nDescription: This function implements the Alternating Direction Implicit (ADI) method for solving a system of partial differential equations. The process involves iteratively updating the grid parameters over a specified number of time steps, with column and row sweep operations. \n\n### Pragma Directives:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n- `#pragma ACCEL kernel`: Designate the following function for hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "### Function Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n#### Brief Description:\nThe `kernel_adi` function represents an implementation of the ADI algorithm for solving a partial differential equation. It iterates through time steps to simulate the diffusion process in a 60x60 grid.\n\n#### Pragma Directives Translated:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n- `#pragma ACCEL kernel`: Designate the following function for hardware acceleration.\n\nEach pragma directive indicates the desired behavior for the subsequent loops and designates the function for hardware acceleration.\n\nThe code within each pragma block is modified to specify the appropriate loop optimizations and parallelization strategies to be used during High-Level Synthesis (HLS) compilation and synthesis. These directives guide the HLS toolchain in generating hardware designs from the given C code.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "To generate the provided HLS (High-Level Synthesis) C code, you should consider the following:\n\nFunction Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nDescription:\nThe function `kernel_adi` represents a kernel for 2D Alternating Direction Implicit (ADI) iterations. It takes integer `tsteps`, integer `n`, and four 2D arrays of double values (`u`, `v`, `p`, and `q`) as parameters and performs a series of computations involving these arrays over a set of time steps.\n\n#pragma Directives Explained:\n1. `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n2. `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole without dividing it into smaller parts.\n3. `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "#### Function Header ####\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\n#### Code's Overall Process ####\nThe function `kernel_adi` performs the Alternating Direction Implicit (ADI) method for solving the heat equation. It iteratively calculates the temperature distribution in a 2D space over a given number of time steps.\n\n#### Pragmas Explanation ####\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n- `#pragma ACCEL kernel`: Designate the following function for hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nDescription:\nThe `kernel_adi` function represents an algorithm for solving the Alternating Direction Implicit (ADI) method, which is commonly used in solving partial differential equations. This specific function takes multiple parameters including time steps, array sizes, and multiple 2D arrays to perform computation over a time period.\n\n#pragma explanations:\n1. `#pragma ACCEL PIPELINE auto{off}`\n   - This directive means \"Do not automatically pipeline this loop,\" which indicates that hardware acceleration should not automatically pipeline the specified loop iterations for parallel processing.\n\n2. `#pragma ACCEL TILE FACTOR=auto{1}`\n   - This pragma means \"Keep this loop whole, without dividing it into smaller parts,\" indicating that the loop should not be partitioned into smaller sections during hardware acceleration.\n\n3. `#pragma ACCEL PARALLEL FACTOR=auto{1}`\n   - This directive translates to \"Execute loop iterations sequentially, not concurrently,\" which means that the loop iterations should not be executed in parallel on the hardware accelerator and should be processed sequentially.\n\nOverall, the `kernel_adi` function is designated for hardware acceleration and includes pragma directives to control loop pipelining, tiling, and parallelization during the hardware synthesis process.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS code is a C function named 'kernel_adi', designated for hardware acceleration. It takes five parameters: 'tsteps' (an integer), 'n' (an integer), 'u', 'v', 'p', and 'q' (all 2D arrays of size 60x60, containing double precision floating-point numbers).\n\nThe overall process of the code involves solving a system of linear equations using an alternating direction implicit (ADI) method. The function iterates over time steps and performs column and row sweeps, calculating values for 'u', 'v', 'p', and 'q'.\n\nThe #pragma directives in the code provide guidance to the high-level synthesis tool for translating the C code into hardware. Here's what they mean in natural language:\n\n1. '#pragma ACCEL PIPELINE auto{off}': Do not automatically pipeline this loop.\n2. '#pragma ACCEL TILE FACTOR=auto{1}': Keep this loop whole, without dividing it into smaller parts.\n3. '#pragma ACCEL PARALLEL FACTOR=auto{1}': Execute loop iterations sequentially, not concurrently.\n\nIn summary, this HLS code represents a hardware-accelerated C function that carries out an ADI method to solve a system of linear equations, with specific guidance to the synthesis tool for loop optimization and parallelization.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "To generate the provided HLS code snippet, follow these instructions:\n\n**Function Header:**\n```c\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n```\n\n**Description:**\nThis HLS code defines a kernel function 'kernel_adi' that implements the Alternating Direction Implicit (ADI) method. The function takes several parameters including the number of time steps, the size of the grid, and arrays 'u', 'v', 'p', and 'q' representing physical quantities in a grid.\n\n**Pragmas:**\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n- `#pragma ACCEL kernel`: Designate the following function for hardware acceleration.\n\nFollowing these instructions, you can process the HLS code snippet to effectively apply hardware acceleration and optimize loop execution for the ADI method.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS (High-Level Synthesis) code is for a function called `kernel_adi`, which accepts five parameters: an integer `tsteps`, an integer `n`, and three 2D arrays of doubles: `u[60][60]`, `v[60][60]`, `p[60][60]`, and `q[60][60]`. The overall process of this code appears to be implementing the Alternating Direction Implicit (ADI) method to solve a differential equation over a grid.\n\nThe `#pragma` directives in the code are used to guide the high-level synthesis tool in optimizing the hardware implementation of the underlying C code.\n\n- `#pragma ACCEL PIPELINE auto{off}`: Instructs to not automatically pipeline the loop, indicating that the loop should not be split into stages to enable concurrent execution.\n  \n- `#pragma ACCEL TILE FACTOR=auto{1}`: Advises to keep the loop whole without dividing it into smaller parts, potentially to maintain data locality and minimize communication overhead.\n\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Specifies to execute loop iterations sequentially, not concurrently. This can be perceived as suggesting sequential processing, likely due to dependencies or resource constraints.\n\n- `#pragma ACCEL PIPELINE auto{flatten}`: Instructs to automatically flatten the pipeline, implying that the tool should attempt to optimize the pipeline by reducing or removing pipeline dependencies.\n\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Similar to the previous `TILE` directive, this specifies to keep the loop whole without dividing it into smaller parts, likely to preserve data locality and reduce overhead.\n\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`, `#pragma ACCEL PARALLEL FACTOR=auto{2}`, `#pragma ACCEL PARALLEL FACTOR=auto{58}`, `#pragma ACCEL PARALLEL FACTOR=auto{4}`: These directives suggest different levels of concurrent execution for loop iterations, with factors of `1`, `2`, `58`, and `4`, indicating the degree of parallelism the tool should aim to achieve.\n\nFinally, the `#pragma ACCEL kernel` directive designates the following function for hardware acceleration, indicating that the `kernel_adi` function should be implemented in hardware to achieve performance improvements.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "### Function header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\n### Description:\nThe `kernel_adi` function represents the computation of an Alternating Direction Implicit (ADI) method for solving a partial differential equation. The function takes several parameters including the time steps `tsteps`, the size `n`, and multiple 2D arrays `u`, `v`, `p`, and `q` for calculations. The ADI method involves column and row sweep iterations for updating these arrays based on specific mathematical computations.\n\n### Pragmas Explanation:\n- `#pragma ACCEL PIPELINE auto{off}`: This pragma directive instructs to not automatically pipeline the following loop, allowing for manual optimization of loop iterations.\n  \n- `#pragma ACCEL TILE FACTOR=auto{1}`: This pragma directive ensures that the loop iteration is not divided into smaller parts, keeping the loop whole and undivided for optimization.\n\n- `#pragma ACCEL PARALLEL FACTOR=auto{16}`: This pragma directive specifies executing the loop iterations sequentially rather than concurrently, with a parallel factor of 16. This means that 16 loop iterations will be executed at once.\n\n- `#pragma ACCEL kernel`: This pragma directive designates the following function for hardware acceleration, indicating that the `kernel_adi` function is intended for synthesis into hardware design.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS (High-Level Synthesis) C code represents a function `kernel_adi` that is designated for hardware acceleration. This function takes 5 parameters: `tsteps` of type int, `n` of type int, `u` of type double 2D array, `v` of type double 2D array, `p` of type double 2D array, and `q` of type double 2D array. The function then performs a series of computations involving these arrays and loop iterations for a total of 40 time steps.\n\nDuring the execution, specific #pragma directives are used to guide the HLS synthesis tools on how to optimize the code for hardware acceleration. The `#pragma ACCEL PIPELINE auto{off}` directive instructs the synthesis tools not to automatically pipeline the loop, while `#pragma ACCEL TILE FACTOR=auto{1}` guides the tools to keep the loop whole, without dividing it into smaller parts. Additionally, `#pragma ACCEL PARALLEL FACTOR=auto{1}` is used to execute loop iterations sequentially, not concurrently.\n\nThe code contains two main sweeping loops: a column sweep and a row sweep, each containing nested loops with additional parallelism directives. These directives help optimize the hardware acceleration process for the specific computations involved in the nested loops.\n\nIn summary, the provided function `kernel_adi` is used for hardware acceleration and contains specific directives to guide the HLS synthesis tools on how to optimize the code for parallelism, tiling, and pipelining.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nDescription:\nThe `kernel_adi` function represents an iterative algorithm for solving a specific type of partial differential equations. It involves updating the values of arrays `u`, `v`, `p`, and `q` over a number of time steps (`tsteps`) based on certain calculations using constants and intermediate variables. The process consists of column sweeps and row sweeps, each involving nested loops to update the array values.\n\n#pragma Directives:\n- `#pragma ACCEL PIPELINE auto{off}` - Do not automatically pipeline the loop for parallel execution.\n- `#pragma ACCEL TILE FACTOR=auto{1}` - Keep the loop whole without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}` - Execute loop iterations sequentially, not concurrently.\n- `#pragma ACCEL PIPELINE auto{flatten}` - Automatically flatten the loop for more efficient hardware implementation.\n- `#pragma ACCEL PIPELINE auto{}` - Automatically apply a pipeline to the loop for parallel processing.\n- `#pragma ACCEL PARALLEL FACTOR=auto{2}` - Execute loop iterations concurrently with a parallel factor of 2.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function Header:\nThe function is named `kernel_adi` and it takes five parameters: `tsteps` of type int, `n` of type int, `u` of type double 2D array with size [60][60], `v` of type double 2D array with size [60][60], `p` of type double 2D array with size [60][60], and `q` of type double 2D array with size [60][60].\n\nProcess Description:\nThe `kernel_adi` function implements the Alternating Direction Implicit (ADI) method to solve a 2D diffusion problem. It applies column and row sweeps to update the input arrays `u`, `v`, `p`, and `q` over a certain number of time steps.\n\n#pragma Directives Explanation:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline the following loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n- `#pragma ACCEL kernel`: Designate the `kernel_adi` function for hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\nDescription:\nThe `kernel_adi` function takes in parameters `tsteps`, `n`, `u`, `v`, `p`, and `q`, and performs a series of computations involving array manipulations within nested loops.\n\nPragma Directives:\n- `#pragma ACCEL PIPELINE auto{off}`: Prevent automatic pipelining of the following loops.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep loops whole without splitting them into smaller parts for optimization.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n\nOverall, the function is designated for hardware acceleration and includes directives to control loop optimizations for pipelining, tiling, and parallelization.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function header:\n```C\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nDescription:\nThe `kernel_adi` function accepts parameters for the number of time steps (`tsteps`), the size (`n`), and arrays `u`, `v`, `p`, and `q`. It performs a computation that simulates an alternating direction implicit (ADI) solver.\n\n#pragma Directives:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n- `#pragma ACCEL PIPELINE auto{flatten}`: Automatically flatten this loop for parallel execution.\n- `#pragma ACCEL PARALLEL FACTOR=auto{29}`: Run the loop iterations in parallel, with a factor specified automatically.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided C code is an implementation of the Alternating Direction Implicit (ADI) method using arrays. The function `void kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])` takes in several parameters, including the number of time steps (`tsteps`), the array dimensions (`n`), and multiple 2D arrays (`u`, `v`, `p`, `q`) for computation.\n\nThe code incorporates several `#pragma` directives for High-Level Synthesis (HLS) acceleration. First, the `#pragma ACCEL kernel` designates the `kernel_adi` function for hardware acceleration. Following this, there are directives that control loop optimization and parallelization. For instance, `#pragma ACCEL PIPELINE auto{off}` disables automatic loop pipelining. Similarly, `#pragma ACCEL TILE FACTOR=auto{1}` and `#pragma ACCEL PARALLEL FACTOR=auto{1}` specify that the loop should be kept whole and iterations should be executed sequentially rather than concurrently.\n\nWithin the code, there are nested loops for both column sweep and row sweep, and the directives are applied to these loops to control their behavior during HLS synthesis. For example, the `#pragma ACCEL PARALLEL FACTOR=auto{8}` directive specifies that the loop body can be executed concurrently with a factor of 8, and similar directives are used for other loops to control parallelization and optimization.\n\nIn summary, this HLS code aims to optimize and parallelize the computation of the ADI method, and the `#pragma` directives are used to guide the HLS tool in performing appropriate optimizations and parallelization.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nDescription:\nThe `kernel_adi` function performs the Alternating Direction Implicit (ADI) algorithm, which solves a system of equations that represents a physical phenomenon evolving over time and space. It involves nested loops for column and row sweeps.\n\n#pragma directives interpretation:\n1. `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n2. `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n3. `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The function `kernel_adi` has the following signature:\n\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nThis function represents the Alternating Direction Implicit (ADI) method for solving a system of partial differential equations. It takes in several parameters including the number of time steps `tsteps`, the grid size `n`, and arrays `u`, `v`, `p`, and `q` representing the different variables in the system.\n\nThe provided code contains three main parts: initialization of variables, column sweep, and row sweep. Each sweep involves nested loops to update the `v` and `u` arrays based on the values of `p` and `q`. The loops are subject to various pragma directives for parallelism and pipeline optimizations.\n\nThe pragma directives in the code can be interpreted as follows:\n1. `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n2. `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n3. `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n\nThese directives provide instructions to the high-level synthesis tool regarding how to optimize the hardware implementation of the loops for parallelism and pipelining.\n\nIn summary, the `kernel_adi` function utilizes the ADI method to solve a system of partial differential equations and includes pragma directives to guide the high-level synthesis tool in optimizing the hardware implementation for parallelism and pipelining.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "### Function Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\n### Description:\nThe `kernel_adi` function performs an Alternating Direction Implicit (ADI) algorithm for solving a system of Partial Differential Equations (PDEs) over a 60x60 grid. It iterates over 40 time steps, performing column and row sweeps, updating the `u`, `v`, `p`, and `q` arrays based on computed values and constants.\n\n### #pragma Directives:\n1. `#pragma ACCEL PIPELINE auto{off}` - Do not automatically pipeline this loop.\n2. `#pragma ACCEL TILE FACTOR=auto{1}` - Keep this loop whole, without dividing it into smaller parts.\n3. `#pragma ACCEL PARALLEL FACTOR=auto{1}` - Execute loop iterations sequentially, not concurrently.\n   - (inside nested loops) `#pragma ACCEL PARALLEL FACTOR=auto{1}` - Execute loop iterations sequentially, not concurrently.\n\nThis HLS code designates the `kernel_adi` function for hardware acceleration and provides directives for loop optimization and parallelization.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The given HLS (High-Level Synthesis) code is a C function named `kernel_adi` with the following signature:\n\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nThis function performs an iterative computation to solve a specific problem. It involves multiple loops and calculations to update the values of arrays `u`, `v`, `p`, and `q`. The code is designed for hardware acceleration.\n\nThe `#pragma` directives in the code provide instructions for the high-level synthesis tool to optimize hardware implementation. They are translated as follows:\n\n- `#pragma ACCEL PIPELINE auto{off}`:\n  - Natural language interpretation: Do not automatically pipeline this loop.\n\n- `#pragma ACCEL TILE FACTOR=auto{1}`:\n  - Natural language interpretation: Keep this loop whole, without dividing it into smaller parts.\n\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`:\n  - Natural language interpretation: Execute loop iterations sequentially, not concurrently.\n\nOverall, the function `kernel_adi` carries out complex computations and is optimized for hardware acceleration using the specified pragma directives.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "### Function Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\n### Brief Description:\nThe `kernel_adi` function calculates the alternating direction implicit (ADI) method to solve a partial differential equation over a grid for a specified number of time steps.\n\n### Pragma Directives:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n- `#pragma ACCEL PIPELINE auto{flatten}`: Automatically flatten the pipeline for this loop.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The function 'kernel_adi' is designated for hardware acceleration and takes in the parameters 'tsteps', 'n', 'u[60][60]', 'v[60][60]', 'p[60][60]', and 'q[60][60]'. This function performs a numerical computation process known as the Alternating Direction Implicit (ADI) method to solve a specific type of partial differential equation.\n\nThe '#pragma' directives in the code can be interpreted as follows:\n- '#pragma ACCEL PIPELINE \"off\"': Do not automatically pipeline this loop.\n- '#pragma ACCEL TILE FACTOR=1': Keep this loop whole, without dividing it into smaller parts.\n- '#pragma ACCEL PARALLEL FACTOR=1': Execute loop iterations sequentially, not concurrently.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS C code is a kernel function for the ADI (Alternating Direction Implicit) method. This method solves a system of linear equations that arise when using finite difference methods to approximate the partial differential equation. The code consists of two nested loops and involves calculations using arrays and constants.\n\nHere are the natural language explanations for the #pragma directives used in the code:\n\n1. #pragma ACCEL PIPELINE auto{off} - Do not automatically pipeline this loop.\n2. #pragma ACCEL TILE FACTOR=auto{1} - Keep this loop whole, without dividing it into smaller parts.\n3. #pragma ACCEL PARALLEL FACTOR=auto{1} - Execute loop iterations sequentially, not concurrently.\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\n- The function `kernel_adi` takes in the parameters `tsteps`, `n`, `u[60][60]`, `v[60][60]`, `p[60][60]`, and `q[60][60]`.\n- The overall process of the function involves performing the Alternating Direction Implicit (ADI) method for solving a specific mathematical problem.\n\nPragma Directives Translation:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n- `#pragma ACCEL kernel`: Designate the `kernel_adi` function for hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "### Function Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\n### Description:\nThe `kernel_adi` function accepts several parameters and performs the Alternating Direction Implicit (ADI) method on a grid of values represented by the arrays `u`, `v`, `p`, and `q`. This method iteratively solves a partial differential equation.\n\n### Pragma Directives Explanation:\n- `#pragma ACCEL PIPELINE auto{off}`:\n  - Do not automatically pipeline the following loop.\n\n- `#pragma ACCEL TILE FACTOR=auto{1}`:\n  - Keep the following loop as a whole, without dividing it into smaller parts.\n\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`:\n  - Execute the iterations of the following loop sequentially, not concurrently.\n\nThe pragma directives are used to guide the high-level synthesis tool in generating hardware designs from the provided C code. They control the parallelism, pipelining, and loop tiling behavior in the hardware implementation.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function Header:\n```c\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n```\n\nDescription:\nThe `kernel_adi` function performs the alternating direction implicit method to solve a system of linear equations. It first initializes various constants and then iteratively performs column and row sweeps to calculate the values of arrays `u`, `v`, `p`, and `q`.\n\n#pragma Directives:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline the loops.\n  \n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep the loops whole, without dividing them into smaller parts.\n\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n\n- `#pragma ACCEL kernel`: Designate the following function for hardware acceleration.\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nDescription:\nThe `kernel_adi` function performs the Alternating Direction Implicit (ADI) method to solve a system of partial differential equations over multiple time steps. It calculates the values of `u`, `v`, `p`, and `q` arrays based on the input parameters `tsteps` and `n`, representing the number of time steps and the size of the arrays.\n\nExplanation of #pragma directives:\n1. `#pragma ACCEL PIPELINE \"off\"`: Do not automatically pipeline this loop.\n2. `#pragma ACCEL TILE FACTOR=1`: Keep this loop whole, without dividing it into smaller parts.\n3. `#pragma ACCEL PARALLEL FACTOR=1`: Execute loop iterations sequentially, not concurrently.\n4. `#pragma ACCEL kernel`: Designate the following function for hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "```plaintext\nFunction Header:\n-------------\nFunction Name: kernel_adi\nParameters:\n- tsteps: integer\n- n: integer\n- u: 2D array of double\n- v: 2D array of double\n- p: 2D array of double\n- q: 2D array of double\n\nDescription:\n-----------\nThis function implements the Alternating Direction Implicit (ADI) algorithm to solve a system of partial differential equations over a specified number of time steps. It involves nested loops for column and row sweeps, performing various calculations using the input arrays u, v, p, and q.\n\n#pragma Directives:\n---------------\n1. #pragma ACCEL kernel\n   - Designates the following function for hardware acceleration.\n\n2. #pragma ACCEL PIPELINE auto{off}\n   - Disables automatic loop pipelining, instructing the tool not to automatically pipeline the loops to maximize flexibility.\n\n3. #pragma ACCEL TILE FACTOR=auto{1}\n   - Suggests to keep the loops whole and not divide them into smaller parts for better optimization.\n\n4. #pragma ACCEL PARALLEL FACTOR=auto{1}\n   - Suggests executing loop iterations sequentially, rather than concurrently, to avoid parallelization.\n\n5. #pragma ACCEL PARALLEL FACTOR=auto{58}\n   - Suggests parallelizing the loop with a factor of 58, indicating potential parallel execution of 58 iterations at a time.\n\n6. #pragma ACCEL PARALLEL FACTOR=auto{4}\n   - Suggests parallelizing the loop with a factor of 4, indicating potential parallel execution of 4 iterations at a time.\n\n7. #pragma ACCEL PARALLEL FACTOR=auto{2}\n   - Suggests parallelizing the loop with a factor of 2, indicating potential parallel execution of 2 iterations at a time.\n\n```\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS (High-Level Synthesis) code snippet is a C function `kernel_adi` that encapsulates an algorithm for solving a specific problem. The function takes five parameters: `int tsteps`, `int n`, `double u[60][60]`, `double v[60][60]`, `double p[60][60]`, and `double q[60][60]`. The function calculates the values of `u` and `v` arrays based on a complex set of operations involving various mathematical calculations.\n\nIn terms of directives, the code has several `#pragma` statements that govern how certain parts of the code should be treated during synthesis.\n\nRegarding the directives used, they translate into the following natural language explanations:\n\n1. `#pragma ACCEL PIPELINE auto{off}`: This directive indicates that the specified loop should not be automatically pipelined, meaning that iterations should not be executed in parallel by default.\n\n2. `#pragma ACCEL TILE FACTOR=auto{1}`: This pragma is intended to keep the specified loop whole, without dividing it into smaller parts. It requests the HLS tool to preserve the loop structure when implementing the hardware.\n\n3. `#pragma ACCEL PARALLEL FACTOR=auto{1}`: This pragma specifies that loop iterations should be executed sequentially, not concurrently. It requests the HLS tool to execute iterations one after the other rather than in parallel.\n\nIn summary, the `kernel_adi` function contains computational logic and is accompanied by pragmas governing the synthesis process to achieve optimal hardware implementation.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "### Function Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\n### Description:\nThis HLS code implements the ADI (Alternating Direction Implicit) method for solving a 2D heat equation. It contains nested loops for conducting column sweep and row sweep computations for a given number of time steps.\n\n### Pragma Directives:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n- `#pragma ACCEL kernel`: Designate the following function for hardware acceleration.\n\nThe code uses pragma directives to guide the HLS tool on loop optimizations such as pipelining, tiling, and parallelization to maximize hardware performance during synthesis.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS (High-Level Synthesis) code is a kernel function named `kernel_adi` written in C, intended for hardware acceleration. This function takes six parameters: `tsteps` of type int, `n` of type int, `u` of type double[60][60], `v` of type double[60][60], `p` of type double[60][60], and `q` of type double[60][60]. The function processes a simulation with a multi-dimensional grid using the Alternating Direction Implicit (ADI) method. \n\nThe function contains several #pragma directives that provide guidance to the high-level synthesis tool on how to optimize and parallelize the loops for hardware implementation.\n\n- `#pragma ACCEL PIPELINE auto{off}`: This directive instructs the tool not to automatically pipeline the loop, implying that the iterations should be executed sequentially without overlapping.\n\n- `#pragma ACCEL TILE FACTOR=auto{1}`: This directive indicates that the loop should be kept whole and not divided into smaller parts for optimization.\n\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: This directive suggests that loop iterations should not be executed concurrently but rather sequentially.\n\nThese directives help guide the high-level synthesis tool in transforming the C code into an optimized hardware implementation, ensuring efficient resource utilization while meeting the specified design constraints.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS (High-Level Synthesis) code snippet is a C function named `kernel_adi` with the following signature: \n\n```c\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n```\nThis function performs the Alternating Direction Implicit (ADI) method to solve a system of partial differential equations in 2D space. It initializes various constants and then implements a time-stepping process composed of two sweeps: a column sweep and a row sweep. Each sweep involves solving a system of linear equations and updating the input arrays `u` and `v`.\n\nRegarding the #pragma directives, they can be interpreted as follows:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop for parallelism.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts for parallelization.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently, with a parallel factor of 1.\n\nThroughout the code, these directives are applied to specify how the loops should be parallelized and pipelined for hardware acceleration.\n\nThe code snippet is designed for hardware acceleration using HLS, and the provided function `kernel_adi` is designated for hardware acceleration through the `#pragma ACCEL kernel` directive.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The function `kernel_adi` takes in five parameters: `tsteps` (an integer), `n` (an integer), `u` (a 2D array of doubles), `v` (a 2D array of doubles), `p` (a 2D array of doubles), and `q` (a 2D array of doubles).\n\nThe algorithm involves initializing several constants and then executing a double loop, performing column and row sweeps. During these sweeps, various calculations are performed on the input arrays `u`, `v`, `p`, and `q`.\n\nThe `#pragma` directives in the code provide guidance for the high-level synthesis. Specifically, `#pragma ACCEL kernel` designates the following function for hardware acceleration. Inside the function, `#pragma ACCEL PIPELINE auto{off}` instructs not to automatically pipeline the loop, `#pragma ACCEL TILE FACTOR=auto{1}` maintains the whole loop without dividing it into smaller parts, and `#pragma ACCEL PARALLEL FACTOR=auto{1}` executes loop iterations sequentially, not concurrently.\n\nIn summary, this code describes a function that performs a series of calculations on input arrays, with specific pragma directives guiding the high-level synthesis tool on how to parallelize and optimize the hardware implementation of the code.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS C code snippet defines a function named `kernel_adi` which is designated for hardware acceleration. This function takes in 5 parameters: an integer `tsteps`, an integer `n`, and 4 2D arrays of doubles (`u`, `v`, `p`, and `q`).\n\nThe function represents a 2D heat equation solver using the ADI (Alternating Direction Implicit) method. It initializes various constants and coefficients, then enters the main time-stepping loop which consists of column and row sweeps to solve the heat equation.\n\nAs for the `#pragma` directives, they instruct the HLS tool to perform certain optimizations during synthesis. Specifically, the `#pragma ACCEL PIPELINE auto{off}` directive indicates that the loop should not be automatically pipelined, the `#pragma ACCEL TILE FACTOR=auto{1}` directive tells the compiler to keep the loop whole without dividing it into smaller parts, and the `#pragma ACCEL PARALLEL FACTOR=auto{1}` directive specifies to execute loop iterations sequentially, not concurrently. Additionally, within the loops, there are specific directives for pipelining, tiling, and parallelization, which are similarly designed to control the synthesis optimizations for those specific loop nests.\n\nIn summary, this HLS C code defines a hardware-accelerated function for solving a 2D heat equation using the ADI method, and provides specific directives for optimizing the synthesis process.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "### Function Header:\n**Function Name:** kernel_adi  \n**Parameters:**  \n- tsteps (int)\n- n (double)\n- u[60][60] (double)\n- v[60][60] (double)\n- p[60][60] (double)\n- q[60][60] (double)\n\n### Process Description:\nThe function `kernel_adi` implements the Alternating Direction Implicit Method for solving a two-dimensional heat equation. It performs column and row sweeps over a grid, updating the values based on the heat equation's discretized form.\n\n### #pragma Directives:\n1. **#pragma ACCEL PIPELINE auto{off}**  \n   - Explanation: Do not automatically pipeline this loop.\n\n2. **#pragma ACCEL TILE FACTOR=auto{1}**  \n   - Explanation: Keep this loop whole, without dividing it into smaller parts.\n\n3. **#pragma ACCEL PARALLEL FACTOR=auto{1}**  \n   - Explanation: Execute loop iterations sequentially, not concurrently.\n\n4. **#pragma ACCEL PIPELINE auto{flatten}**  \n   - Explanation: Automatically flatten the loop to maximize parallelism.\n\n5. **#pragma ACCEL PARALLEL FACTOR=auto{29}**  \n   - Explanation: Execute parallel iterations based on the specified factor value.\n\n6. **#pragma ACCEL PARALLEL FACTOR=auto{32}**  \n   - Explanation: Execute parallel iterations based on the specified factor value.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "### Function Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n### Description:\nThis function `kernel_adi` represents an algorithm for the Alternating Direction Implicit (ADI) method. It performs a calculation over 40 time-steps to solve a diffusion problem in a 60x60 grid. The process involves column and row sweeps, updating the values of arrays `u`, `v`, `p`, and `q` at each time-step.\n\n### Pragmas:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline the loops within the function, allowing for manual control over the pipeline.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep the loops whole without dividing them into smaller parts, enabling the hardware to process each loop as a single entity without fragmentation.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently, to maintain the data dependencies and computational order.\n- `#pragma ACCERL kernel`: Designates the following function for hardware acceleration, implying that it will be translated into hardware language for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "#### Function Header:\nFunction Name: kernel_adi\nParameters: \n- int tsteps\n- int n\n- double u[60][60]\n- double v[60][60]\n- double p[60][60]\n- double q[60][60]\n\n#### Description:\nThe function `kernel_adi` performs an iterative process for 40 time steps to solve a system of 2D equations using the alternating direction implicit (ADI) method. It involves calculations based on the values of arrays `u`, `v`, `p`, and `q` to update their elements in a specific sequence.\n\n#### Pragmas:\n- `#pragma ACCEL PIPELINE auto{off}`: Disable automatic pipelining for the following loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep the loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n- Additional pragma directives are included within the loops for controlling pipelining, tiling, and parallelization on specific nested loops within the main iteration.\n\nThis HLS code is designed for hardware acceleration and utilizes various pragma directives to control pipeline initiation, loop tiling, and loop parallelization.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\nDescription:\nThis function `kernel_adi` performs an iterative computation involving a set of nested loops to solve an implicit system of 2D equations over multiple time steps. It calculates the values of arrays `u`, `v`, `p`, and `q` by applying certain mathematical operations and conditions within nested loops.\n\n#pragma Directives:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n\nThe code is an implementation of the Alternating Direction Implicit (ADI) method for solving a heat equation. It defines various coefficients and parameters before entering into nested loops for column and row sweeps to solve the equation. The loops are annotated with different `#pragma` directives to guide the HLS tool in optimizing the hardware implementation.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "### Function Header:\n**Function:** `void kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])`\n\n**Parameters:**\n- `tsteps` (int): number of time steps\n- `n` (int): dimension of the problem\n- `u[60][60]` (double): input array u\n- `v[60][60]` (double): input array v\n- `p[60][60]` (double): input array p\n- `q[60][60]` (double): input array q\n\n### Description:\nThe `kernel_adi` function represents an iterative algorithm for solving a 2D problem using the Alternating Direction Implicit (ADI) method. It performs a series of computations over a grid for a specified number of time steps, involving calculations related to fluid dynamics or heat transfer.\n\n### Pragmas:\n1. `#pragma ACCEL PIPELINE auto{off}` - Do not automatically pipeline this loop\n2. `#pragma ACCEL TILE FACTOR=auto{1}` - Keep this loop whole, without dividing it into smaller parts\n3. `#pragma ACCEL PARALLEL FACTOR=auto{1}` - Execute loop iterations sequentially, not concurrently\n4. `#pragma ACCEL kernel` - Designate the following function for hardware acceleration\n\nThe code includes several nested loops, and relevant #pragma directives are applied to control pipelining, loop tiling, and parallelization to optimize hardware acceleration for these computational tasks.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function header: \n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nDescription: \nThis function `kernel_adi` performs an iterative computation of the Alternating Direction Implicit (ADI) method to solve a set of partial differential equations. It initializes some constants and then performs column and row sweeps to update the values in the 2D arrays u, v, p, and q for a specified number of time steps.\n\n#pragma Directives Explanation:\n1. `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n2. `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n3. `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided C code snippet is a kernel function named \"kernel_adi\" that takes in five parameters: an integer \"tsteps,\" an integer \"n,\" and 2D arrays of doubles \"u,\" \"v,\" \"p,\" and \"q.\" The process of this kernel involves performing computation-intensive iterative procedures for a specified number of time steps.\n\nThe code implements various numerical calculations and utilizes loop optimizations for hardware acceleration using HLS. Specifically, it employs #pragma directives to guide the HLS tool in optimizing the hardware implementation.\n\nNow, let's break down the pragma directives:\n\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n\nOverall, the function is designated for hardware acceleration, and the given pragma directives provide guidelines for loop optimization for efficient hardware implementation.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided C code defines a function named 'kernel_adi', which takes in five parameters: an integer 'tsteps', an integer 'n', and arrays of double values 'u', 'v', 'p', and 'q'. The function calculates the values of some variables based on the given inputs and then performs a series of nested loops to update the arrays 'v', 'p', 'q', and 'u' according to a specific algorithm involving the values set earlier on.\n\nThe code includes several #pragma directives to guide the High-Level Synthesis process:\n1. #pragma ACCEL PIPELINE auto{off}: This directive instructs not to automatically pipeline the subsequent loop, preserving the original loop structure.\n2. #pragma ACCEL TILE FACTOR=auto{1}: This directive suggests keeping the loop iteration whole without dividing it into smaller parts.\n3. #pragma ACCEL PARALLEL FACTOR=auto{1}: This directive indicates executing loop iterations sequentially, not concurrently.\n\nOverall, the function is designated for hardware acceleration, as indicated by the '#pragma ACCEL kernel' statement at the beginning of the code.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided C code defines a function called kernel_adi, which is designated for hardware acceleration. This function takes in five parameters: an integer tsteps, an integer n, and three 2D arrays of doubles named u, v, p, and q, each with dimensions 60x60. The function performs a simulation involving multiple iterations over a 2D grid of data.\n\nThe code contains a series of pragma directives that provide instructions to the High-Level Synthesis (HLS) tool during the synthesis process. These directives help optimize the implementation of the function for acceleration on hardware. \n\nThe pragma directives in the code can be translated as follows:\n1. `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n2. `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n3. `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n\nThe function performs calculations using the input data, with the main loop iterating over a simulation for 40 time steps. Within the loop, there are column and row sweep operations that involve nested loops to update the values in the arrays v, p, q, u based on the computed results.\n\nOverall, this function is intended to be optimized for hardware acceleration with the pragma directives guiding the HLS tool to apply specific optimizations for this purpose.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "### Function Header:\n```\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n### Process Overview:\nThis function `kernel_adi` takes in several parameters as inputs and performs a set of calculations in a nested loop structure. The nested loops perform column and row sweeps, iterating through arrays and performing computations based on the array values. The computations involve a series of mathematical operations and assignments on the arrays `u`, `v`, `p`, and `q` over a number of time steps (`tsteps`).\n\n### #pragma Directives:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently. This pragma indicates that the loop iterations should be executed in sequential order.\n- `#pragma ACCEL PIPELINE auto{flatten}`: Automatically flatten this loop to maximize parallelism.\n- `#pragma ACCEL PARALLEL FACTOR=auto{29}`: Execute loop iterations concurrently with a parallelism factor of 29.\n- `#pragma ACCEL PARALLEL FACTOR=auto{16}`: Execute loop iterations concurrently with a parallelism factor of 16.\n\nThese directives are used to guide the high-level synthesis tool in optimizing the hardware design based on loop restructuring, pipelining, and parallelization for FPGA acceleration. They control loop unrolling, pipelining, and parallelization to achieve efficient hardware implementation.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS (High-Level Synthesis) code is a C function kernel_adi with the following signature:\n\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nThis function is intended for hardware acceleration and contains a series of computations for an ADI (Alternating Direction Implicit) method over a 60x60 grid.\n\nThe code begins by defining several variables and then enters a nested loop structure with specific pragma directives applied for hardware synthesis.\n\nIn natural language, the pragma directives can be translated as follows:\n\n- `#pragma ACCEL PIPELINE auto{off}` \u2192 \"Do not automatically pipeline this loop.\"\n- `#pragma ACCEL TILE FACTOR=auto{1}` \u2192 \"Keep this loop whole, without dividing it into smaller parts.\"\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}` \u2192 \"Execute loop iterations sequentially, not concurrently.\"\n\nThese pragmas control the hardware synthesis process, optimizing loop iteration execution and dataflow management for efficient performance.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "## Function Header:\nThe provided HLS code defines a function named `kernel_adi` with the following parameters:\n- `tsteps` - integer\n- `n` - integer\n- `u[60][60]` - 2D array of doubles\n- `v[60][60]` - 2D array of doubles\n- `p[60][60]` - 2D array of doubles\n- `q[60][60]` - 2D array of doubles\n\n## Brief Description:\nThe function `kernel_adi` implements the Alternating Direction Implicit (ADI) method for solving a specific type of partial differential equation. It involves performing column and row sweeps on 2D arrays `u`, `v`, `p`, and `q` for a specific number of time steps (`tsteps`).\n\n## Pragma Directives Explanation:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n- `#pragma ACCEL PIPELINE auto{flatten}`: Flatten the loop so that it can be easily parallelized.\n- `#pragma ACCEL PARALLEL FACTOR=auto{2}`: Execute loop iterations in parallel with a parallelization factor of 2.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The function is named kernel_adi and takes five input parameters: tsteps (an integer), n (an integer), u (a 60x60 matrix of doubles), v (a 60x60 matrix of doubles), and p (a 60x60 matrix of doubles), and q (a 60x60 matrix of doubles). The code calculates various constants and then enters a series of nested loops to perform a multi-step process for a specific number of time steps (tsteps). The outermost loop represents the time steps, followed by two inner loops for column sweep and row sweep, each containing further nested loops for computations.\n\nThe #pragma directives can be interpreted as follows:\n- #pragma ACCEL PIPELINE auto{off}: Do not automatically pipeline this loop.\n- #pragma ACCEL TILE FACTOR=auto{1}: Keep this loop whole, without dividing it into smaller parts.\n- #pragma ACCEL PARALLEL FACTOR=auto{1}: Execute loop iterations sequentially, not concurrently.\n- #pragma ACCEL PIPELINE auto{}: Automatically pipeline this loop.\n- #pragma ACCEL TILE FACTOR=auto{1}: Keep this loop whole, without dividing it into smaller parts.\n- #pragma ACCEL PARALLEL FACTOR=auto{1}: Execute loop iterations sequentially, not concurrently.\n- #pragma ACCEL PARALLEL FACTOR=auto{58}: Execute loop iterations concurrently with a factor of 58.\n- #pragma ACCEL PARALLEL FACTOR=auto{4}: Execute loop iterations concurrently with a factor of 4.\n- #pragma ACCEL PIPELINE auto{off}: Do not automatically pipeline this loop.\n- #pragma ACCEL TILE FACTOR=auto{1}: Keep this loop whole, without dividing it into smaller parts.\n- #pragma ACCEL PARALLEL FACTOR=auto{2}: Execute loop iterations concurrently with a factor of 2.\n- #pragma ACCEL PARALLEL FACTOR=auto{58}: Execute loop iterations concurrently with a factor of 58.\n- #pragma ACCEL PARALLEL FACTOR=auto{8}: Execute loop iterations concurrently with a factor of 8.\n\nThese directives guide the high-level synthesis tool on how to optimize the hardware implementation of the code during synthesis.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The given HLS C code snippet is a function named `kernel_adi`, which takes in five parameters: `tsteps` (an integer), `n` (an integer), `u` (a 2D array of doubles), `v` (a 2D array of doubles), `p` (a 2D array of doubles), and `q` (a 2D array of doubles). The function is designated for hardware acceleration.\n\nThe code computes the alternating direction implicit (ADI) method for solving a partial differential equation. It initializes several variables and then performs column and row sweeps for a specific number of time steps, where it updates the arrays `u`, `v`, `p`, and `q` based on certain calculations.\n\nThe `#pragma` directives are used to specify how the loops and computations should be optimized for hardware synthesis. Here's how each directive would be interpreted:\n\n1. `#pragma ACCEL PIPELINE auto{off}`:\n    - Interpretation: Do not automatically pipeline this loop.\n\n2. `#pragma ACCEL TILE FACTOR=auto{1}`:\n    - Interpretation: Keep this loop whole, without dividing it into smaller parts.\n\n3. `#pragma ACCEL PARALLEL FACTOR=auto{1}`:\n    - Interpretation: Execute loop iterations sequentially, not concurrently.\n\nThe code contains nested loops with specific pragma directives for pipeline, tiling, and parallelization to optimize the hardware performance and resource utilization.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nDescription:\nThe `kernel_adi` function is designed for hardware acceleration and performs the Alternating Direction Implicit (ADI) method for solving a partial differential equation. It takes multiple parameters including the number of time steps `tsteps`, the dimension `n`, and arrays `u`, `v`, `p`, and `q` representing the grid values.\n\n#pragma Directives:\n- `#pragma ACCEL PIPELINE auto{off}`: This pragma directive specifies that no automatic pipelining should be applied to the following loops, essentially indicating that the loops should not be broken down into stages for concurrent execution.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: This pragma directive instructs to keep the following loop whole without dividing it into smaller parts, with the tile factor being automatically determined at 1.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: With this pragma directive, the loop iterations are to be executed sequentially rather than concurrently, and the parallel factor is to be automatically set to 1. This means the loop is not to be parallelized.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS (High-Level Synthesis) code is a C function named 'kernel_adi', which is designated for hardware acceleration. It takes in 6 parameters: an integer 'tsteps', another integer 'n', and 4 two-dimensional arrays of type double - 'u', 'v', 'p', and 'q'. The code focuses on solving a 2D heat diffusion problem over 40 time steps using the ADI (Alternating Direction Implicit) method.\n\nThe code begins with initialization and computation of various constants and coefficients required for the ADI method. It then contains nested loops for column and row sweeps, each with further nested loops to perform numerical computations.\n\nWhen translating the #pragma directives into natural language:\n- '#pragma ACCEL PIPELINE auto{off}' implies that the loop should not be automatically pipelined to improve performance.\n- '#pragma ACCEL TILE FACTOR=auto{1}' instructs to keep the loop whole without dividing it into smaller parts.\n- '#pragma ACCEL PARALLEL FACTOR=auto{1}' indicates that loop iterations should be executed sequentially, not concurrently.\n\nFor specific loops within the column and row sweeps, additional directives are present, tailored to optimizing the performance of those loops.\n\nIn summary, the function 'kernel_adi' is intended for hardware acceleration and is structured to solve the heat diffusion problem using the ADI method, with specific pragma directives guiding the HLS synthesis process for optimizing performance.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "#### Function Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\n#### Description:\nThe function `kernel_adi` performs the Alternating Direction Implicit (ADI) method, an iterative method used to solve parabolic and elliptic partial differential equations. It takes in the number of time steps `tsteps`, the dimension `n`, and arrays `u`, `v`, `p`, and `q`. It then performs computations to solve the partial differential equations using nested loops and array operations.\n\n#### Pragmas:\n1. `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n2. `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n3. `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n4. `#pragma ACCEL PIPELINE auto{flatten}`: Apply loop flattening optimization to pipeline the loop.\n5. `#pragma ACCEL PARALLEL FACTOR=auto{29}`: Execute loop iterations concurrently, potentially using 29 parallel instances.\n6. `#pragma ACCEL PARALLEL FACTOR=auto{8}`: Execute loop iterations concurrently, potentially using 8 parallel instances.\n\n#### Additional Explanation:\nThe function defines several variables and then performs two main nested loops, representing the column sweep and the row sweep of the ADI method. Each loop is optimized using different #pragma directives to control loop pipelining, loop tiling, and loop parallelization for hardware acceleration. These directives help in optimizing the code for high-level synthesis and hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided C code is for the `kernel_adi` function, which is intended to be designated for hardware acceleration using `#pragma ACCEL kernel`. The function takes in several parameters including `tsteps`, `n`, `u[60][60]`, `v[60][60]`, `p[60][60]`, and `q[60][60]`.\n\nThe code initializes several variables and then contains nested loops for column and row sweeps. Within each loop, there are computations involving the given arrays and constants. \n\nThe code also contains several `#pragma` directives to guide the high-level synthesis process:\n- `#pragma ACCEL PIPELINE auto{off}`: This directive indicates to the synthesis tool not to automatically pipeline the specified loops.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: This directive indicates that the specified loops should remain whole without being divided into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: This directive indicates that the loop iterations should be executed sequentially, not concurrently.\n\nIn summary, the `kernel_adi` function prepares and updates arrays `u`, `v`, `p`, and `q` using column and row sweeps over 40 iterations. The appropriate `#pragma` directives are included to guide the hardware synthesis process.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\nDescription:\nThis HLS code defines a function `kernel_adi` that performs the Alternating Direction Implicit (ADI) method for solving a 2D heat equation. It initializes various constants and then conducts column and row sweep operations to update the input arrays `u`, `v`, `p`, and `q` for a specified number of time steps.\n\n#pragma Directives:\n- `#pragma ACCEL PIPELINE auto{off}`: It instructs the tool not to automatically pipeline the subsequent loop, allowing for manual optimization of loop initiation interval.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: It directs the tool to keep the following loop whole without dividing it into smaller parts, providing opportunities for parallelism. \n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: It indicates that loop iterations should be executed sequentially, not concurrently, enhancing loop-level parallelism.\n\nPlease note that the original code may contain some inconsistencies or errors related to pragma syntax which need to be verified with the tool documentation.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS (High-Level Synthesis) code is a C function that utilizes hardware acceleration for a computational algorithm. The function is named kernel_adi and takes in six parameters: tsteps (integer), n (double), and 4 2D arrays of size 60x60 (u, v, p, q, all of type double). The overall process involves performing iterative computations using double precision variables and nested loops to update the arrays based on certain mathematical operations. The code leverages hardware-specific optimizations using #pragma directives to enhance performance when synthesized into hardware.\n\nThe function begins by initializing various double precision variables and then enters into two main nested loop regions: Column Sweep and Row Sweep. Within each sweep, there are inner nested loops containing computations on the input arrays.\n\nFor optimization, the following #pragma directives have been used:\n- #pragma ACCEL PIPELINE auto{off}: Do not automatically pipeline this loop.\n- #pragma ACCEL TILE FACTOR=auto{1}: Keep this loop whole, without dividing it into smaller parts.\n- #pragma ACCEL PARALLEL FACTOR=auto{1}: Execute loop iterations sequentially, not concurrently.\n- #pragma ACCEL kernel: Designate the following function for hardware acceleration.\n\nThese directives are aimed at guiding the HLS tool to better optimize the hardware synthesis process.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nDescription:\nThis function `kernel_adi` implements the Alternating Direction Implicit (ADI) method for solving a partial differential equation over a 2D grid. It performs a series of iterations to update the values of `u`, `v`, `p`, and `q` based on certain time and space steps.\n\nPragma Directives:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n- `#pragma ACCEL kernel`: Designate the following function for hardware acceleration.\n\nOverall, the code is designed to be optimized for hardware acceleration, with specific directives to control loop parallelization, data access patterns, and pipelining.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The function header for the provided HLS (High-Level Synthesis) code snippet is as follows:\n\nFunction: kernel_adi\nParameters:\n- tsteps (int)\n- n (int)\n- u[60][60] (double)\n- v[60][60] (double)\n- p[60][60] (double)\n- q[60][60] (double)\n\nBrief Description:\nThis function represents an iterative process that computes the values of arrays u, v, p, and q based on a set of mathematical operations and is designed for hardware acceleration.\n\nTranslation of #pragma Directives:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n- `#pragma ACCEL kernel`: Designate the following function for hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "### Function Header:\nFunction Name: kernel_adi\nParameters: \n- tsteps (int)\n- n (int)\n- u[60][60] (double)\n- v[60][60] (double)\n- p[60][60] (double)\n- q[60][60] (double)\n\n### Description:\nThe kernel_adi function represents a high-level synthesis (HLS) code that solves the alternating direction implicit (ADI) method for solving a particular system of partial differential equations. It initializes certain variables, sets coefficients, and then iterates over a set of nested loops to perform column and row sweeps.\n\n### Pragma Directives (Translated):\n- `#pragma ACCEL PIPELINE auto{off}` : Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}` : Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}` : Execute loop iterations sequentially, not concurrently.\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function: void kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n\nDescription: The kernel_adi function represents the Alternating Direction Implicit (ADI) method for solving a 2D heat equation. It operates on the arrays u, v, p, and q, with given dimensions, over a specified number of time steps. The process involves multiple nested loops performing calculations for a given number of iterations.\n\n#pragma Directives:\n1. #pragma ACCEL PIPELINE auto{off}: Do not automatically pipeline this loop.\n2. #pragma ACCEL TILE FACTOR=auto{1}: Keep this loop whole without dividing it into smaller parts.\n3. #pragma ACCEL PARALLEL FACTOR=auto{1}: Execute loop iterations sequentially, not concurrently.\n4. #pragma ACCEL kernel: Designate the following function for hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nDescription:\nThe function `kernel_adi` implements an Alternating Direction Implicit (ADI) iterative solver for a specific differential equation. It performs column and row sweeps on a 2D grid to iteratively solve the equation over a certain number of time steps.\n\n#pragma Directives:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n- `#pragma ACCEL kernel`: Designate the following function for hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "### Function Header\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\n### Description\nThe `kernel_adi` function takes in the number of time steps `tsteps`, the dimension `n`, and arrays `u`, `v`, `p`, and `q` of size 60x60 to perform an iterative computation for the Alternating Direction Implicit method.\n\n### #pragma Directives\n- `#pragma ACCEL PIPELINE auto{off}`\n  - Process: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`\n  - Process: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`\n  - Process: Execute loop iterations sequentially, not concurrently.\n- `#pragma ACCEL kernel`\n  - Process: Designate the following function for hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS (High-Level Synthesis) code is a function named 'kernel_adi' with the following header: \n\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nThis function takes several parameters including tsteps, n, and multidimensional arrays u, v, p, and q.\n\nThe code initializes various variables and computes values for DX, DY, DT, B1, B2, mul1, mul2, a, b, c, d, e, and f. \n\nAfter the initialization, the code includes several #pragma directives that give instructions to the HLS tool. Let's translate these directives:\n\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n- Inside the loops, there are additional directives with similar translations to control pipelining, tiling, and parallelism for specific loop iterations.\n\nOverall, the function 'kernel_adi' is designed for hardware acceleration, and the pragma directives are provided to guide the HLS tool in optimizing the hardware implementation of the nested loops within the function.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS C code contains a function named kernel_adi with the following header: \n\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nThis function performs the Alternating Direction Implicit (ADI) method for solving a particular differential equation. It iterates over time steps using both column and row sweeps to update the variables.\n\nThe HLS directives provided in the code can be explained as follows:\n- `#pragma ACCEL PIPELINE auto{off}`: This directive signifies not to automatically pipeline the loop, allowing for full control over loop initiation and termination.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: This directive keeps the loop whole, preventing it from being divided into smaller parts to maximize performance.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Indicates that loop iterations should be executed sequentially, rather than concurrently, to avoid data dependencies.\n\nAdditionally, within the code, there are specific pragma directives for inner loops. These include pipeline, tile, and parallelization directives. They all follow the same format as the top-level directives with slight variations based on the characteristics of each loop.\n\nThe code includes explicit directives for pipelining the column sweep loop, ensuring the loop is not divided into smaller parts. The parallelization factor and the tile factor are also set for each inner loop, specifying how the iterations should be distributed across hardware resources.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "### Function Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\n### Description:\nThis HLS C function `kernel_adi` calculates the Alternating Direction Implicit (ADI) method for solving a system of equations. It performs column and row sweeps for a specified number of time steps, updating the arrays `u`, `v`, `p`, and `q` based on the ADI method's iterative calculations.\n\n### #pragma Directives:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n- `#pragma ACCEL kernel`: Designate the following function for hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS (High-Level Synthesis) code is written in C and designed for hardware acceleration. The function `kernel_adi` takes in five parameters: `tsteps` (integer), `n` (integer), `u` (2D array of doubles), `v` (2D array of doubles), `p` (2D array of doubles), and `q` (2D array of doubles). The function performs the Alternating Direction Implicit (ADI) method to solve a partial differential equation over 40 time steps for a grid of size 60x60.\n\nThe process involves several pragma directives to specify hardware synthesis optimizations. The `#pragma ACCEL PIPELINE auto{off}` directive is used to turn off automatic pipelining for certain loops, while `#pragma ACCEL TILE FACTOR=auto{1}` is applied to keep certain loops whole without dividing them into smaller parts. The `#pragma ACCEL PARALLEL FACTOR=auto{1}` directive is used to execute loop iterations sequentially, rather than concurrently.\n\nThe code contains nested loops that represent the column sweep and row sweep computations for the ADI method. Within these loops, additional pragma directives are used to control the pipelining and parallelization of specific loop iterations.\n\nOverall, this HLS code applies hardware synthesis optimizations to the ADI method for solving a partial differential equation, with careful control over loop pipelining and parallelization to improve hardware performance.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "To begin, the provided HLS (High-Level Synthesis) code is a C function named `kernel_adi` that takes in five parameters: an integer `tsteps`, and four 2D arrays of double type: `u`, `v`, `p`, and `q`, with dimensions 60x60. This function represents a 2D ADI (Alternating Direction Implicit) solver, which iterates over 40 time steps to solve a partial differential equation. \n\nThe code starts by initializing constants and variables necessary for the computation. Inside the function, there are two main nested loops, corresponding to the column sweep and row sweep, which perform calculations and update the arrays `p`, `q`, `u`, and `v` based on the ADI solver algorithm.\n\nNow, let's interpret the #pragma directives in natural language:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts. \n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n- `#pragma ACCEL PIPELINE auto{flatten}`: Automatically flatten loop nests to allow for concurrent execution.\n- `#pragma ACCEL PARALLEL FACTOR=auto{29}`: Execute loop iterations concurrently, with a factor of 29.\n\nIn summary, the function `kernel_adi` is designated for hardware acceleration and consists of nested loops with specific pragma directives to control pipelining, tiling, and parallelization for efficient hardware implementation.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "### Function Header\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\n### Description\nThe `kernel_adi` function represents the algorithm for solving the alternating direction implicit (ADI) equation. It takes in the number of time steps (`tsteps`), the size of the grid (`n`), and arrays `u`, `v`, `p`, and `q` of dimensions 60x60 for computation.\n\nThe process involves iterating through different sweeps and performing computations involving the input arrays `u`, `v`, `p`, and `q` according to the ADI method.\n\n### Pragmas\n- `#pragma ACCEL PIPELINE auto{off}`\n  - Do not automatically pipeline this loop.\n\n- `#pragma ACCEL TILE FACTOR=auto{1}`\n  - Keep this loop whole, without dividing it into smaller parts.\n\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`\n  - Execute loop iterations sequentially, not concurrently.\n\n- `#pragma ACCEL PIPELINE auto{flatten}`\n  - Automatically flatten the loop for better hardware acceleration.\n\n- `#pragma ACCEL PARALLEL FACTOR=auto{29}`\n  - Execute loop iterations concurrently, allowing 29 iterations to be processed in parallel.\n\n- Various other `#pragma` directives exist within the loop constructs to control loop parallelization, pipelining, and tiling. These directives optimize the hardware acceleration of the algorithm by guiding the HLS tool on how to transform the C code into hardware-specific designs.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "### Function Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\n### Description:\nThe `kernel_adi` function represents an algorithm for solving a 2D ADI (Alternating Direction Implicit) equation using Jacobi relaxation. It performs both column and row sweeps over a 60x60 grid for a specified number of time steps. The calculations involve updating values in the arrays `u`, `v`, `p`, and `q` based on specific mathematical operations.\n\n### Pragmas Explained:\n1. `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n2. `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n3. `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS code is a C function named `kernel_adi` intended for hardware acceleration. It takes in five parameters: an integer `tsteps`, an integer `n`, and four 2D arrays of doubles `u[60][60]`, `v[60][60]`, `p[60][60]`, and `q[60][60]`. The function performs the Alternating Direction Implicit (ADI) computation for a computational fluid dynamics simulation over 40 time steps, with a grid size of 60x60.\n\nThe function begins by initializing variables and coefficients for the ADI computation. It then goes into a nested loop, with the outer loop iterating through the time steps and the inner loops performing column and row sweeps over the 2D arrays. Within these loops, parallelism and pipeline directives are applied to optimize the hardware acceleration of the computation.\n\nThe specific pragma directives used in the code can be interpreted as follows:\n\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n\nAdditionally, within the loops, specific parallel factor values like `29` and `4` are mentioned for the row sweep, further detailing the parallelism strategy.\n\nPlease note that some directives like `#pragma ACCEL PIPELINE auto{flatten}` and `#pragma ACCEL PARALLEL FACTOR=auto{2}` are explicitly defined within the loop bodies, indicating specific optimization for those sections of code.\n\nIn summary, the function `kernel_adi` is designed for hardware acceleration and includes pragma directives to optimize parallelism, loop pipelining, and loop partitioning for efficient implementation on an FPGA or similar hardware accelerator.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nDescription:\nThe function `kernel_adi` represents an algorithm for Alternating Direction Implicit (ADI) method. This method is used to solve a partial differential equation for simulating the diffusion of a substance over time.\n\nPragma Directives Explanation:\n1. `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n2. `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n3. `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nThe function `kernel_adi` takes in parameters `tsteps`, `n`, and arrays `u`, `v`, `p`, and `q` of 60x60 double precision values.\n\nDescription:\nThe `kernel_adi` function implements the ADI (Alternating Direction Implicit) method, which is an iterative technique used to solve partial differential equations in computational physics and engineering. The function performs column and row sweeps over the arrays `u`, `v`, `p`, and `q` for a specified number of time steps.\n\n#pragma Directives:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n- The nested `#pragma` directives within the loops have similar interpretations, such as turning off pipeline optimization and specifying parallelism factors for loop iterations.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided C code snippet represents a function called `kernel_adi` with various parameters and computations related to an iterative process. The function's overall process involves performing a computation over a two-dimensional array in a time-stepped manner as well as column and row sweeps. It is intended for high-level synthesis (HLS) targeting hardware acceleration.\n\nThe pragma directives in the code serve as instructions for the HLS tools to apply optimizations during synthesis. The `#pragma ACCEL kernel` designates the following function for hardware acceleration. Subsequently, the `#pragma ACCEL PIPELINE auto{off}` directive instructs to not automatically pipeline the loops, while `#pragma ACCEL TILE FACTOR=auto{1}` indicates that the loops should not be divided into smaller parts, and `#pragma ACCEL PARALLEL FACTOR=auto{1}` requires the loop iterations to be executed sequentially, rather than concurrently.\n\nIn summary, the `kernel_adi` function represents a computation that is intended to be accelerated on hardware, and the pragma directives provide guidance for HLS tools to optimize the synthesis process according to the specifications mentioned above.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided code is a function named `kernel_adi` that takes five parameters: an integer `tsteps`, an integer `n`, and arrays `u`, `v`, `p`, and `q`, each of size 60x60. The code implements the Alternating Direction Implicit (ADI) method to solve a particular problem over a series of time steps. It leverages nested loops to perform column and row sweeps while making some computations and updating the arrays `u`, `v`, `p`, and `q`. \n\nFor the given `kernel_adi` function, there are several `#pragma` directives used to guide the high-level synthesis process:\n- `#pragma ACCEL PIPELINE auto{off}`: This directive instructs not to automatically pipeline the following loop, which means it should be executed sequentially.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: This directive advises to keep the following loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: This directive indicates to execute the following loop iterations sequentially, not concurrently.\n\nThese `#pragma` directives guide the high-level synthesis tool in optimizing the hardware implementation of the given function by specifying how the loops should be parallelized and pipelined.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The given HLS (High-Level Synthesis) C code defines a function `kernel_adi` that comprises the implementation of the ADI (Alternating Direction Implicit) algorithm. This algorithm solves a system of partial differential equations using a two-step process: column sweep and row sweep. The function takes five parameters: `tsteps` for time steps, and arrays `u`, `v`, `p`, and `q` representing the solutions for the system. \n\nThe algorithm computes various intermediary values using double precision arithmetic and then iterates through a sequence of nested loops to perform the column and row sweeps, updating the solution arrays. \n\nThe code includes a series of `#pragma` directives, which map to specific HLS transformations:\n- `#pragma ACCEL PIPELINE auto{off}` : Instructs the HLS tool to not automatically pipeline the following loop, thereby preventing the operation from being divided into smaller parts.\n\n- `#pragma ACCEL TILE FACTOR=auto{1}` : Directs the HLS tool to keep the subsequent loop as a whole without dividing it into smaller parts.\n\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}` : Instructs the HLS tool to execute the loop iterations sequentially, not concurrently.\n\n- `#pragma ACCEL PIPELINE auto{flatten}` : Specifies that the HLS tool should flatten loop hierarchies automatically for better parallelism.\n\nThe `#pragma ACCEL kernel` designates the following function for hardware acceleration.\n\nBy applying these directives, the code aims to guide the HLS tool in optimizing the hardware implementation of the ADI algorithm for FPGA acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS code is a C function named `kernel_adi` that includes a series of calculations using arrays and loops. The function takes in five parameters: `tsteps` of type integer, `n` of type integer, `u` of type double array [60][60], `v` of type double array [60][60], `p` of type double array [60][60], and `q` of type double array [60][60].\n\nThe main process of the code involves performing a series of computations including assignments, calculations, and nested loops. It is designated for hardware acceleration using `#pragma ACCEL kernel`.\n\nThere are several #pragma directives used within the code for hardware synthesis optimizations:\n- `#pragma ACCEL PIPELINE auto{off}`: This directive turns off automatic loop pipelining, instructing the hardware not to pipeline this loop automatically.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: This directive keeps the loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: This directive executes loop iterations sequentially, not concurrently. \n\nIn addition to these #pragma directives, there are nested directives within the loops to control their behavior during hardware synthesis, including pipelining, tiling, and parallelization directives.\n\nOverall, this C function is designed for hardware acceleration and includes specific directives to optimize loop behavior during synthesis.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided code defines a function `kernel_adi` that performs an iterative computation involving multiple nested loops. This function takes as parameters an integer `tsteps` and four 2D arrays, `u`, `v`, `p`, and `q`, each of size 60x60. The function computes and updates the values in the arrays `u`, `v`, `p`, and `q` based on specific mathematical operations and iterations.\n\nThe `#pragma` directives in the code provide guidance for high-level synthesis (HLS) tools to optimize hardware implementation of the loops within the function. The `#pragma ACCEL kernel` directive designates the `kernel_adi` function for hardware acceleration.\n\nThe specific `#pragma` directives within the loops offer further optimizations such as pipelining, loop tiling, and parallel execution to improve the hardware performance. For instance, `#pragma ACCEL PIPELINE auto{off}` indicates that the following loop should not be automatically pipelined, while `#pragma ACCEL TILE FACTOR=auto{1}` instructs the tool to keep the loop whole, without dividing it into smaller parts. Additionally, `#pragma ACCEL PARALLEL FACTOR=auto{1}` specifies that loop iterations should be executed sequentially, not concurrently.\n\nOverall, the HLS directives aim to guide the tool in transforming the C code into a hardware description that maximizes performance and resource utilization while meeting the desired functionality.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "### Function Header:\n**Function Name:** kernel_adi  \n**Parameters:**  \n- int tsteps\n- int n\n- double u[60][60]\n- double v[60][60]\n- double p[60][60]\n- double q[60][60]\n\n### Description:\nThe 'kernel_adi' function takes in time steps (tsteps), a constant (n), and arrays u, v, p, and q of size 60x60, and performs the Alternating Direction Implicit (ADI) method for solving 2D heat equations. It incorporates column and row sweep iterations to update the arrays based on calculated values using a set of differential equations.\n\n### Pragmas Explanation:\n**1. #pragma ACCEL PIPELINE auto{off}**  \n   - Explanation: Do not automatically pipeline this loop.\n\n**2. #pragma ACCEL TILE FACTOR=auto{1}**  \n   - Explanation: Keep this loop whole, without dividing it into smaller parts.\n\n**3. #pragma ACCEL PARALLEL FACTOR=auto{1}**  \n   - Explanation: Execute loop iterations sequentially, not concurrently.\n\n**4. #pragma ACCEL PIPELINE auto{flatten}**  \n   - Explanation: Automatically flatten the loop to allow better parallelization.\n\n**5. #pragma ACCEL PARALLEL FACTOR=auto{29}**  \n   - Explanation: Execute loop iterations concurrently with a factor of 29.\n\n**6. #pragma ACCEL PARALLEL FACTOR=auto{2}**  \n   - Explanation: Execute loop iterations concurrently with a factor of 2.\n\n**7. #pragma ACCEL PARALLEL FACTOR=auto{58}**  \n   - Explanation: Execute loop iterations concurrently with a factor of 58.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{58}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS (High-Level Synthesis) code snippet involves a kernel function called \"kernel_adi\", which takes in five parameters: an integer \"tsteps\", an integer \"n\", and four 2D arrays of doubles: \"u[60][60]\", \"v[60][60]\", \"p[60][60]\", and \"q[60][60]\".\n\nThe overall process of the code involves initializing certain variables, setting up nested loops for column and row operations, and performing computations on the arrays within those loops.\n\nThe \"#pragma\" directives within the code can be interpreted as follows:\n\n- \"#pragma ACCEL PIPELINE auto{off}\": Do not automatically pipeline this loop.\n- \"#pragma ACCEL TILE FACTOR=auto{1}\": Keep this loop whole, without dividing it into smaller parts.\n- \"#pragma ACCEL PARALLEL FACTOR=auto{1}\": Execute loop iterations sequentially, not concurrently.\n- \"#pragma ACCEL kernel\": Designate the following function for hardware acceleration.\n\nIn summary, this HLS code snippet defines a kernel function for hardware acceleration, and its process involves performing column and row operations on 2D arrays using specific #pragma directives to control loop behavior.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS (High-Level Synthesis) C code is a function named `kernel_adi` that is designated for hardware acceleration. The function takes in 5 parameters: `tsteps`, `n`, `u[60][60]`, `v[60][60]`, `p[60][60]`, and `q[60][60]`. The overall process of the code calculates the ADI (Alternating Direction Implicit) method for solving differential equations.\n\nThe #pragma directives in the code can be translated as follows:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline this loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n\nThe code includes nested loops with various #pragma directives within them, each controlling the parallelism, pipelining, and loop tiling of the associated loop. The comments in the code also indicate that specific loop indices should be standardized.\n\nIn summary, the `kernel_adi` function is implemented for hardware acceleration and contains specific #pragma directives to control loop optimizations, such as pipelining, loop tiling, and parallel execution.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS C code snippet defines a function 'kernel_adi', which is designated for hardware acceleration. The function takes in 5 parameters: 'tsteps' (integer), 'n' (integer), 'u' (a 60x60 matrix of doubles), 'v' (a 60x60 matrix of doubles), 'p' (a 60x60 matrix of doubles), and 'q' (a 60x60 matrix of doubles).\n\nThe code aims to implement the Alternating Direction Implicit (ADI) method for solving a partial differential equation. It involves initializing various variables and then iteratively performing column and row sweeps.\n\nThe '#pragma' directives in the code provide instructions for high-level synthesis. They control loop optimizations and parallelism. The following explanations give a natural language interpretation of the '#pragma' directives translated from the HLS code:\n\n1. '#pragma ACCEL PIPELINE auto{off}': Do not automatically pipeline this loop.\n2. '#pragma ACCEL TILE FACTOR=auto{1}': Keep this loop whole, without dividing it into smaller parts.\n3. '#pragma ACCEL PARALLEL FACTOR=auto{1}': Execute loop iterations sequentially, not concurrently.\n\nThese directives help guide the high-level synthesis tool in optimizing the hardware implementation of the specified loops and iterations.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "To understand the provided HLS (High-Level Synthesis) code, we first look at the function header. The function is named `kernel_adi` and it takes in five parameters: an integer `tsteps`, an integer `n`, and three 2D arrays of type double: `u[60][60]`, `v[60][60]`, `p[60][60]`, and `q[60][60]`.\n\nThe code implements the Alternating Direction Implicit (ADI) method to solve a system of partial differential equations. The process involves initializing several constants and coefficients, then iterating through main and sub-loops to update the arrays `v`, `p`, `q`, and `u` for a given number of time steps.\n\nNow let's interpret the #pragma directives in the code:\n\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline the subsequent loop.\n\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep the following loop whole, without dividing it into smaller parts.\n\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n\nThe `kernel_adi` function is designated for hardware acceleration using the `#pragma ACCEL kernel` directive.\n\nIn summary, the `kernel_adi` function implements the ADI method to solve a system of partial differential equations. The #pragma directives provide guidance for the HLS tool on how to optimize the hardware implementation of the loops within the function.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The given C code snippet defines a function named `kernel_adi` with the following signature:\n\n```c\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n```\n\nThe function consists of a time-stepping loop that performs a 2D computation using the ADI (Alternating Direction Implicit) method to solve a particular problem, likely a partial differential equation. This method involves first sweeping through the columns of a grid and then sweeping through the rows.\n\nThe code contains several `#pragma` directives, which provide guidance to the High-Level Synthesis (HLS) tool for generating hardware accelerators. Here's a translation of the directives into natural language:\n\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline the following loop.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently.\n- Nested within loops:\n  - `#pragma ACCEL PIPELINE auto{off}`: Do not automatically pipeline the following loop within the parent loop.\n  - `#pragma ACCEL TILE FACTOR=auto{1}`: Keep this loop whole, without dividing it into smaller parts within the parent loop.\n  - `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently within the parent loop.\n\nOverall, the function is designated for hardware acceleration using the `#pragma ACCEL kernel` directive. The HLS tool should consider the provided directives to guide the generation of hardware optimized for the given loop structure.\n\nThis natural language instruction provides an overview of the function, its purpose, and the HLS directives embedded within the provided C code.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nDescription:\nThe `kernel_adi` function represents an iterative algorithm for solving a set of differential equations using the ADI (Alternating Direction Implicit) method. It operates on arrays `u`, `v`, `p`, and `q` of size 60x60, updating their values utilizing nested loops and specific mathematical operations.\n\nPragma Directives Translation:\n- `#pragma ACCEL PIPELINE auto{off}`: Do not automatically parallelize the loop to increase throughput.\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Keep the loop as a whole, without dividing it into smaller parts for better operation on an FPGA.\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`: Execute loop iterations sequentially, not concurrently to keep data dependencies intact.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The given code is a high-level synthesis (HLS) function written in C. It is meant to be targeted for hardware acceleration.\n\nFunction Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nProcess Description:\nThe function `kernel_adi` performs an iterative computation using the ADI (Alternating Direction Implicit) method. It consists of two main nested loops representing the column sweep and row sweep, where certain calculations are applied to the input arrays `u`, `v`, `p`, and `q`. Several computations are parallelized and optimized for hardware acceleration.\n\n#pragma Directives:\n- `#pragma ACCEL PIPELINE auto{off}`\n  - Do not automatically pipeline this loop.\n\n- `#pragma ACCEL TILE FACTOR=auto{1}`\n  - Keep this loop whole, without dividing it into smaller parts.\n\n- `#pragma ACCEL PARALLEL FACTOR=auto{1}`\n  - Execute loop iterations sequentially, not concurrently.\n\n- `#pragma ACCEL kernel`\n  - Designate the following function for hardware acceleration.\n\nPlease note that the provided code snippet does not include the detailed explanations for `#pragma ACCEL PIPELINE auto{off}`, `#pragma ACCEL TILE FACTOR=auto{1}`, and `#pragma ACCEL PARALLEL FACTOR=auto{1}`. If you require more detailed interpretations for these directives, please provide additional details and I will be glad to assist further.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Function Header:\n```c\nvoid kernel_adi(int tsteps, int n, double u[60][60], double v[60][60], double p[60][60], double q[60][60])\n```\n\nDescription:\nThe function `kernel_adi` takes in parameters `tsteps`, `n`, `u`, `v`, `p`, and `q` and performs the Alternating Direction Implicit (ADI) method on the input arrays `u`, `v`, `p`, and `q` for a specified number of time steps.\n\n#pragma Directives:\n1. `#pragma ACCEL PIPELINE auto{off}` \n   - Do not automatically pipeline this loop.\n\n2. `#pragma ACCEL TILE FACTOR=auto{1}`\n   - Keep this loop whole, without dividing it into smaller parts.\n\n3. `#pragma ACCEL PARALLEL FACTOR=auto{1}` \n   - Execute loop iterations sequentially, not concurrently.\n\n4. `#pragma ACCEL PIPELINE auto{flatten}`\n   - Automatically flatten loops for hardware acceleration.\n\n5. `#pragma ACCEL PARALLEL FACTOR=auto{29}`\n   - Execute loop iterations in parallel, dividing into 29 parts for hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -c / (a * p[i][j - 1] + b);\n        q[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n      }\n      v[60 - 1][i] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j <= 57; j++) {\n        int _in_j_0 = 58 + -1 * j;\n        v[_in_j_0][i] = p[i][_in_j_0] * v[_in_j_0 + 1][i] + q[i][_in_j_0];\n      }\n      j = 1 + -1;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -f / (d * p[i][j - 1] + e);\n        q[i][j] = (-a * v[i - 1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n      }\n      u[i][60 - 1] = 1.0;\n/* Standardize from: for(j = 60 - 2;j >= 1;j--) {...} */\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j <= 57; j++) {\n        int _in_j = 58 + -1 * j;\n        u[i][_in_j] = p[i][_in_j] * u[i][_in_j + 1] + q[i][_in_j];\n      }\n      j = 1 + -1;\n    }\n  }\n//#pragma endscop\n}\n"}
