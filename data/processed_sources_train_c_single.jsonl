{"instruction": "Generate HLS code with the following instructions:", "input": "This code calculates the kernel matrix multiplication. Five 2D float arrays are defined, these arrays are A, B, C, D and E_out each with a size of N * N. There are temporary arrays and buffer arrays for each input and output. First two loops iterate over each element for each array A, B, C, D and E_out. Buffer arrays take the input arrays' values and E_out and temporary arrays are set to zero. Then, there are three nested loops where the first temporary array calculates the product of arrays A and B. Another three nested loops calculate the product of arrays C and D, results are stored in a second temporary array. The final three nested loops calculates the product of the two temporary arrays results and stored the results in a buffer array for E_out. Finally the buffered output values are written back in array E_out. You need to use pragma directives to parallelize the three set of loops for matrix multiplication separately to increase efficiency, pragma for dataflow to allow all loops and function calls to run concurrently, and pragma to enable the pipelining of loops for higher throughput.", "output": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n#define N 64\n\n#define DATA_TYPE float\n#define SCALAR_VAL(x) x##f\n#define SQRT_FUN(x) sqrtf(x)\n#define EXP_FUN(x) expf(x)\n#define POW_FUN(x,y) powf(x,y)\n\nvoid k3mm(DATA_TYPE A[N][N], DATA_TYPE B[N][N], DATA_TYPE C[N][N], DATA_TYPE D[N][N], DATA_TYPE E_out[N][N]);\n\nvoid k3mm(DATA_TYPE A[N][N], DATA_TYPE B[N][N], DATA_TYPE C[N][N], DATA_TYPE D[N][N], DATA_TYPE E_out[N][N])\n{\n    int i, j, k;\n\n    DATA_TYPE buff_A[N][N];\n    DATA_TYPE buff_B[N][N];\n    DATA_TYPE buff_C[N][N];\n    DATA_TYPE buff_D[N][N];\n    DATA_TYPE buff_E_out[N][N];\n    DATA_TYPE tmp1[N][N];\n    DATA_TYPE tmp2[N][N];\n\n    lprd_1: for (i = 0; i < N; i++) {\n        lprd_2: for (j = 0; j < N; j++) {\n            buff_A[i][j] = A[i][j];\n            buff_B[i][j] = B[i][j];\n            buff_C[i][j] = C[i][j];\n            buff_D[i][j] = D[i][j];\n            buff_E_out[i][j] = 0;\n            tmp1[i][j] = 0;\n            tmp2[i][j] = 0;\n        }\n    }\n\n    lp1: for (i = 0; i < N; i++) {\n        lp2: for (j = 0; j < N; j++) {\n            lp3: for (k = 0; k < N; k++) {\n                tmp1[i][j] += buff_A[i][k] * buff_B[k][j];\n            }\n        }\n    }\n\n    lp4: for (i = 0; i < N; i++) {\n        lp5: for (j = 0; j < N; j++) {\n            lp6: for (k = 0; k < N; k++) {\n                tmp2[i][j] += buff_C[i][k] * buff_D[k][j];\n            }\n        }\n    }\n    \n    lp7: for (i = 0; i < N; i++) {\n        lp8: for (j = 0; j < N; j++) {\n            lp9: for (k = 0; k < N; k++) {\n                buff_E_out[i][j] += tmp1[i][k] * tmp2[k][j];\n            }\n        }\n    }\n\n    lpwr_1: for (i = 0; i < N; i++) {\n        lpwr_2: for (j = 0; j < N; j++) {\n            E_out[i][j] = buff_E_out[i][j];\n        }\n    }\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The given C code demonstrates how to define a function `cpp_ap_int_arith` that performs four basic arithmetic operations using ap_integer types from the 'ap_int.h' library. The function takes four input parameters: `dinA_t inA`, `dinB_t inB`, `dinC_t inC`, and `dinD_t inD` - these are custom data types of various bit lengths defined using the `ap_int` and `ap_uint` classes. Then, it performs multiplication of `inA` and `inB`, addition of `inB` and `inA`, division of `inC` by `inA`, and remainder operation of `inD` mod `inA`. The results of these operations are stored in the pointers `out1`, `out2`, `out3`, and `out4`, which are sent as parameters to the function. These pointers are also defined with custom data types (`dout1_t`, `dout2_t`, `dout3_t`, `dout4_t`) of various bit lengths. Please note that this code does not contain any pragma values to be described.", "output": "#include <stdio.h>\n#include \"ap_int.h\"\n\n#define N 9\n\ntypedef ap_int<6> dinA_t;\ntypedef ap_int<12> dinB_t;\ntypedef ap_int<22> dinC_t;\ntypedef ap_int<33> dinD_t;\n\ntypedef ap_int<18> dout1_t;\ntypedef ap_uint<13> dout2_t;\ntypedef ap_int<22> dout3_t;\ntypedef ap_int<6> dout4_t;\n\nvoid cpp_ap_int_arith(dinA_t inA,dinB_t inB,dinC_t inC,dinD_t inD,dout1_t *out1,dout2_t *out2,dout3_t *out3,dout4_t *out4);\n\n\nvoid cpp_ap_int_arith(dinA_t  inA, dinB_t  inB, dinC_t  inC, dinD_t  inD,\n  \t\t       dout1_t *out1, dout2_t *out2, dout3_t *out3, dout4_t *out4\n  ) {\n\n\t// Basic arithmetic operations\n\t*out1 = inA * inB;\n\t*out2 = inB + inA;\n\t*out3 = inC / inA;\n\t*out4 = inD % inA;\n\n} \n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "This high-level synthesis (HLS) C code describes the hardware implementation of a digit recognition system using a K-Nearest Neighbors (KNN) algorithm. The code contains three essential functions: popcount, update_knn, and knn_vote, used for calculating Hamming distances, updating K nearest neighbors, and voting for the final result respectively.\n\nIn the update_knn function, the test and training instances are taken, and the distances from the test instance to the training instances are updated by comparing with the K nearest known distances. '#pragma HLS inline' is used to optimize this function by avoiding the overhead of function call.\n\nThe knn_vote function takes the list of nearest neighbor distances and returns the label with the most votes. The list maintains K nearest distances and their corresponding labels. '#pragma HLS inline' is used here too.\n\nThe main function, DigitRec, contains a significant amount of logic to coordinate the digit recognition process. It first checks the 'run' variable to see if it needs to load data (when run equals 0) or process data (when run equals 1). Training data are partitioned for parallel access and processing through loops that are pipelined for efficiency.\n\nAlso, the code uses '#pragma SDS data mem_attribute' and '#pragma SDS data data_mover' to specify the data accessibility characteristics and the method of moving data from the processor to the FPGA, using the AXIDMA_SIMPLE method.", "output": "/*===============================================================*/\n/*                                                               */\n/*                          digitrec.cpp                         */\n/*                                                               */\n/*             Hardware function for digit recognition           */\n/*                                                               */\n/*===============================================================*/\n\n// dataset information\n#define NUM_TRAINING 18000\n#define CLASS_SIZE 1800\n#define NUM_TEST 2000\n#define DIGIT_WIDTH 4\n\n// typedefs\ntypedef unsigned long long DigitType;\ntypedef unsigned char      LabelType;\n\n// parameters\n#define K_CONST 3\n#define PAR_FACTOR 40\n\n#include \"ap_int.h\"\n// sdsoc wide vector type\ntypedef ap_uint<256>  WholeDigitType;\n\n#pragma SDS data mem_attribute(global_training_set:PHYSICAL_CONTIGUOUS, global_test_set:PHYSICAL_CONTIGUOUS, global_results:PHYSICAL_CONTIGUOUS)\n#pragma SDS data data_mover(global_training_set:AXIDMA_SIMPLE, global_test_set:AXIDMA_SIMPLE, global_results:AXIDMA_SIMPLE)\nvoid DigitRec(WholeDigitType global_training_set[NUM_TRAINING / 2], WholeDigitType global_test_set[NUM_TEST], LabelType global_results[NUM_TEST], int run);\n\n\n// popcount function\nint popcount(WholeDigitType x)\n{\n  // most straightforward implementation\n  // actually not bad on FPGA\n  int cnt = 0;\n  for (int i = 0; i < 256; i ++ )\n    cnt = cnt + x[i];\n\n  return cnt;\n}\n\n// Given the test instance and a (new) training instance, this\n// function maintains/updates an array of K minimum\n// distances per training set.\nvoid update_knn( WholeDigitType test_inst, WholeDigitType train_inst, int min_distances[K_CONST] ) \n{\n  #pragma HLS inline\n\n  // Compute the difference using XOR\n  WholeDigitType diff = test_inst ^ train_inst;\n\n  int dist = 0;\n\n  dist = popcount(diff);\n\n  int max_dist = 0;\n  int max_dist_id = K_CONST+1;\n  int k = 0;\n\n  // Find the max distance\n  FIND_MAX_DIST: for ( int k = 0; k < K_CONST; ++k ) \n  {\n    if ( min_distances[k] > max_dist ) \n    {\n      max_dist = min_distances[k];\n      max_dist_id = k;\n    }\n  }\n\n  // Replace the entry with the max distance\n  if ( dist < max_dist )\n    min_distances[max_dist_id] = dist;\n\n  return;\n}\n\n// Given 10xK minimum distance values, this function\n// finds the actual K nearest neighbors and determines the\n// final output based on the most common int represented by\n// these nearest neighbors (i.e., a vote among KNNs).\nLabelType knn_vote( int knn_set[PAR_FACTOR * K_CONST] ) \n{\n  #pragma HLS inline\n\n  // local buffers\n\n  // final K nearest neighbors\n  int min_distance_list[K_CONST];\n  #pragma HLS array_partition variable=min_distance_list complete dim=0\n  // labels for the K nearest neighbors\n  int label_list[K_CONST];\n  #pragma HLS array_partition variable=label_list complete dim=0\n  // voting boxes\n  int vote_list[10];\n  #pragma HLS array_partition variable=vote_list complete dim=0\n\n  int pos = 1000;\n\n  // initialize\n  INIT_1: for (int i = 0;i < K_CONST; i ++ )\n  {\n    #pragma HLS unroll\n    min_distance_list[i] = 256;\n    label_list[i] = 9;\n  }\n\n  INIT_2: for (int i = 0;i < 10; i ++ )\n  {\n    #pragma HLS unroll\n    vote_list[i] = 0;\n  }\n\n  // go through all the lanes\n  // do an insertion sort to keep a sorted neighbor list\n  LANES: for (int i = 0; i < PAR_FACTOR; i ++ )\n  {\n    INSERTION_SORT_OUTER: for (int j = 0; j < K_CONST; j ++ )\n    {\n      #pragma HLS pipeline\n      pos = 1000;\n      INSERTION_SORT_INNER: for (int r = 0; r < K_CONST; r ++ )\n      {\n        #pragma HLS unroll\n        pos = ((knn_set[i*K_CONST+j] < min_distance_list[r]) && (pos > K_CONST)) ? r : pos;\n      }\n\n      INSERT: for (int r = K_CONST ;r > 0; r -- )\n      {\n        #pragma HLS unroll\n        if(r-1 > pos)\n        {\n          min_distance_list[r-1] = min_distance_list[r-2];\n          label_list[r-1] = label_list[r-2];\n        }\n        else if (r-1 == pos)\n        {\n          min_distance_list[r-1] = knn_set[i*K_CONST+j];\n          label_list[r-1] = i / (PAR_FACTOR / 10);\n        }\n      }\n    }\n  }\n\n  // vote\n  INCREMENT: for (int i = 0;i < K_CONST; i ++ )\n  {\n    #pragma HLS pipeline\n    vote_list[label_list[i]] += 1;\n  }\n\n  LabelType max_vote;\n  max_vote = 0;\n\n  // find the maximum value\n  VOTE: for (int i = 0;i < 10; i ++ )\n  {\n    #pragma HLS unroll\n    if(vote_list[i] >= vote_list[max_vote])\n    {\n      max_vote = i;\n    }\n  }\n\n  return max_vote;\n\n}\n\n// top-level hardware function\n// since AXIDMA_SIMPLE interface does not support arrays with size more than 16384 on interface\n// we call this function twice to transfer data\nvoid DigitRec(WholeDigitType global_training_set[NUM_TRAINING / 2], WholeDigitType global_test_set[NUM_TEST], LabelType global_results[NUM_TEST], int run) \n{\n\n  // This array stores K minimum distances per training set\n  int knn_set[PAR_FACTOR * K_CONST];\n  //#pragma HLS array_partition variable=knn_set complete dim=0\n\n  static WholeDigitType training_set [NUM_TRAINING];\n  // to be used in a pragma\n  const int unroll_factor = PAR_FACTOR;\n  //#pragma HLS array_partition variable=training_set block factor=unroll_factor dim=0\n\n  static WholeDigitType test_set     [NUM_TEST];\n  static LabelType results           [NUM_TEST];\n\n  // the first time, just do data transfer and return\n  if (run == 0)\n  {\n    // copy the training set for the first time\n    lp1:for (int i = 0; i < NUM_TRAINING / 2; i ++ )\n      //#pragma HLS pipeline\n      training_set[i] = global_training_set[i];\n    return;\n  }\n\n  // for the second time\n  lp2:for (int i = 0; i < NUM_TRAINING / 2; i ++ )\n    //#pragma HLS pipeline\n    training_set[i + NUM_TRAINING / 2] = global_training_set[i];\n  // copy the test set\n  lp3:for (int i = 0; i < NUM_TEST; i ++ )\n    //#pragma HLS pipeline\n    test_set[i] = global_test_set[i];\n\n  // loop through test set\n  TEST_LOOP: for (int t = 0; t < NUM_TEST; ++t) \n  {\n    // fetch one instance\n    WholeDigitType test_instance = test_set[t];\n\n    // Initialize the knn set\n    SET_KNN_SET: for ( int i = 0; i < K_CONST * PAR_FACTOR ; ++i ) \n    {\n      #pragma HLS unroll\n      // Note that the max distance is 256\n      knn_set[i] = 256;\n    }\n\n    TRAINING_LOOP : for ( int i = 0; i < NUM_TRAINING / PAR_FACTOR; ++i ) \n    {\n      //#pragma HLS pipeline\n      LANES : for ( int j = 0; j < PAR_FACTOR; j++ ) \n      {\n        //#pragma HLS unroll\n        // Read a new instance from the training set\n        WholeDigitType training_instance = training_set[j * NUM_TRAINING / PAR_FACTOR + i];\n\n        // Update the KNN set\n        update_knn( test_instance, training_instance, &knn_set[j * K_CONST] );\n      }\n    }\n    // Compute the final output\n    LabelType max_vote = knn_vote(knn_set);\n    results[t] = max_vote;\n\n  }\n\n  // copy the results out\n  lp4: for (int i = 0; i < NUM_TEST; i ++ )\n    //#pragma HLS pipeline\n    global_results[i] = results[i];\n\n}\n\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The given C code is implementing the SYRK (\"symmetric rank-k\") operation in linear algebra. The SYRK operation is a simplified version of the matrix-matrix multiplication, where one of the input matrices is assumed to be the transpose of the other. The function `syrk` has five major sections.\n\n1. In the first section, the function initializes two buffers `buff_A0` and `buff_A1` with the same values from matrix A, `buff_B` with the values of matrix B, and `buff_C_out` with zeros. \n2. Then it performs the first round of multiplication operation, where each element of `buff_C_out` is incremented with the multiplication of `alpha`, `buff_A0[i][k]` and `buff_A1[j][k]`. \n3. In the third section, each element of `buff_C_out` is incremented with the multiplication of `beta` and `buff_B[i][j]`. \n4. Lastly, the contents of `buff_C_out` are written to the output matrix `C_out`. If `j` is greater than `i`, the element at `C_out[i][j]` is set to zero; otherwise, it's set to `buff_C_out[i][j]`.\n5. There is no specific #pragma is used in the code, hence, it will depend on the compiler's default settings for optimization.\n\nMake sure to set optimization flags appropriate to your specific hardware when compiling this code for better performance.", "output": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n#define N 64\n\n#define DATA_TYPE float\n#define SCALAR_VAL(x) x##f\n#define SQRT_FUN(x) sqrtf(x)\n#define EXP_FUN(x) expf(x)\n#define POW_FUN(x,y) powf(x,y)\n\nvoid syrk(DATA_TYPE alpha, DATA_TYPE beta, DATA_TYPE A[N][N], DATA_TYPE B[N][N], DATA_TYPE C_out[N][N]);\n\n\nvoid syrk(DATA_TYPE alpha, DATA_TYPE beta, DATA_TYPE A[N][N], DATA_TYPE B[N][N], DATA_TYPE C_out[N][N]) {\n\tint i, j, k;\n\n\tDATA_TYPE buff_A0[N][N], buff_A1[N][N];\n\tDATA_TYPE buff_B[N][N];\n\tDATA_TYPE buff_C_out[N][N];\n\n\tlprd_1: for (i = 0; i < N; i++) {\n\t\tlprd_2: for (j = 0; j < N; j++) {\n\t\t\tbuff_A0[i][j] = A[i][j];\n\t\t\tbuff_A1[i][j] = A[i][j];\n\t\t\tbuff_B[i][j] = B[i][j];\n\t\t\tbuff_C_out[i][j] = 0;\n\t\t}\n\t}\n\n\tlp1: for (i = 0; i < N; i++) {\n\t\tlp2: for (j = 0; j < N; j++) {\n\t\t\t// if (j > i) continue;\n\t\t\tlp3: for (k = 0; k < N; k++) {\n\t\t\t\tbuff_C_out[i][j] += alpha * buff_A0[i][k] * buff_A1[j][k];\n\t\t\t}\n\t\t}\n\t}\n\n\tlp4: for (i = 0; i < N; i++) {\n\t\tlp5: for (j = 0; j < N; j++) {\n\t\t\t// if (j > i) continue;\n\t\t\tbuff_C_out[i][j] += beta * buff_B[i][j];\n\t\t}\n\t}\n\n\t\n\n\tlpwr_1: for(i = 0; i < N; i++) {\n\t\tlpwr_2: for(j = 0; j < N; j++) {\n\t\t\tif (j > i) C_out[i][j] = 0;\n\t\t\telse C_out[i][j] = buff_C_out[i][j];\n\t\t}\n\t}\n}\n\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "This C code is a function called 'atax' used to perform a specific mathematical operation on arrays 'A', 'x' and 'y_out'. The function uses a set of nested 'for' loops to iterate over these arrays. \n\nThe initial block of nested loops reads data from the input arrays 'A' and 'x' and initializes arrays 'buff_A', 'buff_x', 'buff_y_out' and 'tmp1'. \n\nIn the second block of nested loops, each element 'i' of 'tmp1' array is updated by adding the product of element 'i' of array 'buff_A' and element 'j' of 'buff_x'. \n\nIn the third block, each element 'j' of 'buff_y_out' array is updated by adding the product of element 'i' of 'tmp1' and element 'i' of 'buff_A'. \n\nFinally, in the last 'for' loop, the values from the 'buff_y_out' array are copied back into 'y_out' array. \n\nTo optimize this function for HLS, you could apply pipeline optimization to each of the loops as '#pragma HLS PIPELINE' in the loop's immediate preceding line. Also, you may want to apply dataflow optimization at function level as '#pragma HLS DATAFLOW' at the start of function definition, and the arrays could be set to block, which improves the memory access speed by '#pragma HLS ARRAY_PARTITION block factor=<...> VARIABLE=<...>' before each array initialization.", "output": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n#define N 64\n\n#define DATA_TYPE float\n#define SCALAR_VAL(x) x##f\n#define SQRT_FUN(x) sqrtf(x)\n#define EXP_FUN(x) expf(x)\n#define POW_FUN(x,y) powf(x,y)\n\nvoid atax(DATA_TYPE A[N][N], DATA_TYPE x[N], DATA_TYPE y_out[N]);\n\nvoid atax(DATA_TYPE A[N][N], DATA_TYPE x[N], DATA_TYPE y_out[N])\n{\n    int i, j;\n    DATA_TYPE buff_A[N][N];\n    DATA_TYPE buff_x[N];\n    DATA_TYPE buff_y_out[N];\n    DATA_TYPE tmp1[N];\n\n    lprd_1: for (i = 0; i < N; i++) {\n        buff_x[i] = x[i];\n    \tbuff_y_out[i] = 0;\n        tmp1[i] = 0;\n    \tlprd_2: for (j = 0; j < N; j++) {\n    \t\tbuff_A[i][j] = A[i][j];\n    \t}\n    }\n\n    lp1: for (i = 0; i < N; i++) {\n        lp2: for (j = 0; j < N; j++) {\n\t        tmp1[i] = tmp1[i] + buff_A[i][j] * buff_x[j];\n        }\n    }\n\n    lp3: for (i = 0; i < N; i++) {\n        lp4: for (j = 0; j < N; j++) {\n        \tbuff_y_out[j] = buff_y_out[j] + buff_A[i][j] * tmp1[i];\n        }\n    }\n\n    lpwr_1: for (i = 0; i < N; i++) {\n        y_out[i] = buff_y_out[i];\n    }\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The provided HLS (High Level Synthesis) code in C, defines and implements a function named 'syr2k' which performs a symmetric rank-2k update. \n\nFirst, it defines two pre-provisioned multi-dimensional arrays 'buff_A' and 'buff_B' as well as 'buff_C' and 'buff_D_out' each of size NxN, also temporary arrays 'tmp1' and 'tmp2'. Before processing, the code fills 'buff_A', 'buff_B', 'buff_C' and 'buff_D_out' with values copied from input arrays 'A', 'B' and 'C' and initialized 'tmp1', 'tmp2' and 'buff_D_out' with 0.\n\nThen, in the next two loops, it computes 'tmp1' and 'tmp2' respectively by traversing over each cell of NxN matrices 'buff_A' and 'buff_B' and multiply it with a scalar value 'alpha'. \n\nAfterwards, a new loop is used to compute 'buff_D_out', this is done by adding the computed 'tmp1', 'tmp2' and the product of 'beta' and 'buff_C'.\n\nFinally, the output array 'D_out' is updated with the values from 'buff_D_out', discarding the upper triangular part of 'buff_D_out' (when j>i).\n\nNote: No pragma directives are used in the given code. Pragma directives would be used for optimization purposes such as pipelining, parallelization and specification of operation on hardware (FPGA) accelerators. These directives precede loop or functions they are intended to optimize.\n", "output": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n#define N 64\n\n#define DATA_TYPE float\n#define SCALAR_VAL(x) x##f\n#define SQRT_FUN(x) sqrtf(x)\n#define EXP_FUN(x) expf(x)\n#define POW_FUN(x,y) powf(x,y)\n\nvoid syr2k(DATA_TYPE alpha, DATA_TYPE beta, DATA_TYPE A[N][N], DATA_TYPE B[N][N], DATA_TYPE C[N][N], DATA_TYPE D_out[N][N]);\n\n\nvoid syr2k(DATA_TYPE alpha, DATA_TYPE beta, DATA_TYPE A[N][N], DATA_TYPE B[N][N], DATA_TYPE C[N][N], DATA_TYPE D_out[N][N]){\n\tint i, j, k;\n\tDATA_TYPE buff_A0[N][N], buff_A1[N][N];\n\tDATA_TYPE buff_B0[N][N], buff_B1[N][N];\n\tDATA_TYPE buff_C[N][N];\n\tDATA_TYPE buff_D_out[N][N];\n\tDATA_TYPE tmp1[N][N];\n\tDATA_TYPE tmp2[N][N];\n\n\n\tlprd_1: for (i = 0; i < N; i++){\n\t\tlprd_2: for (j = 0; j < N; j++){\n\t\t\tbuff_A0[i][j] = A[i][j];\n\t\t\tbuff_A1[i][j] = A[i][j];\n\t\t\tbuff_B0[i][j] = B[i][j];\n\t\t\tbuff_B1[i][j] = B[i][j];\n\t\t\tbuff_C[i][j] = C[i][j];\n\t\t\tbuff_D_out[i][j] = 0;\n\t\t\ttmp1[i][j] = 0;\n\t\t\ttmp2[i][j] = 0;\n\t\t}\n\t}\n\n\tlp1: for (i = 0; i < N; i++){\n\t\tlp2: for (j = 0; j < N; j++){\n\t\t\t// if (j > i) continue;\n\t\t\tlp3: for (k = 0; k < N; k++){\n\t\t\t\ttmp1[i][j] += alpha * buff_A0[i][k] * buff_B0[j][k];\n\t\t\t}\n\t\t}\n\t}\n\n\tlp4: for (i = 0; i < N; i++){\n\t\tlp5: for (j = 0; j < N; j++){\n\t\t\t// if (j > i) continue;\n\t\t\tlp6: for (k = 0; k < N; k++){\n\t\t\t\ttmp2[i][j] += alpha * buff_B0[i][k] * buff_A1[j][k];\n\t\t\t}\n\t\t}\n\t}\n\n\tlp7: for (i = 0; i < N; i++){\n\t\tlp8: for (j = 0; j < N; j++){\n\t\t\t//if (j > i) continue;\n\t\t\tbuff_D_out[i][j] = tmp1[i][j] + tmp2[i][j] + beta * buff_C[i][j];\n\t\t}\n\t}\n\n\tlpwr_1: for(i = 0; i < N; i++){\n\t\tlpwr_2: for(j = 0; j < N; j++){\n\t\t\tif (j > i) D_out[i][j] = 0;\n\t\t\telse D_out[i][j] = buff_D_out[i][j];\n\t\t}\n\t}\n}\n\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The HLS code is a standard C implementation for the linear algebra operation named \"GESUMMV\" (Generalized Scaled Sum of a Matrix and a Vector). It operates on two square matrices (A and B), two real numbers (alpha and beta), and one vector (x) of size N, and outputs a vector (y_out) also of size N. \n\nThe code starts by defining requisite data types, macros and declaring all necessary variables, including buffers for matrices A and B, the input vector x, and the output vector y_out. It also declares two temporary variables, tmp1 and tmp2, to hold intermediate results.\n\nThe function 'gesummv' is then defined, which executes five main loops namely 'lprd', 'lp1' , 'lp2' , 'lp3', 'lp4', 'lp5', and 'lpwr'.\n\nIn 'lprd' loop, the function first copies the input matrices A and B, and vector x into the respective buffers, and also initializes the variables, tmp1, tmp2, and buff_y_out with zero.\n\nIn the 'lp1' and 'lp2' loops, the function then calculates the product of 'alpha' and each element of matrix A and vector x, and accumulates the results in tmp1.\n\nSimilarly, in the 'lp3' and 'lp4' loops, the function calculates the product of 'beta' and each element of matrix B and vector x, and accumulates the results in tmp2.\n\nThen in 'lp5', it adds respective elements in tmp1 and tmp2 and stores the result in buff_y_out.\n\nFinally, in 'lpwr' it copies buff_y_out into the output vector y_out.\n\nThis code is set up to be processed using High Level Synthesis (HLS), which could be facilitated by using pragma directives to guide how HLS tool performs the synthesis. However, it's noted that no specific pragma values are currently present in the code.", "output": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n#define N 64\n\n#define DATA_TYPE float\n#define SCALAR_VAL(x) x##f\n#define SQRT_FUN(x) sqrtf(x)\n#define EXP_FUN(x) expf(x)\n#define POW_FUN(x,y) powf(x,y)\n\nvoid gesummv(DATA_TYPE alpha, DATA_TYPE beta, DATA_TYPE A[N][N], DATA_TYPE B[N][N], DATA_TYPE x[N], DATA_TYPE y_out[N]);\n\n\nvoid gesummv(DATA_TYPE alpha, DATA_TYPE beta, DATA_TYPE A[N][N], DATA_TYPE B[N][N], DATA_TYPE x[N], DATA_TYPE y_out[N])\n{\n    int i, j;\n\tDATA_TYPE buff_A[N][N];\n\tDATA_TYPE buff_B[N][N];\n\tDATA_TYPE buff_x[N];\n\tDATA_TYPE buff_y_out[N];\n\tDATA_TYPE tmp1[N];\n\tDATA_TYPE tmp2[N];\n\n\tlprd_1: for(i = 0; i < N; i++) {\n\t\tbuff_x[i] = x[i];\n\t\ttmp1[i] = 0;\n\t\ttmp2[i] = 0;\n\t\tbuff_y_out[i] = 0;\n\t\tlprd_2: for(j = 0; j < N; j++) {\n\t\t\tbuff_A[i][j] = A[i][j];\n\t\t\tbuff_B[i][j] = B[i][j];\n\t\t}\n\t}\n\n    lp1: for(i = 0; i < N; i++) {\n        lp2: for(j = 0; j < N; j++) {\n\t        tmp1[i] += alpha * buff_A[i][j] * buff_x[j];\n        }\n    }\n\n\tlp3: for(i = 0; i < N; i++) {\n        lp4: for(j = 0; j < N; j++) {\n\t        tmp2[i] += beta * buff_B[i][j] * buff_x[j];\n        }\n    }\n\n\tlp5: for(i = 0; i < N; i++) {\n\t\tbuff_y_out[i] = tmp1[i] + tmp2[i];\n\t}\n\n\tlpwr: for(i = 0; i < N; i++) {\n\t\ty_out[i] = buff_y_out[i];\n\t}\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "This HLS C based code performs 3D rendering using various specialized data types and functions. It first includes files and defines the world, then struct data types for 3D and 2D triangles as well as candidate pixels and colored pixels. Then it defines data access patterns for input and output using \"#pragma SDS data access_pattern(input:SEQUENTIAL, output:SEQUENTIAL)\". It then develops multiple utility functions, each with a specific role in the 3D rendering process. These include functions for determining clockwise order of a triangle's vertex, swapping vertices of a 2D triangle and detemining whether a pixel is within a triangle etc.\n\nIt then performs various processes stages including projecting a 3D triangle to 2D, a bounding box calculation, finding pixels in bounding box, filtering hidden pixels, colouring the frame buffer and finally outputting the result. \n\nLastly, the main rendering function. Through an interface pragma, it accesses memory for input and output and performs the data processing, transforming 3D triangles to 2D, with provided datasets, performing rasterization, culling and coloring.\n\nSummary of HLS Pragmas,\n\"#pragma HLS INTERFACE m_axi port=input offset=slave bundle=gmem\" and \"#pragma HLS INTERFACE m_axi port=output offset=slave bundle=gmem\" are used to indicate the input and output ports as master AXI interfaces with offset of slave and in the 'gmem' bundle.\n\"#pragma HLS INTERFACE s_axilite port=input bundle=control\", \"#pragma HLS INTERFACE s_axilite port=output bundle=control\" and \"#pragma HLS INTERFACE s_axilite port=return bundle=control\" are for creating AXI lightweight interfaces.\n\nOther Pragmas like \"#pragma HLS INLINE off\", \"#pragma HLS PIPELINE II=1\", and \"#pragma HLS dataflow\" are used for pipelining and parallelizing loops and functions, instructing HLS to avoid automatic inlining of certain functions and to control pipelining and dataflow of the design. \n\nThe flow of execution starts from a series of 3D triangles which are then subject to projection to 2D. Then, rasterization which gives the bounding box of these triangles in order to find the pixels inside the triangle. Then, zculling - a depth checking mechanism to avoid hidden pixels before coloring the frame buffer and outputting the resulting 2D image.", "output": "/*===============================================================*/\n/*                                                               */\n/*                        rendering.cpp                          */\n/*                                                               */\n/*                 C++ kernel for 3D Rendering                   */\n/*                                                               */\n/*===============================================================*/\n\n#include <string>\n\n#include \"ap_int.h\"\n// sdsoc wide vector type\ntypedef ap_uint<256>  WholeDigitType;\n\n// resolution 256x256\nconst int MAX_X = 256;\nconst int MAX_Y = 256;\n\n// number of values in frame buffer: 32 bits\nconst int NUM_FB = MAX_X * MAX_Y / 4;\n// dataset information \nconst int NUM_3D_TRI = 3192;\n\n// specialized datatypes\ntypedef unsigned char bit8;\ntypedef unsigned int bit32;\n\n// struct: 3D triangle\ntypedef struct\n{\n  bit8   x0;\n  bit8   y0;\n  bit8   z0;\n  bit8   x1;\n  bit8   y1;\n  bit8   z1;\n  bit8   x2;\n  bit8   y2;\n  bit8   z2;\n} Triangle_3D;\n\n// struct: 2D triangle\ntypedef struct\n{\n  bit8   x0;\n  bit8   y0;\n  bit8   x1;\n  bit8   y1;\n  bit8   x2;\n  bit8   y2;\n  bit8   z;\n} Triangle_2D;\n\n// struct: candidate pixels\ntypedef struct\n{\n  bit8   x;\n  bit8   y;\n  bit8   z;\n  bit8   color;\n} CandidatePixel;\n\n// struct: colored pixel\ntypedef struct\n{\n  bit8   x;\n  bit8   y;\n  bit8   color;\n} Pixel;\n\n// dataflow switch\n\n\n#pragma SDS data access_pattern(input:SEQUENTIAL, output:SEQUENTIAL)\nvoid rendering(bit32 input[3*NUM_3D_TRI], bit32 output[NUM_FB]);\n\n/*======================UTILITY FUNCTIONS========================*/\n\n\n// Determine whether three vertices of a trianlgLe\n// (x0,y0) (x1,y1) (x2,y2) are in clockwise order by Pineda algorithm\n// if so, return a number > 0\n// else if three points are in line, return a number == 0\n// else in counterclockwise order, return a number < 0\nint check_clockwise( Triangle_2D triangle_2d )\n{\n  int cw;\n\n  cw = (triangle_2d.x2 - triangle_2d.x0) * (triangle_2d.y1 - triangle_2d.y0)\n       - (triangle_2d.y2 - triangle_2d.y0) * (triangle_2d.x1 - triangle_2d.x0);\n\n  return cw;\n\n}\n\n// swap (x0, y0) (x1, y1) of a Triangle_2D\nvoid clockwise_vertices( Triangle_2D *triangle_2d )\n{\n\n  bit8 tmp_x, tmp_y;\n\n  tmp_x = triangle_2d->x0;\n  tmp_y = triangle_2d->y0;\n\n  triangle_2d->x0 = triangle_2d->x1;\n  triangle_2d->y0 = triangle_2d->y1;\n\n  triangle_2d->x1 = tmp_x;\n  triangle_2d->y1 = tmp_y;\n\n}\n\n\n// Given a pixel, determine whether it is inside the triangle\n// by Pineda algorithm\n// if so, return true\n// else, return false\nbit1 pixel_in_triangle( bit8 x, bit8 y, Triangle_2D triangle_2d )\n{\n\n  int pi0, pi1, pi2;\n\n  pi0 = (x - triangle_2d.x0) * (triangle_2d.y1 - triangle_2d.y0) - (y - triangle_2d.y0) * (triangle_2d.x1 - triangle_2d.x0);\n  pi1 = (x - triangle_2d.x1) * (triangle_2d.y2 - triangle_2d.y1) - (y - triangle_2d.y1) * (triangle_2d.x2 - triangle_2d.x1);\n  pi2 = (x - triangle_2d.x2) * (triangle_2d.y0 - triangle_2d.y2) - (y - triangle_2d.y2) * (triangle_2d.x0 - triangle_2d.x2);\n\n  return (pi0 >= 0 && pi1 >= 0 && pi2 >= 0);\n}\n\n// find the min from 3 integers\nbit8 find_min( bit8 in0, bit8 in1, bit8 in2 )\n{\n  if (in0 < in1)\n  {\n    if (in0 < in2)\n      return in0;\n    else \n      return in2;\n  }\n  else \n  {\n    if (in1 < in2) \n      return in1;\n    else \n      return in2;\n  }\n}\n\n\n// find the max from 3 integers\nbit8 find_max( bit8 in0, bit8 in1, bit8 in2 )\n{\n  if (in0 > in1)\n  {\n    if (in0 > in2)\n      return in0;\n    else \n      return in2;\n  }\n  else \n  {\n    if (in1 > in2) \n      return in1;\n    else \n      return in2;\n  }\n}\n\n/*======================PROCESSING STAGES========================*/\n\n// project a 3D triangle to a 2D triangle\nvoid projection ( Triangle_3D triangle_3d, Triangle_2D *triangle_2d, bit2 angle )\n{\n  #pragma HLS INLINE off\n  // Setting camera to (0,0,-1), the canvas at z=0 plane\n  // The 3D model lies in z>0 space\n  // The coordinate on canvas is proportional to the corresponding coordinate \n  // on space\n  if(angle == 0)\n  {\n    triangle_2d->x0 = triangle_3d.x0;\n    triangle_2d->y0 = triangle_3d.y0;\n    triangle_2d->x1 = triangle_3d.x1;\n    triangle_2d->y1 = triangle_3d.y1;\n    triangle_2d->x2 = triangle_3d.x2;\n    triangle_2d->y2 = triangle_3d.y2;\n    triangle_2d->z  = triangle_3d.z0 / 3 + triangle_3d.z1 / 3 + triangle_3d.z2 / 3;\n  }\n\n  else if(angle == 1)\n  {\n    triangle_2d->x0 = triangle_3d.x0;\n    triangle_2d->y0 = triangle_3d.z0;\n    triangle_2d->x1 = triangle_3d.x1;\n    triangle_2d->y1 = triangle_3d.z1;\n    triangle_2d->x2 = triangle_3d.x2;\n    triangle_2d->y2 = triangle_3d.z2;\n    triangle_2d->z  = triangle_3d.y0 / 3 + triangle_3d.y1 / 3 + triangle_3d.y2 / 3;\n  }\n      \n  else if(angle == 2)\n  {\n    triangle_2d->x0 = triangle_3d.z0;\n    triangle_2d->y0 = triangle_3d.y0;\n    triangle_2d->x1 = triangle_3d.z1;\n    triangle_2d->y1 = triangle_3d.y1;\n    triangle_2d->x2 = triangle_3d.z2;\n    triangle_2d->y2 = triangle_3d.y2;\n    triangle_2d->z  = triangle_3d.x0 / 3 + triangle_3d.x1 / 3 + triangle_3d.x2 / 3;\n  }\n}\n\n// calculate bounding box for a 2D triangle\nbit2 rasterization1 ( Triangle_2D triangle_2d, bit8 max_min[], Triangle_2D *triangle_2d_same, bit16 max_index[])\n{\n  #pragma HLS INLINE off\n  // clockwise the vertices of input 2d triangle\n  if ( check_clockwise( triangle_2d ) == 0 )\n    return 1;\n  if ( check_clockwise( triangle_2d ) < 0 )\n    clockwise_vertices( &triangle_2d );\n\n  // copy the same 2D triangle\n  triangle_2d_same->x0 = triangle_2d.x0;\n  triangle_2d_same->y0 = triangle_2d.y0;\n  triangle_2d_same->x1 = triangle_2d.x1;\n  triangle_2d_same->y1 = triangle_2d.y1;\n  triangle_2d_same->x2 = triangle_2d.x2;\n  triangle_2d_same->y2 = triangle_2d.y2;\n  triangle_2d_same->z  = triangle_2d.z ;\n\n  // find the rectangle bounds of 2D triangles\n  max_min[0] = find_min( triangle_2d.x0, triangle_2d.x1, triangle_2d.x2 );\n  max_min[1] = find_max( triangle_2d.x0, triangle_2d.x1, triangle_2d.x2 );\n  max_min[2] = find_min( triangle_2d.y0, triangle_2d.y1, triangle_2d.y2 );\n  max_min[3] = find_max( triangle_2d.y0, triangle_2d.y1, triangle_2d.y2 );\n  max_min[4] = max_min[1] - max_min[0];\n\n  // calculate index for searching pixels\n  max_index[0] = (max_min[1] - max_min[0]) * (max_min[3] - max_min[2]);\n\n  return 0;\n}\n\n// find pixels in the triangles from the bounding box\nbit16 rasterization2 ( bit2 flag, bit8 max_min[], bit16 max_index[], Triangle_2D triangle_2d_same, CandidatePixel fragment2[] )\n{\n  #pragma HLS INLINE off\n  // clockwise the vertices of input 2d triangle\n  if ( flag )\n  {\n    return 0;\n  }\n  bit8 color = 100;\n  bit16 i = 0;\n\n  RAST2: for ( bit16 k = 0; k < max_index[0]; k++ )\n  {\n    #pragma HLS PIPELINE II=1\n    bit8 x = max_min[0] + k%max_min[4];\n    bit8 y = max_min[2] + k/max_min[4];\n\n    if( pixel_in_triangle( x, y, triangle_2d_same ) )\n    {\n      fragment2[i].x = x;\n      fragment2[i].y = y;\n      fragment2[i].z = triangle_2d_same.z;\n      fragment2[i].color = color;\n      i++;\n    }\n  }\n\n  return i;\n}\n\n// filter hidden pixels\nbit16 zculling ( bit16 counter, CandidatePixel fragments[], bit16 size, Pixel pixels[])\n{\n  #pragma HLS INLINE off\n\n  // initilize the z-buffer in rendering first triangle for an image\n  static bit8 z_buffer[MAX_X][MAX_Y];\n  if (counter == 0)\n  {\n    ZCULLING_INIT_ROW: for ( bit16 i = 0; i < MAX_X; i++)\n    {\n      #pragma HLS PIPELINE II=1\n      ZCULLING_INIT_COL: for ( bit16 j = 0; j < MAX_Y; j++)\n      {\n        z_buffer[i][j] = 255;\n      }\n    }\n  }\n\n  // pixel counter\n  bit16 pixel_cntr = 0;\n  \n  // update z-buffer and pixels\n  ZCULLING: for ( bit16 n = 0; n < size; n++ ) \n  {\n    #pragma HLS PIPELINE II=1\n    if( fragments[n].z < z_buffer[fragments[n].y][fragments[n].x] )\n    {\n      pixels[pixel_cntr].x     = fragments[n].x;\n      pixels[pixel_cntr].y     = fragments[n].y;\n      pixels[pixel_cntr].color = fragments[n].color;\n      pixel_cntr++;\n      z_buffer[fragments[n].y][fragments[n].x] = fragments[n].z;\n    }\n  }\n\n  return pixel_cntr;\n}\n\n// color the frame buffer\nvoid coloringFB(bit16 counter,  bit16 size_pixels, Pixel pixels[], bit8 frame_buffer[MAX_X][MAX_Y])\n{\n  #pragma HLS INLINE off\n\n  if ( counter == 0 )\n  {\n    // initilize the framebuffer for a new image\n    COLORING_FB_INIT_ROW: for ( bit16 i = 0; i < MAX_X; i++)\n    {\n      #pragma HLS PIPELINE II=1\n      COLORING_FB_INIT_COL: for ( bit16 j = 0; j < MAX_Y; j++)\n        frame_buffer[i][j] = 0;\n    }\n  }\n\n  // update the framebuffer\n  COLORING_FB: for ( bit16 i = 0; i < size_pixels; i++)\n  {\n    #pragma HLS PIPELINE II=1\n    frame_buffer[ pixels[i].x ][ pixels[i].y ] = pixels[i].color;\n  }\n\n}\n\n// stream out the frame buffer\nvoid output_FB(bit8 frame_buffer[MAX_X][MAX_Y], bit32 output[NUM_FB])\n{\n  #pragma HLS INLINE\n  bit32 out_FB = 0;\n  OUTPUT_FB_ROW: for ( bit16 i = 0; i < MAX_X; i++)\n  {\n    #pragma HLS PIPELINE II=1\n    OUTPUT_FB_COL: for ( bit16 j = 0; j < MAX_Y; j = j + 4)\n    {\n      out_FB( 7,  0) = frame_buffer[i][j + 0];\n      out_FB(15,  8) = frame_buffer[i][j + 1];\n      out_FB(23, 16) = frame_buffer[i][j + 2];\n      out_FB(31, 24) = frame_buffer[i][j + 3];\n      output[i * MAX_Y / 4 + j / 4] = out_FB;\n    }\n  }\n}\n\n\n/*========================TOP FUNCTION===========================*/\nextern \"C\" \n{\n  void rendering( bit32 input[3*NUM_3D_TRI], bit32 output[NUM_FB])\n  {\n    #pragma HLS INTERFACE m_axi port=input offset=slave bundle=gmem\n    #pragma HLS INTERFACE m_axi port=output offset=slave bundle=gmem\n    #pragma HLS INTERFACE s_axilite port=input bundle=control\n    #pragma HLS INTERFACE s_axilite port=output bundle=control\n    #pragma HLS INTERFACE s_axilite port=return bundle=control\n  \n    // local variables\n    Triangle_3D triangle_3ds;\n    Triangle_2D triangle_2ds;\n    Triangle_2D triangle_2ds_same;\n  \n    bit16 size_fragment;\n    CandidatePixel fragment[500];\n  \n    bit16 size_pixels;\n    Pixel pixels[500];\n  \n    bit8 frame_buffer[MAX_X][MAX_Y];\n    bit2 angle = 0;\n  \n    bit8 max_min[5];\n    bit16 max_index[1];\n    bit2 flag;\n  \n    // processing NUM_3D_TRI 3D triangles\n    TRIANGLES: for (bit16 i = 0; i < NUM_3D_TRI; i++)\n    {\n      bit32 input_lo  = input[3*i];\n      bit32 input_mi  = input[3*i+1];\n      bit32 input_hi  = input[3*i+2];\n  \n      triangle_3ds.x0 = input_lo( 7,  0);\n      triangle_3ds.y0 = input_lo(15,  8);\n      triangle_3ds.z0 = input_lo(23, 16);\n      triangle_3ds.x1 = input_lo(31, 24);\n      triangle_3ds.y1 = input_mi( 7,  0);\n      triangle_3ds.z1 = input_mi(15,  8);\n      triangle_3ds.x2 = input_mi(23, 16);\n      triangle_3ds.y2 = input_mi(31, 24);\n      triangle_3ds.z2 = input_hi( 7,  0);\n\n      // turn on dataflow if it is enabled \n      #ifdef ENABLE_DATAFLOW\n        #pragma HLS dataflow\n      #endif\n\n      // five stages for processing each 3D triangle\n      projection( triangle_3ds, &triangle_2ds, angle );\n      flag = rasterization1( triangle_2ds, max_min, &triangle_2ds_same, max_index);\n      size_fragment = rasterization2( flag, max_min, max_index, triangle_2ds_same, fragment );\n      size_pixels = zculling( i, fragment, size_fragment, pixels);\n      coloringFB ( i, size_pixels, pixels, frame_buffer);\n    }\n  \n    // output values: frame buffer\n    output_FB(frame_buffer,output);\n  }\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "This C code defines the implementation of the generalized matrix-matrix multiplication (GEMM) kernel. In this kernel, matrices A, B, and C of size N by N are loaded into buffer arrays buff_A, buff_B, and buff_C respectively in the 'lprd_1' and 'lprd_2' loop nest, and a temporary array 'tmp1' is initialized to zeros. Then, it performs the matrix multiplication operation in the 'lp1', 'lp2', and 'lp3' loop nest where each element of 'tmp1' is updated with the result of 'alpha' times the multiplication of elements of 'buff_A' and 'buff_B' plus the existing value in 'tmp1'. In the 'lp4' and 'lp5' loop nest, each element in 'buff_C' is updated by adding the multiplication of 'beta' and the corresponding element in 'buff_C' to the corresponding 'tmp1' element. Finally, the updated 'buff_C' is written back into the 'D_out' array in the 'lpwr_1' and 'lpwr_2' loop nest. The '#pragma' directives in this code could instruct the compiler about various aspects of optimization and parallelization but they are not included in the given code.", "output": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n#define N  64\n#define DATA_TYPE float\n#define SCALAR_VAL(x) x##f\n#define SQRT_FUN(x) sqrtf(x)\n#define EXP_FUN(x) expf(x)\n#define POW_FUN(x,y) powf(x,y)\n\nvoid gemm(DATA_TYPE alpha, DATA_TYPE beta, DATA_TYPE A[N][N], DATA_TYPE B[N][N], DATA_TYPE C[N][N], DATA_TYPE D[N][N]);\n\n\nvoid gemm(DATA_TYPE alpha, DATA_TYPE beta, DATA_TYPE A[N][N], DATA_TYPE B[N][N], DATA_TYPE C[N][N], DATA_TYPE D_out[N][N])\n{\n    int i, j, k;\n\n    DATA_TYPE buff_A[N][N]; \n    DATA_TYPE buff_B[N][N]; \n    DATA_TYPE buff_C[N][N];\n    DATA_TYPE tmp1[N][N];\n\n    lprd_1: for (i = 0; i < N; i++){\n        lprd_2: for (j = 0; j < N; j++){\n            buff_A[i][j] = A[i][j];\n            buff_B[i][j] = B[i][j];\n            buff_C[i][j] = C[i][j];\n            tmp1[i][j] = 0;\n        }\n    }\n\n    lp1: for (i = 0; i < N; i++) {\n        lp2: for (j = 0; j < N; j++) {\n            lp3: for (k = 0; k < N; k++) {\n                tmp1[i][j] = alpha * buff_A[i][k] * buff_B[k][j] + tmp1[i][j];\n            }\n        }\n    }\n\n    lp4: for (i = 0; i < N; i++) {\n        lp5: for (j = 0; j < N; j++) {\n\t        buff_C[i][j] = beta * buff_C[i][j] + tmp1[i][j];\n        }\n    }\n\n    lpwr_1: for (i = 0; i < N; i++){\n        lpwr_2: for (j = 0; j < N; j++){\n            D_out[i][j] = buff_C[i][j];\n        }\n    }\n}"}
