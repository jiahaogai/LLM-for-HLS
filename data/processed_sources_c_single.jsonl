{"instruction": "Generate HLS code with the following instructions:", "input": "Write a function named 'k3mm' in C, taking five 2-dimensional float arrays named 'A', 'B', 'C', 'D', and 'E_out' of size N x N as parameters. The function executes matrix computations by first initializing temporary buffers 'buff_A', 'buff_B', 'buff_C', 'buff_D', 'buff_E_out', 'tmp1', and 'tmp2' with the initial values of 'A', 'B', 'C', 'D' and 0, respectively. Then, the function computes matrix multiplication of 'buff_A' and 'buff_B', and 'buff_C' and 'buff_D', storing results in 'tmp1' and 'tmp2,' respectively. Subsequently, the function performs matrix multiplication of 'tmp1' and 'tmp2', storing result in 'buff_E_out'. Finally, copy the contents of 'buff_E_out' to 'E_out'. Treat each loop as a hardware kernel for acceleration and run the iterations in sequential order, not in parallel or pipeline form, using the respective pragma values '#pragma ACCEL kernel', '#pragma ACCEL PARALLEL FACTOR=1', and '#pragma ACCEL PIPELINE \"off\"'.", "output": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n#define N 64\n\n#define DATA_TYPE float\n#define SCALAR_VAL(x) x##f\n#define SQRT_FUN(x) sqrtf(x)\n#define EXP_FUN(x) expf(x)\n#define POW_FUN(x,y) powf(x,y)\n\nvoid k3mm(DATA_TYPE A[N][N], DATA_TYPE B[N][N], DATA_TYPE C[N][N], DATA_TYPE D[N][N], DATA_TYPE E_out[N][N]);\n\nvoid k3mm(DATA_TYPE A[N][N], DATA_TYPE B[N][N], DATA_TYPE C[N][N], DATA_TYPE D[N][N], DATA_TYPE E_out[N][N])\n{\n    int i, j, k;\n\n    DATA_TYPE buff_A[N][N];\n    DATA_TYPE buff_B[N][N];\n    DATA_TYPE buff_C[N][N];\n    DATA_TYPE buff_D[N][N];\n    DATA_TYPE buff_E_out[N][N];\n    DATA_TYPE tmp1[N][N];\n    DATA_TYPE tmp2[N][N];\n\n    lprd_1: for (i = 0; i < N; i++) {\n        lprd_2: for (j = 0; j < N; j++) {\n            buff_A[i][j] = A[i][j];\n            buff_B[i][j] = B[i][j];\n            buff_C[i][j] = C[i][j];\n            buff_D[i][j] = D[i][j];\n            buff_E_out[i][j] = 0;\n            tmp1[i][j] = 0;\n            tmp2[i][j] = 0;\n        }\n    }\n\n    lp1: for (i = 0; i < N; i++) {\n        lp2: for (j = 0; j < N; j++) {\n            lp3: for (k = 0; k < N; k++) {\n                tmp1[i][j] += buff_A[i][k] * buff_B[k][j];\n            }\n        }\n    }\n\n    lp4: for (i = 0; i < N; i++) {\n        lp5: for (j = 0; j < N; j++) {\n            lp6: for (k = 0; k < N; k++) {\n                tmp2[i][j] += buff_C[i][k] * buff_D[k][j];\n            }\n        }\n    }\n    \n    lp7: for (i = 0; i < N; i++) {\n        lp8: for (j = 0; j < N; j++) {\n            lp9: for (k = 0; k < N; k++) {\n                buff_E_out[i][j] += tmp1[i][k] * tmp2[k][j];\n            }\n        }\n    }\n\n    lpwr_1: for (i = 0; i < N; i++) {\n        lpwr_2: for (j = 0; j < N; j++) {\n            E_out[i][j] = buff_E_out[i][j];\n        }\n    }\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a function named 'mvt' in C language that takes in 7 parameters: two 2D arrays 'A', four 1D arrays 'x1', 'x2', 'y1', 'y2', and two 1D arrays 'x1_out', 'x2_out'. This function should have five separate loops named 'lprd_1', 'lprd_2', 'lp1', 'lp2', 'lp3', 'lp4', 'lpwr' each of which process different operations. The first two loops copy the input arrays to buff_x1, buff_x2, buff_y1, buff_y2 and buff_A respectively. The 'lp1' and 'lp2' loops perform multiplication of elements in buff_A and buff_y1, then addition with the corresponding elements in buff_x1. The 'lp3' and 'lp4' loops perform multiplication of elements in buff_A and buff_y2, then addition with the corresponding elements in buff_x2. In the last loop 'lpwr', the function should store results into x1_out and x2_out. Do not specify any #pragma values to use in these loops for now.", "output": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n#define N 64\n\n#define DATA_TYPE float\n#define SCALAR_VAL(x) x##f\n#define SQRT_FUN(x) sqrtf(x)\n#define EXP_FUN(x) expf(x)\n#define POW_FUN(x,y) powf(x,y)\n\nvoid mvt(DATA_TYPE A[N][N], DATA_TYPE x1[N], DATA_TYPE x2[N], DATA_TYPE y1[N], DATA_TYPE y2[N], DATA_TYPE x1_out[N], DATA_TYPE x2_out[N]);\n\n\nvoid mvt(DATA_TYPE A[N][N], DATA_TYPE x1[N], DATA_TYPE x2[N], DATA_TYPE y1[N], DATA_TYPE y2[N], DATA_TYPE x1_out[N], DATA_TYPE x2_out[N])\n{\n\tint i, j;\n\tDATA_TYPE buff_A[N][N];\n\tDATA_TYPE buff_x1[N];\n\tDATA_TYPE buff_x2[N];\n\tDATA_TYPE buff_y1[N];\n\tDATA_TYPE buff_y2[N];\n\n\tlprd_1: for (i = 0; i < N; i++) {\n\t\tbuff_x1[i] = x1[i];\n\t\tbuff_x2[i] = x2[i];\n\t\tbuff_y1[i] = y1[i];\n\t\tbuff_y2[i] = y2[i];\n    \tlprd_2: for (j = 0; j < N; j++) {\n\t\t\tbuff_A[i][j] = A[i][j];\n\t\t}\n\t}\n\n\tlp1: for (i = 0; i < N; i++) {\n    \tlp2: for (j = 0; j < N; j++) {\n      \t\tbuff_x1[i] = buff_x1[i] + buff_A[i][j] * buff_y1[j];\n\t\t}\n\t}\n\n\tlp3: for (i = 0; i < N; i++) {\n\t\tlp4: for (j = 0; j < N; j++) {\n    \t\tbuff_x2[i] = buff_x2[i] + buff_A[j][i] * buff_y2[j];\n\t\t}\n\t}\n\t\n\tlpwr: for (i = 0; i < N; i++) {\n\t\tx1_out[i] = buff_x1[i];\n\t\tx2_out[i] = buff_x2[i];\n\t}\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function named 'cpp_ap_int_arith' that performs basic arithmetic operations. This function takes in four arguments namely 'inA', 'inB', 'inC' and 'inD' which are of type ap_int<6>, ap_int<12>, ap_int<22>, and ap_int<33> respectively. The function also takes in four pointer arguments named 'out1', 'out2', 'out3', and 'out4' of types ap_int<18>, ap_uint<13>, ap_int<22> and ap_int<6> respectively. These pointers are used to store the return results of the operations. The operation includes calculating the product of 'inA' and 'inB', saved to '*out1', the sum of 'inB' and 'inA' saved to '*out2', the division of 'inC' by 'inA' saved to '*out3', and the remainder of the division of 'inD' by 'inA' saved to '*out4'. No specific #pragma values are communicated, hence no acceleration or parallel processing instructions are given for the function or its loop.\n", "output": "#include <stdio.h>\n#include \"ap_int.h\"\n\n#define N 9\n\ntypedef ap_int<6> dinA_t;\ntypedef ap_int<12> dinB_t;\ntypedef ap_int<22> dinC_t;\ntypedef ap_int<33> dinD_t;\n\ntypedef ap_int<18> dout1_t;\ntypedef ap_uint<13> dout2_t;\ntypedef ap_int<22> dout3_t;\ntypedef ap_int<6> dout4_t;\n\nvoid cpp_ap_int_arith(dinA_t inA,dinB_t inB,dinC_t inC,dinD_t inD,dout1_t *out1,dout2_t *out2,dout3_t *out3,dout4_t *out4);\n\n\nvoid cpp_ap_int_arith(dinA_t  inA, dinB_t  inB, dinC_t  inC, dinD_t  inD,\n  \t\t       dout1_t *out1, dout2_t *out2, dout3_t *out3, dout4_t *out4\n  ) {\n\n\t// Basic arithmetic operations\n\t*out1 = inA * inB;\n\t*out2 = inB + inA;\n\t*out3 = inC / inA;\n\t*out4 = inD % inA;\n\n} \n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a function named 'k2mm' in C language that takes two scalar values 'alpha' and 'beta' and five two-dimensional arrays, 'A', 'B', 'C', 'D', and 'E_out' as parameters. Start by defining 'N' as 64 and initialize array buffers for all input arrays. All elements of 'E_out', 'tmp1' and 'tmp2' arrays should be initially set to zero. The function should then perform three levels of nested loops on all the arrays of size 'N x N'. In the first loop, it calculates alpha times the product of elements of 'A' and 'B', accumulates these products in 'tmp1'. In the second loop, it multipliers elements of 'tmp1' and 'C' and accumulates the results in 'tmp2'. Finally, in the third loop, it computes the sum of 'tmp2' and the product of 'beta' and 'D', stores the results back in 'buff_E_out'. After all computations, assign the values from 'buff_E_out' back to 'E_out'. Make sure the loops aren't automatically pipelined but processed in their original, full form without breaking them into smaller chunks. The function should be treated as a hardware kernel for acceleration.", "output": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n#define N 64\n\n#define DATA_TYPE float\n#define SCALAR_VAL(x) x##f\n#define SQRT_FUN(x) sqrtf(x)\n#define EXP_FUN(x) expf(x)\n#define POW_FUN(x,y) powf(x,y)\n\nvoid k2mm(DATA_TYPE alpha, DATA_TYPE beta, DATA_TYPE A[N][N], DATA_TYPE B[N][N], DATA_TYPE C[N][N], DATA_TYPE D[N][N], DATA_TYPE E_out[N][N]);\n\n\n/* D := alpha*A*B*C + beta*D */\nvoid k2mm(DATA_TYPE alpha, DATA_TYPE beta, DATA_TYPE A[N][N], DATA_TYPE B[N][N], DATA_TYPE C[N][N], DATA_TYPE D[N][N], DATA_TYPE E_out[N][N])\n{\n    int i, j, k;\n    DATA_TYPE buff_A[N][N]; \n    DATA_TYPE buff_B[N][N]; \n    DATA_TYPE buff_C[N][N];\n    DATA_TYPE buff_D[N][N];\n    DATA_TYPE buff_E_out[N][N];\n    DATA_TYPE tmp1[N][N];\n    DATA_TYPE tmp2[N][N];\n\n    lprd_1: for (i = 0; i < N; i++){\n        lprd_2: for (j = 0; j < N; j++){\n            buff_A[i][j] = A[i][j];\n            buff_B[i][j] = B[i][j];\n            buff_C[i][j] = C[i][j];\n            buff_D[i][j] = D[i][j];\n            buff_E_out[i][j] = 0;\n            tmp1[i][j] = 0;\n            tmp2[i][j] = 0;\n        }\n    }\n\n    lp1: for (i = 0; i < N; i++) {\n        lp2: for (j = 0; j < N; j++) {\n\t        lp3: for (k = 0; k < N; ++k) {\n                tmp1[i][j] += alpha * buff_A[i][k] * buff_B[k][j];\n            }\n        }\n    }\n    \n    lp4: for (i = 0; i < N; i++) {\n        lp5: for (j = 0; j < N; j++) {\n\t        lp6: for (k = 0; k < N; k++) {\n                tmp2[i][j] += tmp1[i][k] * buff_C[k][j];\n            }\n        }\n    }\n\n    lp7: for (i = 0; i < N; i++) {\n        lp8: for (j = 0; j < N; j++) {\n            buff_E_out[i][j] = tmp2[i][j] + beta * buff_D[i][j];\n        }\n    }\n\n\n    lpwr_1: for (i = 0; i < N; i++){\n        lpwr_2: for (j = 0; j < N; j++){\n            E_out[i][j] = buff_E_out[i][j];\n        }\n    }\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a function named 'gemm' in C with the parameters: alpha, beta, A, B, C, and D_out all of type DATA_TYPE and the function should perform the General Matrix Multiply (GEMM) operation. The function needs to initialize matrices buff_A, buff_B, buff_C, and tmp1 from the input matrix A, B, C. Then, it performs the matrix multiplication and addition operations in nested loop structures, where the innermost loop represents the multiply-accumulate for GEMM. The results are stored temporarily in tmp1, then updated to the output matrix D_out individually. For the function, you do not need to specify any special #pragma values for code optimizations. However, if needed, you can include #pragma keywords according to the needs and constraints of execution environment and hardware architecture.", "output": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n#define N  64\n#define DATA_TYPE float\n#define SCALAR_VAL(x) x##f\n#define SQRT_FUN(x) sqrtf(x)\n#define EXP_FUN(x) expf(x)\n#define POW_FUN(x,y) powf(x,y)\n\nvoid gemm(DATA_TYPE alpha, DATA_TYPE beta, DATA_TYPE A[N][N], DATA_TYPE B[N][N], DATA_TYPE C[N][N], DATA_TYPE D[N][N]);\n\n\nvoid gemm(DATA_TYPE alpha, DATA_TYPE beta, DATA_TYPE A[N][N], DATA_TYPE B[N][N], DATA_TYPE C[N][N], DATA_TYPE D_out[N][N])\n{\n    int i, j, k;\n\n    DATA_TYPE buff_A[N][N]; \n    DATA_TYPE buff_B[N][N]; \n    DATA_TYPE buff_C[N][N];\n    DATA_TYPE tmp1[N][N];\n\n    lprd_1: for (i = 0; i < N; i++){\n        lprd_2: for (j = 0; j < N; j++){\n            buff_A[i][j] = A[i][j];\n            buff_B[i][j] = B[i][j];\n            buff_C[i][j] = C[i][j];\n            tmp1[i][j] = 0;\n        }\n    }\n\n    lp1: for (i = 0; i < N; i++) {\n        lp2: for (j = 0; j < N; j++) {\n            lp3: for (k = 0; k < N; k++) {\n                tmp1[i][j] = alpha * buff_A[i][k] * buff_B[k][j] + tmp1[i][j];\n            }\n        }\n    }\n\n    lp4: for (i = 0; i < N; i++) {\n        lp5: for (j = 0; j < N; j++) {\n\t        buff_C[i][j] = beta * buff_C[i][j] + tmp1[i][j];\n        }\n    }\n\n    lpwr_1: for (i = 0; i < N; i++){\n        lpwr_2: for (j = 0; j < N; j++){\n            D_out[i][j] = buff_C[i][j];\n        }\n    }\n}"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a HLS function in C named 'rendering' which processes 3 dimensional models for rendering. The function takes two arguments: 'input' of type 'bit32' which is the array of 3 dimensional triangles to be processed and 'output' of type 'bit32' which is the array that will store the rendered image. The function processes each 3D triangle through five stages: projection, rasterization1, rasterization2, zculling, and coloringFB. The projection stage projects the 3D triangle to a 2D plane. The rasterization1 stage calculates the rectangle bounds of 2D triangles. The rasterization2 stage finds the pixels in the triangle from the bounding box. The zculling stage filters hidden pixels and updates z-buffer and pixels. The coloringFB stage colors the frame buffer based on the pixel data. Finally, output_FB copies the pixels to the output frame buffer array. Make sure you are instructing the SDSoC environment to consider the access pattern to input and output arrays as 'SEQUENTIAL' by specifying '#pragma SDS data access_pattern(input:SEQUENTIAL, output:SEQUENTIAL)' at the beginning of the rendering function for efficient hardware implementation.", "output": "/*===============================================================*/\n/*                                                               */\n/*                        rendering.cpp                          */\n/*                                                               */\n/*                 C++ kernel for 3D Rendering                   */\n/*                                                               */\n/*===============================================================*/\n\n#include <string>\n\n#include \"ap_int.h\"\n// sdsoc wide vector type\ntypedef ap_uint<256>  WholeDigitType;\n\n// resolution 256x256\nconst int MAX_X = 256;\nconst int MAX_Y = 256;\n\n// number of values in frame buffer: 32 bits\nconst int NUM_FB = MAX_X * MAX_Y / 4;\n// dataset information \nconst int NUM_3D_TRI = 3192;\n\n// specialized datatypes\ntypedef unsigned char bit8;\ntypedef unsigned int bit32;\n\n// struct: 3D triangle\ntypedef struct\n{\n  bit8   x0;\n  bit8   y0;\n  bit8   z0;\n  bit8   x1;\n  bit8   y1;\n  bit8   z1;\n  bit8   x2;\n  bit8   y2;\n  bit8   z2;\n} Triangle_3D;\n\n// struct: 2D triangle\ntypedef struct\n{\n  bit8   x0;\n  bit8   y0;\n  bit8   x1;\n  bit8   y1;\n  bit8   x2;\n  bit8   y2;\n  bit8   z;\n} Triangle_2D;\n\n// struct: candidate pixels\ntypedef struct\n{\n  bit8   x;\n  bit8   y;\n  bit8   z;\n  bit8   color;\n} CandidatePixel;\n\n// struct: colored pixel\ntypedef struct\n{\n  bit8   x;\n  bit8   y;\n  bit8   color;\n} Pixel;\n\n// dataflow switch\n\n\n#pragma SDS data access_pattern(input:SEQUENTIAL, output:SEQUENTIAL)\nvoid rendering(bit32 input[3*NUM_3D_TRI], bit32 output[NUM_FB]);\n\n/*======================UTILITY FUNCTIONS========================*/\n\n\n// Determine whether three vertices of a trianlgLe\n// (x0,y0) (x1,y1) (x2,y2) are in clockwise order by Pineda algorithm\n// if so, return a number > 0\n// else if three points are in line, return a number == 0\n// else in counterclockwise order, return a number < 0\nint check_clockwise( Triangle_2D triangle_2d )\n{\n  int cw;\n\n  cw = (triangle_2d.x2 - triangle_2d.x0) * (triangle_2d.y1 - triangle_2d.y0)\n       - (triangle_2d.y2 - triangle_2d.y0) * (triangle_2d.x1 - triangle_2d.x0);\n\n  return cw;\n\n}\n\n// swap (x0, y0) (x1, y1) of a Triangle_2D\nvoid clockwise_vertices( Triangle_2D *triangle_2d )\n{\n\n  bit8 tmp_x, tmp_y;\n\n  tmp_x = triangle_2d->x0;\n  tmp_y = triangle_2d->y0;\n\n  triangle_2d->x0 = triangle_2d->x1;\n  triangle_2d->y0 = triangle_2d->y1;\n\n  triangle_2d->x1 = tmp_x;\n  triangle_2d->y1 = tmp_y;\n\n}\n\n\n// Given a pixel, determine whether it is inside the triangle\n// by Pineda algorithm\n// if so, return true\n// else, return false\nbit1 pixel_in_triangle( bit8 x, bit8 y, Triangle_2D triangle_2d )\n{\n\n  int pi0, pi1, pi2;\n\n  pi0 = (x - triangle_2d.x0) * (triangle_2d.y1 - triangle_2d.y0) - (y - triangle_2d.y0) * (triangle_2d.x1 - triangle_2d.x0);\n  pi1 = (x - triangle_2d.x1) * (triangle_2d.y2 - triangle_2d.y1) - (y - triangle_2d.y1) * (triangle_2d.x2 - triangle_2d.x1);\n  pi2 = (x - triangle_2d.x2) * (triangle_2d.y0 - triangle_2d.y2) - (y - triangle_2d.y2) * (triangle_2d.x0 - triangle_2d.x2);\n\n  return (pi0 >= 0 && pi1 >= 0 && pi2 >= 0);\n}\n\n// find the min from 3 integers\nbit8 find_min( bit8 in0, bit8 in1, bit8 in2 )\n{\n  if (in0 < in1)\n  {\n    if (in0 < in2)\n      return in0;\n    else \n      return in2;\n  }\n  else \n  {\n    if (in1 < in2) \n      return in1;\n    else \n      return in2;\n  }\n}\n\n\n// find the max from 3 integers\nbit8 find_max( bit8 in0, bit8 in1, bit8 in2 )\n{\n  if (in0 > in1)\n  {\n    if (in0 > in2)\n      return in0;\n    else \n      return in2;\n  }\n  else \n  {\n    if (in1 > in2) \n      return in1;\n    else \n      return in2;\n  }\n}\n\n/*======================PROCESSING STAGES========================*/\n\n// project a 3D triangle to a 2D triangle\nvoid projection ( Triangle_3D triangle_3d, Triangle_2D *triangle_2d, bit2 angle )\n{\n  #pragma HLS INLINE off\n  // Setting camera to (0,0,-1), the canvas at z=0 plane\n  // The 3D model lies in z>0 space\n  // The coordinate on canvas is proportional to the corresponding coordinate \n  // on space\n  if(angle == 0)\n  {\n    triangle_2d->x0 = triangle_3d.x0;\n    triangle_2d->y0 = triangle_3d.y0;\n    triangle_2d->x1 = triangle_3d.x1;\n    triangle_2d->y1 = triangle_3d.y1;\n    triangle_2d->x2 = triangle_3d.x2;\n    triangle_2d->y2 = triangle_3d.y2;\n    triangle_2d->z  = triangle_3d.z0 / 3 + triangle_3d.z1 / 3 + triangle_3d.z2 / 3;\n  }\n\n  else if(angle == 1)\n  {\n    triangle_2d->x0 = triangle_3d.x0;\n    triangle_2d->y0 = triangle_3d.z0;\n    triangle_2d->x1 = triangle_3d.x1;\n    triangle_2d->y1 = triangle_3d.z1;\n    triangle_2d->x2 = triangle_3d.x2;\n    triangle_2d->y2 = triangle_3d.z2;\n    triangle_2d->z  = triangle_3d.y0 / 3 + triangle_3d.y1 / 3 + triangle_3d.y2 / 3;\n  }\n      \n  else if(angle == 2)\n  {\n    triangle_2d->x0 = triangle_3d.z0;\n    triangle_2d->y0 = triangle_3d.y0;\n    triangle_2d->x1 = triangle_3d.z1;\n    triangle_2d->y1 = triangle_3d.y1;\n    triangle_2d->x2 = triangle_3d.z2;\n    triangle_2d->y2 = triangle_3d.y2;\n    triangle_2d->z  = triangle_3d.x0 / 3 + triangle_3d.x1 / 3 + triangle_3d.x2 / 3;\n  }\n}\n\n// calculate bounding box for a 2D triangle\nbit2 rasterization1 ( Triangle_2D triangle_2d, bit8 max_min[], Triangle_2D *triangle_2d_same, bit16 max_index[])\n{\n  #pragma HLS INLINE off\n  // clockwise the vertices of input 2d triangle\n  if ( check_clockwise( triangle_2d ) == 0 )\n    return 1;\n  if ( check_clockwise( triangle_2d ) < 0 )\n    clockwise_vertices( &triangle_2d );\n\n  // copy the same 2D triangle\n  triangle_2d_same->x0 = triangle_2d.x0;\n  triangle_2d_same->y0 = triangle_2d.y0;\n  triangle_2d_same->x1 = triangle_2d.x1;\n  triangle_2d_same->y1 = triangle_2d.y1;\n  triangle_2d_same->x2 = triangle_2d.x2;\n  triangle_2d_same->y2 = triangle_2d.y2;\n  triangle_2d_same->z  = triangle_2d.z ;\n\n  // find the rectangle bounds of 2D triangles\n  max_min[0] = find_min( triangle_2d.x0, triangle_2d.x1, triangle_2d.x2 );\n  max_min[1] = find_max( triangle_2d.x0, triangle_2d.x1, triangle_2d.x2 );\n  max_min[2] = find_min( triangle_2d.y0, triangle_2d.y1, triangle_2d.y2 );\n  max_min[3] = find_max( triangle_2d.y0, triangle_2d.y1, triangle_2d.y2 );\n  max_min[4] = max_min[1] - max_min[0];\n\n  // calculate index for searching pixels\n  max_index[0] = (max_min[1] - max_min[0]) * (max_min[3] - max_min[2]);\n\n  return 0;\n}\n\n// find pixels in the triangles from the bounding box\nbit16 rasterization2 ( bit2 flag, bit8 max_min[], bit16 max_index[], Triangle_2D triangle_2d_same, CandidatePixel fragment2[] )\n{\n  #pragma HLS INLINE off\n  // clockwise the vertices of input 2d triangle\n  if ( flag )\n  {\n    return 0;\n  }\n  bit8 color = 100;\n  bit16 i = 0;\n\n  RAST2: for ( bit16 k = 0; k < max_index[0]; k++ )\n  {\n    #pragma HLS PIPELINE II=1\n    bit8 x = max_min[0] + k%max_min[4];\n    bit8 y = max_min[2] + k/max_min[4];\n\n    if( pixel_in_triangle( x, y, triangle_2d_same ) )\n    {\n      fragment2[i].x = x;\n      fragment2[i].y = y;\n      fragment2[i].z = triangle_2d_same.z;\n      fragment2[i].color = color;\n      i++;\n    }\n  }\n\n  return i;\n}\n\n// filter hidden pixels\nbit16 zculling ( bit16 counter, CandidatePixel fragments[], bit16 size, Pixel pixels[])\n{\n  #pragma HLS INLINE off\n\n  // initilize the z-buffer in rendering first triangle for an image\n  static bit8 z_buffer[MAX_X][MAX_Y];\n  if (counter == 0)\n  {\n    ZCULLING_INIT_ROW: for ( bit16 i = 0; i < MAX_X; i++)\n    {\n      #pragma HLS PIPELINE II=1\n      ZCULLING_INIT_COL: for ( bit16 j = 0; j < MAX_Y; j++)\n      {\n        z_buffer[i][j] = 255;\n      }\n    }\n  }\n\n  // pixel counter\n  bit16 pixel_cntr = 0;\n  \n  // update z-buffer and pixels\n  ZCULLING: for ( bit16 n = 0; n < size; n++ ) \n  {\n    #pragma HLS PIPELINE II=1\n    if( fragments[n].z < z_buffer[fragments[n].y][fragments[n].x] )\n    {\n      pixels[pixel_cntr].x     = fragments[n].x;\n      pixels[pixel_cntr].y     = fragments[n].y;\n      pixels[pixel_cntr].color = fragments[n].color;\n      pixel_cntr++;\n      z_buffer[fragments[n].y][fragments[n].x] = fragments[n].z;\n    }\n  }\n\n  return pixel_cntr;\n}\n\n// color the frame buffer\nvoid coloringFB(bit16 counter,  bit16 size_pixels, Pixel pixels[], bit8 frame_buffer[MAX_X][MAX_Y])\n{\n  #pragma HLS INLINE off\n\n  if ( counter == 0 )\n  {\n    // initilize the framebuffer for a new image\n    COLORING_FB_INIT_ROW: for ( bit16 i = 0; i < MAX_X; i++)\n    {\n      #pragma HLS PIPELINE II=1\n      COLORING_FB_INIT_COL: for ( bit16 j = 0; j < MAX_Y; j++)\n        frame_buffer[i][j] = 0;\n    }\n  }\n\n  // update the framebuffer\n  COLORING_FB: for ( bit16 i = 0; i < size_pixels; i++)\n  {\n    #pragma HLS PIPELINE II=1\n    frame_buffer[ pixels[i].x ][ pixels[i].y ] = pixels[i].color;\n  }\n\n}\n\n// stream out the frame buffer\nvoid output_FB(bit8 frame_buffer[MAX_X][MAX_Y], bit32 output[NUM_FB])\n{\n  #pragma HLS INLINE\n  bit32 out_FB = 0;\n  OUTPUT_FB_ROW: for ( bit16 i = 0; i < MAX_X; i++)\n  {\n    #pragma HLS PIPELINE II=1\n    OUTPUT_FB_COL: for ( bit16 j = 0; j < MAX_Y; j = j + 4)\n    {\n      out_FB( 7,  0) = frame_buffer[i][j + 0];\n      out_FB(15,  8) = frame_buffer[i][j + 1];\n      out_FB(23, 16) = frame_buffer[i][j + 2];\n      out_FB(31, 24) = frame_buffer[i][j + 3];\n      output[i * MAX_Y / 4 + j / 4] = out_FB;\n    }\n  }\n}\n\n\n/*========================TOP FUNCTION===========================*/\nextern \"C\" \n{\n  void rendering( bit32 input[3*NUM_3D_TRI], bit32 output[NUM_FB])\n  {\n    #pragma HLS INTERFACE m_axi port=input offset=slave bundle=gmem\n    #pragma HLS INTERFACE m_axi port=output offset=slave bundle=gmem\n    #pragma HLS INTERFACE s_axilite port=input bundle=control\n    #pragma HLS INTERFACE s_axilite port=output bundle=control\n    #pragma HLS INTERFACE s_axilite port=return bundle=control\n  \n    // local variables\n    Triangle_3D triangle_3ds;\n    Triangle_2D triangle_2ds;\n    Triangle_2D triangle_2ds_same;\n  \n    bit16 size_fragment;\n    CandidatePixel fragment[500];\n  \n    bit16 size_pixels;\n    Pixel pixels[500];\n  \n    bit8 frame_buffer[MAX_X][MAX_Y];\n    bit2 angle = 0;\n  \n    bit8 max_min[5];\n    bit16 max_index[1];\n    bit2 flag;\n  \n    // processing NUM_3D_TRI 3D triangles\n    TRIANGLES: for (bit16 i = 0; i < NUM_3D_TRI; i++)\n    {\n      bit32 input_lo  = input[3*i];\n      bit32 input_mi  = input[3*i+1];\n      bit32 input_hi  = input[3*i+2];\n  \n      triangle_3ds.x0 = input_lo( 7,  0);\n      triangle_3ds.y0 = input_lo(15,  8);\n      triangle_3ds.z0 = input_lo(23, 16);\n      triangle_3ds.x1 = input_lo(31, 24);\n      triangle_3ds.y1 = input_mi( 7,  0);\n      triangle_3ds.z1 = input_mi(15,  8);\n      triangle_3ds.x2 = input_mi(23, 16);\n      triangle_3ds.y2 = input_mi(31, 24);\n      triangle_3ds.z2 = input_hi( 7,  0);\n\n      // turn on dataflow if it is enabled \n      #ifdef ENABLE_DATAFLOW\n        #pragma HLS dataflow\n      #endif\n\n      // five stages for processing each 3D triangle\n      projection( triangle_3ds, &triangle_2ds, angle );\n      flag = rasterization1( triangle_2ds, max_min, &triangle_2ds_same, max_index);\n      size_fragment = rasterization2( flag, max_min, max_index, triangle_2ds_same, fragment );\n      size_pixels = zculling( i, fragment, size_fragment, pixels);\n      coloringFB ( i, size_pixels, pixels, frame_buffer);\n    }\n  \n    // output values: frame buffer\n    output_FB(frame_buffer,output);\n  }\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a C function named 'bicg' that processes the BiCG algorithm given multi-dimensional and single-dimensional float arrays 'A', 'p', 'r', 's_out', 'q_out' respectively. Start the function by declaring the variables 'i' and 'j' alongside buffer arrays. Afterwards, copy the input arrays 'p', 'r' and 'A' to the corresponding buffer arrays, and initialize 's_out' and 'q_out' buffer arrays with 0s. Next, run two nested loops to perform calculations for 'buff_s_out' array. Run another pair of nested loops afterwards to perform calculations for 'buff_q_out' array. Finally, create a loop to copy the values of 'buff_s_out' and 'buff_q_out' back to 's_out' and 'q_out' respectively. Remember to treat the function 'bicg' as a hardware kernel for acceleration, ensure the loops are processed in a sequential manner and not broken down to smaller chunks.", "output": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n#define N 64\n\n#define DATA_TYPE float\n#define SCALAR_VAL(x) x##f\n#define SQRT_FUN(x) sqrtf(x)\n#define EXP_FUN(x) expf(x)\n#define POW_FUN(x,y) powf(x,y)\n\nvoid bicg(DATA_TYPE A[N][N], DATA_TYPE p[N], DATA_TYPE r[N], DATA_TYPE s_out[N], DATA_TYPE q_out[N]);\n\nvoid bicg(DATA_TYPE A[N][N], DATA_TYPE p[N], DATA_TYPE r[N], DATA_TYPE s_out[N], DATA_TYPE q_out[N])\n{\n    int i, j;\n\n\tDATA_TYPE buff_A[N][N];\n\tDATA_TYPE buff_p[N];\n\tDATA_TYPE buff_r[N];\n\tDATA_TYPE buff_s_out[N];\n\tDATA_TYPE buff_q_out[N];\n\n\tlprd_1: for (i = 0; i < N; i++) {\n\t\tbuff_p[i] = p[i];\n\t\tbuff_r[i] = r[i];\n\t\tbuff_s_out[i] = 0;\n\t\tbuff_q_out[i] = 0;\n\t\tlprd_2: for (j = 0; j < N; j++) {\n\t\t\tbuff_A[i][j] = A[i][j];\n\t\t}\n\t}\n\n    lp1: for (i = 0; i < N; i++) {\n        lp2: for (j = 0; j < N; j++) {\n\t        buff_s_out[j] = buff_s_out[j] + buff_A[i][j] * buff_r[i];\n\t\t}\n\t}\n\n\tlp3: for (i = 0; i < N; i++) {\n        lp4: for (j = 0; j < N; j++) {\n\t        buff_q_out[i] = buff_q_out[i] + buff_A[i][j] * buff_p[j];\n\t    }\n    }\n\n\tlpwr: for (i = 0; i < N; i++) {\n\t\ts_out[i] = buff_s_out[i];\n\t\tq_out[i] = buff_q_out[i];\n\t}\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Instruct the model to write a C code for a function named 'gesummv' that takes seven parameters: alpha, beta, two 2D arrays A and B, an array x, and an array y_out. The function 'gesummv' performs the generalized matrix vector multiplication (gesummv). \n\n1. The iteration process starts with initializing the values in the arrays buff_A, buff_B, buff_x, tmp1, tmp2, buff_y_out with corresponding values from the passed arrays and some initializations;\n2. Then, the program loops over 'N' for alpha times the multiplication of corresponding elements of buff_A and buff_x, and store each result in 'tmp1'; \n3. Similarly, loops over 'N' again for beta times the multiplication of corresponding elements of buff_B and buff_x, and store each result in 'tmp2'; \n4. Then, another loop sums the corresponding elements of tmp1 and tmp2 and stores the result in buff_y_out;\n5. Finally, buff_y_out is copied to y_out. \n\nThis function treats every loop as a hardware kernel for acceleration, avoids automatic pipeline, ensures the iterations run in a serial manner, and processes loops in their original full form without breaking it into smaller chunks which are all represented by '#pragma ACCEL kernel', '#pragma ACCEL PIPELINE \"off\"', '#pragma ACCEL PARALLEL FACTOR=1', '#pragma ACCEL TILE FACTOR=1' respectively.", "output": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n#define N 64\n\n#define DATA_TYPE float\n#define SCALAR_VAL(x) x##f\n#define SQRT_FUN(x) sqrtf(x)\n#define EXP_FUN(x) expf(x)\n#define POW_FUN(x,y) powf(x,y)\n\nvoid gesummv(DATA_TYPE alpha, DATA_TYPE beta, DATA_TYPE A[N][N], DATA_TYPE B[N][N], DATA_TYPE x[N], DATA_TYPE y_out[N]);\n\n\nvoid gesummv(DATA_TYPE alpha, DATA_TYPE beta, DATA_TYPE A[N][N], DATA_TYPE B[N][N], DATA_TYPE x[N], DATA_TYPE y_out[N])\n{\n    int i, j;\n\tDATA_TYPE buff_A[N][N];\n\tDATA_TYPE buff_B[N][N];\n\tDATA_TYPE buff_x[N];\n\tDATA_TYPE buff_y_out[N];\n\tDATA_TYPE tmp1[N];\n\tDATA_TYPE tmp2[N];\n\n\tlprd_1: for(i = 0; i < N; i++) {\n\t\tbuff_x[i] = x[i];\n\t\ttmp1[i] = 0;\n\t\ttmp2[i] = 0;\n\t\tbuff_y_out[i] = 0;\n\t\tlprd_2: for(j = 0; j < N; j++) {\n\t\t\tbuff_A[i][j] = A[i][j];\n\t\t\tbuff_B[i][j] = B[i][j];\n\t\t}\n\t}\n\n    lp1: for(i = 0; i < N; i++) {\n        lp2: for(j = 0; j < N; j++) {\n\t        tmp1[i] += alpha * buff_A[i][j] * buff_x[j];\n        }\n    }\n\n\tlp3: for(i = 0; i < N; i++) {\n        lp4: for(j = 0; j < N; j++) {\n\t        tmp2[i] += beta * buff_B[i][j] * buff_x[j];\n        }\n    }\n\n\tlp5: for(i = 0; i < N; i++) {\n\t\tbuff_y_out[i] = tmp1[i] + tmp2[i];\n\t}\n\n\tlpwr: for(i = 0; i < N; i++) {\n\t\ty_out[i] = buff_y_out[i];\n\t}\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Generate a function named 'atax' that takes three arrays 'A', 'x', and 'y_out' with each array of size 'N' as parameters. This function should perform three main operations. Firstly, it initializes temporary arrays 'buff_A', 'buff_x', 'buff_y_out' and 'tmp1' with the values of the original arrays, and all 'tmp1' and 'buff_y_out' values simultaneously reset to zero. Secondly, it calculates the accumulated sum of the product of corresponding 'buff_A' and 'buff_x' entries into 'tmp1', in a doubly nested loop. Thirdly, it updates 'buff_y_out' by performing the addition of the previous value and the product of 'buff_A' and 'tmp1' in another nested loop. Finally, it copies the 'buff_y_out' into 'y_out'. \n\nYou should use #pragma directives to instruct the compiler not to break these loops into smaller chunks, not to pipeline them for parallel processing, and treat the entire function as a hardware kernel for acceleration. Make sure all these instructions apply specifically to the loops 'lprd_1', 'lprd_2', 'lp1', 'lp2', 'lp3', 'lp4', and 'lpwr_1'. So, '#pragma ACCEL PIPELINE \"off\"', '#pragma ACCEL TILE FACTOR=1', '#pragma ACCEL PARALLEL FACTOR=1' and '#pragma ACCEL kernel' should be included respectively before those loops.\n", "output": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n#define N 64\n\n#define DATA_TYPE float\n#define SCALAR_VAL(x) x##f\n#define SQRT_FUN(x) sqrtf(x)\n#define EXP_FUN(x) expf(x)\n#define POW_FUN(x,y) powf(x,y)\n\nvoid atax(DATA_TYPE A[N][N], DATA_TYPE x[N], DATA_TYPE y_out[N]);\n\nvoid atax(DATA_TYPE A[N][N], DATA_TYPE x[N], DATA_TYPE y_out[N])\n{\n    int i, j;\n    DATA_TYPE buff_A[N][N];\n    DATA_TYPE buff_x[N];\n    DATA_TYPE buff_y_out[N];\n    DATA_TYPE tmp1[N];\n\n    lprd_1: for (i = 0; i < N; i++) {\n        buff_x[i] = x[i];\n    \tbuff_y_out[i] = 0;\n        tmp1[i] = 0;\n    \tlprd_2: for (j = 0; j < N; j++) {\n    \t\tbuff_A[i][j] = A[i][j];\n    \t}\n    }\n\n    lp1: for (i = 0; i < N; i++) {\n        lp2: for (j = 0; j < N; j++) {\n\t        tmp1[i] = tmp1[i] + buff_A[i][j] * buff_x[j];\n        }\n    }\n\n    lp3: for (i = 0; i < N; i++) {\n        lp4: for (j = 0; j < N; j++) {\n        \tbuff_y_out[j] = buff_y_out[j] + buff_A[i][j] * tmp1[i];\n        }\n    }\n\n    lpwr_1: for (i = 0; i < N; i++) {\n        y_out[i] = buff_y_out[i];\n    }\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a HLS hardware kernel in C for optical flow calculations in video processing with the function name `optical_flow`. This function takes two parameters:a 2D array `frames_t frames[MAX_HEIGHT][MAX_WIDTH]` representing multiple video frames with height and width as defined constants, and an output 2D array `velocity_t outputs[MAX_HEIGHT][MAX_WIDTH]` to store the resultant velocity vectors after the optical flow computation. The overall computation process of the function includes the stages of gradient calculation in x, y, z directions, gradient weight filtering in x, y directions, outer product derivation, tensor weighting in x, y directions and flow calculation. These stages are implemented as separate functions. \n\nThere are several pragma directives and their requirements in this code:\n\n1. `#pragma HLS array_partition variable=<variable_name> complete dim=<dim_number>`, such as `#pragma HLS array_partition variable=buf complete dim=1` and `#pragma HLS array_partition variable=smallbuf complete dim=0`: These partition the specified array along the specified dimension to facilitate parallel accesses by enabling concurrent reads and writes to different partitions. In this way, they can help improving performance but with increased resource utilization.\n   \n2. `#pragma HLS pipeline II=1`: This directive accelerates loops by overlapping the execution of iterations. Here, the initiation interval (II) is answered as 1, meaning an operation can be initiated in every cycle. \n\n3. `#pragma HLS dependence variable=buf inter false`: This asserts that no loop-carried dependencies exist for the specified variable `buf`, allowing loops to be safely pipelined. \n\n4. `#pragma HLS DATAFLOW`: This converts the series of function calls in the code into a set of concurrently executing hardware blocks. \n\n5. `#pragma HLS data_pack variable=<variable_name>`: This directive allows the packing of the members of a structure variable type into a single wide data type, improving the throughput of reading from and writing to this type of variables. \n\n6. `#pragma SDS data access_pattern(frames:SEQUENTIAL, outputs:SEQUENTIAL)`: This directive indicates that the access pattern for `frames` and `outputs` is sequential, implying that access to these variables would be in a sequential manner. \n\n7. `#pragma HLS STREAM variable=<variable_name> depth=<depth_number>`, such as `#pragma HLS STREAM variable=gradient_z depth=max_width*4`: These directives specify a FIFO-like behavior for the variables `gradient_z`, which is used to store communications between hardware function calls, where the FIFO depth is determined by the product of `max_width` and 4. This indicates that the order of reading and writing into these variable will follow the order of function calls.\n", "output": "/*===============================================================*/\n/*                                                               */\n/*                      optical_flow.cpp                         */\n/*                                                               */\n/*             Hardware function for optical flow                */\n/*                                                               */\n/*===============================================================*/\n\nconst int MAX_HEIGHT = 436;\nconst int MAX_WIDTH = 1024;\n\n// basic typedefs\n\n#include \"ap_fixed.h\"\n#include <hls_video.h>\ntypedef ap_fixed<17,9> input_t;\ntypedef ap_fixed<32,13> pixel_t;\ntypedef ap_fixed<32,27> outer_pixel_t;\ntypedef ap_fixed<64,56> calc_pixel_t;\ntypedef ap_fixed<32,13> vel_pixel_t;\n\ntypedef float pixel_t;\ntypedef float outer_pixel_t;\ntypedef float vel_pixel_t;\n\ntypedef struct{\n\tpixel_t x;\n\tpixel_t y;\n\tpixel_t z;\n}gradient_t;\n\ntypedef struct{\n    outer_pixel_t val[6];\n}outer_t; \n\ntypedef struct{\n    outer_pixel_t val[6];\n}tensor_t;\n\ntypedef struct{\n    vel_pixel_t x;\n    vel_pixel_t y;\n}velocity_t;\n\n\ntypedef ap_uint<64> frames_t;\n\n#include \"optical_flow.h\"\n// use HLS video library\n\n\n// use HLS fixed point\n// convolution filters\nconst int GRAD_WEIGHTS[] =  {1,-8,0,8,-1};\nconst pixel_t GRAD_FILTER[] = {0.0755, 0.133, 0.1869, 0.2903, 0.1869, 0.133, 0.0755};\nconst pixel_t TENSOR_FILTER[] = {0.3243, 0.3513, 0.3243};\n\n// top-level function \n#pragma SDS data access_pattern(frames:SEQUENTIAL, outputs:SEQUENTIAL)\nvoid optical_flow(frames_t   frames[MAX_HEIGHT][MAX_WIDTH],\n                  velocity_t outputs[MAX_HEIGHT][MAX_WIDTH]);\n\n// define these constants so they can be used in pragma\nconst int max_width = MAX_WIDTH; \nconst int default_depth = MAX_WIDTH;\n// calculate gradient in x and y directions\nvoid gradient_xy_calc(input_t frame[MAX_HEIGHT][MAX_WIDTH],\n    pixel_t gradient_x[MAX_HEIGHT][MAX_WIDTH],\n    pixel_t gradient_y[MAX_HEIGHT][MAX_WIDTH])\n{\n  // our own line buffer\n  static pixel_t buf[5][MAX_WIDTH];\n  #pragma HLS array_partition variable=buf complete dim=1\n\n  // small buffer\n  pixel_t smallbuf[5];\n  #pragma HLS array_partition variable=smallbuf complete dim=0\n  \n  // window buffer\n  hls::Window<5,5,input_t> window;\n\n  const int GRAD_WEIGHTS[] =  {1,-8,0,8,-1};\n\n  GRAD_XY_OUTER: for(int r=0; r<MAX_HEIGHT+2; r++)\n  {\n    GRAD_XY_INNER: for(int c=0; c<MAX_WIDTH+2; c++)\n    {\n      #pragma HLS pipeline II=1\n      // read out values from current line buffer\n      for (int i = 0; i < 4; i ++ )\n        smallbuf[i] = buf[i+1][c];\n      // the new value is either 0 or read from frame\n      if (r<MAX_HEIGHT && c<MAX_WIDTH)\n        smallbuf[4] = (pixel_t)(frame[r][c]);\n      else if (c < MAX_WIDTH)\n        smallbuf[4] = 0;\n      // update line buffer\n      if(r<MAX_HEIGHT && c<MAX_WIDTH)\n      {\n        for (int i = 0; i < 4; i ++ )\n          buf[i][c] = smallbuf[i];\n        buf[4][c] = smallbuf[4];\n      }\n      else if(c<MAX_WIDTH)\n      {\n        for (int i = 0; i < 4; i ++ )\n          buf[i][c] = smallbuf[i];\n        buf[4][c] = smallbuf[4];\n      }\n\n      // manage window buffer\n      if(r<MAX_HEIGHT && c<MAX_WIDTH)\n      {\n        window.shift_pixels_left();\n        \n        for (int i = 0; i < 5; i ++ )\n          window.insert_pixel(smallbuf[i],i,4);\n      }\n      else\n      {\n        window.shift_pixels_left();\n        window.insert_pixel(0,0,4);\n        window.insert_pixel(0,1,4);\n        window.insert_pixel(0,2,4);\n        window.insert_pixel(0,3,4);\n        window.insert_pixel(0,4,4);\n      }\n\n      // compute gradient\n      pixel_t x_grad = 0;\n      pixel_t y_grad = 0;\n      if(r>=4 && r<MAX_HEIGHT && c>=4 && c<MAX_WIDTH)\n      {\n        GRAD_XY_XYGRAD: for(int i=0; i<5; i++)\n        {\n          x_grad += window.getval(2,i)*GRAD_WEIGHTS[i];\n          y_grad += window.getval(i,2)*GRAD_WEIGHTS[i];\n        }\n        gradient_x[r-2][c-2] = x_grad/12;\n        gradient_y[r-2][c-2] = y_grad/12;\n      }\n      else if(r>=2 && c>=2)\n      {\n        gradient_x[r-2][c-2] = 0;\n        gradient_y[r-2][c-2] = 0;\n      }\n    }\n  }\n}\n\n// calculate gradient in the z direction\nvoid gradient_z_calc(input_t frame1[MAX_HEIGHT][MAX_WIDTH], \n    input_t frame2[MAX_HEIGHT][MAX_WIDTH], \n    input_t frame3[MAX_HEIGHT][MAX_WIDTH], \n    input_t frame4[MAX_HEIGHT][MAX_WIDTH], \n    input_t frame5[MAX_HEIGHT][MAX_WIDTH], \n    pixel_t gradient_z[MAX_HEIGHT][MAX_WIDTH])\n{\n  const int GRAD_WEIGHTS[] =  {1,-8,0,8,-1};\n  GRAD_Z_OUTER: for(int r=0; r<MAX_HEIGHT; r++)\n  {\n    GRAD_Z_INNER: for(int c=0; c<MAX_WIDTH; c++)\n    {\n      #pragma HLS pipeline II=1\n      gradient_z[r][c] =((pixel_t)(frame1[r][c]*GRAD_WEIGHTS[0] \n                        + frame2[r][c]*GRAD_WEIGHTS[1]\n                        + frame3[r][c]*GRAD_WEIGHTS[2]\n                        + frame4[r][c]*GRAD_WEIGHTS[3]\n                        + frame5[r][c]*GRAD_WEIGHTS[4]))/12;\n    }\n  }\n}\n\n// average the gradient in y direction\nvoid gradient_weight_y(pixel_t gradient_x[MAX_HEIGHT][MAX_WIDTH],\n    pixel_t gradient_y[MAX_HEIGHT][MAX_WIDTH],\n    pixel_t gradient_z[MAX_HEIGHT][MAX_WIDTH],\n    gradient_t filt_grad[MAX_HEIGHT][MAX_WIDTH])\n{\n  hls::LineBuffer<7,MAX_WIDTH,gradient_t> buf;\n\n  const pixel_t GRAD_FILTER[] = {0.0755, 0.133, 0.1869, 0.2903, 0.1869, 0.133, 0.0755};\n  GRAD_WEIGHT_Y_OUTER: for(int r=0; r<MAX_HEIGHT+3; r++)\n  {\n    GRAD_WEIGHT_Y_INNER: for(int c=0; c<MAX_WIDTH; c++)\n    {\n      #pragma HLS pipeline II=1\n      #pragma HLS dependence variable=buf inter false\n\n      if(r<MAX_HEIGHT)\n      {\n        buf.shift_pixels_up(c);\n        gradient_t tmp;\n        tmp.x = gradient_x[r][c];\n        tmp.y = gradient_y[r][c];\n        tmp.z = gradient_z[r][c];\n        buf.insert_bottom_row(tmp,c);\n      }\n      else\n      {\n        buf.shift_pixels_up(c);\n        gradient_t tmp;\n        tmp.x = 0;\n        tmp.y = 0;\n        tmp.z = 0;\n        buf.insert_bottom_row(tmp,c);\n      }     \n\n      gradient_t acc;\n      acc.x = 0;\n      acc.y = 0;\n      acc.z = 0;\n      if(r >= 6 && r<MAX_HEIGHT)\n      { \n        GRAD_WEIGHT_Y_ACC: for(int i=0; i<7; i++)\n        {\n          acc.x += buf.getval(i,c).x*GRAD_FILTER[i];\n          acc.y += buf.getval(i,c).y*GRAD_FILTER[i];\n          acc.z += buf.getval(i,c).z*GRAD_FILTER[i];\n        }\n        filt_grad[r-3][c] = acc;\n      }\n      else if(r>=3)\n      {\n        filt_grad[r-3][c] = acc;\n      }\n    }\n  }\n}\n\n// average gradient in the x direction\nvoid gradient_weight_x(gradient_t y_filt[MAX_HEIGHT][MAX_WIDTH],\n                       gradient_t filt_grad[MAX_HEIGHT][MAX_WIDTH])\n{\n  hls::Window<1,7,gradient_t> buf;\n  const pixel_t GRAD_FILTER[] = {0.0755, 0.133, 0.1869, 0.2903, 0.1869, 0.133, 0.0755};\n  GRAD_WEIGHT_X_OUTER: for(int r=0; r<MAX_HEIGHT; r++)\n  {\n    GRAD_WEIGHT_X_INNER: for(int c=0; c<MAX_WIDTH+3; c++)\n    {\n      #pragma HLS pipeline II=1\n      buf.shift_pixels_left();\n      gradient_t tmp;\n      if(c<MAX_WIDTH)\n      {\n        tmp = y_filt[r][c];\n      }\n      else\n      {\n        tmp.x = 0;\n        tmp.y = 0;\n        tmp.z = 0;  \n      }\n      buf.insert_pixel(tmp,0,6);\n\n      gradient_t acc;\n      acc.x = 0;\n      acc.y = 0;\n      acc.z = 0;\n      if(c >= 6 && c<MAX_WIDTH) \n      {\n        GRAD_WEIGHT_X_ACC: for(int i=0; i<7; i++)\n        {\n          acc.x += buf.getval(0,i).x*GRAD_FILTER[i];\n          acc.y += buf.getval(0,i).y*GRAD_FILTER[i];\n          acc.z += buf.getval(0,i).z*GRAD_FILTER[i];\n        }\n        filt_grad[r][c-3] = acc;\n      }\n      else if(c>=3)\n      {\n        filt_grad[r][c-3] = acc;\n      }\n    }\n  }\n}\n\n// outer product \nvoid outer_product(gradient_t gradient[MAX_HEIGHT][MAX_WIDTH],\n     outer_t outer_product[MAX_HEIGHT][MAX_WIDTH])\n{\n  OUTER_OUTER: for(int r=0; r<MAX_HEIGHT; r++)\n  {\n    OUTER_INNER: for(int c=0; c<MAX_WIDTH; c++)\n    {\n      #pragma HLS pipeline II=1\n      gradient_t grad = gradient[r][c];\n      outer_pixel_t x = (outer_pixel_t) grad.x;\n      outer_pixel_t y = (outer_pixel_t) grad.y;\n      outer_pixel_t z = (outer_pixel_t) grad.z;\n      outer_t out;\n      out.val[0] = (x*x);\n      out.val[1] = (y*y);\n      out.val[2] = (z*z);\n      out.val[3] = (x*y);\n      out.val[4] = (x*z);\n      out.val[5] = (y*z);\n      outer_product[r][c] = out;\n    }\n  }\n}\n\n// tensor weight\nvoid tensor_weight_y(outer_t outer[MAX_HEIGHT][MAX_WIDTH],\n                     tensor_t tensor_y[MAX_HEIGHT][MAX_WIDTH])\n{\n  hls::LineBuffer<3,MAX_WIDTH,outer_t> buf;\n  const pixel_t TENSOR_FILTER[] = {0.3243, 0.3513, 0.3243};\n  TENSOR_WEIGHT_Y_OUTER: for(int r=0; r<MAX_HEIGHT+1; r++)\n  {\n    TENSOR_WEIGHT_Y_INNER: for(int c=0; c<MAX_WIDTH; c++)\n    {\n      #pragma HLS pipeline II=1\n      \n      outer_t tmp;\n      #pragma HLS data_pack variable=tmp\n      #pragma HLS data_pack variable=buf.val[0]\n      buf.shift_pixels_up(c);\n      if(r<MAX_HEIGHT)\n      {\n        tmp = outer[r][c];\n      }\n      else\n      {\n        TENSOR_WEIGHT_Y_TMP_INIT: for(int i=0; i<6; i++)\n          tmp.val[i] = 0;\n      }   \n      buf.insert_bottom_row(tmp,c);\n\n      tensor_t acc;\n      TENSOR_WEIGHT_Y_ACC_INIT: for(int k =0; k<6; k++)\n        acc.val[k] = 0;\n     \n      if (r >= 2 && r < MAX_HEIGHT) \n      {\n        TENSOR_WEIGHT_Y_TMP_OUTER: for(int i=0; i<3; i++)\n        {\n          tmp = buf.getval(i,c);\n          pixel_t k = TENSOR_FILTER[i];\n          TENSOR_WEIGHT_Y_TMP_INNER: for(int component=0; component<6; component++)\n          {\n            acc.val[component] += tmp.val[component]*k;\n          }\n        }\n      }\n      if(r >= 1)\n      { \n        tensor_y[r-1][c] = acc;      \n      }\n    }\n  }\n}\n\nvoid tensor_weight_x(tensor_t tensor_y[MAX_HEIGHT][MAX_WIDTH],\n                     tensor_t tensor[MAX_HEIGHT][MAX_WIDTH])\n{\n  hls::Window<1,3,tensor_t> buf;\n  const pixel_t TENSOR_FILTER[] = {0.3243, 0.3513, 0.3243};\n  //const float TENSOR_FILTER[] = {0.3243, 0.3513, 0.3243};\n  TENSOR_WEIGHT_X_OUTER: for(int r=0; r<MAX_HEIGHT; r++)\n  {\n    TENSOR_WEIGHT_X_INNER: for(int c=0; c<MAX_WIDTH+1; c++)\n    {\n      #pragma HLS pipeline II=1\n      buf.shift_pixels_left();\n      tensor_t tmp;\n      if(c<MAX_WIDTH)\n      {\n        tmp = tensor_y[r][c];\n      }\n      else\n      {\n        TENSOR_WEIGHT_X_TMP_INIT: for(int i=0; i<6; i++)\n          tmp.val[i] = 0;\n      }\n      buf.insert_pixel(tmp,0,2);\n\n      tensor_t acc;\n      TENSOR_WEIGHT_X_ACC_INIT: for(int k =0; k<6; k++)\n        acc.val[k] = 0;\n      if (c >= 2 && c < MAX_WIDTH) \n      {\n        TENSOR_WEIGHT_X_TMP_OUTER: for(int i=0; i<3; i++)\n        {\n          tmp = buf.getval(0,i);\n          TENSOR_WEIGHT_X_TMP_INNER: for(int component=0; component<6; component++)\n          {\n            acc.val[component] += tmp.val[component]*TENSOR_FILTER[i];\n          }\n        }\n      }\n      if(c>=1)\n      {\n        tensor[r][c-1] = acc;\n      }\n    }\n  }\n}\n\n// compute output flow\nvoid flow_calc(tensor_t tensors[MAX_HEIGHT][MAX_WIDTH],\n               velocity_t outputs[MAX_HEIGHT][MAX_WIDTH])\n{\n  static outer_pixel_t buf[2];\n  FLOW_OUTER: for(int r=0; r<MAX_HEIGHT; r++)\n  {\n    FLOW_INNER: for(int c=0; c<MAX_WIDTH; c++)\n    {\n      #pragma HLS pipeline II=1\n      tensor_t tmp_tensor = tensors[r][c];\n      if(r>=2 && r<MAX_HEIGHT-2 && c>=2 && c<MAX_WIDTH-2)\n      {\n\t      calc_pixel_t t1 = (calc_pixel_t) tmp_tensor.val[0];\n\t      calc_pixel_t t2 = (calc_pixel_t) tmp_tensor.val[1];\n\t      calc_pixel_t t3 = (calc_pixel_t) tmp_tensor.val[2];\n\t      calc_pixel_t t4 = (calc_pixel_t) tmp_tensor.val[3];\n\t      calc_pixel_t t5 = (calc_pixel_t) tmp_tensor.val[4];\n\t      calc_pixel_t t6 = (calc_pixel_t) tmp_tensor.val[5];\n\n        calc_pixel_t denom = t1*t2-t4*t4;\n\t      calc_pixel_t numer0 = t6*t4-t5*t2;\n\t      calc_pixel_t numer1 = t5*t4-t6*t1;\n\n\t      if(denom != 0)\n        {\n          buf[0] = numer0 / denom;\n          buf[1] = numer1 / denom;\n\t      } \n\t      else\n\t      {\n\t\t      buf[0] = 0;\n\t\t      buf[1] = 0;\n\t      }\n      }\n      else\n      {\n        buf[0] = buf[1] = 0;\n      }\n\n      outputs[r][c].x = (vel_pixel_t)buf[0];\n      outputs[r][c].y = (vel_pixel_t)buf[1];\n\n    }\n  }\n}\n\n// top-level kernel function\nvoid optical_flow(frames_t   frames[MAX_HEIGHT][MAX_WIDTH],\n                  velocity_t outputs[MAX_HEIGHT][MAX_WIDTH])\n{\n  #pragma HLS data_pack variable=outputs\n\n  #pragma HLS DATAFLOW\n\n  // FIFOs connecting the stages\n  static pixel_t gradient_x[MAX_HEIGHT][MAX_WIDTH];\n  //#pragma HLS STREAM variable=gradient_x depth=default_depth\n  static pixel_t gradient_y[MAX_HEIGHT][MAX_WIDTH];\n  //#pragma HLS STREAM variable=gradient_y depth=default_depth\n  static pixel_t gradient_z[MAX_HEIGHT][MAX_WIDTH];\n  //#pragma HLS STREAM variable=gradient_z depth=max_width*4\n  static gradient_t y_filtered[MAX_HEIGHT][MAX_WIDTH];\n  //#pragma HLS STREAM variable=y_filtered depth=default_depth\n  static gradient_t filtered_gradient[MAX_HEIGHT][MAX_WIDTH];\n  //#pragma HLS STREAM variable=filtered_gradient depth=default_depth\n  static outer_t out_product[MAX_HEIGHT][MAX_WIDTH];\n  //#pragma HLS STREAM variable=out_product depth=default_depth\n  #pragma HLS data_pack variable=out_product\n  static tensor_t tensor_y[MAX_HEIGHT][MAX_WIDTH];\n  //#pragma HLS STREAM variable=tensor_y depth=default_depth\n  #pragma HLS data_pack variable=tensor_y\n  static tensor_t tensor[MAX_HEIGHT][MAX_WIDTH];\n  //#pragma HLS STREAM variable=tensor depth=default_depth\n  #pragma HLS data_pack variable=tensor\n\n  // FIFOs for streaming in, just for clarity\n  static input_t frame1_a[MAX_HEIGHT][MAX_WIDTH];\n  //#pragma HLS STREAM variable=frame1_a depth=default_depth\n  static input_t frame2_a[MAX_HEIGHT][MAX_WIDTH];\n  //#pragma HLS STREAM variable=frame2_a depth=default_depth\n  static input_t frame4_a[MAX_HEIGHT][MAX_WIDTH];\n  //#pragma HLS STREAM variable=frame4_a depth=default_depth\n  static input_t frame5_a[MAX_HEIGHT][MAX_WIDTH];\n  //#pragma HLS STREAM variable=frame5_a depth=default_depth\n\n  //Need to duplicate frame3 for the two calculations\n  static input_t frame3_a[MAX_HEIGHT][MAX_WIDTH];\n  //#pragma HLS STREAM variable=frame3_a depth=default_depth\n  static input_t frame3_b[MAX_HEIGHT][MAX_WIDTH];\n  //#pragma HLS STREAM variable=frame3_b depth=default_depth\n\n  // stream in and organize the inputs\n  static frames_t buf;\n  FRAMES_CP_OUTER: for (int r=0; r<MAX_HEIGHT; r++) \n  {\n    FRAMES_CP_INNER: for (int c=0; c<MAX_WIDTH; c++) \n    {\n      #pragma HLS pipeline II=1\n\n      // one wide read\n      buf = frames[r][c];\n      // assign values to the FIFOs\n      frame1_a[r][c] = ((input_t)(buf(7 ,  0)) >> 8);\n      frame2_a[r][c] = ((input_t)(buf(15,  8)) >> 8);\n      frame3_a[r][c] = ((input_t)(buf(23, 16)) >> 8);\n      frame3_b[r][c] = ((input_t)(buf(23, 16)) >> 8);\n      frame4_a[r][c] = ((input_t)(buf(31, 24)) >> 8);\n      frame5_a[r][c] = ((input_t)(buf(39, 32)) >> 8);\n    }\n  }\n  //\n  // compute\n  gradient_xy_calc(frame3_a, gradient_x, gradient_y);\n  gradient_z_calc(frame1_a, frame2_a, frame3_b, frame4_a, frame5_a, gradient_z);\n  gradient_weight_y(gradient_x, gradient_y, gradient_z, y_filtered);\n  gradient_weight_x(y_filtered, filtered_gradient);\n  outer_product(filtered_gradient, out_product);\n  tensor_weight_y(out_product, tensor_y);\n  tensor_weight_x(tensor_y, tensor);\n  flow_calc(tensor, outputs);\n\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a C function named `syr2k` that, using matrix multiplication and addition, computes a symmetric rank-2k operation. The function parameters will include `alpha` and `beta`, which are scalar values, as well as `A`, `B`, `C`, and `D_out`, which are 2D arrays. \n\nThe function will consist of several separate parts: Firstly, it will take the arrays A, B and C, and copy their contents to buffer arrays named `buff_A0`, `buff_A1`, `buff_B0`, `buff_B1` and `buff_C`. It will also create the output array `buff_D_out` and two temporary arrays `tmp1` and `tmp2` and initializes them to 0. \n\nNext, two sets of nested loops will be used to multiply `alpha` by the values in the buffer arrays and sum the results, storing these in the `tmp1` and `tmp2` arrays.\n\nThen, another set of nested loops will add the results from `tmp1`, `tmp2` and `beta` times `buff_C` and store the results to `buff_D_out`.\n\nFinally, there will iterate through `buff_D_out`, and in the case where column `j` is greater than row `i`, it will put a zero in the corresponding position in `D_out`, otherwise it will write the value from `buff_D_out` to `D_out`. Make sure to not break these loops into smaller chunks, run the loop iterations one after the other, not in parallel, and do not automatically pipeline these final loops. Remember to treat the function as a hardware kernel for acceleration.", "output": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n#define N 64\n\n#define DATA_TYPE float\n#define SCALAR_VAL(x) x##f\n#define SQRT_FUN(x) sqrtf(x)\n#define EXP_FUN(x) expf(x)\n#define POW_FUN(x,y) powf(x,y)\n\nvoid syr2k(DATA_TYPE alpha, DATA_TYPE beta, DATA_TYPE A[N][N], DATA_TYPE B[N][N], DATA_TYPE C[N][N], DATA_TYPE D_out[N][N]);\n\n\nvoid syr2k(DATA_TYPE alpha, DATA_TYPE beta, DATA_TYPE A[N][N], DATA_TYPE B[N][N], DATA_TYPE C[N][N], DATA_TYPE D_out[N][N]){\n\tint i, j, k;\n\tDATA_TYPE buff_A0[N][N], buff_A1[N][N];\n\tDATA_TYPE buff_B0[N][N], buff_B1[N][N];\n\tDATA_TYPE buff_C[N][N];\n\tDATA_TYPE buff_D_out[N][N];\n\tDATA_TYPE tmp1[N][N];\n\tDATA_TYPE tmp2[N][N];\n\n\n\tlprd_1: for (i = 0; i < N; i++){\n\t\tlprd_2: for (j = 0; j < N; j++){\n\t\t\tbuff_A0[i][j] = A[i][j];\n\t\t\tbuff_A1[i][j] = A[i][j];\n\t\t\tbuff_B0[i][j] = B[i][j];\n\t\t\tbuff_B1[i][j] = B[i][j];\n\t\t\tbuff_C[i][j] = C[i][j];\n\t\t\tbuff_D_out[i][j] = 0;\n\t\t\ttmp1[i][j] = 0;\n\t\t\ttmp2[i][j] = 0;\n\t\t}\n\t}\n\n\tlp1: for (i = 0; i < N; i++){\n\t\tlp2: for (j = 0; j < N; j++){\n\t\t\t// if (j > i) continue;\n\t\t\tlp3: for (k = 0; k < N; k++){\n\t\t\t\ttmp1[i][j] += alpha * buff_A0[i][k] * buff_B0[j][k];\n\t\t\t}\n\t\t}\n\t}\n\n\tlp4: for (i = 0; i < N; i++){\n\t\tlp5: for (j = 0; j < N; j++){\n\t\t\t// if (j > i) continue;\n\t\t\tlp6: for (k = 0; k < N; k++){\n\t\t\t\ttmp2[i][j] += alpha * buff_B0[i][k] * buff_A1[j][k];\n\t\t\t}\n\t\t}\n\t}\n\n\tlp7: for (i = 0; i < N; i++){\n\t\tlp8: for (j = 0; j < N; j++){\n\t\t\t//if (j > i) continue;\n\t\t\tbuff_D_out[i][j] = tmp1[i][j] + tmp2[i][j] + beta * buff_C[i][j];\n\t\t}\n\t}\n\n\tlpwr_1: for(i = 0; i < N; i++){\n\t\tlpwr_2: for(j = 0; j < N; j++){\n\t\t\tif (j > i) D_out[i][j] = 0;\n\t\t\telse D_out[i][j] = buff_D_out[i][j];\n\t\t}\n\t}\n}\n\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function 'syrk' in C language that utilizes hardware acceleration and floating-point operations for Symmetric Rank-k operations. The function syrk takes in five parameters: two scalars 'alpha' and 'beta' and three 2D arrays 'A', 'B', and 'C_out', all of type 'DATA_TYPE'. \n\nStart the function by declaring integer variables 'i', 'j', 'k' and buffer arrays buff_A0, buff_A1, buff_B, and buff_C_out the same size as the input arrays. Load data from the input arrays into the buffer arrays in a nested loop tagged as 'lprd_1' and 'lprd_2'.\n\nIn the next series of nested loops tagged 'lp1', 'lp2', and 'lp3', each element of 'buff_C_out' is updated with the product of 'alpha', 'buff_A0' and 'buff_A1'. Follow this up with another pair of nested loops tagged 'lp4' and 'lp5' that update each element of 'buff_C_out' with the product of 'beta' and 'buff_B'.\n\nFinally, using loops 'lpwr_1' and 'lpwr_2', output the 'buff_C_out' values where 'j' is less than or equal to 'i' into 'C_out', and otherwise set 'C_out' to 0. \n\nThis function should treat all major sections and nested loops as individual tasks to be executed in parallel without automatic pipelining and without breaking the loops into smaller chunks for more efficient computation. Use pragma directives such as '#pragma ACCEL TILE FACTOR=1' for no tiling, '#pragma ACCEL PARALLEL FACTOR=1' for no parallel loop iterations, and '#pragma ACCEL PIPELINE \"off\"' to turn off automatic loop pipelining. Use '#pragma ACCEL kernel' at the start of the function to mark it as a hardware kernel.", "output": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n#define N 64\n\n#define DATA_TYPE float\n#define SCALAR_VAL(x) x##f\n#define SQRT_FUN(x) sqrtf(x)\n#define EXP_FUN(x) expf(x)\n#define POW_FUN(x,y) powf(x,y)\n\nvoid syrk(DATA_TYPE alpha, DATA_TYPE beta, DATA_TYPE A[N][N], DATA_TYPE B[N][N], DATA_TYPE C_out[N][N]);\n\n\nvoid syrk(DATA_TYPE alpha, DATA_TYPE beta, DATA_TYPE A[N][N], DATA_TYPE B[N][N], DATA_TYPE C_out[N][N]) {\n\tint i, j, k;\n\n\tDATA_TYPE buff_A0[N][N], buff_A1[N][N];\n\tDATA_TYPE buff_B[N][N];\n\tDATA_TYPE buff_C_out[N][N];\n\n\tlprd_1: for (i = 0; i < N; i++) {\n\t\tlprd_2: for (j = 0; j < N; j++) {\n\t\t\tbuff_A0[i][j] = A[i][j];\n\t\t\tbuff_A1[i][j] = A[i][j];\n\t\t\tbuff_B[i][j] = B[i][j];\n\t\t\tbuff_C_out[i][j] = 0;\n\t\t}\n\t}\n\n\tlp1: for (i = 0; i < N; i++) {\n\t\tlp2: for (j = 0; j < N; j++) {\n\t\t\t// if (j > i) continue;\n\t\t\tlp3: for (k = 0; k < N; k++) {\n\t\t\t\tbuff_C_out[i][j] += alpha * buff_A0[i][k] * buff_A1[j][k];\n\t\t\t}\n\t\t}\n\t}\n\n\tlp4: for (i = 0; i < N; i++) {\n\t\tlp5: for (j = 0; j < N; j++) {\n\t\t\t// if (j > i) continue;\n\t\t\tbuff_C_out[i][j] += beta * buff_B[i][j];\n\t\t}\n\t}\n\n\t\n\n\tlpwr_1: for(i = 0; i < N; i++) {\n\t\tlpwr_2: for(j = 0; j < N; j++) {\n\t\t\tif (j > i) C_out[i][j] = 0;\n\t\t\telse C_out[i][j] = buff_C_out[i][j];\n\t\t}\n\t}\n}\n\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a digit recognition system named 'DigitRec' in HLS C designed for acceleration in FPGA. The system should use a dataset of 18000 training infractions and 2000 test examples, and the digits to be recognized are 4 pixels wide. The data type named 'WholeDigitType' should use 'ap_uint<256>', a 'SDSoC wide vector type'. The physical contiguous memory is used for the acceleration to ensure that global test set, training data set and the results are stored efficiently. This is achieved using '#pragma SDS data mem_attribute'. To optimize the data transfer with the host memory, is utilized the '#pragma SDS data data_mover' to enable AXIDMA_SIMPLE mode. \n\nIn the DigitRec function, use a static training set array and block partition it with the '#pragma HLS array_partition' where the block factor attribute equal to the unrolla_factor, which is 'PAR_FACTOR'. Use the inline function popcount to handle 256 numbers storing into a parallel factor. In the function loop pipeline the run with pragma to achieve better performance.\n\nThe actual recognition is based on a voting system among the nearest neighbors. After preparing the distance measurements, use the 'knn_vote' function with the purpose of collecting the votes for each possible digit (0 to 9) then find the maximum value to determine the label. This function should also be inline for acceleration performance.\n\nFor each training instance, compute the difference to the test instance using XOR operation. Then, find the maximum distance and replace if the computed distance is less than the maximum. For each of the test data, initialize a local array knn_set then fetch a test instance from the test_set inside a loop. This continues as the system keeps updating & computing KNNs.\n\nThe first time the function is called only data transfer is performed then the function returns. For the second call, copy the training and the test set and start processing the test set. The function 'update_knn' is used to keep track of the K minimum distances for a given set. Once the KNN set is updated, compute the final output and store it in the results array. Copy the results back to the globally accessible results array. \n\nAlso, remember to turn off the automatic pipelining optimization for loops related to the data transfer from the memory to the FPGA and operate with the entire loop by using pragma and the ACCEL features such as PIPELINE and PARALLEL.", "output": "/*===============================================================*/\n/*                                                               */\n/*                          digitrec.cpp                         */\n/*                                                               */\n/*             Hardware function for digit recognition           */\n/*                                                               */\n/*===============================================================*/\n\n// dataset information\n#define NUM_TRAINING 18000\n#define CLASS_SIZE 1800\n#define NUM_TEST 2000\n#define DIGIT_WIDTH 4\n\n// typedefs\ntypedef unsigned long long DigitType;\ntypedef unsigned char      LabelType;\n\n// parameters\n#define K_CONST 3\n#define PAR_FACTOR 40\n\n#include \"ap_int.h\"\n// sdsoc wide vector type\ntypedef ap_uint<256>  WholeDigitType;\n\n#pragma SDS data mem_attribute(global_training_set:PHYSICAL_CONTIGUOUS, global_test_set:PHYSICAL_CONTIGUOUS, global_results:PHYSICAL_CONTIGUOUS)\n#pragma SDS data data_mover(global_training_set:AXIDMA_SIMPLE, global_test_set:AXIDMA_SIMPLE, global_results:AXIDMA_SIMPLE)\nvoid DigitRec(WholeDigitType global_training_set[NUM_TRAINING / 2], WholeDigitType global_test_set[NUM_TEST], LabelType global_results[NUM_TEST], int run);\n\n\n// popcount function\nint popcount(WholeDigitType x)\n{\n  // most straightforward implementation\n  // actually not bad on FPGA\n  int cnt = 0;\n  for (int i = 0; i < 256; i ++ )\n    cnt = cnt + x[i];\n\n  return cnt;\n}\n\n// Given the test instance and a (new) training instance, this\n// function maintains/updates an array of K minimum\n// distances per training set.\nvoid update_knn( WholeDigitType test_inst, WholeDigitType train_inst, int min_distances[K_CONST] ) \n{\n  #pragma HLS inline\n\n  // Compute the difference using XOR\n  WholeDigitType diff = test_inst ^ train_inst;\n\n  int dist = 0;\n\n  dist = popcount(diff);\n\n  int max_dist = 0;\n  int max_dist_id = K_CONST+1;\n  int k = 0;\n\n  // Find the max distance\n  FIND_MAX_DIST: for ( int k = 0; k < K_CONST; ++k ) \n  {\n    if ( min_distances[k] > max_dist ) \n    {\n      max_dist = min_distances[k];\n      max_dist_id = k;\n    }\n  }\n\n  // Replace the entry with the max distance\n  if ( dist < max_dist )\n    min_distances[max_dist_id] = dist;\n\n  return;\n}\n\n// Given 10xK minimum distance values, this function\n// finds the actual K nearest neighbors and determines the\n// final output based on the most common int represented by\n// these nearest neighbors (i.e., a vote among KNNs).\nLabelType knn_vote( int knn_set[PAR_FACTOR * K_CONST] ) \n{\n  #pragma HLS inline\n\n  // local buffers\n\n  // final K nearest neighbors\n  int min_distance_list[K_CONST];\n  #pragma HLS array_partition variable=min_distance_list complete dim=0\n  // labels for the K nearest neighbors\n  int label_list[K_CONST];\n  #pragma HLS array_partition variable=label_list complete dim=0\n  // voting boxes\n  int vote_list[10];\n  #pragma HLS array_partition variable=vote_list complete dim=0\n\n  int pos = 1000;\n\n  // initialize\n  INIT_1: for (int i = 0;i < K_CONST; i ++ )\n  {\n    #pragma HLS unroll\n    min_distance_list[i] = 256;\n    label_list[i] = 9;\n  }\n\n  INIT_2: for (int i = 0;i < 10; i ++ )\n  {\n    #pragma HLS unroll\n    vote_list[i] = 0;\n  }\n\n  // go through all the lanes\n  // do an insertion sort to keep a sorted neighbor list\n  LANES: for (int i = 0; i < PAR_FACTOR; i ++ )\n  {\n    INSERTION_SORT_OUTER: for (int j = 0; j < K_CONST; j ++ )\n    {\n      #pragma HLS pipeline\n      pos = 1000;\n      INSERTION_SORT_INNER: for (int r = 0; r < K_CONST; r ++ )\n      {\n        #pragma HLS unroll\n        pos = ((knn_set[i*K_CONST+j] < min_distance_list[r]) && (pos > K_CONST)) ? r : pos;\n      }\n\n      INSERT: for (int r = K_CONST ;r > 0; r -- )\n      {\n        #pragma HLS unroll\n        if(r-1 > pos)\n        {\n          min_distance_list[r-1] = min_distance_list[r-2];\n          label_list[r-1] = label_list[r-2];\n        }\n        else if (r-1 == pos)\n        {\n          min_distance_list[r-1] = knn_set[i*K_CONST+j];\n          label_list[r-1] = i / (PAR_FACTOR / 10);\n        }\n      }\n    }\n  }\n\n  // vote\n  INCREMENT: for (int i = 0;i < K_CONST; i ++ )\n  {\n    #pragma HLS pipeline\n    vote_list[label_list[i]] += 1;\n  }\n\n  LabelType max_vote;\n  max_vote = 0;\n\n  // find the maximum value\n  VOTE: for (int i = 0;i < 10; i ++ )\n  {\n    #pragma HLS unroll\n    if(vote_list[i] >= vote_list[max_vote])\n    {\n      max_vote = i;\n    }\n  }\n\n  return max_vote;\n\n}\n\n// top-level hardware function\n// since AXIDMA_SIMPLE interface does not support arrays with size more than 16384 on interface\n// we call this function twice to transfer data\nvoid DigitRec(WholeDigitType global_training_set[NUM_TRAINING / 2], WholeDigitType global_test_set[NUM_TEST], LabelType global_results[NUM_TEST], int run) \n{\n\n  // This array stores K minimum distances per training set\n  int knn_set[PAR_FACTOR * K_CONST];\n  //#pragma HLS array_partition variable=knn_set complete dim=0\n\n  static WholeDigitType training_set [NUM_TRAINING];\n  // to be used in a pragma\n  const int unroll_factor = PAR_FACTOR;\n  //#pragma HLS array_partition variable=training_set block factor=unroll_factor dim=0\n\n  static WholeDigitType test_set     [NUM_TEST];\n  static LabelType results           [NUM_TEST];\n\n  // the first time, just do data transfer and return\n  if (run == 0)\n  {\n    // copy the training set for the first time\n    lp1:for (int i = 0; i < NUM_TRAINING / 2; i ++ )\n      //#pragma HLS pipeline\n      training_set[i] = global_training_set[i];\n    return;\n  }\n\n  // for the second time\n  lp2:for (int i = 0; i < NUM_TRAINING / 2; i ++ )\n    //#pragma HLS pipeline\n    training_set[i + NUM_TRAINING / 2] = global_training_set[i];\n  // copy the test set\n  lp3:for (int i = 0; i < NUM_TEST; i ++ )\n    //#pragma HLS pipeline\n    test_set[i] = global_test_set[i];\n\n  // loop through test set\n  TEST_LOOP: for (int t = 0; t < NUM_TEST; ++t) \n  {\n    // fetch one instance\n    WholeDigitType test_instance = test_set[t];\n\n    // Initialize the knn set\n    SET_KNN_SET: for ( int i = 0; i < K_CONST * PAR_FACTOR ; ++i ) \n    {\n      #pragma HLS unroll\n      // Note that the max distance is 256\n      knn_set[i] = 256;\n    }\n\n    TRAINING_LOOP : for ( int i = 0; i < NUM_TRAINING / PAR_FACTOR; ++i ) \n    {\n      //#pragma HLS pipeline\n      LANES : for ( int j = 0; j < PAR_FACTOR; j++ ) \n      {\n        //#pragma HLS unroll\n        // Read a new instance from the training set\n        WholeDigitType training_instance = training_set[j * NUM_TRAINING / PAR_FACTOR + i];\n\n        // Update the KNN set\n        update_knn( test_instance, training_instance, &knn_set[j * K_CONST] );\n      }\n    }\n    // Compute the final output\n    LabelType max_vote = knn_vote(knn_set);\n    results[t] = max_vote;\n\n  }\n\n  // copy the results out\n  lp4: for (int i = 0; i < NUM_TEST; i ++ )\n    //#pragma HLS pipeline\n    global_results[i] = results[i];\n\n}\n\n"}
