{"instruction": "Generate HLS code with the following instructions:", "input": "Create an HLS C code for a function named `kernel_3mm` which takes as parameters nine integers representing array dimensions (ni, nj, nk, nl, nm) and seven 2-dimensional arrays of type double (E,A,B,F,C,D,G). The function must be treated as a hardware-accelerated kernel. Within this kernel, it should perform three separate matrix multiplications - E=A*B, F=C*D and G=E*F. To control flow, the loops in this kernel should not be automatically pipelined and they should be executed in their original form, not broken into smaller parts for parallel processing. This is specified by using #pragma ACCEL PIPELINE auto{off}, #pragma ACCEL TILE FACTOR=auto{1}, and #pragma ACCEL PARALLEL FACTOR=auto{1}, respectively. The parallel factor for calculating the elements of F can be increased to 5 to enhance computation speed with #pragma ACCEL PARALLEL FACTOR=auto{5}.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function named 'kernel_3mm' with parameters: five integer values (ni, nj, nk, nl, nm) and seven 2D Arrays of doubles (E, A, B, F, C, D, G). Define this function as a hardware kernel for acceleration with '#pragma ACCEL kernel'. \n\nInside the function, define three integers (i, j, k). The function carries out three main procedures. \n\nThe first procedure is to calculate the matrix product of A and B, stored in E. Create three nested loops for this calculation, with i ranging from 0 to 39, j from 0 to 49, and k from 0 to 59. Do not automatically pipeline these loops and process them fully without separating them or running them in parallel - translate this stipulation using their respective pragma values '#pragma ACCEL PIPELINE auto{off}', '#pragma ACCEL TILE FACTOR=auto{1}', and '#pragma ACCEL PARALLEL FACTOR=auto{1}'.\n\nThe second procedure calculates the matrix product of C and D, stored in F. Similarly, create three nested loops for this, with i ranging from 0 to 49, j from 0 to 69, and k from 0 to 79. Do not automatically pipeline and tile these loops, but use '#pragma ACCEL PARALLEL FACTOR=auto{32}' for optimized parallel computing in the innermost loop.\n\nFinally, calculate the matrix product of E and F and store the result in G, using three nested loops with i ranging from 0 to 39, j from 0 to 69, and k from 0 to 49. Do not automatically pipeline or tile these loops, but run the innermost loop in parallel using '#pragma ACCEL PARALLEL FACTOR=auto{10}' for optimization.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a C function with the header \"void kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\" that is considered to be a hardware kernel for acceleration. This function should essentially perform three separate matrix multiplications with matrix dimensions provided as parameters. Use various #pragma directives to guide the compilation and execution of these multiplications. \n\nFor the first multiplication 'E = A*B', handle the loop without automatic pipelining or partitioning and not in parallel, for each iteration initialize E[i][j] to 0.0 then compute the multiplication value for E[i][j] which is the sum of the product A[i][k]*B[k][j] in a nested loop with the same rules. \n\nSecond, for the matrix multiplication 'F = C*D', run similar steps but with the innermost loop that deals with the actual multiplication carried out using a parallelism factor of 32. \n\nFinally, for 'G = E*F', return to the rules of the first multiplication. \n\nRemember, this series of computations should be done without substantially reformatting or breaking down the loops for more efficient execution, since each #pragma directive contains 'ACCEL TILE FACTOR' set to 1, indicating that the loop should be executed in its original, whole form.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "You are to write a function called 'kernel_3mm' that takes as its parameters seven integer dimensions (ni,nj,nk,nl,nm) and seven two-dimensional double arrays (E,A,B,F,C,D,G). The function should be treated as a hardware kernel for acceleration. Inside this function, you need to do the following:\n\n1. Create two integer variables (i, j, and k). \n2. Calculate the product of the matrices A and B, and store the result in matrix E. To do this, iterate over each element of E, initialize it to 0.0, and then for each index 'k', add to it the product of the corresponding elements from A and B. Use the pragma values to ensure that loops are not automatically pipelined (ACCEL PIPELINE auto{off}), are processed in their original, full form without extracting any common factors (ACCEL TILE FACTOR=auto{1}), and are not parallelized (ACCEL PARALLEL FACTOR=auto{1}).\n\n3. Calculate the product of the matrices C and D, and store the result in matrix F. Follow the same process as above, but use ACCEL PARALLEL FACTOR=auto{20} in the innermost loop.\n\n4. Calculate the product of the matrices E and F, and store the result in matrix G. Follow the same process as above, but use ACCEL PARALLEL FACTOR=auto{25} in the innermost loop. Again, make sure not to pipeline these loops, perform any loop tiling or excessive parallelization with the same pragmas as before.\n\nNote that pipelining, tiling, or parallelizing might negatively affect the overall performance of sequential or dependent computation, hence it is disabled in our context. Lastly, you should disable respective complex optimizations for each of these loops by marking them as pragma ACCEL PIPELINE, ACCEL TILE FACTOR, and ACCEL PARALLEL all set to their minimum values respectively.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{25}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Prompt:\nWrite a function in C, named 'kernel_3mm', under the 'ACCEL kernel' directive for hardware acceleration. This function takes five integer arguments: ni, nj, nk, nl, nm, and seven 2D array arguments: E, A, B, F, C, D, G. There are three main steps to the function:\n\n1. Implement a nested loop to multiply the matrices A and B and store the result in E. Use #pragma ACCEL PIPELINE auto{off}, #pragma ACCEL TILE FACTOR=auto{1}, and #pragma ACCEL PARALLEL FACTOR=auto{1} to disable automatic pipelining, process the loop in its original form and run loop iterations sequentially. For the innermost loop, enable parallelism with a parallel factor of auto{60}.\n\n2. Implement another nested loop to multiply the matrices C and D and store the result in F. Use #pragma ACCEL PIPELINE auto{off}, #pragma ACCEL TILE FACTOR=auto{1}, and #pragma ACCEL PARALLEL FACTOR=auto{1} to disable automatic pipelining, process the loop in its original form and run loop iterations sequentially. For the innermost loop, enable parallelism with a parallel factor of auto{80}.\n\n3. Implement a third nested loop to multiply the matrices E and F and store the result in G. Use #pragma ACCEL PIPELINE auto{off}, #pragma ACCEL TILE FACTOR=auto{1}, and #pragma ACCEL PARALLEL FACTOR=auto{1} to disable automatic pipelining, process the loop in its original form and run loop iterations sequentially. For the innermost loop, enable parallelism with a parallel factor of auto{50}.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a C HLS kernel function called 'kernel_3mm' that receives integers ni, nj, nk, nl, nm and six 2D double arrays E[40][50], A[40][60], B[60][50], F[50][70], C[50][80], D[80][70] and G[40][70] as parameters. In this function, populate array E with the multiplication of arrays A and B. Then populate array F with the multiplication of arrays C and D. Afterwards fill array G with the multiplication of arrays E and F. For each of these loops, use the ACCEL PIPELINE pragma to disable automatic pipelining, use the ACCEL TILE FACTOR pragma to keep the loop in its original, full form without breaking it into smaller chunks and use the ACCEL PARALLEL FACTOR pragma to make sure that the iterations of each loop run one after the other, not in parallel except for the k loop inside the F and G calculations where parallel factor is set to 4 and 2 respectively.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a HLS C function called 'kernel_3mm'. Treat the function as a kernel for hardware acceleration. Declare the function with the parameters 'int ni, nj, nk, nl, nm' and 7 2D arrays 'double E, A, B, F, C, D, G'. \n\nIn the function, declare integer variables 'i, j, k'. \n\nThen start with a series of loops. Before the loops use the pragmas 'PIPELINE' with automatic flattening, 'TILE' with a factor automatically assigned as 1, and 'PARALLEL' with a factor automatically assigned as 1. \n\nCreate the first loop for 'i' from 0 to 40. Inside this loop, repeat the same pragmas but with 'PIPELINE' set to off. Then nest a loop for 'j' from 0 to 50 with the similar pragmas. In the innermost part of this nested loop, initialize 'E[i][j]' to 0.0 and create another nested loop for 'k' from 0 to 60, with 'PARALLEL' pragma having a factor of 1, where 'E[i][j]' is calculated by accumulating the product of 'A[i][k]' and 'B[k][j]'. \n\nFollowing the same pattern, write another series of loops for 'i' from 0 to 50 and 'j' from 0 to 70, But here, 'F[i][j]' is initialized to 0.0 and in the innermost loop for 'k' from 0 to 80, 'F[i][j]' is calculated by accumulating the product of 'C[i][k]' and 'D[k][j]'. Change the 'PARALLEL' pragma factor to 2 in the innermost loop. \n\nFinally, create another series of loops for 'i' from 0 to 40 and 'j' from 0 to 70. Again, 'G[i][j]' is initialized to 0.0 and the innermost loop for 'k' from 0 to 50 calculates 'G[i][j]' by accumulating the product of 'E[i][k]' and 'F[k][j]'. In this final loop, increase the 'PARALLEL' pragma factor to 8.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a hardware acceleration kernel function named `kernel_3mm` with input parameters for 5 matrix sizes 'ni', 'nj', 'nk', 'nl', 'nm' and 7 two-dimensional arrays 'E', 'A', 'B', 'F', 'C', 'D', 'G'. Within the function, do not automatically pipeline the loops. Process the loops in their full form without breaking them into smaller parts, and run the iterations of loops one after the other, not in parallel.\n\nPerform three separate matrix multiplications as follows:\n\n1. Calculate matrix multiplication of 'A' and 'B', store the result into 'E'. Inside this loops, flatten the pipeline and conduct the operations in full, not breaking them up, with iterations run one after the other.\n2. Calculate matrix multiplication of 'C' and 'D', store the result into 'F'. Again, flatten the pipeline and conduct operations in full form, with iterations run one after the other.\n3. Finally, calculate matrix multiplication of 'E' and 'F', store result into 'G'. Unlike before, allow certain parts of this loops go parallel.\n\nFor the final multiplication, do not automatically pipeline the process for the outer loop, while for the inner loop, allow a smaller portion of iterations run together. Make adjustments if distributor deems necessary.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{25}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function titled 'kernel_3mm', which acts as a hardware kernel for acceleration according to the '#pragma ACCEL kernel' directive. This function accepts nine arguments, five integers (ni, nj, nk, nl, nm) and four 2D double arrays (E, A, B, F, C, D, G). The function contains three primary for-loops with nested loops within each of them. \n\nIrrespective of the loop, '#pragma ACCEL PIPELINE auto{off}' indicates that the loop shouldn't be automatically pipelined. '#pragma ACCEL TILE FACTOR=auto{1}' means each loop should be processed in its original, full form without breaking it into smaller parts. '#pragma ACCEL PARALLEL FACTOR=auto{1}' specifies that the iterations should be run one after the other and not in parallel.\n\nIn the third loop, the nested loop for calculating F utilizes '#pragma ACCEL PARALLEL FACTOR=auto{5}' to ensure five iterations run concurrently. Similarly, the nested loop under the final loop employs '#pragma ACCEL PARALLEL FACTOR=auto{10}', which means ten iterations run in parallel. \n\nOverall, the function calculates the products of matrices A and B, assigns it to E, then calculates the product of matrices C and D, assigns it to F, and finally calculates the product of matrices E and F and assigns it to G.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a function named 'kernel_3mm' with specified parameters and arrays. Now, carry out three matrix multiplications in this function which is treated as a hardware kernel using '#pragma ACCEL kernel'. For each multiplication operation, disable the automatic pipeline process, run the loop iterations sequentially instead of parallel and avoid breaking the loop into smaller chunks using '#pragma ACCEL PIPELINE auto{off}', '#pragma ACCEL PARALLEL FACTOR=auto{1}', and '#pragma ACCEL TILE FACTOR=auto{1}'. Perform the following matrix multiplications: firstly compute 'E' from 'A' times 'B', then compute 'F' from 'C' times 'D' and finally compute 'G' from 'E' times 'F'. Remember to run the innermost for-loop for each multiplication operation with an automatic parallel factor of 1, 5 and 4 respectively.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a CUDA kernel called \"kernel_3mm\" that takes in 5 integers (ni, nj, nk, nl, nm) and seven 2D arrays of doubles (E, A, B, F, C, D, G). Inside this kernel, perform matrix multiplication operation in three main steps. Each step is optimized with three pragma factors. First, disable automatic pipelining with \"#pragma ACCEL PIPELINE auto{off}\". Second, process each loop in its original full form, rather than breaking it into smaller chunks, with \"#pragma ACCEL TILE FACTOR=auto{1}\". Lastly, ensure that all iterations of loops are executed one after another, not in parallel, with \"#pragma ACCEL PARALLEL FACTOR=auto{1}\".\n\nThe first operation computes matrix E by multiplying matrices A and B, with the innermost loop parallel factor set to \"1\". The second operation computes matrix F by multiplying matrices C and D, with the innermost loop parallel factor set to \"5\". The final operation computes matrix G by multiplying the previously calculated matrices E and F, with the innermost loop parallel factor set to \"25\".", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{25}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Please compose a hardware accelerated C function named 'kernel_3mm'. The function should receive integers 'ni', 'nj', 'nk', 'nl', and 'nm' and six double 2D arrays: 'E', 'A', 'B', 'F', 'C', 'D', and 'G'. Start by indicating this function as a hardware accelerated kernel with 'ACCEL kernel' pragma. The function includes three main operations:\n1. Calculate 'E' as the product of matrices 'A' and 'B'. Do not automatically pipeline this loop, process this loop in its original form without splitting it, and run the iterations one after the other, not in parallel. Use 'ACCEL PIPELINE auto{off}', 'ACCEL TILE FACTOR=auto{1}', and 'ACCEL PARALLEL FACTOR=auto{1}' pragmas respectively.\n2. Calculate 'F' as the product of matrices 'C' and 'D'. Apply the same pragma instructions as before but remember to give the last nested loop a parallelism factor of 5 with 'ACCEL PARALLEL FACTOR=auto{5}'.\n3. Calculate 'G' as the product of matrices 'E' and 'F' using the previous pragma instructions but the last nested loop should have a parallelism factor of 2 with 'ACCEL PARALLEL FACTOR=auto{2}'.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function called 'kernel_3mm' which takes five integers (ni,nj,nk,nl,nm) and seven two-dimensional double arrays (E, A, B, F, C, D, G) as arguments. Declare three integer variables (i, j, k). The function will go through three major operations: calculating the product of matrices A and B to result in matrix E, calculating the product of matrices C and D to result in matrix F, and finally calculating the product of matrices E and F to result in matrix G.\n\nFor each operation, a triple-nested loop is used where the outer and middle loops have disabled automatic pipelining, are not broken into smaller chunks and the iterations of the loop are run one after the other, not in parallel. The inner loop is generally run with the same settings, except for the second and third operations where the loop iterations run in parallel with a factor of 5 and 50 respectively. Indicate each operation explicitly to be run as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a C code for a function titled \"kernel_3mm\" that accepts 7 parameters: five integers (ni, nj, nk, nl, nm) and six 2D arrays of double (E, A, B, F, C, D, G). The function should perform matrix operations such as matrix multiplication between A & B (to form E), then C & D (to form F) and, finally, E & F (to form G). These operations should be accelerated using HLS pragmas, like the defined ACCEL kernel. In subdividing the operations, avoid automatic pipelining (pragma ACCEL PIPELINE auto{off}) and specify the full form of the loop to be processed without subdividing it (pragma ACCEL TILE FACTOR=auto{1}). The iterations of each main loop should run serially, not in parallel (pragma ACCEL PARALLEL FACTOR=auto{1}). The inner loops contain different pragma configurations, such as automatic pipelining (pragma ACCEL PIPELINE auto{}) and iterations running with two and thirty-two in parallel (pragma ACCEL PARALLEL FACTOR=auto{2}, pragma ACCEL PARALLEL FACTOR=auto{32}).", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a kernel function named 'kernel_3mm', in which you first create two 2D arrays 'E' and 'F' by respectively multiplying each element of arrays 'A' and 'B', and 'C' and 'D', using three nested for loops for each operation. Mark these operations to be executed linearly rather than concurrently and avoid loop flattening. Then, use another set of three nested for loops to fill 2D array 'G' by taking the product of each corresponding element in arrays 'E' and 'F'. These operations should also be processed one by one and the loop should not be flattened. For optimizing the performance, use automatic parallel factor decision making, and for specific parts, control the loop tiling and pipelining by turning them off.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{14}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware-accelerated kernel function named 'kernel_3mm' which takes 5 integers (ni, nj, nk, nl, nm) and 7 two-dimensional arrays (A[40][60], B[60][50], C[50][80], D[80][70], E[40][50], F[50][70] and G[40][70]) as parameters. Inside this function, you'll compute matrix multiplications E = A*B, F = C*D, and G = E*F using nested for-loops. For the loops, apply respective HLS pragmas.\n\nFor the first loop computing E = A*B, disable automatic pipelining, don't automatically break the loop into smaller chunks, and don't run loop iterations in parallel. Inside these loops, apply HLS pragmas for automatic pipelining, not breaking the loop into smaller chunks, and not running iterations in parallel with a specific factor of 60 for the innermost loop.\n\nFor the second loop computing F = C*D, disable automatic pipelining, don't automatically break the loop into smaller chunks, and don't run loop iterations in parallel. Inside these loops, apply HLS pragmas for flattening the pipeline, not breaking the loop into smaller chunks, and not running iterations in parallel with no specific factor for the innermost loop.\n\nFor the third loop computing G = E*F, disable automatic pipelining, don't automatically break the loop into smaller chunks, and don't run loop iterations in parallel. Inside these loops, apply HLS pragmas for disabling automatic pipelining, not breaking the loop into smaller chunks, and running the iterations in parallel with a specific factor of 7 for the outer loop and 10 for the innermost loop. \n\nRemember, all these codes should be wrapped within the HLS kernel pragma to signify that the whole function is a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a high-level synthesis (HLS) function \"kernel_3mm\" that will perform multiply-and-accumulate operations on three pairs of 2D arrays. The function signature should include parameters for array dimensions, and input arrays A,B,C,D,E,F and G. This function will be a hardware kernel for acceleration as indicated by '#pragma ACCEL kernel'. Within the function, perform three matrix multiplications as follows:\n\n1) E := A*B with iterations being carried out sequentially (not in parallel) and without automated pipelining or splitting the loop into smaller chunks. These specifications are described by '#pragma ACCEL PIPELINE auto{off}', '#pragma ACCEL TILE FACTOR=auto{1}', and '#pragma ACCEL PARALLEL FACTOR=auto{1}'.\n\n2) F := C*D with the same specifications as the first operation, except for the innermost loop, where iterations can happen in parallel with a factor of 4.\n\n3) G := E*F, again with the same specifications as the first operation, but the innermost loop this time has a parallel factor of 50.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "I need you to write a function called \"kernel_3mm\", which will be treated as a hardware kernel for acceleration. This function accepts 7 parameters, that include 5 integer parameters, and 6 double array parameters. The calculation inside this function contains three matrix multiplication operations\u2014E equals A multiplied by B, F equals C multiplied by D, and G equals E multiplied by F. The dimensions of these matrices are provided as arguments. You will be using three nested loops for each multiplication. \n\nFor the first operation, the outer two loops that are iterating over 'i' and 'j' variables shouldn't be automatically pipelined and should be processed in their original, full form without breaking into smaller chunks. They should run iterations one after the other, not in parallel. However, the innermost loop running over 'k' can parallelize up to 60 iterations. \n\nFor the second operation, perform the same restrictions for the outer two loops, but this time, the innermost loop should parallelize up to 16 iterations.\n\nFor the third operation, again, the same restrictions apply to the outer loops, but allow the inner loop to parallelize up to 32 iterations. Please maintain the original form of these loops while processing. The end goal is to optimize and accelerate this function for hardware performance.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a C function called 'kernel_3mm' which will be used as a hardware kernel for acceleration. This function should take in 9 parameters: 5 integers ni, nj, nk, nl, nm and 4 2D double arrays - E[40][50], A[40][60], B[60][50], F[50][70], C[50][80], D[80][70], G[40][70]. Don't automatically pipeline all the loops, process them in their original, full form without breaking it into smaller chunks, and run the iterations one after the other, not in parallel. Implement three main matrix multiplications. First, E = A * B. Iterate over i and j from 0 to 39 and from 0 to 49, respectively without parallelism but parallelize the innermost loop with factor 60. Second, calculate F = C * D. Iterate over i and j both from 0 to 49 without parallelism but parallelize the internal loop with factor 80. Lastly, compute G = E * F. Iterate over i and j from 0 to 39 and from 0 to 69, respectively with all computations done sequentially, but the innermost loop will run 4 iterations simultaneously.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a function named 'kernel_3mm' that accepts seven parameters; 5 integers (ni, nj, nk, nl, nm) representing the dimensions of five 2-D arrays (E, A, B, F, C, D, G) and these five arrays. This function should apply three matrix multiplications E=A*B, F=C*D, and G=E*F. For each multiplication, use three nested loops where iterations should not be run in parallel. Therefore, set \"#pragma ACCEL PARALLEL FACTOR\" to 1. For each loop, iterations should be executed serially and not be pipelined automatically, so use \"#pragma ACCEL PIPELINE\" and set it to off. Also, process the loop in its original form without dividing it into smaller chunks. Apply this by setting \"#pragma ACCEL TILE FACTOR\" to 1. For the inner loops, increase the parallel factor progressively for the second and third kernel i.e. F=C*D and G=E*F to auto{8} and auto{10} respectively. Finally, treat the function as a hardware accelerator kernel by using '#pragma ACCEL kernel' at the start of the function.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Generate a C-based HLS code that consists of a kernel function named 'kernel_3mm' with multiple parameters that includes five 2D arrays. In this kernel function, it performs three multiplication processes between the arrays. In each process, disable automatic pipelining, prevent the breakdown of the loops into smaller parts and run the iterations of the loops one after the other and not in parallel, by using the respective #pragma commands for pipeline, tile, and parallel as 'off' and  with a factor of '1'. However, in the last iterations within the second and the third multiplications, set the parallel factor to '8' and '16' respectively to allow simultaneous computations. Specifically, the code should first compute E=A*B, then F=C*D, and finally G=E*F, where A, B, C, D,E, F, and G are matrices. All values in E, F, and G should be initially set to 0.0 before the computations.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function named 'kernel_3mm' dedicated for hardware acceleration. The function, which takes integers 'ni', 'nj', 'nk', 'nl', 'nm', and six 2D arrays 'E', 'A', 'B', 'F', 'C', 'D', 'G' as parameters, performs three separate matrix multiplications: 'E' = 'A'*'B', 'F' = 'C'*'D', and 'G' = 'E'*'F'. Implement each multiplication inside a set of three nested loops. \n\nFor the first outer loop in each matrix multiplication, use automatic flattening to pipeline the loop, set the tile factor to 1 to prevent dividing the loop into smaller chunks and set the parallel factor to 1 to indicate that the iterations of the loop should not be ran in parallel. For the second inner loop, disable pipeline, use a tile factor of 1 and a parallel factor of 1. For the final inner loop, use parallel factor of 1. \n\nHowever, for the second inner loop in the second matrix multiplication, make it unique by setting parallel factor to 10 to indicate that 10 iterations of the loop should be ran at the same time.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function with the header 'void kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])'. This function should be treated as a hardware kernel for acceleration, denoted by '#pragma ACCEL kernel'. Inside the function, perform three matrix multiplications: E = A * B, F = C * D, and G = E * F. For each matrix multiplication, use three nested loops with respective pragma directives above them to control their efficiency. The i and j loops should not be automatically pipelined and should be processed in their original form without breaking them into smaller chunks or running their iterations in parallel, indicated by '#pragma ACCEL PIPELINE auto{off}', '#pragma ACCEL TILE FACTOR=auto{1}',and '#pragma ACCEL PARALLEL FACTOR=auto{1}'. The innermost k loop should run iterations in parallel, marked by  '#pragma ACCEL PARALLEL FACTOR=auto{60}' for the first multiplication, '#pragma ACCEL PARALLEL FACTOR=auto{80}' for the second, and '#pragma ACCEL PARALLEL FACTOR=auto{50}' for the last.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a function named 'kernel_3mm' that accepts nine arguments: five integers (ni, nj, nk, nl, nm) and four 2D double arrays (A, B, C, D). This function's header should be treated as a hardware kernel for acceleration. The function carries out three main matrix multiplications: E = A * B, F = C * D, and G = E * F. It implements three main loops for each of these respective operations, and within each, three nested loops. For the first loop in each operation, do not automatically pipeline the loop, preserve its full structure, and perform iterations sequentially. For the second nested loop, enable automatic pipelining, maintain the loop's full structure, and perform iterations in pairs. The final nested loop should then perform iterations in sets of 32. For the 'F = C * D' operation, when executing the second loop, flatten pipelining. Lastly, remember not to pipeline each main loop automatically, ensure their full structure is preserved, and execute iterations one after another.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a C HLS function named `kernel_3mm` with arguments containing the array dimensions (ni, nj, nk, nl, nm) and six, two-dimensional arrays named 'E', 'A', 'B', 'F', 'C', 'D', and 'G' respectively. Use the '#pragma ACCEL kernel' to denote that this function is a hardware kernel for acceleration.\n\nFirstly, calculate matrix multiplication of 'A' and 'B' storing the result in 'E' with the outer loop iterations not auto pipelined, the inner loops executed in their unbroken, full form and not parallelized. Use '#pragma ACCEL PIPELINE auto{off}', '#pragma ACCEL TILE FACTOR=auto{1}' and '#pragma ACCEL PARALLEL FACTOR=auto{1}' respectively.\n\nNext, calculate matrix multiplication of 'C' and 'D' storing the result in 'F' with the same settings for pipeline, tiling and parallel loop factor except for the deepest loop that can be partially parallelized using '#pragma ACCEL PARALLEL FACTOR=auto{4}'.\n\nFinally, calculate matrix multiplication of 'E' and 'F' storing the result in 'G' with same settings as in first operation, but use '#pragma ACCEL PARALLEL FACTOR=auto{5}' for the deepest loop to indicate deeper level of parallelization.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware accelerated function called 'kernel_3mm' that performs multiple matrix multiplications. The function should start off taking input parameters for array dimensions as well as six 2D arrays, E, A, B, F, C, D, and G. It should start with three main nested for loops that perform the calculations E = A*B, F = C*D, and G = E*F respectively. Inside each nested loop, add #pragma statements to give prescriptive execution to the HLS compiler for each process. Consider not automatically pipelining each loop using '#pragma ACCEL PIPELINE auto{off}', process each loop in its original form, not breaking it into smaller chunks by defining '#pragma ACCEL TILE FACTOR=auto{1}', and allow the iterations of each loop run one after the other, avoiding parallel processing using pragma ACCEL PARALLEL FACTOR=auto{1}. However, for the inner dimension computations of F and G, allow parallel processing with #pragma ACCEL PARALLEL FACTOR=auto{4} and #pragma ACCEL PARALLEL FACTOR=auto{25} respectively.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{25}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Develop a function called 'kernel_3mm' with the specified parameters. This function is designed for acceleration as a hardware kernel. The task within the function revolves around performing matrix multiplications with three pairs of matrices: A and B, C and D, E and F. For each multiplication process, apply three loops.\n\nThe first loop which processes 'E:=A*B' shouldn't be automatically pipelined and it should run in its original form as a whole without being divided into smaller pieces. Also, ensure the iterations are handled sequentially, not concurrently.\n\nThe second and inner loop should be processed with automatic pipelining and following the same rules previously defined. The third loop, which performs the multiplication and addition, should run 32 iterations at a time in parallel. \n\nApply similar rules for other two processes 'F:=C*D' and 'G:=E*F', but treating the subsequent item in the second loop as one large operation instead of multiple small ones. \n\nRemember, for all these processes, treat the block of codes within the function as a single, inseparable unit.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a C function called 'kernel_3mm' which is designed for hardware acceleration. This function should take the integers ni, nj, nk, nl, and nm as well as the 2D array parameters E, A, B, F, C, D, and G. First, initialize two loop counters i, and j, and a loop index k. Create three main for loops that calculate the matrix multiplications E=A*B, F=C*D, and G=E*F. Inside each of these main loops, a nested loop should be implemented that processes each element of the 2D arrays. Use the appropriate '#pragma' commands which instruct the compiler to turn off automatic loop pipelining, to process the loop in its original form, not to break it into smaller chunks of loop body code, and to carry out loop iterations one after the other not in parallel. For the innermost loop of the last two matrix calculations, allow parallel execution with up to 8 concurrent iterations.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware accelerated kernel function named 'kernel_3mm' taking 7 parameters; five 2D arrays 'E', 'A', 'B', 'F', 'C', 'D', 'G' and five integer values 'ni', 'nj', 'nk', 'nl', 'nm'. This function calculates the matrix multiplication for three sets of matrices (E = A*B, F = C*D, G = E*F). For each matrix multiplication set, encapsulate each nested iteration process with pragmas, 'ACCEL PIPELINE', 'ACCEL TILE' and 'ACCEL PARALLEL' which command the compiler to not automatically pipeline this loop, process this loop in its original form without breaking it into smaller chunks, and run the iterations of this loop in sequence, not parallel. The innermost loop of each set should have 'ACCEL PARALLEL' pragma with a factor of '1' for matrix E calculation, '80' for matrix F calculation, and '50' for matrix G calculation respectively.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function called 'kernel_3mm' that takes as arguments integer values 'ni', 'nj', 'nk', 'nl', 'nm' and six double 2-dimensional arrays 'A', 'B', 'C', 'D', 'E', 'F', 'G'. Treat this function as a hardware kernel for acceleration. \n\nInside this function, perform three sequences of matrix multiplications: E = A * B, F = C * D, and G = E * F. Each sequence will contain nested for-loops to perform the multiplication of elements. \n\nIn the first sequence, for each matrix E element, calculate it by multiplying corresponding elements in matrix A and B and add them using loop with not automatic pipelining, a process in its original, full form without breaking it into smaller chunks, and running iterations one after the other, not in parallel. Then process the innermost loop by parallelizing it to run 60 iterations simultaneously. \n\nIn the second sequence, for each matrix F element, calculate it by multiplying corresponding elements in matrix C and D and add them using the same process from E, but the innermost loop should run 16 iterations simultaneously. \n\nIn the third sequence, for each matrix G element, calculate it by multiplying corresponding elements in matrix E and F and add them using the same process from E, but the outer loop should run 8 iterations simultaneously, and the innermost loop should run 2 iterations simultaneously.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a C function named \"kernel_3mm\" that takes 7 arguments: 5 integers (ni, nj, nk, nl, nm) and 6 2D double arrays (E[40][50], A[40][60], B[60][50], F[50][70], C[50][80], D[80][70], G[40][70]). This function represents a hardware kernel for acceleration so use '#pragma ACCEL kernel'. The function will perform three matrix multiplications (A*B, C*D, E*F) and store the results in E, F, and G respectively.\n\nFor each of these operations, there are nested for-loops. Use '#pragma ACCEL PIPELINE auto{off}' to prevent automatic pipeline, '#pragma ACCEL TILE FACTOR=auto{1}' to maintain the original loop without breaking it into smaller chunks, and '#pragma ACCEL PARALLEL FACTOR=auto{1}' to ensure that loop iterations are executed one after the other, not in parallel.\n\nAdditionally, in the inner loop iteration of the second and third multiplication operation, apply a different setting for '#pragma ACCEL PARALLEL FACTOR', which is 8 and 32 respectively, to execute loop iterations in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a functional kernel called \"kernel_3mm\" with parameters \"int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70]\". Disable the pipelining and processing iterations of loops in parallel by setting #pragma ACCEL PIPELINE and #pragma ACCEL PARALLEL to auto{off} and auto{1} respectively. Also prevent breaking the loop into smaller chunks by setting #pragma ACCEL TILE FACTOR to auto{1}. In the first loop, compute the matrix multiplication of A and B and store the result in matrix E. Repeat the same settings and process for the second loop where matrix multiplication of C and D is computed and stored in matrix F. Conduct the same steps again for the third loop, but enable the flattening of the loop hierarchy using #pragma ACCEL PIPELINE auto{flatten}, perform the matrix multiplication of E and F, and store the result in matrix G.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware kernel function 'kernel_3mm' that takes in nine parameters: five integers 'ni', 'nj', 'nk', 'nl', 'nm' and four 2D arrays 'E', 'A', 'B', 'F', 'C', 'D', 'G'. This function then performs matrix multiplication operations namely: E = A * B, F = C * D, and G = E * F. In the matrix multiplication operations, do not automatically pipeline the loops, treat each loop in its original form without splitting it into smaller chunks, and process the iterations of the loops one after the other, not in parallel. Specifically, follow this for both the 'i' iteration and 'j' iteration loops. In the 'k' iteration for the matrix multiplication, allow two iterations to be processed in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware accelerated kernel function called \"kernel_3mm\". This function takes as input, the number of rows and columns of different matrices, A, B, E, C, D, F, G, and performs matrix multiplication in three stages. First, it multiplies matrices A and B to obtain E; then it multiplies C and D to obtain F, and finally, uses E and F to calculate G. During each stage, don't allow any loop to be pipelined, make sure the loops are executed in their entirety, not being broken into smaller parts, and process each loop one iteration after the another, not in parallel. However, use parallelism of 60 iterations when calculating E and F matrices, and use parallelism of 16 iterations when calculating G matrix. Conclude both inner and outer loops with similar pragmas.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a hardware kernel function `kernel_3mm`, which accepts nine parameters: five integers (`ni,` `nj,` `nk,` `nl,` `nm`) and four double multi-dimensional arrays (`E[40][50],` `A[40][60],` `B[60][50]`, `F[50][70],` `C[50][80],` `D[80][70],` `G[40][70]`). Inside the function, perform three major operations: `E := A*B,` `F := C*D,` and `G := E*F.` Each of these operations is achieved with three nested for-loops. For each loop in each operation, set pragma values to control the pipeline, parallelism and tiling. Specifically, for each outer loop turn off automatic pipeline, set tile factor to 1 and parallel factor to auto 1. For each middle loop process in its original form without automatically breaking it into smaller chunks. And for the inner loop of first operation set parallel factor to auto 16, for the second operation set parallel factor to auto 32, and for the third operation set parallel factor to auto 50 to achieve different levels of parallel processing.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "The HLS code is written in C with the function named 'kernel_3mm', which performs three successive matrix multiplications: E = A*B, F = C*D, then G = E*F. The function inputs include the following parameters and arrays: five integers ni, nj, nk, nl, nm, and six double arrays: E[40][50], A[40][60], B[60][50], F[50][70], C[50][80], D[80][70], G[40][70].\n\nThe code has parallel for-loops without the automatic pipelining and original form process. Use '#pragma ACCEL PIPELINE auto{off}', '#pragma ACCEL TILE FACTOR=auto{1}', and '#pragma ACCEL PARALLEL FACTOR=auto{1}' at the beginning of each for-loop to indicate these respective actions on the loops.\n\nFor the innermost for-loop within the A*B and E*F multiplications, use '#pragma ACCEL PARALLEL FACTOR=auto{60}' and '#pragma ACCEL PARALLEL FACTOR=auto{10}' respectively to process the iterations in parallel. For the innermost loop in the C*D multiplication, use '#pragma ACCEL PIPELINE auto{flatten}' and '#pragma ACCEL PARALLEL FACTOR=auto{1}' to run the loop iterations one after the other in its original form without transforming nested loops into a single loop.\n\nFor hardware acceleration, use '#pragma ACCEL kernel'.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a hardware accelerated kernel function named 'kernel_3mm' in C language. This function takes seven parameters, five dimensions (ni, nj, nk, nl, nm) and two matrices (E and G). Inside this function, declare two variables (i and j). The function will execute three major operations:\n\n1) Multiply matrices A and B to get the result stored in matrix E. In this segment, use the pragma values 'PIPELINE auto{off}', 'TILE FACTOR=auto{1}', and 'PARALLEL FACTOR=auto{1}' for the first level loop that runs 40 times ('i' from 0 to 40). Similarly, for the second level loop running 50 times ('j' from 0 to 50), use 'PIPELINE auto{}', 'TILE FACTOR=auto{1}', and 'PARALLEL FACTOR=auto{2}'. For the innermost loop running 60 times ('k' from 0 to 60), set 'PARALLEL FACTOR=auto{32}'.\n\n2) Multiply matrices C and D to get the result stored in matrix F. Use the same pragma values for the first level loop as in the first operation, but for its second level loop that runs 70 times ('j' from 0 to 70), use 'PIPELINE auto{flatten}', 'TILE FACTOR=auto{1}', and 'PARALLEL FACTOR=auto{4}'. For the innermost loop running 80 times ('k' from 0 to 80), set 'PARALLEL FACTOR=auto{1}'.\n\n3) Multiply matrices E and F to get the result stored in matrix G, using similar pragma values to the first operation.\n\nRemember to consider pragma values application to differentiate between loop levels and ensure efficiency in your hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "In the function `kernel_3mm` with parameters `ni`, `nj`, `nk`, `nl`, `nm` and two-dimensional arrays `E`, `A`, `B`, `F`, `C`, `D`, and `G`, treat the function as a hardware kernel for acceleration.\n\nThe program is divided into three sections.\n\nIn the first section labeled \"E := A*B\", we have a triple nested loop to compute the matrix multiplication of `A` and `B`, storing the result in `E`. For each loop, do not automatically pipeline it, process it in its original, full form without breaking it into smaller chunks, and run the iterations one after the other, not in parallel.\n\nIn the second section labeled \"F := C*D\", the operation is the same as the first section, but we are computing the multiplication of `C` and `D`, storing the result in `F`. The only difference is the for the innermost loop of the second section, I want the iterations to be explored in parallel with a factor of 8.\n\nIn the third section labeled \"G := E*F\", this is again similar to the first and second sections: the product of the arrays `E` and `F` is stored in the array `G`. For the innermost loop of the third section, parallelize the iterations with a factor of 2.\n\nEnd the function after this.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a HLS(C) function 'kernel_3mm' that treats the function as a hardware kernel for acceleration(#pragma ACCEL kernel). The function receives several integers(ni, nj, nk, nl, nm) and multiple 2-dimensional arrays(E, A, B, F, C, D, G) as parameters.\n\nInside the function body, create three nested loop constructs for matrix multiplication where each one is indicated by a corresponding matrix operation E = A*B, F = C*D, G = E*F.\n\nFor each loop construct, ensure that the loops are not automatically pipelined(#pragma ACCEL PIPELINE auto{off}), the loops are processed in its original full form without breaking it into smaller chunks(#pragma ACCEL TILE FACTOR=auto{1}), and the iterations of the loop run one after the other, not in parallel(#pragma ACCEL PARALLEL FACTOR=auto{1}) at the start.\n\nFor the innermost loops of the second and third constructs, switch to executing the loop iterations in parallel(#pragma ACCEL PARALLEL FACTOR=auto{8} for the second and #pragma ACCEL PARALLEL FACTOR=auto{5} for the third), where each loop multiplies two elements from the input matrices and adds the result to the corresponding element in E, F or G matrices or set the element in E, F or G to 0.0 if it's the first iteration of the loop.\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Instruct the generator to create a kernel function named 'kernel_3mm'. The function will take in 5 integers (ni, nj, nk, nl, nm) and 7 two-dimensional arrays (E, A, B, F, C, D, G) with sizes 40x50, 40x60, 60x50, 50x70, 50x80, 80x70, and 40x70 respectively.\n\nThe task of the function is organized into three major sections:\n  i. In the first section, use a three-tiered loop structure to multiply matrices A and B and store the result in matrix E. For the outermost loop, use '#pragma ACCEL PIPELINE auto', '#pragma ACCEL TILE FACTOR=auto{1}', and '#pragma ACCEL PARALLEL FACTOR=auto{1}' to indicate that loop iterations should not be pipelined and should run in the original order. For the intermediate and inner loops, use '#pragma ACCEL PIPELINE auto{off}', '#pragma ACCEL TILE FACTOR=auto{1}', and '#pragma ACCEL PARALLEL FACTOR=auto{1}' to ensure the same sequential execution.\n  \n  ii. In the second section, a similar three-tiered loop structure is used to multiply matrix C with D and store the result in F. Similar pragma clauses are used for the outermost and intermediate loops, but for the inner loop, use '#pragma ACCEL PARALLEL FACTOR=auto{32}' to denote parallelism with a factor of 32.\n  \n  iii. Finally, in the third section, another three-tiered loop structure is used to multiply matrix E with F and store the result in G. For these loops, use the same pragma clauses as the first section to prevent parallel execution and maintain the original order.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a hardware accelerated function called kernel_3mm that accepts 7 parameters: five integers namely ni, nj, nk, nl, and nm; and six two-dimensional arrays of doubles, namely E, A, B, F, C, D, and G. Configure the function to not automatically pipeline or parallelize the processing of the loops and instead handle the iterations on a serial basis, as well as not to break down the loop into smaller chunks. This is achieved with '#pragma ACCEL PIPELINE auto{off}', '#pragma ACCEL PARALLEL FACTOR=auto{1}', and '#pragma ACCEL TILE FACTOR=auto{1}' directives respectively.\n\nWithin the function, perform the following operations: \n\nFirst compute the product of arrays A and B and assign it to array E. This is a nested loop operation that also needs to be performed in serial format i.e. one iteration at a time, and without breaking the loop into smaller chunks. \n\nSimilar procedure is to be followed for computing the product of arrays C and D and storing it in array F, but this time allowing iterations to be processed in parallel, 8 at a time, with the directive '#pragma ACCEL PARALLEL FACTOR=auto{8}'. \n\nFinally, multiply arrays E and F and store the result in array G using a similar nested loop operation as above but this time allowing iterations to be processed in parallel, 25 at a time using the directive '#pragma ACCEL PARALLEL FACTOR=auto{25}'. \n\nRemember to not enable automatic pipelining, parallelization or chunking of loop for these operations.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{25}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a HLS accelerated kernel function named 'kernel_3mm'. This function should take as inputs: five integers (ni, nj, nk, nl, nm) and seven two-dimensional matrices (E[40][50], A[40][60], B[60][50], F[50][70], C[50][80], D[80][70], G[40][70]). Implement three operations: (1) multiply matrices A and B and store results in E, (2) multiply matrices C and D and store results in F, and (3) multiply matrices E and F and store results in G. \n\nFor each operation, ensure that it happens in sequential manner using following accelerations pragmas for each loop: turn off the automatic pipelining, don't break the loop into smaller chunks ('#pragma ACCEL TILE FACTOR=auto{1}') and ensure iterations run one after the other, not in parallel ('#pragma ACCEL PARALLEL FACTOR=auto{1}') for the outmost loops. For inner loop during first and second operation, use only one operation in parallel ('#pragma ACCEL PARALLEL FACTOR=auto{1}'), and for inner loop in last operation run 32 operations in parallel ('#pragma ACCEL PARALLEL FACTOR=auto{32}').\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write an HLS kernel function named 'kernel_3mm' that performs triple matrix multiplication. Accept nine arguments: five integer variables 'ni', 'nj', 'nk', 'nl', 'nm' and four 2D double arrays 'E', 'A', 'B', 'F', 'C', 'D', 'G'. \n\nIn the function, first calculate the product of matrices 'A' and 'B' and store it in 'E'. Use '#pragma ACCEL PIPELINE auto{off}', '#pragma ACCEL TILE FACTOR=auto{1}' and '#pragma ACCEL PARALLEL FACTOR=auto{1}' to manage the loops for full computations.\n\nNext, calculate the product of matrices 'C' and 'D', storing the result in 'F'. Again handle the loops with '#pragma ACCEL PIPELINE auto{flatten}', '#pragma ACCEL TILE FACTOR=auto{1}' and '#pragma ACCEL PARALLEL FACTOR=auto{1}'.\n\nFinally, compute the product of matrices 'E' and 'F' and store in 'G'. Use '#pragma ACCEL PARALLEL FACTOR=auto{10}' to adjust parallelism factor.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a HLS kernel function named 'kernel_3mm' that takes seven 2D arrays ('E', 'A', 'B', 'F', 'C', 'D', 'G') and five integers ('ni', 'nj', 'nk', 'nl', 'nm') as input. The function will perform matrix multiplications in three steps: multiply 'A' and 'B' to update 'E', then multiply 'C' and 'D' to update 'F', and finally multiply 'E' and 'F' to update 'G'. \n\nIn terms of optimization, don't automatically pipeline all the loops, process all loops in their original, full form without breaking them into smaller chunks, and run the iterations of main loops one after the other, not in parallel. \n\nHowever, for the innermost loops in the first section, run the iterations in parallel with a factor of two, and in the last section run the iterations in parallel with a factor of five. Only in the second section, flatten the pipeline stages of the inner loop while keeping all iterations in order but not running in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a kernel function named \"kernel_3mm\" that receives 7 parameters, which are 5 integers (ni,nj,nk,nl,nm), and 2 double matrices (E, A, B, F, C, D, G). In this function, we're performing three matrix multiplications operations: E = A*B, F = C*D, G = E*F. \n\nFor each step, use three nested loops iterating over different ranges based on their corresponding arguments. For all loops, switch off automatic pipelining, hinder the loops breaking into smaller chunks, and run the iterations one after another, not in parallel by declaring three pragma values: \"#pragma ACCEL PIPELINE auto{off}\", \"#pragma ACCEL TILE FACTOR=auto{1}\", and \"#pragma ACCEL PARALLEL FACTOR=auto{1}\". \n\nFor the deepest loop in each level, use pragma \"#pragma ACCEL PARALLEL FACTOR=auto{2}\"\" in the first operation, and \"#pragma ACCEL PARALLEL FACTOR=auto{1}\" for the rest. In the last operation (G = E*F), while iterating over matrices E and F, treat the loop in its original, full form without breaking it down by declaring \"#pragma ACCEL PIPELINE auto{flatten}\"", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function titled 'kernel_3mm' with parameters ni, nj, nk, nl, nm, and matrices E, A, B, F, C, D, G. This function will be treated as a hardware kernel for acceleration. Inside the function, declare three integer variables: i, j, and k. \n\nFirstly, compute the product of matrices A and B and store it in E. This is done through a triple nested loop structure, with three for loops. While processing these loops, do not automatically pipeline the loops but process them in their original full form, not breaking them into smaller chunks, and run the iterations of the loops sequentially instead of in parallel. \n\nNext, compute the product of matrices C and D, and store the result in F. Use the same loop structure and pragma restrictions as earlier, with the exception that for the inner-most loop, you can opt to run iterations in parallel automatically.\n\nFinally, compute the product of matrices E and F and save it in matrix G, also use the same loop structure and pragma restrictions as the first calculation (A*B).", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a C function named 'kernel_3mm' in which initialize the two-dimensional arrays 'E', 'F' and 'G'. The function is aimed to be a hardware kernel for acceleration. Within this function, there are three main steps:\n\n1. Compute the product of matrices 'A' and 'B' and store the result in 'E'. Disable the automatic pipelining, and process this loop in its original, full form without breaking it into smaller chunks. The iterations of these loops should not run in parallel. \n\n2. Then, compute the product of matrices 'C' and 'D' and store the result in 'F'. Turn off the automatic pipelining but treat multiple iterations as an entity to optimize performance.\n\n3. Lastly, compute the product of matrices 'E' and 'F' which you got from the above steps and store the final result in 'G'. This loop should also be executed in sequence and maintain its original size for each tile. All these processes should close the automatic pipelining.\n\nAlso, make sure the third computing step for each array multiplies each element of a row from 'E' or 'F' by each element of a column from 'B', 'D' or 'F' respectively and adds it to 'G'.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create an HLS-accelerated function called 'kernel_3mm' which takes in multi-dimensional arrays and their sizes as parameters.  The script contains three main matrix multiplication sections: E = A * B, F = C * D, and G = E * F. \n\nIn the beginning of each section, put '#pragma ACCEL PIPELINE auto{off}' to prevent automatic pipelining and use '#pragma ACCEL TILE FACTOR=auto{1}' to process loops in their original, full form without breaking them into smaller chunks, then follow with '#pragma ACCEL PARALLEL FACTOR=auto{1}' to execute loop iterations sequentially.\n\nIn the nested loops where the computation of E[i][j], F[i][j], and G[i][j] is performed separately, we turn off automatic pipelining and keep the loop unpartitioned but specify different parallel factor using 'ACCEL PARALLEL FACTOR': 'auto{60}' for computation of E[i][j], 'auto{80}' for F[i][j] calculation, and 'auto{1}' for G[i][j] calculation to perform iterations of the innermost loop in parallel, depending on the size of involved arrays. \n\nFinally, in the loop that calculates G[i][j] use '#pragma ACCEL PIPELINE auto{flatten}' to flatten the nested loop structure into a single-level loop and '#pragma ACCEL PARALLEL FACTOR=auto{8}' to execute 8 iterations of the loop in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware-accelerated kernel function in C named 'kernel_3mm' accepting parameters of five integers (ni, nj, nk, nl, nm) and six double 2D arrays (E, A, B, F, C, D, G). Treat each nested loop for calculation as a full process that is not to be divided ('pragma ACCEL TILE FACTOR=1') and are executed sequentially, not in parallel ('pragma ACCEL PARALLEL FACTOR=1'). The first loop calculates E as the multiplication of A and B. The second loop calculates F as the multiplication of C and D. The final loop calculates G as the multiplication of E and F. For each loop sequence, do not automatically optimize their processes ('pragma ACCEL PIPELINE auto{off}'). However, some parts of the loop for F and G calculations can be run in parallel ('pragma ACCEL PARALLEL FACTOR') with values 8 and 50 respectively.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Design an accelerator kernel function named 'kernel_3mm' intended for matrix multiplication operation. The function must take in nine arguments: five whole numbers named 'ni', 'nj', 'nk', 'nl', and 'nm', and four 2D double arrays named 'A', 'B', 'C', 'D', 'E', 'F' and 'G'. The process of this function involves three main steps: \n\n1) Compute the matrix multiplication between 'A' and 'B' arrays and assign the result to 'E' array. In this loop, do not automatically pipeline, process this loop in its original, full form without breaking it into smaller chunks and run the iterations of this loop one after the other, not in parallel.\n\n2) Second, compute the multiplication between arrays 'C' and 'D' and save the result into array 'F'. In this loop, again no need to automatically apply pipeline optimization and treat the loop as a whole unit and not as separate parts, but let all iterations run together, not in sequence.\n\n3) Finally, calculate the product between 'E' and 'F' arrays and store the outcome to array 'G'. In this section as well, do not auto pipeline this loop but manage it in its original full form without any partition and allow the iterations to run one by one not parallelly.\n\nBear in mind that for innermost portions of each step, we will keep the pipeline setting turned off, maintain the loop as a whole and do not execute it in parallel except for the first step where we might run iterations in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function called 'kernel_3mm' that will function as a hardware kernel for acceleration. This function takes in 7 arguments, 5 integers (ni, nj, nk, nl, nm) representing the length of the matrix and 6 2Dt arrays (E[40][50], A[40][60], B[60][50], F[50][70], C[50][80], D[80][70], G[40][70]). In this function, three multiplication operations will be performed on different sets of these arrays, utilizing nested loops to iterate through the arrays' index positions and compute the products. Specifically, array 'E' will be computed by 'A' multiplied by 'B', array 'F' by 'C' & 'D', and array 'G' by 'E' & 'F'. Each of these operations will be handled in their original sequence without pipelining or breaking into smaller groups. However, the inner-most nested loop in each operation will be set to run iterations in parallel with auto-determined factors of 30, 20, and 50 for three operations respectively.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a HLS kernel function in C called `kernel_3mm` that accepts various integer parameters (namely ni, nj, nk, nl, nm) and 7 arrays (namely E, A, B, F, C, D, G). Initially, the ACCEL pragma commands should specify not to pipeline all three main loops, to process the entire loops without breaking into smaller parts, and to execute iterations sequentially. Meanwhile, for the E, F, G calculations, initiate E[i][j], F[i][j], G[i][j] to 0.00 then utilize the respective innermost loops to iterate via k and accumulate the product of respective indices A[i][k] & B[k][j], C[i][k] & D[k][j], E[i][k] & F[k][j] to E[i][j], F[i][j], G[i][j] respectively. This inner loop should have more parallel iterations (with auto factor 20, 32, 50 respectively) than the sequential ones set for the outer loops.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a kernel, called 'kernel_3mm' that performs matrix multiplications between several 2D arrays. The function takes in five dimensions as input (ni, nj, nk, nl, nm) and seven 2D double arrays (E[40][50], A[40][60], B[60][50], F[50][70], C[50][80], D[80][70], G[40][70]).\n\nThere are three sections to this code: \n\n1. Firstly, create an outer loop for 'i' ranging from 0-40, with no automatic pipelining, processing the full loop without breaking it into smaller chunks and running iterations serially rather than parallelly. Inside this loop, initialize a nested loop for 'j' 0-50, again with the same directives. Then, initialize another nested loop for 'k' from 0-60 to perform a multiplication operation between elements of 2D arrays A and B and store the result in array E. \n\n2. Secondly, create another outer loop for 'i' from 0-50, again not automatically pipelined, full-form processed and executed sequentially. Inside this loop, initialize a nested loop for 'j' from 0-70. Then, start another nested loop for 'k' 0-80 intended to multiply elements of 2D arrays C and D storing the result in array F.\n\n3. Lastly, create a last outer loop for 'i', again with the same special instructions as above, ranging from 0 to 40. Inside this loop, initialize a nested loop for 'j' from 0 to 70. Finally, initialize another nested loop for 'k' from 0 to 50 to multiplies the respective elements of arrays E and F and stores the result in array G.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a C function called \"kernel_3mm\" that's declared as a hardware-accelerated kernel. The function should take multiple integer parameters and matrices of double precision values ('A', 'B', 'C', 'D', 'E', 'F', and 'G') as its parameters. The function should calculate matrix multiplication for 'E', which is the product of 'A' and 'B'; for 'F', the product of 'C' and 'D'; and for 'G', the product of 'E' and 'F'. \n\nFor each major block of operations ('E', 'F', and 'G'), set the compiler directives to not automatically pipeline this loop, to process the loop in its original, full form without breaking it into smaller chunks, and to run the iterations of the loop one after the other, not in parallel. Follow this for the outer loops i and j.\n\nHowever, for the innermost loops which perform computation (k loop), let the compiler decide how many iterations of the loop to run concurrently, with a hint that it can experiment up-to doing 20 iterations in parallel for 'E' and 'F' computation and 50 iterations in parallel for 'G' computation.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a function named 'kernel_3mm' which is treated as a hardware kernel for acceleration. The function takes nine parameters, five integers 'ni', 'nj', 'nk', 'nl', 'nm' and four 2D double arrays 'E', 'A', 'B', 'F', 'C', 'D', 'G' of sizes [40][50], [40][60], [60][50], [50][70], [50][80], [80][70] and [40][70] respectively. \n\nThe function does three major calculations. First, it calculates array 'E' as the product of arrays 'A' and 'B'. Second, it calculates array 'F' as the product of arrays 'C' and 'D'. Lastly, it calculates array 'G' as the product of the previously calculated arrays 'E' and 'F'. \n\nIn each major calculation block, run each for-loop iteration one after another, not in parallel via '#pragma ACCEL PARALLEL FACTOR=auto{1}'. Also, make sure to not automatically pipeline the loops using '#pragma ACCEL PIPELINE auto{off}' and process each loop in its original full form without breaking it into smaller chunks using '#pragma ACCEL TILE FACTOR=auto{1}'.\n\nIn the final inner nested loops recalculating arrays 'F' and 'G', set the #pragma ACCEL PARALLEL FACTOR=auto{4} which would allow four iterations of a loop to be executed concurrently.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a function named \"kernel_3mm\" that accepts nine parameters: five integers (ni, nj, nk, nl, nm) and four double 2D arrays (E[40][50], A[40][60], B[60][50], F[50][70], C[50][80], D[80][70], G[40][70]). Within this function, do not automatically parallelize or break down any of the loops. \n\nFirst, calculate the matrix multiplication of A and B, storing the result in the E matrix. Start by setting every cell of E to zero, then process the entries in a double nested loop where each element E[i][j] is populated by summing up the multiplication of corresponding elements from A and B arrays for every row 'i' and column 'j'. \n\nRepeat a similar process to calculate the matrix multiplication of C and D, storing the result in F matrix. \n\nFinally, calculate the matrix multiplication of E and F, storing the result in the G matrix. For each of these operations, ensure that the HLS code will initiate and run each loop one after the other, not in parallel. And use the '#pragma ACCEL kernel' directive to annotate this function to let the compiler know it should be treated as a hardware acceleration kernel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function called 'kernel_3mm'. This function will expect several parameters: five integer values, namely 'ni', 'nj', 'nk', 'nl', 'nm', as well as six 2D arrays of doubles named 'E', 'A', 'B', 'F', 'C', 'D', and 'G' with predefined sizes. Start by indicating that the function will be a hardware acceleration kernel using '#pragma ACCEL kernel'. \n\nThe core functionality of this function is matrix multiplication. First, we conduct the operation E = A * B. We don't want to pipeline the loop automatically, or tile or parallelize it at a size larger than one element for the first two 'for' loops. Hence, use the pragmas 'ACCEL PIPELINE auto{off}', 'ACCEL TILE FACTOR=auto{1}', and 'ACCEL PARALLEL FACTOR=auto{1}' for both loops. In the innermost loop, however, allow parallelism to a factor of 'auto{16}', using 'ACCEL PARALLEL FACTOR=auto{16}'.\n\nNext, perform the operation F = C * D in a similar manner. Again, the first two loops will not be pipelined, tiled or parallelized beyond an element size of one with their corresponding pragmas. The third loop will be parallelized to a factor of 'auto{32}' using 'ACCEL PARALLEL FACTOR=auto{32}'.\n\nFinally, execute the operation G = E * F. Similar to the previous blocks, the two outer loops won't be pipelined, tiled or parallelized beyond one element size with the same pragmas. The innermost loop allows a parallelism to a factor of 'auto{50}', with the pragma 'ACCEL PARALLEL FACTOR=auto{50}'.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function named `kernel_3mm` with eight parameters: five integers`ni`, `nj`, `nk`, `nl`, `nm` and six 2D arrays `E`, `A`, `B`, `F`, `C`, `D`, `G`. Inside this function, you will write three consecutive matrix multiplication processes. Prior to each process, use three `pragma ACCEL` directives: 'PIPELINE' set to 'off', 'TILE FACTOR' set to 1, and 'PARALLEL FACTOR' set to 1 to disable pipelining and parallelism between loop iterations and prevent breaking the loop into smaller chunks. For the first process, compute the product of matrix `A` and `B` and store it in matrix `E`. Then, in the second process, compute the product of matrix `C` and `D` and store it in matrix `F`. In the final process, compute the product of matrix `E` and `F` and store it in matrix `G`. During the element-wise multiplication inside each process, re-enable parallelism with 'PARALLEL FACTOR' set to 60, 80, and 25 respectively. Lastly, specify the entire function as a hardware acceleration kernel using the `pragma ACCEL kernel` directive.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{25}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "This is a function for matrix multiplication in high performance computing using hardware acceleration. Name the function as 'kernel_3mm'. The input matrices are A, B, C, D, E, F, G of different dimensions defined by integers ni, nj, nk, nl, nm. \n\nThe operation is performed in 3 parts.\n\n- First, set E as the result of A multiplied by B. For this, we'll use \"#pragma ACCEL PIPELINE auto{off}\", \"#pragma ACCEL TILE FACTOR=auto{1}\", and \"#pragma ACCEL PARALLEL FACTOR=auto{1}\". Loop through each element of A, multiply it with the corresponding element in B, and add it to E. \n\n- Then do the same for C and D, setting F as the result of C multiplied by D using \"#pragma ACCEL PIPELINE auto{flatten}\". \n\n- Then, calculate G as the result of E multiplied by F using the same pragmas as in the first step except for \"#pragma ACCEL PARALLEL FACTOR=auto{8}\" in the innermost loop. \n\nIn every loop, set the running sum variable (E[i][j], F[i][j], G[i][j]) to 0.0 before operating.\n\nNote that, all operations are not pipelined and parallelism factor is set to auto in all pragma parallel factors. However, the parallel factor equals 2 in the third innermost loop when we set E[i][j] and 8 in the last innermost loop when we operate on G[I][j].", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware-accelerated kernel function named 'kernel_3mm' in C, which takes in seven two-dimensional arrays (E, A, B, F, C, D, and G) with different dimensions and five integers (ni, nj, nk, nl, nm). This function performs matrix multiplications. First, calculate matrix E as the product of A and B, then calculate matrix F as the product of C and D, and finally, calculate matrix G as the product of E and F. In each multiplication operation, initialize all elements of the result matrix to 0, and then accumulate the products of the corresponding elements of the input matrices.\n\nFor each loop in this function use three pragma values: \n- Turn off auto pipelining with '#pragma ACCEL PIPELINE auto{off}'\n- Prevent the loop from being divided into smaller chunks using '#pragma ACCEL TILE FACTOR=auto{1}'\n- Limit the number of concurrent loop iterations explicitly setting the parallel factor via '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n\nFor the inner-most loops in the calculations of 'E', 'F', and 'G', set the parallel factor to 6, 20, and 8 respectively using '#pragma ACCEL PARALLEL FACTOR=auto{<factor>}' to run several iterations in parallel for gaining performance benefits. \n\nThe function should be treated as a hardware kernel for acceleration as indicated by '#pragma ACCEL kernel'.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Provide an implementation for the function 'kernel_3mm' which accepts five integer and six double 2D array parameters. Declare this function as a hardware kernel for acceleration. In this function, perform three major operations: \nFirstly, compute the matrix multiplication of 'A' and 'B' and store the result in 'E' - loop iterations here should not be pipelined or split into smaller chunks and should not run in parallel, but the innermost loop operation (multiplication and addition) should run in a parallelized manner up to a factor of 60. \nSecondly, compute the matrix multiplication of 'C' and 'D' and store the result in 'F' - again keep the loop iterations in the original sequence and run them one after the other, not in parallel; however, ensure the innermost loop operation is parallelized with a factor of 80. \nFinally, multiply matrix 'E' and 'F' and store the result in 'G' - in this step, do not automatically pipeline the loops, but the inner loop can be flattened for pipeline operations. The loops should not be split and the outer loops iterations should run in parallel up to a factor of 8 while the innermost loop operation should run serially.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a HLS C code using the function header `kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])` inside a `#pragma ACCEL kernel` that will help hardware compilation of the function. The code performs two level nested loops first to compute the product of matrix A and B by adding up the multiplication of corresponding elements and storing it in matrix E. Then it runs the two level nested loops to compute the product of matrix C and D in a similar fashion storing the resulting matrix in F. Finally, it computes the product of matrix E and F through nested loops to produce matrix G. For all three main loops and their nested loops, ensure with `#pragma ACCEL PIPELINE auto{off}` that the loops are not automatically pipelined, use `#pragma ACCEL TILE FACTOR=auto{1}` to process loops in their original full form without breaking it into smaller chunks and `#pragma ACCEL PARALLEL FACTOR=auto{1}` indicating that iterations of loops should run one after the other, not in parallel. In F matrix calculation, use `#pragma ACCEL PARALLEL FACTOR=auto{8}` to allow 8 iterations to run in parallel in the innermost loop. But in the pipeline pragma for the last main loop, use the option `{flatten}` to allow loop flattening if possible.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Implement a kernel function named 'kernel_3mm' that takes nine parameters: five integer variables 'ni', 'nj', 'nk', 'nl', and 'nm', and four multi-dimensional arrays 'E', 'A', 'B', 'C', 'D', 'F' and 'G'. This function will perform three matrix multiplications and store results in arrays 'E', 'F', and 'G'. \n\nStart off by declaring the function and implementing the three matrix multiplications without any loop optimizations. \nFirst, compute the multiplication of matrices 'A' and 'B' and store the result in matrix 'E'. Declare loop variables and process arrays with sizes (40x50), (40x60) and (60x50) sequentially and in original form without making any modifications or optimizing. \n\nNext, perform multiplication of matrices 'C' and 'D' and store the result in matrix 'F'. Similarly, process arrays with sizes (50x70), (50x80) and (80x70) sequentially and in original form without optimization. However, for 'F[i][j]', explicitly instruct the sequencer not to automatically pipeline iterations or to retile them, and to execute iterations in their original, full form in parallel.\n \nFinally, carry out the multiplication of matrices 'E' and 'F' and store the output in matrix 'G'. Here too, process arrays with sizes (40x70), (40x50) and (50x70) sequentially and in original form without making any modifications or optimizing. \n\nRemember to use pipeline with 'off' setting for sequential processing, tile factor of '1' for full form looping, and parallel factor of '1' for serial looping in all three sections within the ACCEL pragma settings.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a 'kernel_3mm' function for FPGA acceleration that accepts integer parameters ni, nj, nk, nl, nm and multi-dimensional array parameters E, A, B, F, C, D, G. The function performs three matrix multiplications in sequence. For each multiplication, do not automatically pipeline the loops 'i' and 'j' and process them in their original form without breaking them into smaller chunks. Run the 'i' and 'j' iterations one after the other, not in parallel. \n\nFor the inner loop 'k' in the first two multiplications, ensure its iterations are also executed one after another, not in parallel. But for the inner loop 'k' in the last multiplication, set 'k' to run with a degree of parallelism of 50 iterations at the same time.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a function named 'kernel_3mm', which should be treated as a hardware kernel for acceleration. This function receives nine arguments - five integers namely ni, nj, nk, nl, nm, and four 2D matrices namely E, A, B, F, C, D and G respectively.\n\nWithin this function, apply a series of matrix multiplications. First, initialize a nested 'for' loop where 'i' ranges from 0 to 40 and 'j' ranges from 0 to 50. Configure so that loop iterations aren't automatically pipelined, run in their original full form without breaking into smaller chunks and process sequentially. Within this, a loop where 'k' ranges from 0 to 60 should have the same configurations as well. Calculations should result in the matrix 'E' being equal to the product of 'A' and 'B' matrices.\n\nNext, follow similar instructions for matrices 'F' with the multiplication of matrices 'C' and 'D'. However, 'i' should range from 0 to 50 and 'j' from 0 to 70 while 'k' ranges from 0 to 80.\n\nFinally, perform the multiplication process between matrices 'E' and 'F' with the result stored in 'G'. Let 'i' range from 0 to 40 and 'j' range from 0 to 70, turning the automatic pipeline for this outer loop off. However, 'k' should range from 0 to 50 and note to process up to seven iterations of the intermediary 'for' loop in parallel.\n\nRemember that despite any changes, all iterations of the most nested loop for each matrix multiplication should be processed in its full form without breaking it into smaller chunks. Ensure that they are not automatically pipelined and run sequentially except for the final multiplicative operation where you should allow up to eight iterations to run in parallel. Please keep in mind that comments denoted by \"//\" have been intentionally omitted from this explanation for brevity.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a function called \"kernel_3mm\" with parameters for five integer values and seven two-dimensional arrays of double precision. This function is intended to be treated as a hardware kernel for acceleration. The code body contains three loops, each calculating different multiplications of two matrices. You must ensure that these loops are processed in their original form without breaking them down into smaller chunks and that their iterations are executed sequentially and not in parallel.\n\nIn each loop, you will calculate the multiplication of two matrices by initializing a resulting matrix to 0.0, and for each element of the two input matrices, you will multiply them together and add it to the corresponding value in the result matrix. For the first loop, set the ACCEL PARALLEL FACTOR to sequentially process each iteration, while for the two other loops, increase the value of the PARALLEL FACTOR to allow simultaneous execution of many operations. \n\nFor the first Loop, calculate the product of Matrices A and B and save the result in Matrix E. For the second loop, calculate the product of Matrices C and D and save the result in Matrix F. For the final loop, Find the product of resultant matrices E and F and store it in Matrix G.\n\nFor all the loops, turn off the automatic pipeline pragma and make sure to process the loops in their intrinsic format, without splitting them into smaller sizes.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Prompt: Write a C HLS code using the specified '#pragma ACCEL kernel' to treat the function as a hardware kernel for acceleration. Define a function named 'kernel_3mm' with integer arguments (ni, nj, nk, nl, nm) and 2D arrays for double arguments (E, A, B, F, C, D, G). In the function: First, compute the product of matrices A and B, store it in matrix E. Here, use '#pragma ACCEL PIPELINE auto{flatten}' to optimize the loop for operation at high speed by fusing both dependent and independent operations across loop iterations, as well as '#pragma ACCEL TILE FACTOR=auto{1}' and '#pragma ACCEL PARALLEL FACTOR=auto{1}' - to process this loop in its original, full form without breaking it into smaller chunks and to run the iterations of this loop one after the other, not in parallel respectively, for each nested loop included. \n\nNext, compute the product of matrices C and D, store it in F, with the same pragma instructions applied, however, in the last loop of this part, use '#pragma ACCEL PARALLEL FACTOR=auto{7}' for that section to run seven iterations of the loop simultaneously.\n\nFinally, compute the product of matrices E and F, store it in G, with the same pragma instructions applied as in the first section. For each computation, make sure to initialize each resulting matrix element to 0.0 before the computation begins.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{7}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function named 'kernel_3mm'. This function should accept nine parameters: five integers ('ni', 'nj', 'nk', 'nl', 'nm') and four 2D double arrays ('A', 'B', 'C', 'D'). Prepare array 'E' from the multiplication of arrays 'A' and 'B', array 'F' from the multiplication of arrays 'C' and 'D', and array 'G' from the multiplication of arrays 'E' and 'F'. \n\nEach loop in the function should have the HLS pragmas to specify hardware acceleration behaviors: 'ACCEL PIPELINE' set to 'auto{off}' makes sure loop is not pipelined, 'ACCEL TILE FACTOR' set to 'auto{1}' ensures the loop process in its original, 'ACCEL PARALLEL FACTOR' set to 'auto{1}' indicates that loop iterations should not be processed in parallel. The exception being the last loop nested inside the second and third loop calculating the multiplication, where 'ACCEL PARALLEL FACTOR' is set to 'auto{5}' and 'auto{32}' respectively.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a C function with the declaration `kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])` to be defined as a hardware acceleration kernel. The function will perform three matrix multiplications.\n\nFirst, it should calculate the matrix product of A and B, and store the result in E. The loop for this calculation must be processed without automatic pipelining, must not be divided into smaller parts, and must have the iterations run in sequential order.\n\nSecond, the function should calculate the matrix product of C and D, and put the result in F. Similarly to the first operation, the loop of the calculation has the same attributes: no automatic pipelining, no breaking into smaller chunks, and non-parallel processing. However, for the innermost loop, you should run the iterations in parallel to a limited extent.\n\nLastly, the function needs to calculate the matrix product of E and F, and store it in G. Use the same attributes for this calculation loop as with the previous ones, including parallelization of the innermost loop.\n\nAll these directives are denoted by \n`#pragma ACCEL PIPELINE auto{off}`, `#pragma ACCEL TILE FACTOR=auto{1}`, and `#pragma ACCEL PARALLEL FACTOR=auto{1}` or `#pragma ACCEL PARALLEL FACTOR=auto{5}`. Ensure to include them at the appropriate places in your code.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Design a HLS kernel function called 'kernel_3mm' which consumes integers ni, nj, nk, nl, nm, and five 2D double arrays named E, A, B, F, C, D, G. Within this function:\n- For every i between 0 and 39, repeat these processes:\n  - For every j in range 0 to 49, initialize the field E[i][j] with 0.0. Then, for each k from 0 up to 59, accumulate the product of A[i][k] and B[k][j] into E[i][j]. \n  - Use '#pragma ACCEL PIPELINE' set to auto{off} to disable automatic pipeline, '#pragma ACCEL TILE FACTOR' set to auto{1} to retain the original loop structure, and '#pragma ACCEL PARALLEL FACTOR' set to auto{1} to execute all iterations in sequence.\n- Similarly, handle another loop with range of i from 0 to 49, each field F[i][j] from 0 to 69 must be updated with the cumulative product of arrays C and D with an additional parallel factor of auto{8} for innermost loop.\n- Lastly, for each i and j within range up to 39 and 69 respectively, update G[i][j] using cumulative product of arrays E and F while retaining previous pragma settings.\n- Ensure that these computations are not automatically pipelined, that the loops retain their full original form without being broken down, and all respective iterations run in sequence, not parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a HLS C code with the function header as 'kernel_3mm'. This hardware kernel function needs to perform matrix operations on the given matrices. Start by initializing 'E' as the product of matrices 'A' and 'B'. The processing should not be automatically pipelined, the loop should run in its original form without being broken down, and the iterations should run sequentially, not parallelly. For the innermost loop, set the parallel processing factor to 16. Similarly, compute 'F' as the product of 'C' and 'D' in the same way as before, just change the parallel processing in the innermost loop to 20. Lastly, determine 'G' as the product of 'E' and 'F', also follow the conditions like before but this time, set the parallel processing of the innermost loop to 50.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a C HLS code called `kernel_3mm` which contains three for loop blocks and should be treated as a hardware kernel for acceleration. This function has nine parameters: five integers (`ni`, `nj`, `nk`, `nl`, `nm`) and four two-dimensional arrays of type double (`E[40][50]`,`A[40][60]`, `B[60][50]`, `F[50][70]`, `C[50][80]`, `D[80][70]`, `G[40][70]`). \n\nWithin for loop blocks, make sure that the calculation does not run automatically with pipeline optimization, each should be processed in its original form without breaking into smaller chunks and iterations should run one after the other, not in parallel except while performing multiplication-addition operations (Notably, the first loop block has a parallel factor of 15, the second one has 32, and the third block has 50). \n\nSpecify that the first loop block is for computing the multiplication of matrices `A` and `B` which results in matrix `E`, the second one computes the multiplication of matrices `C` and `D` into matrix `F`, and the last block multiplies the matrix `E` with `F` to get matrix `G`.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write an HLS C code for a function named 'kernel_3mm'. The function takes in nine parameters: 'ni', 'nj', 'nk', 'nl', 'nm', and five 2D arrays 'E', 'A', 'B', 'F', 'C', 'D', and 'G'. Treat this function as a hardware kernel for acceleration. \n\nStart with three for-loops. The first loop performs matrix multiplication of 'A' and 'B' and stores the result in 'E', with the outermost loop running sequentially and not being pipelined, but processed in its original, full form without breaking it into smaller chunks. \n\nThe second loop performs matrix multiplication of 'C' and 'D' and stores the result in 'F', with the iterations once again running sequentially and not in parallel, and not being automatically pipelined.\n\nThe third loop performs matrix multiplication of 'E' and 'F' in the resulting 'G' array. For the outermost loop, stop it from being automatically pipelined but process the loop in its original, full form without breaking it into smaller chunks and let the iterations run iteratively and not in parallel. For the innermost loop, allow it to be flattened and processed in parallel automatically. \n\nIn all loops, let the iterations run iteratively and not in parallel for the second innermost loop, while for the innermost loop in the first structure, let the iterations run in parallel for the factor automatically decided.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write an HLS C function named 'kernel_3mm' treated as a hardware kernel for acceleration. The function should take nine parameters: five integers 'ni', 'nj', 'nk', 'nl', 'nm', and four 2D double arrays 'E', 'A', 'B', 'F', 'C', 'D', 'G'. Process the function with three computations. The first computation is calculating the matrix multiplication of 'A' and 'B', storing it in 'E', by using three nested for-loops. The second computation is performing the matrix multiplication of 'C' and 'D', storing it in 'F', with three nested loops. Finally, the third computation is multiplying 'E' and 'F' and storing it in 'G' again with three nested for-loops. In each computation, use '#pragma ACCEL PIPELINE auto{off}', '#pragma ACCEL TILE FACTOR=auto{1}', and '#pragma ACCEL PARALLEL FACTOR=auto{1}' for main two for-loops, and different auto parallel factors for the innermost loop: 'auto{1}', 'auto{5}', and 'auto{8}' respectively. This means don't automatically pipeline these loops, process them in their original full form without breaking into smaller chunks, and run the iterations of the loops sequentially, not in parallel, but run the innermost loops with different degree of parallelism depending on the computation.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a function named 'kernel_3mm' that treats the following function as a hardware kernel for acceleration. This function must accept 7 parameters: 5 integers - 'ni', 'nj', 'nk', 'nl', 'nm', and 2 multidimensional arrays - 'E' and 'A', 'B', 'F', 'C', 'D', 'G'. \n\nThe function performs three main calculations labelled 'E:=A*B', 'F:= C*D' and 'G:= E*F'. For each calculation, you will use for-loops that iterate over different arrays. For all these for-loops, ensure the loop iterations are run one after the other, not in parallel by setting the parallel factor to 1. Also, process each loop in its original, full form without breaking it into smaller chunks by setting the tile factor to 1. By default, you will pipeline these loops automatically in a flattened form, however, when operating on arrays 'E', 'F' and 'G', turn the automatic pipeline setting off.\n\nTo perform 'E:=A*B', set an initial value of 0.0 for all elements of 'E' then accumulate products of elements in arrays 'A' and 'B' in a nested for-loop system. \n\nIn 'F:= C*D', initialize all elements of 'F' to 0.0 before summing up the products of corresponding elements in arrays 'C' and 'D'. \n\nPerform 'G:= E*F' in a similar manner, initializing G's elements to zero before summing the products of 'E' and 'F' arrays elements. \n\nPlease remember to include all the appropriate pragmas to dictate the looping handling as indicated above.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a kernel function named 'kernel_3mm' utilizing the pragma 'ACCEL kernel'. The function should take eight parameters: five integers (ni, nj, nk, nl, nm) and six multi-dimensional double arrays (E[40][50], A[40][60], B[60][50], F[50][70], C[50][80], D[80][70], G[40][70]). \n\nFirstly, calculate the product of matrices A and B, storing the results in matrix E. Do this by performing triple nested loops in an ordered, not parallel manner using the pragmas 'PIPELINE auto{off}', 'TILE FACTOR=auto{1}', and 'PARALLEL FACTOR=auto{1}'. \n\nNext, compute the product of matrices C and D, storing the results in matrix F. It will also be performed using the same triple nested loop configuration. However, the innermost loop will be executed in blocks rather than one by one, indicated by 'PARALLEL FACTOR=auto{8}'. \n\nFinally, calculate the product of the newly filled matrices E and F, storing the results in matrix G. Again, use similar loop configuration. The innermost loop of this section will be executed in blocks using 'PARALLEL FACTOR=auto{4}'.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a hardware-accelerated kernel function 'kernel_3mm' with input parameters being integer variables (ni, nj, nk, nl, nm) and 2D arrays of double variables (E[40][50], A[40][60], B[60][50], F[50][70], C[50][80], D[80][70], G[40][70]). Inside this function, you need to write three sets of nested loops without automatic pipelining and without dividing them into smaller chunks. Also, ensure that the loop iterations are run consecutively and not in parallel. \n\nIn the first set, assign 0.0 to each element of array E and then perform the multiplication of arrays A and B and add the result to corresponding E element. The multiplication operation should be done with partial (1/6th) parallelism. \n\nIn the second set of loops, assign 0.0 to each element of array F, and then perform the multiplication of arrays C and D and add the result to corresponding F element. The multiplication operation in this case should be done with parallelism factor of 32. \n\nFinally, in the third set of loops, assign 0.0 to each element of array G, and then perform the multiplication of the previously calculated arrays E and F and add the result to corresponding G element. The multiplication operation in this case should be done with parallelism factor of 50.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a rigid C function named \"kernel_3mm\" with inputs of 5 integers (ni, nj, nk, nl, nm) and 7 two-dimensional double arrays (E[40][50], A[40][60], B[60][50], F[50][70], C[50][80], D[80][70], G[40][70]). The function is treated as a hardware kernel for hardware acceleration. The function performs matrix multiplication in three steps: E = A * B, F = C * D, and G = E * F. \n\nIn each of these process, two types of loops are considered: The outer loops are processed serially, they aren't pipelined and are kept in their full form without breaking into smaller chunks. In the innermost loops where the multiplication and accumulation happens, the iterations are distributed over several processing units, with different factors for each multiplication operation: factor 12 for E = A * B, factor 32 for F = C * D, and factor 50 for G = E * F.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Create a function named 'kernel_3mm', it should accept nine arguments: five integers (ni, nj, nk, nl, nm) and four 2D double arrays (E[40][50], A[40][60], B[60][50], F[50][70], C[50][80], D[80][70], G[40][70]). Treat this function as a hardware kernel for acceleration. Begin by declaring three integer variables i, j, and k.\n\nFirst, initialize the E matrix with the product of matrices A and B. For this, create three nested loops, i, j, and k. Don't automatically pipeline the i loop and process it without breaking it into smaller parts, run its iterations one after the other. Similarly, for the j loop, disable automatic pipelining, process it in its original form without breaking it into smaller parts, however, run its iterations twice in parallel. For the k loop, run its iterations 32 times in parallel.\n\nNext, initialize the F matrix with the product of matrices C and D. Create similar three loops as before. Don't allow pipelining for the loop i, keep it unbroken and execute its iterations consequentially. In the j loop, flatten the pipeline, keep the loop unbroken and execute the iterations one after the other. For k, run the iterations one by one.\n\nFinally, initialize the G matrix with the product of the matrices E and F. Follow similar steps as before but allow automatic pipeline optimization for the 'j' loop and run two of its iterations in parallel. For the k loop run its iterations 32 times in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
{"instruction": "Generate HLS code with the following instructions:", "input": "Write a function named 'kernel_3mm' which serves as an accelerated hardware kernel. It will process a series of matrix multiplications between matrices A, B, C, D, E, F and G. For computing each matrix, ensure the pipeline and tiling are switched off so that the whole loop is processed at once. Specifically, set the parallel factor as 1 to execute the iterations serially. \n\n1. For the first operation, calculate matrix E such that E[i][j] equals the sum of A[i][k] times B[k][j]. Here, use a parallel factor of 30 to divide the innermost loop into parallel instances. \n\n2. Similarly, calculate matrix F such that F[i][j] equals the sum of C[i][k] times D[k][j], applying a parallel factor of 20 for the innermost loop. \n\n3. Finally, calculate matrix G such that G[i][j] equals the sum of E[i][k] times F[k][j]. For this calculation, use a parallel factor of 50 for the innermost loop. \n\nDuring these operations, each matrix element is initialized to 0 before being used for computation.", "output": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}\n"}
