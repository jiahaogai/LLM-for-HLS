{"input": "To generate the given HLS codes in C, use the following natural language instructions for specific #pragma values:\n\n1. **Treat the following function as a hardware kernel for acceleration**\n   - Description: Specify the function as a hardware kernel for acceleration\n   - HLS Code: `#pragma ACCEL kernel`\n\n2. **Don't automatically pipeline this loop**\n   - Description: Disable automatic loop pipelining\n   - HLS Code: `#pragma ACCEL PIPELINE \"off\"`\n\n3. **Process this loop in its original, full form without breaking it into smaller chunks**\n   - Description: Set tile factor to 1 to process loop in its original form\n   - HLS Code: `#pragma ACCEL TILE FACTOR=1`\n\n4. **Run the iterations of this loop one after the other, not in parallel**\n   - Description: Set parallel factor to 1 to run loop iterations sequentially\n   - HLS Code: `#pragma ACCEL PARALLEL FACTOR=1`\n\nThese natural language instructions can be used to generate the HLS codes for the given C function.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_in_j = i * 240 + j;\n        int i_below_j = (i + 1) * 240 + j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 2 * j;\n        int _in_i = 2 * i;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][_in_j + 1] - ex[i][_in_j] + ey[i][_in_i + 1] - ey[i][_in_i]);\n      }\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes:\n\n- Apply automatic pipeline optimization to the loop.\n- Set the tile factor to 'auto' so that the loop is processed in its original, full form without breaking it into smaller chunks.\n- Set the parallel factor to 'auto{2}' for the outer loop and 'auto{1}' for the first inner loop, and 'auto{8}' for the second inner loop.\n- Treat the function 'kernel_jacobi_1d' as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes, apply the following natural language instructions:\n\n1. Use automatic pipelining for the loop.\n2. Apply tiling with an automatic factor of 1 to the loop.\n3. Parallelize the loop with an automatic factor of 2.\n4. Apply parallelization with an automatic factor of 2 to the inner loop.\n5. Further parallelize the loop with an automatic factor of 10.\n\nThese instructions correspond to the given HLS pragmas in the C code.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L4}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (A[i - 1][j] + A[i + 1][j] + A[i][j - 1] + A[i][j + 1] + A[i][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (B[i - 1][j] + B[i + 1][j] + B[i][j - 1] + B[i][j + 1] + B[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes in C, utilize the following concise natural language instructions for specific #pragma values:\n\n- To turn off automatic loop pipelining: \"Disable automatic loop pipelining\"\n- To set the tile factor to 1 for original loop processing: \"Use a tile factor of 1 for loop processing\"\n- To run loop iterations in parallel with a factor of 2: \"Execute loop iterations in parallel with a factor of 2\"\n- To designate the function as a hardware acceleration kernel: \"Designate the following function as a hardware kernel for acceleration\"\n\nOnce implemented with these instructions in mind, the HLS codes when written in C, will execute the desired functionalities.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 2L * (j + 1) - 1 - 1;\n        int _in_i = 2L * (i + 1) - 1 - 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_low = 2 * i;\n        int i_high = i_low + 1;\n        int j_low = 2 * j;\n        int j_high = j_low + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_low][j_low] - ex[i_high][j_low] + ey[i_low][j_low] - ey[i_low][j_high]);\n      }\n    }\n  }\n}"}}
{"input": "Generate HLS code with the following natural language instruction:\n\"Mark this function as a hardware kernel for acceleration, pipeline the outer loop automatically, tile the loop with a factor of 1 automatically, and parallelize the loops with a factor of 2 and 6 respectively.\"", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[j];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes in C, use the following pragma values:\n\n1. Treat the following function as a hardware kernel for acceleration: `#pragma ACCEL kernel`\n\n2. Don't automatically pipeline this loop: `#pragma ACCEL PIPELINE \"off\"`\n\n3. Process this loop in its original, full form without breaking it into smaller chunks: `#pragma ACCEL TILE FACTOR=1`\n\n4. Run the iterations of this loop one after the other, not in parallel: `#pragma ACCEL PARALLEL FACTOR=1`", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "5. Do not change the scope of the for loop with respect to the above pragma\n  \n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL PARAMETER FACTOR=auto{__PARA__L0}\n   \n\n#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "2": "#pragma ACCEL PARALLEL FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L3}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L5}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L6}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L7}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L7}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L7}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L8}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L8}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L9}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L9}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L9}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L10}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L10}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L10}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L10}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L11}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L11}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L11}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L11}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L12}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L12}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L12}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L12}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L13}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L13}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L13}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L13}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L14}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L14}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L14}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L14}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L15}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L15}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L15}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L15}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L16}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L16}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L16}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L16}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L17}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L17}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L17}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L17}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L18}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L18}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L18}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L18}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L19}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L19}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L19}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L19}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L20}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L20}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L20}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L20}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L21}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L21}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L21}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L21}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L22}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L22}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L22}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L22}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L23}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L23}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L23}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L23}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L24}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L24}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L24}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L24}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L25}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L25}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L25}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L25}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L26}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L26}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L26}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L26}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L27}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L27}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L27}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L27}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L28}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L28}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L28}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L28}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L29}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L29}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L29}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L29}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L30}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L30}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L30}"}}
{"input": "To generate the given HLS codes, use the following natural language instructions:\n\n1. Mark the function as a hardware kernel for acceleration.\n   Use: 'Treat the following function as a hardware kernel for acceleration'\n\n2. Don't automatically pipeline the outer loop.\n   Use: '#pragma ACCEL PIPELINE \"off\"'\n\n3. Ensure the loop is processed in its original, full form without breaking it into smaller chunks.\n   Use: '#pragma ACCEL TILE FACTOR=1'\n\n4. Run the iterations of the outer loop one after the other, not in parallel.\n   Use: '#pragma ACCEL PARALLEL FACTOR=1'\n\n5. Optionally, specify the auto factor value for the pipeline, tile, and parallel pragma directives.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "Use: '#pragma ACCEL PIPELINE auto{__PIPE__L0}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L0}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L1}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L1}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L2}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L2}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L3}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L3}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L4}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L4}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L5}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L5}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L6}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L6}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L7}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L7}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L8}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L8}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L9}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L9}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L10}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L10}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L10}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L11}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L11}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L11}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L12}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L12}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L12}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L13}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L13}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L13}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L14}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L14}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L14}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L15}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L15}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L15}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L16}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L16}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L16}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L17}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L17}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L17}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L18}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L18}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L18}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L19}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L19}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L19}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L20}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L20}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L20}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L21}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L21}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L21}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L22}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L22}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L22}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L23}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L23}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L23}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L24}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L24}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L24}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L25}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L25}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L25}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L26}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L26}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L26}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L27}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L27}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L27}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L28}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L28}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L28}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L29}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L29}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L29}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L30}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L30}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L30}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L31}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L31}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L31}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L32}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L32}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L32}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L33}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L33}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L33}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L34}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L34}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L34}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L35}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L35}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L35}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L36}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L36}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L36}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L37}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L37}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L37}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L38}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L38}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L38}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L39}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L39}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L39}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L40", "1": "Use: '#pragma ACCEL PIPELINE auto{__PIPE__L0}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L0}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L1}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L1}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L2}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L2}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L3}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L3}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L4}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L4}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L5}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L5}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L6}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L6}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L7}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L7}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L8}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L8}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L9}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L9}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L10}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L10}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L10}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L11}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L11}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L11}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L12}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L12}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L12}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L13}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L13}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L13}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L14}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L14}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L14}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L15}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L15}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L15}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L16}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L16}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L16}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L17}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L17}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L17}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L18}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L18}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L18}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L19}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L19}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L19}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L20}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L20}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L20}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L21}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L21}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L21}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L22}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L22}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L22}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L23}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L23}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L23}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L24}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L24}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L24}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L25}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L25}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L25}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L26}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L26}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L26}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L27}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L27}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L27}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L28}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L28}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L28}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L29}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L29}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L29}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L30}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L30}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L30}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L31}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L31}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L31}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L32}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L32}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L32}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L33}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L33}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L33}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L34}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L34}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L34}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L35}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L35}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L35}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L36}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L36}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L36}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L37}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L37}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L37}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L38}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L38}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L38}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L39}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L39}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L39}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L40", "2": "Use: '#pragma ACCEL PIPELINE auto{__PIPE__L0}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L0}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L1}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L1}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L2}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L2}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L3}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L3}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L4}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L4}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L5}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L5}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L6}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L6}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L7}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L7}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L8}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L8}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L9}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L9}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L10}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L10}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L10}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L11}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L11}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L11}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L12}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L12}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L12}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L13}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L13}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L13}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L14}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L14}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L14}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L15}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L15}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L15}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L16}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L16}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L16}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L17}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L17}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L17}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L18}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L18}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L18}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L19}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L19}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L19}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L20}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L20}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L20}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L21}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L21}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L21}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L22}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L22}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L22}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L23}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L23}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L23}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L24}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L24}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L24}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L25}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L25}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L25}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L26}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L26}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L26}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L27}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L27}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L27}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L28}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L28}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L28}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L29}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L29}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L29}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L30}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L30}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L30}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L31}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L31}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L31}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L32}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L32}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L32}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L33}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L33}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L33}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L34}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L34}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L34}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L35}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L35}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L35}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L36}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L36}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L36}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L37}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L37}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L37}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L38}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L38}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L38}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L39}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L39}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L39}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L40"}}
{"input": "Process the kernel loop in its original, full form without breaking it into smaller chunks. Then, don't automatically pipeline this loop. Run the iterations of this loop one after the other, not in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes in C, use the following natural language instructions:\n\n1. Treat the following function as a hardware kernel for acceleration.\n2. Don't automatically pipeline this loop and flatten it.\n3. Process this loop in its original, full form without breaking it into smaller chunks automatically.\n4. Run the iterations of this loop one after the other, not in parallel with a factor of 2.\n5. Run the iterations of this loop in parallel with a factor of 16.\n6. Run the iterations of this loop one after the other, not in parallel with a factor of 1.\n\nThe corresponding #pragma values are:\n1. #pragma ACCEL kernel\n2. #pragma ACCEL PIPELINE auto{flatten}\n3. #pragma ACCEL TILE FACTOR=auto{1}\n4. #pragma ACCEL PARALLEL FACTOR=auto{2}\n5. #pragma ACCEL PARALLEL FACTOR=auto{16}\n6. #pragma ACCEL PARALLEL FACTOR=auto{1}", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n\n#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        double delta_x = (double )(ex[i][j + 1] - ex[i][j]);\n        double  delta_y = (double )(ey[i + 1][j] - ey[i][j]);\n        double  delta_z = (double )(hz[i + 1][j] - hz[i][j]);\n        double  si_x = delta_x / (4.0 * (1.0 + delta_x * delta_x + delta_y * delta_y));\n        double  si_y = delta_y / (4.0 * (1.0 + delta_x * delta_x + delta_y * delta_y));\n        double  si_z = delta_z / (4.0 * (1.0 + delta_x * delta_x + delta_y * delta_y));\n        double  xi_x = -1.0 * delta_x / (2.0 * (1.0 + delta_x * delta_x + delta_y * delta_y));\n        double  xi_y = -1.0 * delta_y / (2.0 * (1.0 + delta_x * delta_x + delta_y * delta_y));\n        double  xi_z = -1.0 * delta_z / (2.0 * (1.0 + delta_x * delta_x + delta_y * delta_y));\n        double  _in_1 = si_x * (hz[i][j] - hz[i][j + 1]);\n        double  _in_2 = si_y * (hz[i][j] - hz[i + 1][j]);\n        double  _in_3 = si_z * (hz[i][j] - hz[i + 1][j + 1]);\n        double  _in_4 = xi_x * (_in_1 + _in_2);\n        double  _in_5 = xi_y * (_in_1 + _in_3);\n        double  _in_6 = xi_z * (_in_1 + _in_2 + _in_3);\n        ey[i][j] = ey[i][j] + _in_4;\n        ex[i][j] = ex[i][j] + _in_5;\n        hz[i][j] = hz[i][j] + _in_6;\n      }\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes in C, you should use the following natural language instructions for the specific #pragma values:\n\n1. For the function `kernel_jacobi_1d`:\n    - Treat the following function as a hardware kernel for acceleration.\n\n2. For the first loop:\n    - Don't automatically pipeline this loop.\n\n3. For tiling:\n    - Process this loop in its original, full form without breaking it into smaller chunks.\n\n4. For parallelization with a factor of 2:\n    - Run the iterations of this loop in parallel with a parallel factor of 2.\n\n5. For the inner loop (first usage):\n    - Run the iterations of this loop one after the other, not in parallel.\n\n6. For the inner loop (second usage):\n    - Run the iterations of this loop in parallel with a parallel factor of 8.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes in C, you can use the following concise natural language instruction for the process and pragma values:\n\n\"Designate the following function as a hardware kernel for acceleration\" - this describes the pragma value '#pragma ACCEL kernel'\n\n\"Automatically pipeline this loop without flattening\" - this maps to the pragma value '#pragma ACCEL PIPELINE auto{flatten}'\n\n\"Set the tile factor for loop tiling to be automatically determined as 1\" - this corresponds to the pragma value '#pragma ACCEL TILE FACTOR=auto{1}'\n\n\"Run the iterations of the following loops in parallel with a factor to be automatically determined as 2\" - for both loops, the pragma value is '#pragma ACCEL PARALLEL FACTOR=auto{2}'\n\nFor the provided code snippet, using these natural language instructions will generate the corresponding HLS codes in C with the specified pragma values.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 119; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 119; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L4}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][80],double C[80][50],double D[40][50])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 50; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction=D FACTOR=auto{25}\n      for (k = 0; k < 80; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Apply pipeline optimization to the outer loop, disable automatic pipelining for the middle loop, and flatten the inner loop for parallelization using suitable HLS pragma directives.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[j];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[j];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 90; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Process the loop in its original, full form without breaking it into smaller chunks. Treat the loop iterations as if they are a pipeline, automatically determining the optimal settings. Run two iterations of this loop in parallel. Within this loop, process 24 iterations in parallel, and then process the remaining iterations two at a time in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{24}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (j = 16; j < 24; j++) {\n    \n#pragma ACCEL PARALLEL reduction=A FACTOR=auto{__PARA__L3}\n    for (i = 1; i < 20; i++) {\n      A[j][i] = A[j][i] - A[j][i - 1] * B[j][i - 1];\n    }\n  }\n}", "1": "#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (tj = 0;tj < 20;tj++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    for (tk = 0;tk < 20;tk++) {\n      tmp = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{__PARA__L5}\n      for (i = 0;i < 40;i++) {\n        tmp += A[i][tj][tk] * x[i];\n      }\n      B[tj][tk] = tmp;\n    }\n    tmp2 = 0.0;\n    \n#pragma ACCEL PARALLEL reduction=tmp2 FACTOR=auto{__PARA__L4}\n    for (tk = 0;tk < 20;tk++) {\n      tmp2 += B[tj][tk] * f[tk];\n    }\n    y[tj] = tmp2;\n  }\n  float check = 0.0;\n  \n#pragma ACCEL PARALLEL reduction=check\n  for (tj = 0;tj < 20;tj++) {\n    check += A[tj][tj][tj];\n  }\n  if (fabs(check - 60.928) > 1e-4) {\n    printf(\"Mismatch in kernel 3:\\n\");\n    printf(\"  check= %f\\n\",check);\n    printf(\"  A[16][16][16]: %f\\n\",A[16][16][16]);\n    exit - 1;\n  }\n  else {\n    printf(\"Match in kernel 3.\\n\");\n  }\n}", "2": "#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL reduction=u FACTOR=auto{__PARA__L2}\n    for (i = 1; i < 39; i++) {\n      u[i] = 0.33 * u[i] + 0.33 * v[i] + 0.33 * (q[i] - p[i] * u[i]);\n    }\n    \n#pragma ACCEL PARALLEL reduction=v FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 39; i++) {\n      v[i] = - 1.0 * v[i] + 1.0 * u[i] + 1.0 * (p[i + 1] - p[i]) / (e[i + 1] - d[i]) * (u[i + 1] - u[i]);\n    }\n  }\n}"}}
{"input": "Define a hardware kernel for acceleration. Use parallel and pipeline optimizations for the nested loops. Ensure the outer loop runs in full form without breaking into smaller chunks, and the inner loops process iterations one after another, not in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_0}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[j];\n    }\n    \n#pragma ACCEL PIPELINE auto{off_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1_1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_1}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1_1_0}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1_2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_2}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1_2_0}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1_3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_3}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1_3_0}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes written in C, use the following natural language instruction for the specific #pragma values:\n\n1. To automatically pipeline the loop:\n   Use: \"Automatically pipeline this loop\"\n   Code: `#pragma ACCEL PIPELINE auto{}`\n\n2. To tile the loop with a factor determined automatically:\n   Use: \"Automatically determine the tiling factor for this loop\"\n   Code: `#pragma ACCEL TILE FACTOR=auto{1}`\n\n3. To run iterations of the loop in parallel with an automatically determined factor:\n   Use: \"Automatically determine the parallelization factor for this loop\"\n   Code: `#pragma ACCEL PARALLEL FACTOR=auto{2}`\n\n4. To set a specific parallelization factor for the inner loop:\n   Use: \"Set the parallelization factor for the inner loop to 15\"\n   Code: `#pragma ACCEL PARALLEL FACTOR=auto{15}`\n\n5. To set a specific parallelization factor for another inner loop:\n   Use: \"Set the parallelization factor for the inner loop to 3\"\n   Code: `#pragma ACCEL PARALLEL FACTOR=auto{3}`\n\nBy following these natural language instructions, the given HLS codes can be generated in C with the appropriate #pragma values.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L8}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Process the iterations of the following loop in parallel, utilizing automatic factor calculation.\nDon't automatically pipeline this loop.\nProcess this loop in its original, full form without breaking it into smaller chunks.\nRun the iterations of this loop one after the other, not in parallel. Also, treat the following function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1 * i + 120;\n        int j_col = -1 * j + 120;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the following HLS codes in C:\n```c\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps, int n, double A[120], double B[120])\n{\n  int t;\n  int i;\n#pragma ACCEL PIPELINE auto{flatten}\n#pragma ACCEL TILE FACTOR=auto{1}\n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n}\n```\n\nYou can use the following concise natural language instructions for each #pragma directive:\n\n1. \"Treat the following function as a hardware kernel for acceleration\"\n   - `#pragma ACCEL kernel`\n\n2. \"Don't automatically pipeline this loop, maintain original structure\"\n   - `#pragma ACCEL PIPELINE auto{flatten}` \n\n3. \"Process this loop in its original, full form without breaking it into smaller chunks\"\n   - `#pragma ACCEL TILE FACTOR=auto{1}`\n\n4. \"Run the iterations of this loop in parallel with the specified factor\"\n   - `#pragma ACCEL PARALLEL FACTOR=auto{2}` for the outer loop\n   - `#pragma ACCEL PARALLEL FACTOR=auto{15}` for the first inner loop\n   - `#pragma ACCEL PARALLEL FACTOR=auto{1}` for the second inner loop", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}`", "1": "5. \"Complete kernel", "2": "5. \"Automatically decide unroll factor\"\n   - `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}`\n\n6. \"Automatically decide unroll factor\"\n   - `#pragma ACCEL PIPELINE auto{__PIPE__L2}`"}}
{"input": "Process the following function as a hardware kernel for acceleration.\nEnsure the loop iterations run in parallel, each with an auto-determined factor.\nDisable automatic loop pipelining.\nSet the loop tiling factor to be determined automatically.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 0 + 1L * 1L;\n        int _in_i = 0 + 1L * 1L;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes in C, use the following natural language instruction:\n\n\"Designate the following function as a hardware kernel for acceleration. Sequentially process the iterations of the outer loop, and parallelize the inner loop with a factor of 15. Automatically pipeline the loops and use a tiling factor of 1. Additionally, parallelize the second inner loop with a factor of 1.\"\n\nThis instruction encompasses the use of the following #pragma values:\n- '#pragma ACCEL kernel' to designate the function as a hardware kernel\n- '#pragma ACCEL PIPELINE auto{flatten}' to automatically pipeline the loops\n- '#pragma ACCEL TILE FACTOR=auto{1}' to apply a tiling factor of 1\n- '#pragma ACCEL PARALLEL FACTOR=auto{2}' to parallelize the outer loop\n- '#pragma ACCEL PARALLEL FACTOR=auto{15}' to parallelize the first inner loop with a factor of 15\n- '#pragma ACCEL PARALLEL FACTOR=auto{1}' to parallelize the second inner loop with a factor of 1", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i < 119; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 119; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1 * i;\n        int j_row = -1 * j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_col + 1][j_row + 1] - ex[i_col + 1][j_row] - ey[i_col + 1][j_row + 1] + ey[i_col + 1][j_row]);\n      }\n    }\n  }\n}"}}
{"input": "To generate the given C code with HLS pragmas, you should follow the natural language instructions below:\n\n- Apply automatic pipelining to the loop: '#pragma ACCEL PIPELINE auto{}'\n- Tile the loop with a factor determined automatically: '#pragma ACCEL TILE FACTOR=auto{1}'\n- Parallelize the loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{2}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{3}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{10}'", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}'\n\n#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L2}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L4}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L5}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L6}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}"}}
