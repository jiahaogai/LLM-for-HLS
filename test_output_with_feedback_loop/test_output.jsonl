{"input": "To generate the given HLS codes in C, use the following natural language instructions for specific #pragma values:\n\n1. **Treat the following function as a hardware kernel for acceleration**\n   - Description: Specify the function as a hardware kernel for acceleration\n   - HLS Code: `#pragma ACCEL kernel`\n\n2. **Don't automatically pipeline this loop**\n   - Description: Disable automatic loop pipelining\n   - HLS Code: `#pragma ACCEL PIPELINE \"off\"`\n\n3. **Process this loop in its original, full form without breaking it into smaller chunks**\n   - Description: Set tile factor to 1 to process loop in its original form\n   - HLS Code: `#pragma ACCEL TILE FACTOR=1`\n\n4. **Run the iterations of this loop one after the other, not in parallel**\n   - Description: Set parallel factor to 1 to run loop iterations sequentially\n   - HLS Code: `#pragma ACCEL PARALLEL FACTOR=1`\n\nThese natural language instructions can be used to generate the HLS codes for the given C function.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_in_j = i * 240 + j;\n        int i_below_j = (i + 1) * 240 + j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 2 * j;\n        int _in_i = 2 * i;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][_in_j + 1] - ex[i][_in_j] + ey[i][_in_i + 1] - ey[i][_in_i]);\n      }\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes:\n\n- Apply automatic pipeline optimization to the loop.\n- Set the tile factor to 'auto' so that the loop is processed in its original, full form without breaking it into smaller chunks.\n- Set the parallel factor to 'auto{2}' for the outer loop and 'auto{1}' for the first inner loop, and 'auto{8}' for the second inner loop.\n- Treat the function 'kernel_jacobi_1d' as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes, apply the following natural language instructions:\n\n1. Use automatic pipelining for the loop.\n2. Apply tiling with an automatic factor of 1 to the loop.\n3. Parallelize the loop with an automatic factor of 2.\n4. Apply parallelization with an automatic factor of 2 to the inner loop.\n5. Further parallelize the loop with an automatic factor of 10.\n\nThese instructions correspond to the given HLS pragmas in the C code.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L4}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (A[i - 1][j] + A[i + 1][j] + A[i][j - 1] + A[i][j + 1] + A[i][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (B[i - 1][j] + B[i + 1][j] + B[i][j - 1] + B[i][j + 1] + B[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes in C, utilize the following concise natural language instructions for specific #pragma values:\n\n- To turn off automatic loop pipelining: \"Disable automatic loop pipelining\"\n- To set the tile factor to 1 for original loop processing: \"Use a tile factor of 1 for loop processing\"\n- To run loop iterations in parallel with a factor of 2: \"Execute loop iterations in parallel with a factor of 2\"\n- To designate the function as a hardware acceleration kernel: \"Designate the following function as a hardware kernel for acceleration\"\n\nOnce implemented with these instructions in mind, the HLS codes when written in C, will execute the desired functionalities.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 2L * (j + 1) - 1 - 1;\n        int _in_i = 2L * (i + 1) - 1 - 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_low = 2 * i;\n        int i_high = i_low + 1;\n        int j_low = 2 * j;\n        int j_high = j_low + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_low][j_low] - ex[i_high][j_low] + ey[i_low][j_low] - ey[i_low][j_high]);\n      }\n    }\n  }\n}"}}
{"input": "Generate HLS code with the following natural language instruction:\n\"Mark this function as a hardware kernel for acceleration, pipeline the outer loop automatically, tile the loop with a factor of 1 automatically, and parallelize the loops with a factor of 2 and 6 respectively.\"", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[j];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes in C, use the following pragma values:\n\n1. Treat the following function as a hardware kernel for acceleration: `#pragma ACCEL kernel`\n\n2. Don't automatically pipeline this loop: `#pragma ACCEL PIPELINE \"off\"`\n\n3. Process this loop in its original, full form without breaking it into smaller chunks: `#pragma ACCEL TILE FACTOR=1`\n\n4. Run the iterations of this loop one after the other, not in parallel: `#pragma ACCEL PARALLEL FACTOR=1`", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "5. Do not change the scope of the for loop with respect to the above pragma\n  \n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL PARAMETER FACTOR=auto{__PARA__L0}\n   \n\n#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "2": "#pragma ACCEL PARALLEL FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L3}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L5}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L6}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L7}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L7}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L7}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L8}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L8}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L9}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L9}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L9}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L10}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L10}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L10}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L10}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L11}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L11}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L11}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L11}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L12}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L12}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L12}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L12}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L13}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L13}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L13}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L13}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L14}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L14}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L14}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L14}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L15}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L15}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L15}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L15}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L16}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L16}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L16}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L16}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L17}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L17}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L17}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L17}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L18}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L18}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L18}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L18}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L19}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L19}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L19}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L19}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L20}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L20}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L20}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L20}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L21}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L21}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L21}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L21}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L22}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L22}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L22}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L22}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L23}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L23}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L23}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L23}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L24}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L24}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L24}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L24}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L25}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L25}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L25}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L25}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L26}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L26}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L26}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L26}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L27}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L27}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L27}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L27}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L28}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L28}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L28}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L28}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L29}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L29}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L29}\n  \n#pragma ACCEL WORKER FACTOR=auto{__WORK__L29}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L30}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L30}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L30}"}}
{"input": "To generate the given HLS codes, use the following natural language instructions:\n\n1. Mark the function as a hardware kernel for acceleration.\n   Use: 'Treat the following function as a hardware kernel for acceleration'\n\n2. Don't automatically pipeline the outer loop.\n   Use: '#pragma ACCEL PIPELINE \"off\"'\n\n3. Ensure the loop is processed in its original, full form without breaking it into smaller chunks.\n   Use: '#pragma ACCEL TILE FACTOR=1'\n\n4. Run the iterations of the outer loop one after the other, not in parallel.\n   Use: '#pragma ACCEL PARALLEL FACTOR=1'\n\n5. Optionally, specify the auto factor value for the pipeline, tile, and parallel pragma directives.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "Use: '#pragma ACCEL PIPELINE auto{__PIPE__L0}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L0}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L1}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L1}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L2}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L2}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L3}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L3}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L4}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L4}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L5}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L5}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L6}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L6}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L7}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L7}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L8}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L8}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L9}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L9}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L10}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L10}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L10}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L11}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L11}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L11}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L12}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L12}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L12}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L13}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L13}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L13}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L14}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L14}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L14}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L15}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L15}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L15}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L16}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L16}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L16}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L17}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L17}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L17}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L18}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L18}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L18}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L19}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L19}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L19}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L20}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L20}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L20}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L21}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L21}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L21}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L22}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L22}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L22}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L23}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L23}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L23}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L24}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L24}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L24}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L25}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L25}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L25}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L26}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L26}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L26}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L27}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L27}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L27}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L28}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L28}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L28}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L29}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L29}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L29}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L30}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L30}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L30}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L31}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L31}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L31}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L32}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L32}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L32}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L33}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L33}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L33}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L34}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L34}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L34}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L35}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L35}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L35}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L36}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L36}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L36}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L37}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L37}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L37}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L38}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L38}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L38}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L39}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L39}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L39}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L40", "1": "Use: '#pragma ACCEL PIPELINE auto{__PIPE__L0}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L0}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L1}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L1}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L2}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L2}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L3}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L3}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L4}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L4}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L5}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L5}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L6}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L6}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L7}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L7}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L8}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L8}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L9}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L9}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L10}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L10}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L10}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L11}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L11}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L11}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L12}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L12}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L12}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L13}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L13}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L13}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L14}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L14}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L14}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L15}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L15}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L15}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L16}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L16}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L16}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L17}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L17}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L17}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L18}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L18}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L18}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L19}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L19}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L19}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L20}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L20}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L20}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L21}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L21}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L21}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L22}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L22}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L22}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L23}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L23}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L23}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L24}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L24}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L24}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L25}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L25}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L25}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L26}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L26}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L26}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L27}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L27}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L27}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L28}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L28}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L28}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L29}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L29}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L29}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L30}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L30}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L30}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L31}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L31}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L31}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L32}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L32}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L32}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L33}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L33}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L33}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L34}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L34}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L34}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L35}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L35}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L35}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L36}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L36}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L36}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L37}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L37}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L37}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L38}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L38}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L38}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L39}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L39}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L39}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L40", "2": "Use: '#pragma ACCEL PIPELINE auto{__PIPE__L0}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L0}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L1}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L1}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L2}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L2}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L3}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L3}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L4}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L4}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L5}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L5}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L6}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L6}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L7}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L7}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L8}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L8}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L9}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L9}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L10}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L10}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L10}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L11}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L11}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L11}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L12}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L12}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L12}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L13}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L13}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L13}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L14}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L14}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L14}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L15}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L15}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L15}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L16}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L16}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L16}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L17}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L17}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L17}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L18}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L18}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L18}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L19}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L19}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L19}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L20}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L20}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L20}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L21}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L21}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L21}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L22}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L22}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L22}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L23}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L23}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L23}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L24}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L24}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L24}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L25}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L25}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L25}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L26}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L26}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L26}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L27}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L27}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L27}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L28}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L28}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L28}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L29}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L29}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L29}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L30}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L30}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L30}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L31}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L31}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L31}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L32}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L32}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L32}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L33}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L33}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L33}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L34}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L34}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L34}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L35}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L35}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L35}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L36}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L36}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L36}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L37}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L37}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L37}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L38}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L38}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L38}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L39}'\n   Use: '#pragma ACCEL TILE FACTOR=auto{__TILE__L39}'\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L39}'\n   Use: '#pragma ACCEL PIPELINE auto{__PIPE__L40"}}
{"input": "Process the kernel loop in its original, full form without breaking it into smaller chunks. Then, don't automatically pipeline this loop. Run the iterations of this loop one after the other, not in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes in C, use the following natural language instructions:\n\n1. Treat the following function as a hardware kernel for acceleration.\n2. Don't automatically pipeline this loop and flatten it.\n3. Process this loop in its original, full form without breaking it into smaller chunks automatically.\n4. Run the iterations of this loop one after the other, not in parallel with a factor of 2.\n5. Run the iterations of this loop in parallel with a factor of 16.\n6. Run the iterations of this loop one after the other, not in parallel with a factor of 1.\n\nThe corresponding #pragma values are:\n1. #pragma ACCEL kernel\n2. #pragma ACCEL PIPELINE auto{flatten}\n3. #pragma ACCEL TILE FACTOR=auto{1}\n4. #pragma ACCEL PARALLEL FACTOR=auto{2}\n5. #pragma ACCEL PARALLEL FACTOR=auto{16}\n6. #pragma ACCEL PARALLEL FACTOR=auto{1}", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n\n#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        double delta_x = (double )(ex[i][j + 1] - ex[i][j]);\n        double  delta_y = (double )(ey[i + 1][j] - ey[i][j]);\n        double  delta_z = (double )(hz[i + 1][j] - hz[i][j]);\n        double  si_x = delta_x / (4.0 * (1.0 + delta_x * delta_x + delta_y * delta_y));\n        double  si_y = delta_y / (4.0 * (1.0 + delta_x * delta_x + delta_y * delta_y));\n        double  si_z = delta_z / (4.0 * (1.0 + delta_x * delta_x + delta_y * delta_y));\n        double  xi_x = -1.0 * delta_x / (2.0 * (1.0 + delta_x * delta_x + delta_y * delta_y));\n        double  xi_y = -1.0 * delta_y / (2.0 * (1.0 + delta_x * delta_x + delta_y * delta_y));\n        double  xi_z = -1.0 * delta_z / (2.0 * (1.0 + delta_x * delta_x + delta_y * delta_y));\n        double  _in_1 = si_x * (hz[i][j] - hz[i][j + 1]);\n        double  _in_2 = si_y * (hz[i][j] - hz[i + 1][j]);\n        double  _in_3 = si_z * (hz[i][j] - hz[i + 1][j + 1]);\n        double  _in_4 = xi_x * (_in_1 + _in_2);\n        double  _in_5 = xi_y * (_in_1 + _in_3);\n        double  _in_6 = xi_z * (_in_1 + _in_2 + _in_3);\n        ey[i][j] = ey[i][j] + _in_4;\n        ex[i][j] = ex[i][j] + _in_5;\n        hz[i][j] = hz[i][j] + _in_6;\n      }\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes in C, you should use the following natural language instructions for the specific #pragma values:\n\n1. For the function `kernel_jacobi_1d`:\n    - Treat the following function as a hardware kernel for acceleration.\n\n2. For the first loop:\n    - Don't automatically pipeline this loop.\n\n3. For tiling:\n    - Process this loop in its original, full form without breaking it into smaller chunks.\n\n4. For parallelization with a factor of 2:\n    - Run the iterations of this loop in parallel with a parallel factor of 2.\n\n5. For the inner loop (first usage):\n    - Run the iterations of this loop one after the other, not in parallel.\n\n6. For the inner loop (second usage):\n    - Run the iterations of this loop in parallel with a parallel factor of 8.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes in C, you can use the following concise natural language instruction for the process and pragma values:\n\n\"Designate the following function as a hardware kernel for acceleration\" - this describes the pragma value '#pragma ACCEL kernel'\n\n\"Automatically pipeline this loop without flattening\" - this maps to the pragma value '#pragma ACCEL PIPELINE auto{flatten}'\n\n\"Set the tile factor for loop tiling to be automatically determined as 1\" - this corresponds to the pragma value '#pragma ACCEL TILE FACTOR=auto{1}'\n\n\"Run the iterations of the following loops in parallel with a factor to be automatically determined as 2\" - for both loops, the pragma value is '#pragma ACCEL PARALLEL FACTOR=auto{2}'\n\nFor the provided code snippet, using these natural language instructions will generate the corresponding HLS codes in C with the specified pragma values.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 119; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 119; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L4}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][80],double C[80][50],double D[40][50])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 50; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction=D FACTOR=auto{25}\n      for (k = 0; k < 80; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Apply pipeline optimization to the outer loop, disable automatic pipelining for the middle loop, and flatten the inner loop for parallelization using suitable HLS pragma directives.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[j];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[j];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 90; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Process the loop in its original, full form without breaking it into smaller chunks. Treat the loop iterations as if they are a pipeline, automatically determining the optimal settings. Run two iterations of this loop in parallel. Within this loop, process 24 iterations in parallel, and then process the remaining iterations two at a time in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{24}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (j = 16; j < 24; j++) {\n    \n#pragma ACCEL PARALLEL reduction=A FACTOR=auto{__PARA__L3}\n    for (i = 1; i < 20; i++) {\n      A[j][i] = A[j][i] - A[j][i - 1] * B[j][i - 1];\n    }\n  }\n}", "1": "#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (tj = 0;tj < 20;tj++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    for (tk = 0;tk < 20;tk++) {\n      tmp = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{__PARA__L5}\n      for (i = 0;i < 40;i++) {\n        tmp += A[i][tj][tk] * x[i];\n      }\n      B[tj][tk] = tmp;\n    }\n    tmp2 = 0.0;\n    \n#pragma ACCEL PARALLEL reduction=tmp2 FACTOR=auto{__PARA__L4}\n    for (tk = 0;tk < 20;tk++) {\n      tmp2 += B[tj][tk] * f[tk];\n    }\n    y[tj] = tmp2;\n  }\n  float check = 0.0;\n  \n#pragma ACCEL PARALLEL reduction=check\n  for (tj = 0;tj < 20;tj++) {\n    check += A[tj][tj][tj];\n  }\n  if (fabs(check - 60.928) > 1e-4) {\n    printf(\"Mismatch in kernel 3:\\n\");\n    printf(\"  check= %f\\n\",check);\n    printf(\"  A[16][16][16]: %f\\n\",A[16][16][16]);\n    exit - 1;\n  }\n  else {\n    printf(\"Match in kernel 3.\\n\");\n  }\n}", "2": "#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL reduction=u FACTOR=auto{__PARA__L2}\n    for (i = 1; i < 39; i++) {\n      u[i] = 0.33 * u[i] + 0.33 * v[i] + 0.33 * (q[i] - p[i] * u[i]);\n    }\n    \n#pragma ACCEL PARALLEL reduction=v FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 39; i++) {\n      v[i] = - 1.0 * v[i] + 1.0 * u[i] + 1.0 * (p[i + 1] - p[i]) / (e[i + 1] - d[i]) * (u[i + 1] - u[i]);\n    }\n  }\n}"}}
{"input": "Define a hardware kernel for acceleration. Use parallel and pipeline optimizations for the nested loops. Ensure the outer loop runs in full form without breaking into smaller chunks, and the inner loops process iterations one after another, not in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_0}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[j];\n    }\n    \n#pragma ACCEL PIPELINE auto{off_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1_1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_1}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1_1_0}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1_2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_2}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1_2_0}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1_3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_3}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1_3_0}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes written in C, use the following natural language instruction for the specific #pragma values:\n\n1. To automatically pipeline the loop:\n   Use: \"Automatically pipeline this loop\"\n   Code: `#pragma ACCEL PIPELINE auto{}`\n\n2. To tile the loop with a factor determined automatically:\n   Use: \"Automatically determine the tiling factor for this loop\"\n   Code: `#pragma ACCEL TILE FACTOR=auto{1}`\n\n3. To run iterations of the loop in parallel with an automatically determined factor:\n   Use: \"Automatically determine the parallelization factor for this loop\"\n   Code: `#pragma ACCEL PARALLEL FACTOR=auto{2}`\n\n4. To set a specific parallelization factor for the inner loop:\n   Use: \"Set the parallelization factor for the inner loop to 15\"\n   Code: `#pragma ACCEL PARALLEL FACTOR=auto{15}`\n\n5. To set a specific parallelization factor for another inner loop:\n   Use: \"Set the parallelization factor for the inner loop to 3\"\n   Code: `#pragma ACCEL PARALLEL FACTOR=auto{3}`\n\nBy following these natural language instructions, the given HLS codes can be generated in C with the appropriate #pragma values.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L8}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Process the iterations of the following loop in parallel, utilizing automatic factor calculation.\nDon't automatically pipeline this loop.\nProcess this loop in its original, full form without breaking it into smaller chunks.\nRun the iterations of this loop one after the other, not in parallel. Also, treat the following function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1 * i + 120;\n        int j_col = -1 * j + 120;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the following HLS codes in C:\n```c\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps, int n, double A[120], double B[120])\n{\n  int t;\n  int i;\n#pragma ACCEL PIPELINE auto{flatten}\n#pragma ACCEL TILE FACTOR=auto{1}\n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n}\n```\n\nYou can use the following concise natural language instructions for each #pragma directive:\n\n1. \"Treat the following function as a hardware kernel for acceleration\"\n   - `#pragma ACCEL kernel`\n\n2. \"Don't automatically pipeline this loop, maintain original structure\"\n   - `#pragma ACCEL PIPELINE auto{flatten}` \n\n3. \"Process this loop in its original, full form without breaking it into smaller chunks\"\n   - `#pragma ACCEL TILE FACTOR=auto{1}`\n\n4. \"Run the iterations of this loop in parallel with the specified factor\"\n   - `#pragma ACCEL PARALLEL FACTOR=auto{2}` for the outer loop\n   - `#pragma ACCEL PARALLEL FACTOR=auto{15}` for the first inner loop\n   - `#pragma ACCEL PARALLEL FACTOR=auto{1}` for the second inner loop", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}`", "1": "5. \"Complete kernel", "2": "5. \"Automatically decide unroll factor\"\n   - `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}`\n\n6. \"Automatically decide unroll factor\"\n   - `#pragma ACCEL PIPELINE auto{__PIPE__L2}`"}}
{"input": "Process the following function as a hardware kernel for acceleration.\nEnsure the loop iterations run in parallel, each with an auto-determined factor.\nDisable automatic loop pipelining.\nSet the loop tiling factor to be determined automatically.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 0 + 1L * 1L;\n        int _in_i = 0 + 1L * 1L;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes in C, use the following natural language instruction:\n\n\"Designate the following function as a hardware kernel for acceleration. Sequentially process the iterations of the outer loop, and parallelize the inner loop with a factor of 15. Automatically pipeline the loops and use a tiling factor of 1. Additionally, parallelize the second inner loop with a factor of 1.\"\n\nThis instruction encompasses the use of the following #pragma values:\n- '#pragma ACCEL kernel' to designate the function as a hardware kernel\n- '#pragma ACCEL PIPELINE auto{flatten}' to automatically pipeline the loops\n- '#pragma ACCEL TILE FACTOR=auto{1}' to apply a tiling factor of 1\n- '#pragma ACCEL PARALLEL FACTOR=auto{2}' to parallelize the outer loop\n- '#pragma ACCEL PARALLEL FACTOR=auto{15}' to parallelize the first inner loop with a factor of 15\n- '#pragma ACCEL PARALLEL FACTOR=auto{1}' to parallelize the second inner loop with a factor of 1", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i < 119; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 119; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1 * i;\n        int j_row = -1 * j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_col + 1][j_row + 1] - ex[i_col + 1][j_row] - ey[i_col + 1][j_row + 1] + ey[i_col + 1][j_row]);\n      }\n    }\n  }\n}"}}
{"input": "To generate the given C code with HLS pragmas, you should follow the natural language instructions below:\n\n- Apply automatic pipelining to the loop: '#pragma ACCEL PIPELINE auto{}'\n- Tile the loop with a factor determined automatically: '#pragma ACCEL TILE FACTOR=auto{1}'\n- Parallelize the loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{2}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{3}'\n- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{10}'", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "- Parallelize this nested loop with a factor determined automatically: '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}'\n\n#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L2}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L4}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L5}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L6}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}"}}
{"input": "Process the iterations of the first loop in parallel with a factor determined automatically, then disable automatic pipelining for this loop, and finally, process the second nested loop in parallel with a factor determined automatically and with a reduction performed in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL PIPELINE auto{off}\n\n#pragma ACCEL TILE FACTOR=auto{1}\n  for (j = 1; j <= q; j++) {\n    tmp2 = 0.0;\n    tmp4 = 0.0;\n    tmp5 = 0.0;\n    tmp6 = 0.0;\n\n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n\n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i <= p; i++) {\n      b1 = b[i * (q + 1)];\n      b2 = b[i * (q + 1) + q];\n      a11 = a[i][i];\n      a12 = a[i][j];\n      a21 = a[j][i];\n      a22 = a[j][j];\n      tmp1 = s * b1;\n      tmp3 = s * b2;\n      tmp2 += a12 * tmp1;\n      x[i] += tmp1;\n      x[j] += a12 * tmp3;\n      tmp4 += a11 * tmp1;\n      tmp5 += a22 * tmp3;\n      tmp6 += a21 * (x[i] - x[j]) + a12 * (x[j] - tmp);\n    }\n    x[j] = (x[j] - tmp2) / (-a22 * tmp4 + a11);\n    tmp = x[j];\n  }\n}"}}
{"input": "Process this loop in its original, full form without breaking it into smaller chunks\n#pragma ACCEL PIPELINE auto{off}\n\nDivide the loop into smaller chunks with a factor of 1 along the specified dimension\n#pragma ACCEL TILE FACTOR=auto{1}\n\nRun the iterations of this loop in parallel with a factor of 2\n#pragma ACCEL PARALLEL FACTOR=auto{2}\n\nTreat the following function as a hardware kernel for acceleration\n#pragma ACCEL kernel", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "void kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i - 1) + 1;\n        int j_col = 2L * (j - 1) + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_col][j_col + 1] - ex[i_col][j_col] + ey[i_col + 1][j_col] - ey[i_col][j_col]);\n      }\n    }\n  }\n}", "1": "void kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 2L * j;\n        int _in_i = 2L * i;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "void kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 2L * j;\n        int _in_i = 2L * i;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}"}}
{"input": "Process the following nested loops with tiling, automatically determine the tile factor for the outermost loop and use a tile factor of 8 for the middle loop. Pipeline the loops automatically, except for the innermost loop, which should be pipelined with a flatten option.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{8}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int orig_A[25][20],int sol[25][20])\n{\n  int r;\n  int c;\n  int k;\n  int j;\n  int i;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{8}\n    for (k = 1; k < 25; k++) {\n      j = 0;\n      i = 0;\n      i = ((int )((short )r)) * 20;\n      j = ((int )((short )k)) * 20;\n      sol[r][k] = orig_A[r][k];\n      \n#pragma ACCEL PARALLEL reduction=sol FACTOR=auto{1}\n      for (c = 0; c < 20; c++) {\n        if (c != j) {\n          sol[r][k] = sol[r][k] - orig_A[r][c] * ((double )(orig_A[r][j] / orig_A[j][j]));\n        }\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int orig_A[4096],int sol[4096],int filter[9])\n{\n  int r;\n  int c;\n  int k1;\n  int k2;\n  int temp;\n  int mul;\n  int u;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (r = 0; r < 32; r++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{8}\n    for (c = 0; c < 32; c++) {\n      temp = ((int )0);\n      mul = 0;\n      k1 = 0;\n      int _in_loop_k1 = 0;\n      for (k2 = 0; k2 < 32; k2++) {\n        for (k1 = 0; k1 < 3; k1++) {\n          mul = k1 * 32;\n          temp += filter[k1] * orig_A[(mul + r) * 32 + c];\n        }\n      }\n      u = sol[mul + r * 32 + c];\n      sol[mul + r * 32 + c] = u + temp;\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes in C, follow the natural language instructions provided below:\n\n1. Mark the following function as a hardware kernel for acceleration.\n   Use: 'Treat the following function as a hardware kernel for acceleration'.\n\n2. Don't automatically pipeline the loop.\n   Use: '#pragma ACCEL PIPELINE \"off\"'\n\n3. Process this loop in its original, full form without breaking it into smaller chunks.\n   Use: '#pragma ACCEL TILE FACTOR=1'\n\n4. Run the iterations of this loop one after the other, not in parallel.\n   Use: '#pragma ACCEL PARALLEL FACTOR=1'\n\n5. Auto-pipeline the loop with default settings.\n   Use: '#pragma ACCEL PIPELINE auto{}'\n\n6. Set the tiling factor of the loop to be determined automatically.\n   Use: '#pragma ACCEL TILE FACTOR=auto{1}'\n\n7. Set the parallelization factor of the loop to be determined automatically, with a default factor of 2.\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{2}'\n\n8. Set the parallelization factor of the loop to be determined automatically, with a specific factor of 16.\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{16}'\n\n9. Set the parallelization factor of the loop to be determined automatically, with a specific factor of 3.\n   Use: '#pragma ACCEL PARALLEL FACTOR=auto{3}'\n\nBy following these natural language instructions, you can generate the given HLS codes in C.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = j + 1;\n        int _in_i = i + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes in C, use the following natural language instruction:\n\n\"Annotate the function as a hardware kernel for acceleration, and for the loop iterations:\n- Enable automatic loop pipelining\n- Use an automatic tile factor of 1\n- Parallelize the outer loop with a factor of 2, and the inner loops with factors of 3 and 1 respectively.\"", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_low = 1 + 0 * (1L << 1);\n        int i_high = 1 + 1 * (1L << 1);\n        int j_low = 1 + 1 * (1L << 1);\n        int j_high = 1 + 0 * (1L << 1);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[j][i + 1] - ey[j][i]);\n      }\n    }\n  }\n}"}}
{"input": "To optimize the given C code for hardware acceleration, you should use the following HLS pragmas:\n\n1. Use `#pragma ACCEL PIPELINE off` to prevent automatic pipelining of the loop.\n\n2. Use `#pragma ACCEL TILE FACTOR=1` to process the loop in its original, full form without breaking it into smaller chunks.\n\n3. Use `#pragma ACCEL PARALLEL FACTOR=2` to execute iterations of the loop in parallel with a factor of 2.\n\n4. Finally, declare the function as a hardware kernel for acceleration using `#pragma ACCEL kernel`.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{24}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes in C:\n\n1. Activate kernel acceleration for the function 'kernel_jacobi_1d'.\n2. Deactivate automatic loop pipelining for all loops in the function.\n3. Set the loop tiling factor to 1 for maximum performance.\n4. Set the loop parallelization factor for the outer loop to 2, and for the inner loops to 3 and 12 respectively.\n\nThis set of natural language instructions describes how to use specific #pragma values for HLS code generation.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Generate HLS code for the given C code: \n\nUse the following pragma directives:\n1. Mark the function as a hardware kernel for acceleration: `#pragma ACCEL kernel`\n2. Turn off automatic pipelining for the outer two loops: `#pragma ACCEL PIPELINE auto{off}`\n3. Process the outer loops in their original, full form without breaking them into smaller chunks: `#pragma ACCEL TILE FACTOR=auto{1}`\n4. Apply automatic pipelining for the innermost loop: `#pragma ACCEL PIPELINE auto{}`\n5. Divide the innermost loop into chunks of 4 for tiling: `#pragma ACCEL TILE FACTOR=auto{4}`", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{}\n      \n#pragma ACCEL TILE FACTOR=auto{4}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{16}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}"}}
{"input": "Process the following function as a hardware kernel for acceleration. Don't automatically pipeline the loops. Process the loops in their original, full form without breaking them into smaller chunks. Run the iterations of the loops one after the other, not in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{}\n      \n#pragma ACCEL TILE FACTOR=auto{8}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i - 1) + 1;\n        int j_col = 2L * (j - 1) + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_col][j_col + 1] - ex[i_col][j_col] + ey[i_col + 1][j_col] - ey[i_col][j_col]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1*i;\n        int j_col = j + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_col][j] - ex[i][j_col]) - 0.7 * (ey[i][j_col] - ey[i_col][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i - 1) + 1;\n        int j_col = 2L * (j - 1) + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_col][j_col + 1] - ex[i_col][j_col] + ey[i_col + 1][j_col] - ey[i_col][j_col]);\n      }\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes in C, use the following natural language instructions and corresponding #pragma values:\n\n1. **Process this loop without automatic pipelining**: \n   - Describe: Ensure manual control over loop pipelining\n   - Pragma: `#pragma ACCEL PIPELINE \"off\"`\n\n2. **Keep the loop in its original, full form without breaking it into smaller chunks**:\n   - Describe: Set loop tiling factor to 1\n   - Pragma: `#pragma ACCEL TILE FACTOR=1`\n\n3. **Run the iterations of this loop one after the other, not in parallel**:\n   - Describe: Set loop parallelization factor to 1\n   - Pragma: `#pragma ACCEL PARALLEL FACTOR=1`\n\n4. **Treat the following function as a hardware kernel for acceleration**:\n   - Describe: Mark the function as a hardware accelerator\n   - Pragma: `#pragma ACCEL kernel`", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_3d(int tsteps,int n,double A[20][20][20],double B[20][20][20])\n{\n  int t;\n  int i;\n  int j;\n  int k;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 20; t++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (i = 1; i < 20 - 1; i++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n      for (j = 1; j < 20 - 1; j++) {\n        for (k = 1; k < 20 - 1; k++) {\n          B[i][j][k] = 0.2 * (A[i][j][k] - 0.13 * (A[i][j][k - 1] + A[i][j][k + 1] + A[i][j - 1][k] + A[i][j + 1][k] + A[i - 1][j][k] + A[i + 1][j][k]));\n        }\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    for (i = 1; i < 20 - 1; i++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n      for (j = 1; j < 20 - 1; j++) {\n        for (k = 1; k < 20 - 1; k++) {\n          A[i][j][k] = 0.2 * (B[i][j][k] - 0.13 * (B[i][j][k - 1] + B[i][j][k + 1] + B[i][j - 1][k] + B[i][j + 1][k] + B[i - 1][j][k] + B[i + 1][j][k]));\n        }\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes written in C, use the following natural language instructions for the specific #pragma values:\n\n1. For the outer loop, automatically pipeline the loop without flattening it: \n   ```\n   #pragma ACCEL PIPELINE auto{flatten}\n   ```\n\n2. Tile the loop with a factor automatically determined to be 1: \n   ```\n   #pragma ACCEL TILE FACTOR=auto{1}\n   ```\n\n3. Parallelize the outer loop with a factor automatically determined to be 2: \n   ```\n   #pragma ACCEL PARALLEL FACTOR=auto{2}\n   ```\n\n4. Parallelize the inner loop with a factor automatically determined to be 20: \n   ```\n   #pragma ACCEL PARALLEL FACTOR=auto{20}\n   ```\n\n5. Parallelize another inner loop with a factor automatically determined to be 1: \n   ```\n   #pragma ACCEL PARALLEL FACTOR=auto{1}\n   ```\n\nAdditionally, treat the `kernel_jacobi_1d` function as a hardware kernel for acceleration:\n```\n#pragma ACCEL kernel\n```", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "", "1": "", "2": "### Expected Results"}}
{"input": "To generate the given HLS codes in C, use the following high-level synthesis (HLS) pragmas:\n\n1. Treat the following function as a hardware kernel for acceleration\n   - Natural language instruction: \"Designate this function as a hardware kernel\"\n   - HLS pragma: #pragma ACCEL kernel\n\n2. Don't automatically pipeline this loop\n   - Natural language instruction: \"Do not automatically pipeline this loop\"\n   - HLS pragma: #pragma ACCEL PIPELINE \"off\"\n\n3. Process this loop in its original, full form without breaking it into smaller chunks\n   - Natural language instruction: \"Process this loop with a tile factor of 1\"\n   - HLS pragma: #pragma ACCEL TILE FACTOR=1\n\n4. Run the iterations of this loop one after the other, not in parallel\n   - Natural language instruction: \"Execute this loop sequentially, without parallelization\"\n   - HLS pragma: #pragma ACCEL PARALLEL FACTOR=1\n\nFor the placeholders \"auto\", \"__PARA__L0\", \"__PARA__L4\", \"__PARA__L1\", \"__PARA__L5\", \"__PARA__L2\", \"__PIPE__L3\", \"__TILE__L3\", \"__PIPE__L7\", and \"__PARA__L7_0\", the specific values for these placeholders should be determined based on the specific design and optimization goals. These values need to be chosen based on the particular characteristics and requirements of the target hardware architecture.", "output": "#include <math.h>\n#pragma ACCEL kernel\n\nvoid kernel_correlation(double float_n,double data[100][80],double corr[80][80],double mean[80],double stddev[80])\n{\n  int i;\n  int j;\n  int k;\n  double eps = 0.1;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n  for (j = 0; j < 80; j++) {\n    mean[j] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 100; i++) {\n      mean[j] += data[i][j];\n    }\n    mean[j] /= float_n;\n  }\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n  for (j = 0; j < 80; j++) {\n    stddev[j] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 0; i < 100; i++) {\n      stddev[j] += pow(data[i][j] - mean[j],(double )2);\n    }\n    stddev[j] /= float_n;\n    stddev[j] = sqrt(stddev[j]);\n/* The following in an inelegant but usual way to handle\n         near-zero std. dev. values, which below would cause a zero-\n         divide. */\n    stddev[j] = (stddev[j] <= eps?1.0 : stddev[j]);\n  }\n/* Center and reduce the column vectors. */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (i = 0; i < 100; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (j = 0; j < 80; j++) {\n      data[i][j] -= mean[j];\n      data[i][j] /= sqrt(float_n) * stddev[j];\n    }\n  }\n/* Calculate the m * m correlation matrix. */\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 80 - 1; i++) {\n    corr[i][i] = 1.0;\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L7}\n    for (j = i + 1; j < 80; j++) {\n      corr[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7_0}\n      for (k = 0; k < 100; k++) {\n        corr[i][j] += data[k][i] * data[k][j];\n      }\n      corr[j][i] = corr[i][j];\n    }\n  }\n  corr[80 - 1][80 - 1] = 1.0;\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L4}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_in_j = i * 240 + j;\n        int i_below_j = (i + 1) * 240 + j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL PIPELINE auto{__PIPE__L3} The current auto{__PIPE__L3} pipeline auto{__PIPE__L7} has been specified.\n #pragma ACCEL PIPELINE auto{__PIPE__L3}\n\n #pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n\n #pragma ACCEL PIPELINE auto{__PIPE__L7}\n\n #pragma ACCEL TILE FACTOR=auto{__TILE__L7}\n\n #pragma ACCEL PIPELINE auto{__PIPE__L1}\n\n #pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n\n #pragma ACCEL PIPELINE auto{__PIPE__L5}\n\n #pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n\n #pragma ACCEL PIPELINE auto{__PIPE__L4}\n\n #pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n\n #pragma ACCEL PIPELINE auto{__PIPE__L0}\n\n #pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n\n\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L7}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L7}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n      for (j = 0; j < 240 - 1; j++) {\n        int ii = 1 + 1 * i;\n        int jj = 1 + 1 * j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[ii][jj + 1] - ex[ii][jj] + ey[ii + 1][jj] - ey[ii][jj]);\n      }\n    }\n  }\n}"}}
{"input": "Process the loop iterations in parallel with an automatically determined factor, treat the following function as a hardware kernel for acceleration. For the loop that initializes array 's' with 0 values, do not automatically pipeline the loop. For the nested loop that performs matrix multiplication and reductions, process it in its original, full form without breaking it into smaller chunks.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L4}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L4}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes, use the following comprehensive but concise natural language instruction:\n\n\"Designate the following function as a hardware kernel for acceleration, and automatically pipeline the loop. Then, process the loop in its original, full form without breaking it into smaller chunks, and run the iterations of this loop in parallel with a factor of 2. Within the loop, also run certain iterations in further parallel with a factor of 3 and 10.\"\n\nThis instruction covers the use of the following #pragma values:\n1. '#pragma ACCEL kernel' to designate the function as a hardware kernel for acceleration\n2. '#pragma ACCEL PIPELINE auto{}' to automatically pipeline the loop\n3. '#pragma ACCEL TILE FACTOR=auto{1}' to process the loop in its original, full form without breaking it into smaller chunks\n4. '#pragma ACCEL PARALLEL FACTOR=auto{2}' to run the iterations of the loop in parallel with a factor of 2\n5. '#pragma ACCEL PARALLEL FACTOR=auto{3}' and '#pragma ACCEL PARALLEL FACTOR=auto{10}' to run specific iterations within the loop in further parallel with factors of 3 and 10, respectively.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_up = i + 1;\n        int j_right = j + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_up = i + 1;\n        int j_up = j + 1;\n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7_0}\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_up][j] - ex[i][j]) - 0.7 * (ey[i][j_up] - ey[i][j]) + 1.0 * q[i][j];\n      }\n    }\n  }\n}"}}
{"input": "Process the entire loop in its original, full form without breaking it into smaller chunks, run the iterations of this loop in parallel with automatic factor determination, and avoid automatically pipelining this loop. Treat the following function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        double  delx =  (double )(ex[i + 1][j + 1] - ex[i][j + 1]);\n        double  dely =  (double )(ey[i + 1][j + 1] - ey[i][j + 1]);\n        double  delz =  (double )(hz[i + 1][j + 1] - hz[i][j + 1]);\n        double  d = (delx * delx + dely * dely + delz * delz);\n        d = sqrt(d);\n        hz[i][j] = d;\n      }\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes in C, you would use the following natural language instruction:\n\n\"Mark the following function as a hardware kernel for acceleration and then specify specific optimizations for loops, such as: run the iterations of the loop one after the other, not in parallel; don't automatically pipeline this loop; and process this loop in its original, full form without breaking it into smaller chunks. Also, parallelize the following loop with a factor of 'auto'.\"\n\nThis comprehensive instruction covers the pragma values used in the provided HLS codes.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L4}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}"}}
{"input": "To generate the given HLS code in C, use the following natural language instruction:\n\n- \"Designate the following function as a hardware kernel for acceleration\"\n- \"For the outer loop, automatically pipeline the processing\"\n- \"Break the outer loop into smaller chunks in a way that best suits the target platform\"\n- \"For the middle loop, turn off automatic pipelining\"\n- \"Process the middle loop in its original, full form without breaking it into smaller chunks\"\n- \"For the innermost loop, flatten the loop for parallel processing\"\n- \"Process the innermost loop in its original, full form without breaking it into smaller chunks\"", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}"}}
{"input": "Process the calculations in the kernel function in parallel and treat the function as a hardware kernel for acceleration. The first loop should be parallelized with a parallel factor calculated automatically and the loop body processed without automatic pipelining. Use a tiling factor calculated automatically for the second loop and parallelize it with a factor calculated automatically, then add a reduction clause to the inner loop with a parallel factor calculated automatically.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Process the loop in its original, full form without breaking it into smaller chunks and don't automatically pipeline this loop, run the iterations of this loop one after the other, not in parallel. Treat the following function as a hardware kernel for acceleration.\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1 * i * nx;\n        int j_col = -1 * j * ny;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1;\n        int j_col = -1;\n        double d = 0.0;\n        double e = 0.0;\n        double f = 0.0;\n        double g = 0.0;\n        double h = 0.0;\n        double _in_ = ex[i][j];\n        e = ey[i][j + 1];\n        f = ey[i][j];\n        g = hz[i][j + 1];\n        h = hz[i][j];\n        d = _in_ + 0.25 * (g - h);\n        e -= 0.25 * (f - e);\n        g = ex[i + 1][j] + 0.25 * (h - g);\n        h = e + 0.25 * (d - f);\n        ex[i][j] = d;\n        ey[i][j + 1] = e;\n        hz[i + 1][j] = g;\n        hz[i][j + 1] = h;\n      }\n    }\n  }\n}"}}
{"input": "To generate the HLS codes written in C, use the following comprehensive but very concise natural language instructions for the specific #pragma values:\n\n- Treat the following function as a hardware kernel for acceleration\n  - describe: `#pragma ACCEL kernel`\n\n- Don't automatically pipeline this loop\n  - describe: `#pragma ACCEL PIPELINE \"off\"`\n\n- Process this loop in its original, full form without breaking it into smaller chunks\n  - describe: `#pragma ACCEL TILE FACTOR=1`\n\n- Run the iterations of this loop one after the other, not in parallel\n  - describe: `#pragma ACCEL PARALLEL FACTOR=1`\n\nThese instructions correspond to the HLS codes and their respective #pragma values in the given C code.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": ""}}
{"input": "To generate the given HLS code in C, you should:\n1. Treat the following function as a hardware kernel for acceleration.\n2. Don't automatically pipeline the loops.\n3. Process the loops with their original, full form without breaking them into smaller chunks.\n4. Run the iterations of the loops one after the other, not in parallel.\n\nThe natural language instructions for the pragma values are as follows:\n- '#pragma ACCEL kernel': Treat the following function as a hardware kernel for acceleration.\n- '#pragma ACCEL PIPELINE auto{off}': Don't automatically pipeline the loops.\n- '#pragma ACCEL TILE FACTOR=auto{1}': Process the loops with their original, full form without breaking them into smaller chunks.\n- '#pragma ACCEL PARALLEL FACTOR=auto{2}': Run the iterations of the loops one after the other, not in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction=D FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Process the first loop in parallel with a factor of 1, then pipeline the loop, and finally, process the second loop in parallel with a factor of 1 and utilize reduction for the inner loop.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (tj = 0; tj < 40; tj++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    for (tk = 0; tk < 40; tk++) {\n      tmp = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{__PARA__L5}\n      for (i = 0; i < 120; i++) {\n        tmp += A[i][tj] * B[i][tk];\n      }\n      C4[tj][tk] = tmp;\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (tj = 0; tj <= 31; tj++) {\n    double Si = 0.0;\n    double Sj = 0.0;\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (ti = 0; ti <= 31; ti++) {\n      Si += A[tj * 32 + ti] * B[ti];\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (ti = 0; ti <= 31; ti++) {\n      Sj += A[ti * 32 + tj] * B[ti];\n    }\n    P[tj] = Sj + Si;\n  }\n}"}}
{"input": "To generate the given HLS codes in C, apply the following comprehensive natural language instructions:\n\n1. Treat the following function as a hardware kernel for acceleration.\n\n2. Don't automatically pipeline the outermost loop.\n\n3. Process the outermost loop in its original, full form without breaking it into smaller chunks.\n\n4. Automatically pipeline the middle loop.\n\n5. Process the middle loop in its original, full form without breaking it into smaller chunks.\n\n6. Automatically pipeline the innermost loop.\n\n7. Process the innermost loop in its original, full form without breaking it into smaller chunks.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_gemver(int n,double alpha,double beta,double A[120][120],double u1[120],double v1[120],double u2[120],double v2[120],double w[120],double x[120],double y[120],double z[120])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 120; i++) {\n    x[i] = 0.0;\n    y[i] = 0.0;\n    z[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 120; i++) {\n    \n#pragma ACCEL PARALLEL reduction=x FACTOR=auto{__PARA__L5}\n    for (j = 0; j < 120; j++) {\n      x[i] += A[i][j] * u1[j];\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n  for (i = 0; i < 120; i++) {\n    \n#pragma ACCEL PARALLEL reduction=y FACTOR=auto{__PARA__L6}\n    for (j = 0; j < 120; j++) {\n      y[i] += A[i][j] * v1[j];\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n  for (i = 0; i < 120; i++) {\n    \n#pragma ACCEL PARALLEL reduction=z FACTOR=auto{__PARA__L7}\n    for (j = 0; j < 120; j++) {\n      z[i] += A[i][j] * u2[j] * v2[j];\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n  for (i = 0; i < 120; i++) {\n    w[i] = beta * w[i] + alpha * x[i] + y[i] + z[i];\n  }\n}"}}
{"input": "Process the following function as a hardware kernel for acceleration. Run the iterations of the first loop one after the other, not in parallel. Don't automatically pipeline the second loop. Process the second loop in its original, full form without breaking it into smaller chunks. Run the iterations of the third loop and the inner loop one after the other, not in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L8}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "Don't automatically pipeline the third loop. Pipeline the fourth loop with off\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[i - 1][j] + A[i - 1][j - 1] + A[i - 1][1 + j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[i - 1][j] + B[i - 1][j - 1] + B[i - 1][1 + j]);\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Process the nested loops in their original form, without breaking them into smaller chunks, and run the iterations of the loops one after the other, not in parallel. Additionally, treat the 'kernel_doitgen' function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{2}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int A[25][20][30],int B[25][20][30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        B[r][q][p] = ((long )0);\n      }\n    }\n    for (s = 0; s < 30; s++) {\n      for (q = 0; q < 20; q++) {\n        for (p = 0; p < 30; p++) {\n          if (p < s) {\n            B[r][q][p] += A[r][q][s] * B[r][q][s];\n          }\n        }\n      }\n    }\n    for (s = 0; s < 30; s++) {\n      for (q = 0; q < 20; q++) {\n        for (p = 0; p < 30; p++) {\n          if (s < p) {\n            B[r][q][p] += A[r][q][s] * B[r][q][s];\n          }\n        }\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int A[25][20][30],int B[25][20][30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        B[r][q][p] = ((long )r) * ((long )p) * 3 + ((long )q) * 2 + 1;\n      }\n    }\n    for (p = 0; p < 30; p++) {\n      A[r][0][p] = B[r][0][p];\n    }\n    for (s = 1; s < 20; s++) {\n      for (p = 0; p < 30; p++) {\n        A[r][s][p] = A[r][s - 1][p] + B[r][s][p];\n      }\n    }\n    for (p = 0; p < 30; p++) {\n      A[r][20][p] = B[r][20][p];\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int A[25][20][30],int B[25][20][30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        B[r][q][p] = ((long )r) * ((long )p) * 3 + ((long )q) * 2;\n      }\n    }\n    for (p = 0; p < 30; p++) {\n      A[r][0][p] = B[r][0][p];\n    }\n    for (s = 1; s < 20; s++) {\n      for (p = 0; p < 30; p++) {\n        A[r][s][p] = A[r][s - 1][p] + B[r][s][p];\n      }\n    }\n    for (p = 0; p < 30; p++) {\n      A[r][20][p] = B[r][20][p];\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS code in C, use the following natural language instructions:\n\n1. Treat the following function as a hardware kernel for acceleration.\n2. Don't automatically pipeline this loop.\n3. Process this loop in its original, full form without breaking it into smaller chunks.\n4. Run the iterations of this loop one after the other, not in parallel.\n\nApply these instructions to the respective pragma values in the code.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L8}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 2L * j;\n        int _in_i = 2L * i;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_up = i + 1;\n        int j_right = j + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_up][j] - ex[i][j]) - 0.7 * (ey[i][j_right] - ey[i][j]) ;\n      }\n    }\n  }\n}"}}
{"input": "Process the loop in its original, full form without breaking it into smaller chunks, and do not automatically pipeline it. Also, treat the following function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{2}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _row = i * 240 + j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _row = i * 240 + j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Process the loop with the original code as a hardware kernel for acceleration and automatically parallelize and pipeline the loop while leveraging reduction for parallelization. Use the pragma '#pragma ACCEL kernel' to mark the function as a hardware kernel, '#pragma ACCEL PARALLEL FACTOR=auto{1}' to automatically parallelize the loop, '#pragma ACCEL PIPELINE auto{flatten}' to automatically pipeline the loop, and '#pragma ACCEL PARALLEL reduction FACTOR=auto{1}' to automatically leverage reduction for parallelization.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[410][390],double s[390],double q[410],double p[390],double r[410])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 390; i++) {\n    s[i] = ((double )0);\n    q[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 410; i++) {\n    q[0] += r[i] * A[i][0];\n    s[0] += r[i] * A[i][0];\n// Product is removed from loop, as the following loop depends on it\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 1; j < 390; j++) {\n      q[j] += r[i] * A[i][j];\n      s[j] += A[i][j] * p[j];\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[410][390],double s[390],double q[410],double p[390],double r[410])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 390; i++) {\n    s[i] = ((double )0);\n    q[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 410; i++) {\n    q[0] += r[i] * A[i][0];\n    s[0] += r[i] * A[i][0];\n  }\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 390; i++) {\n    p[i] = q[i] / s[0];\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n  for (i = 0; i < 410; i++) {\n    int _in_j;\n    _in_j = 0;\n    j = 0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (j = 0; j < 390; j++) {\n      q[j] = 0.0;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (j = 0; j < 390; j++) {\n      q[ _in_j ] += r[i] * A[i][j];\n      s[ _in_j ] += r[i] * A[i][j];\n      _in_j = j;\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_gemver(int n,double alpha,double beta,double A[120][120],double u1[120],double v1[120],double u2[120],double v2[120],double w[120],double x[120],double y[120],double z[120])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 120; i++) {\n    for (j = 0; j < 120; j++) {\n      A[i][j] += + u1[i] * v1[j] + u2[i] * v2[j];\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 120; i++) {\n    x[i] = 0.0;\n    y[i] = 0.0;\n    z[i] = 0.0;\n  }\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 120; i++) {\n    double tmp_x = 0.0;\n    double tmp_y = 0.0;\n    double tmp_z = 0.0;\n    double tmp_A = 0.0;\n    int P = 1 + (((int )70) / i);\n    for (j = 1; j <= P * 70; j++) {\n      if (j < 1 + (i * 70)) {\n        tmp_x += x[j] + w[j] * v1[i] ;\n        tmp_y += y[j] + w[j] * v2[i] ;\n        tmp_z += z[j] + w[j] * A[i][j] ;\n      }\n    }\n    x[i] = tmp_x;\n    y[i] = tmp_y;\n    z[i] = tmp_z;\n    for (j = 1; j <= P * 70; j++) {\n      if (j < 1 + (i * 70)) {\n        A[i][j] = A[i][j] + alpha * (x[i] * v1[j] + y[i] * v2[j]);\n      }\n    }\n    z[i] = z[i] + 0.0 + beta * tmp_A;\n  }\n}"}}
{"input": "For the given C code, the comprehensive but very concise natural language instruction would be:\n\n\"Process this function as a hardware kernel for acceleration, turn off automatic pipelining on the loop, set the tile factor to 1, and run the loops in parallel with a factor of 2 and 3 respectively.\"\n\nThis would correspond to the following #pragma directives:\n```c\n#pragma ACCEL kernel\n#pragma ACCEL PIPELINE auto{off}\n#pragma ACCEL TILE FACTOR=auto{1}\n#pragma ACCEL PARALLEL FACTOR=auto{2}\n#pragma ACCEL PARALLEL FACTOR=auto{3}\n```", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "The ACCEL annotation for kernel is required to identify the kernel function, while other ACCEL annotations can be used to tune the performance of individual operations. \n\n# DRIVING FACTOR ANALYSIS\n## Summary of timing breakdown\n\n| Name                  | Min runtime | Max runtime | Avg runtime | Min period | Max period | Avg period |\n| --------------------- | ----------- | ----------- | ----------- | ---------- | ---------- | ---------- |\n| kernel_3mm            | 1.621040    | 2.000000    | 1.720641    | 128        | 128        | 128        |\n| kernel_3mm/kernel_3mm_1 | 0.000000    | 0.000000    | 0.000000    | 1          | 1          | 1          |\n| kernel_3mm/kernel_3mm_2 | 0.000000    | 0.000000    | 0.000000    | 64         | 64         | 64         |\n| kernel_3mm/kernel_3mm_3 | 0.000000    | 0.000000    | 0.000000    | 1          | 1          | 1          |\n| kernel_3mm/kernel_3mm_4 | 0.000000    | 0.000000    | 0.000000    | 16         | 16         | 16         |\n| kernel_3mm/kernel_3mm_5 | 0.000000    | 0.000000    | 0.000000    | 4          | 4          | 4          |\n\n## Detailed kernel: kernel_3mm\n#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "", "2": ""}}
{"input": "Process the following function as a hardware kernel for acceleration. For the loops inside this function, do not automatically pipeline them, and process them in their original, full form without breaking them into smaller chunks. However, run the iterations of each loop one after the other, not in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1*i;\n        int j_row = -1*j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_col + 1][j_row + 1] - ex[i_col + 1][j_row] - ey[i_col + 1][j_row + 1] + ey[i_col + 1][j_row]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_0}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[j];\n    }\n    \n#pragma ACCEL PIPELINE auto{off_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1_1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_1}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1_1_0}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1_2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_2}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1_2_0}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1_3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_3}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1_3_0}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes in C, use the following comprehensive but very concise natural language instructions:\n\n- Treat the following function as a hardware kernel for acceleration: `#pragma ACCEL kernel`\n- Don't automatically pipeline this loop: `#pragma ACCEL PIPELINE \"off\"`\n- Process this loop in its original, full form without breaking it into smaller chunks: `#pragma ACCEL TILE FACTOR=1`\n- Run the iterations of this loop one after the other, not in parallel: `#pragma ACCEL PARALLEL FACTOR=1`", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "- Do not distribute the computation of this loop over the threads: `#pragma ACCEL PARALLEL FACTOR=auto{1}`\n- Do not vectorize the computation of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{16} VECTOR=off`\n- Do not unroll the computation of this loop: `#pragma ACCEL PARALLEL FACTOR=auto{1} UNROLL=off`\n- Do not parallelize the computation of this loop on the outer loop: `#pragma ACCEL PIPELINE auto{off} {_pipeline_off}`\n- Do not parallelize the computation of this loop on the inner loop: `#pragma ACCEL PIPELINE auto{__PIPE__L2} {__PIPE__L2}`\n- Do not parallelize the computation of this loop on the inner-inner loop: `#pragma ACCEL PIPELINE auto{__PIPE__L3} {__PIPE__L3}`\n- Do not parallelize the computation of this loop on the outer-outer loop: `#pragma ACCEL PIPELINE auto{off} {_pipeline_off}`\n- Do not parallelize the computation of this loop on the outer-middle loop: `#pragma ACCEL PIPELINE auto{__PIPE__L1} {__PIPE__L1}`\n- Do not parallelize the computation of this loop on the middle-middle loop: `#pragma ACCEL PIPELINE auto{__PIPE__L4} {__PIPE__L4}`\n- Do not parallelize the computation of this loop on the middle-inner loop: `#pragma ACCEL PIPELINE auto{__PIPE__L5} {__PIPE__L5}`\n- Do not parallelize the computation of this loop on the outer-inner loop: `#pragma ACCEL PIPELINE auto{__PIPE__L6} {__PIPE__L6}`\n- Do not parallelize the computation of this loop on the outer-outer loop: `#pragma ACCEL PIPELINE auto{off} {_pipeline_off}`\n- Do not parallelize the computation of this loop on the outer-middle loop: `#pragma ACCEL PIPELINE auto{__PIPE__L1} {__PIPE__L1}`\n- Do not parallelize the computation of this loop on the middle-middle loop: `#pragma ACCEL PIPELINE auto{__PIPE__L4} {__PIPE__L4}`\n- Do not parallelize the computation of this loop on the middle-inner loop: `#pragma ACCEL PIPELINE auto{__PIPE__L5} {__PIPE__L5}`\n- Do not parallelize the computation of this loop on the outer-inner loop: `#pragma ACCEL PIPELINE auto{__PIPE__L6} {__PIPE__L6}`\n  \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _row = i * 240 + j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1;\n        int j_col = -1;\n        double dxy_2 = ex[i][j] * ex[i][j] + ey[i][j] * ey[i][j];\n        double dzt_2 = hz[i][j] * hz[i][j] + hz[i][j + 1] * hz[i][j + 1] + hz[i + 1][j] * hz[i + 1][j] + hz[i + 1][j + 1] * hz[i + 1][j + 1];\n        double rho = dzt_2 / (dzt_2 + 0.5);\n        double tmp = rho * (hz[i][j + 1] * ey[i][j + 1] - hz[i + 1][j + 1] * ey[i + 1][j + 1] + hz[i][j] * ey[i][j] - hz[i + 1][j] * ey[i + 1][j]);\n        double tmp_2 = rho * (hz[i + 1][j] * ex[i + 1][j] - hz[i][j] * ex[i][j] + hz[i + 1][j + 1] * ex[i + 1][j + 1] - hz[i][j + 1] * ex[i][j + 1]);\n        double dxx = dxy_2;\n        double dyy = dxy_2;\n        double dzx = tmp_2 + ex[i][j] * (-1.0 * (hz[i + 1][j + 1] + hz[i][j + 1]) + hz[i + 1][j] + hz[i][j]);\n        double dzy = tmp_2 + ey[i][j] * (-1.0 * (hz[i + 1][j + 1] + hz[i][j + 1]) + hz[i + 1][j + 1] + hz[i][j + 1]);\n        double dzz = 4.0 * (hz[i][j] - hz[i][j + 1] - hz[i + 1][j] + hz[i + 1][j + 1]);\n        ex[i][j] = dxx - dzx;\n        ey[i][j] = dyy - dzy;\n        hz[i][j] = dzz + tmp;\n      }\n    }\n  }\n}"}}
{"input": "Process the \"doitgen\" function as a hardware kernel for acceleration. Pipeline the outer loop, disable automatic pipelining for the middle loop, and flatten the inner loop. Use tiling with a factor of 8 for the outer loop, and a factor of 1 for the middle and inner loops.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[25][30],double B[25][23][30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n  int t;\n  double temp1;\n  double mul1;\n  double mul2;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  loop_r:\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    loop_q:\n    for (q = 0; q < 30; q++) {\n      C4[r][q] = A[r][0][q] * B[r][0][q];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    loop_p:\n    for (p = 1; p < 20; p++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n      loop_s:\n      for (s = 0; s < 30; s++) {\n        C4[r][s] += A[r][p][s] * B[r][p][s];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  loop_r_1:\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    loop_q_1:\n    for (q = 0; q < 30; q++) {\n      temp1 = 0.0;\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      loop_p_1:\n      for (p = 0; p < 23; p++) {\n        mul1 = A[r][p][q] * B[r][p][q];\n        mul2 = A[r][p][q] * C4[r][q];\n        temp1 = temp1 + mul1 + mul2;\n      }\n      A[r][0][q] = temp1;\n    }\n  }\n}"}}
{"input": "Process the loops in parallel with automatic factor determination to optimize performance\nUse pipeline optimization by automatic flattening to improve throughput\nApply tiling optimization with automatic factor determination\nUtilize parallel reduction for inner loop computation with automatic factor determination", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_gemm(double m1[4096],double m2[4096],double prod[4096])\n{\n  int i;\n  int j;\n  int k;\n  int k_col;\n  int i_col;\n  double mult;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  outer:\n  for (i = 0; i < 64; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    middle:\n    for (j = 0; j < 64; j++) {\n      i_col = i * 64;\n      double sum = (double )0;\n      \n#pragma ACCEL PARALLEL reduction=sum FACTOR=auto{1}\n      inner:\n      for (k = 0; k < 64; k++) {\n        k_col = k * 64;\n        mult = m1[i_col + k] * m2[k_col + j];\n        sum += mult;\n      }\n      prod[i_col + j] = sum;\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{2}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_gemver(int n,double alpha,double beta,double A[120][120],double u1[120],double v1[120],double u2[120],double v2[120],double w[120],double x[120],double y[120],double z[120])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 120; i++) {\n    x[i] = 0.0;\n    y[i] = 0.0;\n    z[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 120; i++) {\n    double tmp1 = 0.0;\n    double tmp2 = 0.0;\n    double u_ij = 0.0;\n    \n#pragma ACCEL PARALLEL reduction=u_ij FACTOR=auto{1}\n    for (j = 0; j < 120; j++) {\n      tmp1 = A[i][j] * u1[j] + v1[i] * A[i][j];\n      u_ij += A[i][j] * v1[j];\n      y[i] += A[i][j] * x[j];\n    }\n    e0: for (j = 0; j < 120; j++) {\n      x[j] = alpha * ((2.0 * y[i]) - x[j] - u_ij);\n      tmp2 += A[i][j] * x[j];\n    }\n    z[i] = beta * v2[i] + tmp1 + u1[i] * tmp2;\n    w[i] = x[i] + y[i] + z[i];\n  }\n}"}}
{"input": "Process the following function as a hardware kernel for acceleration. For the loop within, pipeline it automatically. Then, tile the loop with a factor of 25. Parallelize the loop with a factor of \"auto{__PARA__L0}\", and within that parallel loop, pipeline it off. Then, tile the next loop with a factor of 1, parallelize it with a factor of \"auto{__PARA__L1}\", and within that parallel loop, pipeline it automatically. Then, tile the next loop with a factor of 1, parallelize it with a factor of \"auto{__PARA__L2}\", and within that parallel loop, pipeline it with \"__PIPE__L3\". Finally, parallelize the remaining loop with a factor of 1, and within that loop, pipeline it with \"__PIPE__L7\".", "output": "#include <math.h>\n#pragma ACCEL kernel\n\nvoid kernel_correlation(double float_n,double data[100][80],double corr[80][80],double mean[80],double stddev[80])\n{\n  int i;\n  int j;\n  int k;\n  double eps = 0.1;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{25}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n  for (j = 0; j < 80; j++) {\n    mean[j] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 100; i++) {\n      mean[j] += data[i][j];\n    }\n    mean[j] /= float_n;\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n  for (j = 0; j < 80; j++) {\n    stddev[j] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 0; i < 100; i++) {\n      stddev[j] += pow(data[i][j] - mean[j],(double )2);\n    }\n    stddev[j] /= float_n;\n    stddev[j] = sqrt(stddev[j]);\n/* The following in an inelegant but usual way to handle\n         near-zero std. dev. values, which below would cause a zero-\n         divide. */\n    stddev[j] = (stddev[j] <= eps?1.0 : stddev[j]);\n  }\n/* Center and reduce the column vectors. */\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (i = 0; i < 100; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (j = 0; j < 80; j++) {\n      data[i][j] -= mean[j];\n      data[i][j] /= sqrt(float_n) * stddev[j];\n    }\n  }\n/* Calculate the m * m correlation matrix. */\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 80 - 1; i++) {\n    corr[i][i] = 1.0;\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L7}\n    for (j = i + 1; j < 80; j++) {\n      corr[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7_0}\n      for (k = 0; k < 100; k++) {\n        corr[i][j] += data[k][i] * data[k][j];\n      }\n      corr[j][i] = corr[i][j];\n    }\n  }\n  corr[80 - 1][80 - 1] = 1.0;\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{25}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{25}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{25}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L7}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L7}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{25}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{25}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[j];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L7}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n      for (j = 0; j < 240 - 1; j++) {\n        double  _val_27 = 0.0;\n        double  _val_28 = 0.0;\n        double  _val_29 = 0.0;\n        double  _val_30 = 0.0;\n        double  _val_31 = 0.0;\n        double  _val_32 = 0.0;\n        double  _val_33 = 0.0;\n        double  _val_34 = 0.0;\n        double  _val_35 = 0.0;\n        double  _val_36 = 0.0;\n        double  _val_37 = 0.0;\n        double  _val_38 = 0.0;\n        double  _val_39 = 0.0;\n        double  _val_40 = 0.0;\n        double  _val_41 = 0.0;\n        double  _val_42 = 0.0;\n        double  _val_43 = 0.0;\n\t_val_27 = ex[i][j + 1] - ex[i][j];\n\t_val_28 = ey[i + 1][j] - ey[i][j];\n\t_val_29 = hz[i + 1][j] - hz[i][j];\n\t_val_30 = _val_27 * _val_28 - _val_29;\n\t_val_31 = _val_27 * _val_29 + _val_28 * _val_29;\n\t_val_32 = ex[i + 1][j + 1] - ex[i][j + 1];\n\t_val_33 = ey[i + 1][j + 1] - ey[i][j + 1];\n\t_val_34 = hz[i + 1][j + 1] - hz[i][j + 1];\n\t_val_35 = _val_32 * _val_33 - _val_34;\n\t_val_36 = _val_32 * _val_34 + _val_33 * _val_34;\n\t_val_37 = _val_31 + _val_36;\n\t_val_38 = _val_31 - _val_36;\n\t_val_39 = ey[i + 1][j] - ey[i][j];\n\t_val_40 = hz[i + 1][j] - hz[i][j];\n\t_val_41 = ex[i + 1][j] - ex[i][j];\n\t_val_42 = hz[i + 1][j + 1] - hz[i][j + 1];\n\t_val_43 = _val_39 * _val_40 - _val_41 * _val_42;\n\tex[i][j] = _val_30 / _val_37;\n\tey[i][j] = (_val_31 * _val_42 - _val_34 * _val_41) / _val_37;\n\thz[i][j] = (_val_36 * _val_41 - _val_35 * _val_40) / _val_37;\n\tex[i][j + 1] = _val_38 / _val_37;\n\thz[i][j + 1] = (_val_43) / _val_37;\n      }\n    }\n  }\n}"}}
{"input": "Process the first loop in parallel, automatically determine the parallel factor for optimization. Pipeline the loop automatically using the flatten design. For the second loop, use automatic tiling with a factor of 1. Also, process the second loop in parallel, automatically determining the parallel factor. Apply reduction for the inner parallel loop automatically to optimize. Finally, treat the function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction=D FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[410][390],double s[390],double q[410],double p[390],double r[410])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PARALLEL FACTOR=auto{29}\n  for (i = 0; i < 390; i++) {\n    s[i] = ((double )0);\n    q[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 410; i++) {\n    q[0] += r[i] * A[i][0];\n    s[0] += r[i] * A[i][0];\n//#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (j = 1; j < 390; j++) {\n      q[j] += r[i] * A[i][j];\n      s[j] += r[i] * A[i][j];\n      p[i] = s[j] - q[j];\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction FACTOR=auto{4}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Process the following function as a hardware kernel for acceleration and apply the following directives to the loops:\n1. Disable automatic pipelining for the outermost loop.\n2. Use a tile factor of 1 for both the outermost and the middle loops.\n3. Disable automatic pipelining for the innermost loop, and use a tile factor of 2.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{2}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the following HLS codes in C, you should:\n- Use the pragma #pragma ACCEL kernel to tag the function as a hardware kernel for acceleration.\n- Use #pragma ACCEL PIPELINE auto{} to automatically pipeline the loops.\n- Use #pragma ACCEL TILE FACTOR=8 to break the loop into smaller chunks of size 8.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L0 to run the iterations of the loop in parallel with the specified factor.\n- Use #pragma ACCEL PIPELINE auto{off} to turn off automatic pipelining.\n- Use #pragma ACCEL TILE FACTOR=1 to process the loop in its original, full form without breaking it into smaller chunks.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L1 to run the iterations of the loop in parallel with the specified factor.\n- Use #pragma ACCEL PIPELINE auto{off} to explicitly turn off automatic pipelining.\n- Use #pragma ACCEL TILE FACTOR=1 to process the loop in its original, full form without breaking it into smaller chunks.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L2 to run the iterations of the loop in parallel with the specified factor.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L3} to pipeline the loop with a specific pipeline identifier.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L3 to break the loop into smaller chunks and specify a tile identifier.\n- Use #pragma ACCEL PARALLEL FACTOR=1 to run the iterations of the loop in parallel with a factor of 1.", "output": "#include <math.h>\n#pragma ACCEL kernel\n\nvoid kernel_correlation(double float_n,double data[100][80],double corr[80][80],double mean[80],double stddev[80])\n{\n  int i;\n  int j;\n  int k;\n  double eps = 0.1;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n  for (j = 0; j < 80; j++) {\n    mean[j] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 100; i++) {\n      mean[j] += data[i][j];\n    }\n    mean[j] /= float_n;\n  }\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n  for (j = 0; j < 80; j++) {\n    stddev[j] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 0; i < 100; i++) {\n      stddev[j] += pow(data[i][j] - mean[j],(double )2);\n    }\n    stddev[j] /= float_n;\n    stddev[j] = sqrt(stddev[j]);\n/* The following in an inelegant but usual way to handle\n         near-zero std. dev. values, which below would cause a zero-\n         divide. */\n    stddev[j] = (stddev[j] <= eps?1.0 : stddev[j]);\n  }\n/* Center and reduce the column vectors. */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (i = 0; i < 100; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (j = 0; j < 80; j++) {\n      data[i][j] -= mean[j];\n      data[i][j] /= sqrt(float_n) * stddev[j];\n    }\n  }\n/* Calculate the m * m correlation matrix. */\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 80 - 1; i++) {\n    corr[i][i] = 1.0;\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L7}\n    for (j = i + 1; j < 80; j++) {\n      corr[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7_0}\n      for (k = 0; k < 100; k++) {\n        corr[i][j] += data[k][i] * data[k][j];\n      }\n      corr[j][i] = corr[i][j];\n    }\n  }\n  corr[80 - 1][80 - 1] = 1.0;\n}\n", "predicted": {"0": "- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L4 FAILED_KERNEL auto{__PARA__L4} to run the iterations of the loop in parallel with the specified factor.\n \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_0 = i;\n        int j_0 = j;\n        hz[i_0][j_0] = hz[i_0][j_0] - 0.7 * (ex[i_0][j_0 + 1] - ex[i_0][j_0] + ey[i_0 + 1][j_0] - ey[i_0][j_0]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_up = i + 1;\n        int j_up = j + 1;\n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_up][j] - ex[i][j]) - 0.7 * (ey[i][j_up] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L4__L3 to parallelize the loops within the outer loop of this layer.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L4} to pipeline the loops within this layer.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L4 to set the tile factors.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L5__L4 to parallelize the loops within the outer loop of this layer.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L5} to pipeline the loops within this layer.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L5 to set the tile factors.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L6__L4 to parallelize the loops within the outer loop of this layer.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L6} to pipeline the loops within this layer.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L6 to set the tile factors.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L7__L4 to parallelize the loops within the outer loop of this layer.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L7} to pipeline the loops within this layer.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L7 to set the tile factors.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L8__L4 to parallelize the loops within the outer loop of this layer.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L8} to pipeline the loops within this layer.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L8 to set the tile factors.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L9__L4 to parallelize the loops within the outer loop of this layer.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L9} to pipeline the loops within this layer.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L9 to set the tile factors.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L10__L4 to parallelize the loops within the outer loop of this layer.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L10} to pipeline the loops within this layer.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L10 to set the tile factors.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L11__L4 to parallelize the loops within the outer loop of this layer.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L11} to pipeline the loops within this layer.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L11 to set the tile factors.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L12__L4 to parallelize the loops within the outer loop of this layer.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L12} to pipeline the loops within this layer.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L12 to set the tile factors.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L13__L4 to parallelize the loops within the outer loop of this layer.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L13} to pipeline the loops within this layer.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L13 to set the tile factors.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L14__L4 to parallelize the loops within the outer loop of this layer.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L14} to pipeline the loops within this layer.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L14 to set the tile factors.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L15__L4 to parallelize the loops within the outer loop of this layer.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L15} to pipeline the loops within this layer.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L15 to set the tile factors.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L16__L4 to parallelize the loops within the outer loop of this layer.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L16} to pipeline the loops within this layer.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L16 to set the tile factors.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L17__L4 to parallelize the loops within the outer loop of this layer.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L17} to pipeline the loops within this layer.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L17 to set the tile factors.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L18__L4 to parallelize the loops within the outer loop of this layer.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L18} to pipeline the loops within this layer.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L18 to set the tile factors.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L19__L4 to parallelize the loops within the outer loop of this layer.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L19} to pipeline the loops within this layer.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L19 to set the tile factors.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L20__L4 to parallelize the loops within the outer loop of this layer.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L20} to pipeline the loops within this layer.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L20 to set the tile factors.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L21__L4 to parallelize the loops within the outer loop of this layer.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L21} to pipeline the loops within this layer.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L21 to set the tile factors.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L22__L4 to parallelize the loops within the outer loop of this layer.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L22} to pipeline the loops within this layer.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L22 to set the tile factors.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L23__L4 to parallelize the loops within the outer loop of this layer.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L23} to pipeline the loops within this layer.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L23 to set the tile factors.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L24__L4 to parallelize the loops within the outer loop of this layer.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L24} to pipeline the loops within this layer.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L24 to set the tile factors.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L25__L4 to parallelize the loops within the outer loop of this layer.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L25} to pipeline the loops within this layer.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L25 to set the tile factors.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L26__L4 to parallelize the loops within the outer loop of this layer.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L26} to pipeline the loops within this layer.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L26 to set the tile factors.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L27__L4 to parallelize the loops within the outer loop of this layer.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L27} to pipeline the loops within this layer.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L27 to set the tile factors.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L28__L4 to parallelize the loops within the outer loop of this layer.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L28} to pipeline the loops within this layer.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L28 to set the tile factors.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L29__L4 to parallelize the loops within the outer loop of this layer.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L29} to pipeline the loops within this layer.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L29 to set the tile factors.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L30__L4 to parallelize the loops within the outer loop of this layer.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L30} to pipeline the loops within this layer.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L30 to set the tile factors.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L31__L4 to parallelize the loops within the outer loop of this layer.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L31} to pipeline the loops within this layer.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L31 to set the tile factors.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L32__L4 to parallelize the loops within the outer loop of this layer.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L32} to pipeline the loops within this layer.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L32 to set the tile factors.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L33__L4 to parallelize the loops within the outer loop of this layer.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L33} to pipeline the loops within this layer.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L33 to set the tile factors.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L34__L4 to parallelize the loops within the outer loop of this layer.\n- Use #pragma ACCEL PIPELINE auto{__PIPE__L34} to pipeline the loops within this layer.\n- Use #pragma ACCEL TILE FACTOR=__TILE__L34 to set the tile factors.\n- Use #pragma ACCEL PARALLEL FACTOR=__PARA__L35__L4 to parallelize the loops within the outer loop of this layer.\n- Use #pragma ACCEL PIPELINE"}}
{"input": "To generate the given HLS codes, use the following concise natural language instructions for each #pragma directive:\n\n1. For the directive '#pragma ACCEL PIPELINE auto{off}', use \"Don't automatically pipeline this loop.\"\n2. For the directive '#pragma ACCEL TILE FACTOR=auto{1}', use \"Process this loop in its original, full form without breaking it into smaller chunks.\"\n3. For the directive '#pragma ACCEL PARALLEL FACTOR=auto{2}', use \"Run the iterations of this loop one after the other, not in parallel.\"\n4. For the directive '#pragma ACCEL PARALLEL FACTOR=auto{3}', use \"Run iterations of this loop in parallel with a factor of 3.\"\n5. For the directive '#pragma ACCEL PARALLEL FACTOR=auto{12}', use \"Run iterations of this loop in parallel with a factor of 12.\"\n\nBy following these natural language instructions, you can organize the HLS codes in C as specified.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        double  delta = 1.0 / (1.0 + exp((double )(- 5.0)));\n        hz[i][j] = hz[i][j] + 0.25 * delta * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes written in C, you can use the following natural language instruction:\n\n\"Mark the following function as a hardware kernel for acceleration. Then, for the loops inside the function: run the iterations of the first loop in parallel, pipeline the loop after that, and then break down the third loop into smaller chunks using tiling, and finally, run the innermost loop iterations in parallel with reduction.\"\n\nThis instruction gives a comprehensive but concise overview of the process and the specific #pragma values to use.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n  int t;\n  int a;\n  int b;\n  double Ar_pS;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  loop_r:\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    loop_q:\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      loop_p:\n      for (p = 0; p < 30; p++) {\n        Ar_pS = A[r][q][p];\n        loop_a:\n        for (a = 0; a < 5; a++) {\n          loop_b:\n          for (b = 0; b < 4; b++) {\n            A[r][a + q][b + p] = Ar_pS * A[a + q][b + p][p];\n          }\n        }\n        A[r][q][p] = Ar_pS;\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction=D FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Perform the following operations on the given C code:\n\n- Treat the function as a hardware kernel for acceleration.\n- Run the iterations of the first loop in parallel.\n- Apply automatic pipeline flattening to the loop.\n- Keep the loop in its original form without breaking it into smaller chunks.\n- Run the iterations of the second loop one after the other, not in parallel, and use reduction for parallel operation.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[410][390],double s[390],double q[410],double p[390],double r[410])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n  for (i = 0; i < 390; i++) {\n    s[i] = ((double )0);\n    q[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n  for (i = 0; i < 410; i++) {\n    q[0] += r[i] * A[i][0];\n    s[0] += r[i] * A[i][0];\n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 1; j < 390; j++) {\n      q[j] += r[i] * A[i][j];\n      s[j] += A[i][j] * p[j];\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the HLS codes written in C, use the following natural language instruction:\n\"Declare the following function as a hardware kernel for acceleration. Then, don't automatically pipeline the loop, process the loop in its original, full form without breaking it into smaller chunks, and run the iterations of this loop one after the other, not in parallel. Set the tile factor and parallel factor as auto for optimization.\"\n\nThese instructions correspond to the following #pragma values:\n- '#pragma ACCEL kernel'\n- '#pragma ACCEL PIPELINE auto{}'\n- '#pragma ACCEL TILE FACTOR=auto{1}'\n- '#pragma ACCEL PARALLEL FACTOR=auto{2}'\n- '#pragma ACCEL PARALLEL FACTOR=auto{10}'\n- '#pragma ACCEL PARALLEL FACTOR=auto{6}'", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _row = i * 240 + j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 2L * j;\n        int _in_i = 2L * i;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _row = i * 240 + j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes in C, use the following natural language instructions for the respective #pragma values:\n\n1. For the function 'kernel_jacobi_1d', mark it as a hardware kernel for acceleration.  \n   Instruction: \"Treat the following function as a hardware kernel for acceleration\"\n\n2. For the loop containing the 't' variable, do not automatically pipeline it.  \n   Instruction: \"Don't automatically pipeline this loop\"\n\n3. For the loop containing the 't' variable, process it in its original, full form without breaking it into smaller chunks.  \n   Instruction: \"Process this loop in its original, full form without breaking it into smaller chunks\"\n\n4. For the loop containing the 't' variable, run the iterations one after the other, not in parallel.  \n   Instruction: \"Run the iterations of this loop one after the other, not in parallel\"\n\n5. For the inner loop containing the 'i' variable, run the iterations in parallel with a factor of 2.  \n   Instruction: \"Run the iterations of this loop in parallel with a factor of 2\"\n\n6. For the inner loop containing the 'i' variable, run the iterations in parallel with a factor of 3.  \n   Instruction: \"Run the iterations of this loop in parallel with a factor of 3\"\n\n7. For the inner loop containing the 'i' variable, run the iterations in parallel with a factor of 10.  \n   Instruction: \"Run the iterations of this loop in parallel with a factor of 10\"", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "8. For the inner loop containing the 'i' variable, distribute the loop across 1 compute node.  \n   Instruction: \"Distribute this loop to 1 compute node\"\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Process the following function as a hardware kernel for acceleration, automatically parallelize the outer loop with factor 1, and automatically pipeline the inner loop with the flatten optimization.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes written in C, use the following comprehensive but concise natural language instruction:\n\n- Mark the following function as a hardware kernel for acceleration.\n- Don't automatically pipeline the loops.\n- Process the loops with their original, full form without breaking them into smaller chunks.\n- Run the iterations of the loops one after the other, not in parallel.\n- Turn on automatic parallelization with a factor of 30.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 2 * j;\n        int _in_i = 2 * i;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][_in_j + 1] - ex[i][_in_j] + ey[ _in_i + 1][j] - ey[ _in_i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_gemver(int n,double alpha,double beta,double A[120][120],double u1[120],double v1[120],double u2[120],double v2[120],double w[120],double x[120],double y[120],double z[120])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 120; i++) {\n    z[i] = 0.0;\n    y[i] = 0.0;\n    double tmp = 0.0;\n    double tmp_x = 0.0;\n    double tmp_y = 0.0;\n    double Ai;\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 120; j++) {\n      Ai = A[i][j];\n      z[i] = Ai * v1[j] + z[i];\n      y[i] = u1[j] * Ai + y[i];\n      tmp += Ai * u2[j];\n      tmp_x += Ai * v2[j] * x[j];\n      tmp_y += Ai * v2[j] * y[j];\n    }\n    x[i] = beta * x[i] + alpha * u1[i] * y[i] + z[i];\n    y[i] = beta * y[i] + alpha * tmp;\n    double tmp_x_ = x[i];\n    double tmp_y_ = y[i];\n    double A_i = A[i][i];\n    x[i] = A_i * tmp_x_ + (1.0 + alpha) * x[i];\n    y[i] = A_i * tmp_y_ + (1.0 + alpha) * y[i];\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{30}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Process the entire function as a hardware kernel and automatically pipeline the outer loop, tile the loop with a factor of 1 and parallelize the outer loop with a factor of 2 and the inner loops with factors of 30 and 10 respectively.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 35; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{30}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes in C, use the following comprehensive but concise natural language instructions for the specific #pragma values:\n\n1. Treat the following function as a hardware kernel for acceleration:\n   - Use `#pragma ACCEL kernel`\n\n2. Don't automatically pipeline this loop:\n   - Use `#pragma ACCEL PIPELINE \"off\"`\n\n3. Process this loop in its original, full form without breaking it into smaller chunks:\n   - Use `#pragma ACCEL TILE FACTOR=1`\n\n4. Run the iterations of this loop one after the other, not in parallel:\n   - Use `#pragma ACCEL PARALLEL FACTOR=1`\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "5. Automatically parallelize this loop with a factor of 2:\n   - Use `#pragma ACCEL PARALLEL FACTOR=auto{2}`\n\n  \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "5. Do not change the order of the following two for loops even though they are currently in the wrong order:\n   - #pragma ACCEL PIPELINE auto{__PIPE__L2}\n   - #pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL THREAD FACTOR=1`\n\n  \n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_in_j;\n        int i_n;\n        int j_1;\n        int j_in_i;\n        int j_n;\n        double a;\n        double b;\n        double c;\n        double d;\n        double e;\n        double f;\n        double g;\n        double h;\n        double _in;\n        double _out;\n        \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n\t\ti_n = 2L;\n\t\tj_n = 2L;\n\t\ta = ex[i][j];\n\t\tb = ey[i][j];\n\t\tc = hz[i][j];\n\t\td = ex[i][j + 1];\n\t\te = ey[i][j + 1];\n\t\tf = hz[i][j + 1];\n\t\tg = ex[i + 1][j];\n\t\th = ey[i + 1][j];\n\t\t_in = a * b - c;\n\t\t_out = a * h + b * g - c;\n\t\ti_in_j = i * nx + j;\n\t\tj_1 = j + 1;\n\t\tj_in_i = i * ny + j;\n\t\tex[i][j] = _out;\n\t\tey[i][j] = _in;\n\t\thz[i][j] = _out + (( (d - e) * (b - g)) + ((f - h) * (a - c)) ) / (2.0 * (2.0 * 2.0));\n      }\n    }\n  }\n}"}}
{"input": "To optimize the given C code with HLS, first, mark the function as a hardware kernel using '#pragma ACCEL kernel'. Then, disable automatic pipelining with '#pragma ACCEL PIPELINE auto{off}'. After that, set the tiling factor to 1 for the outermost loop with '#pragma ACCEL TILE FACTOR=auto{1}'. Inside the nested loops, enable automatic pipelining and set the tiling factor to 4 using '#pragma ACCEL PIPELINE auto{flatten}' and '#pragma ACCEL TILE FACTOR=auto{4}' respectively. Additionally, disable automatic pipelining and set the tiling factor to 1 for the innermost loop using '#pragma ACCEL PIPELINE auto{off}' and '#pragma ACCEL TILE FACTOR=auto{1}'.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}"}}
{"input": "Process the first loop in parallel considering an optimal factor automatically. Disable automatic pipelining for this section of code. Divide the iterations of the next loop into smaller chunks for acceleration, using an optimal factor. Finally, execute the following loop in parallel, automatically determining the optimal factor for parallelization and including reduction operations. Remember that the entire function should be treated as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes in C, follow these comprehensive but concise natural language instructions:\n- Mark the function as a hardware kernel for acceleration\n- Do not automatically pipeline the loop\n- Process the loop in its original, full form without breaking it into smaller chunks\n- Run the iterations of this loop one after the other, not in parallel\n- Run the iterations of this loop with a parallel factor of 30\n- Run the iterations of this loop with a parallel factor of 10", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1024}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma AES AES192\n \n// Expkey Schedule\n \n#pragma AES key = {68,136,200,232,149,181,213,245,27,58,90,122,154,186,218,250,42,74,106,138,170,202,234,266,298,194,226,258,32,60,92,124,156,188,220,252,33,61,93,125,157,189,221,253,36,64,96,128,160,192,224,256,41,73,105,137,169,201,233,265,35,67,99,131,163,195,227,259}\n \n// Plaintext\n \n#pragma AES plaintext = {92,3,218,88,169,23,187,242,121,188,49,73,247,123,22,82,172,18,194,223,171,13,220,119,185,234,11,239,170,249,214,61,126,254,21,250,143,114,181,196,228,116,151,235,183,149,113,48,140,236,225,102,155,251,145,122,193,135,248,109,158,231,137,243,79,142,215,238,200,55,112,246,17,209,213,230,110,134,105,255,241,162,207,190,131,99,117,244,168,199,124,91,52,83,141,198,167,108,47,138,101,78,217,240,153,86,233,212,150,89,71,203,237,211,159,80,222,139,104,216,245,205,174,77,90,239,20,152,221,127,252,95,44,107,139,253,224,163,195,241,173,210,98,144,115,219,247,166,100,54,120,235,218,249,133,227,182,161,125,175,74,197,231,25,147,118,243,217,155,103,46,208,191,136,97,223,169,206,177,111,43,157,76,185,232,178,202,141,110,229,251,128,220,63,94,137,242,184,201,165,192,215,130,234,75,143,194,230,254,82,158,225,179,24,150,222,129,255,243,172,205,180,144,112,228,250,161,93,66,134,246,213,248,176,209,147,117,221,253,187,239,210,151,85,214,241,164,196,232,142,114,70,168,235,216,247,181,203,154,116,42,148,231,219,245,175,207,149,119,224,251,167,96,69,136,243,190,212,237,186,200,156,120,218,244,178,202,150,87,221,255,183,237,209,153,81,196,231,215,247,179,203,145,115,228,252,163,92,65,132,245,191,213,240,174,206,147,117,222,254,185,239,211,153,83,198,232,216,249,177,201,149,119,225,251,169,98,62,130,244,192,214,238,188,202,152,114,220,253,171,235,217,250,165,95,68,136,247,194,216,241,177,201,153,115,219,245,183,237,211,155,87,214,241,164,196,232,142,114,78,223,207,171,235,221,167,100,52,82,144,197,231,255,190,222,138,99,116,244,168,199,124,91,54,84,142,196,231,253,174,207,149,119,224,251,170,92,65,133,246,188,210,241,172,205,147,117,221,253,185,239,211,151,83,194,231,215,247,179,203,145,115,228,252,163,94,67,135,244,192,214,238,186,200,152,114,220,253,171,235,217,250,165,96,68,136,247,194,216,241,177,201,149,119,224,251,170,92,65,134,244,192,214,238,186,200,152,114,220,253,171,235,217,250,165,95,68,135,244,192,214,238,186,200,152,114,220,253,171,235,217,250,165,95,68,135,244,192,214,238,186,200,152,114,220,253,171,235,217,250,165,95,68,135,244,192,214,238,186,200,152,114,220,253,171,235,217,250,165,95,68,135,244,192,214,238,186,200,152,114,220,253,171,235,217,250,165,95,68,135,244,192,214,238,186,200,152,114,220,253,171,235,217,250,165,95,68,135,244,192,214,238,186,200,152,114,220,253,171,235,217,250,165,95,68,135,244,192,214,238,186,200,152,114,220,253,171,235,217,250,165,95,68,135,244,192,214,238,186,200,152,114,220,253,171,235,217,250,165,95,68,135,244,192,214,238,186,200,152,114,220,253,171,235,217,250,165,95,68,135,244,192,214,238,186,200,152,114,220,253,171,235,217,250,165,95,68,135,244,192,214,238,186,200,152,114,220,253,171,235,217,250,165,95,68,135,244,192,214,238,186,200,152,114,220,253,171,235,217,250"}}
{"input": "To generate the given HLS codes, use the following comprehensive natural language instruction:\n\n\"Transform the function into a hardware kernel for acceleration. Then, disable automatic pipelining for the loop, set the tiling factor to 1, and ensure parallelism by setting the parallel factor to 2. Within the loop, apply a parallel factor of 30 for the first inner loop and 10 for the second inner loop.\"", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_gemver(int n,double alpha,double beta,double A[120][120],double u1[120],double v1[120],double u2[120],double v2[120],double w[120],double x[120],double y[120],double z[120])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 120; i++) {\n    x[i] = 0.0;\n    y[i] = 0.0;\n    z[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 120; i++) {\n    x[i] += 1.0;\n  }\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 120; i++) {\n    for (j = 0; j < 120; j++) {\n      A[i][j] += u1[i] * v1[j] + u2[i] * v2[j];\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n  for (i = 0; i < 120; i++) {\n    y[i] += 1.0;\n    double tmp2 = 0.0;\n    double tmp1 = 0.0;\n    for (j = 0; j < 120; j++) {\n      tmp2 += A[i][j] * y[j];\n    }\n    tmp1 = alpha * tmp2 + beta * z[i];\n    x[i] += tmp1;\n    w[i] = x[i] + y[i];\n    z[i] = beta * w[i];\n  }\n}"}}
{"input": "Process the loop in its original, full form without breaking it into smaller chunks. Automatically pipeline and flatten the loop. Run the iterations of the loop in parallel with a reduction factor of 1_0 for the temporary array and a reduction factor of 1_1 for the final result array. Treat the following function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_atax(int m,int n,double A[116][124],double x[124],double y[124],double tmp[116])\n{\n  int i;\n  int j;\n//#pragma scop\n  for (i = 0; i < 124; i++) \n    y[i] = ((double )0);\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{116}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    tmp[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1_0}\n    for (j = 0; j < 124; j++) {\n      tmp[i] += A[i][j] * x[j];\n    }\n    \n#pragma ACCEL PARALLEL reduction=y FACTOR=auto{1_1}\n    for (j = 0; j < 124; j++) {\n      y[j] += A[i][j] * tmp[i];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes in C, use the following natural language instruction:\n\n\"Designate the following function as a hardware kernel for acceleration, then automatically pipeline the outer loop, apply a tile factor of 1 to break the loop into smaller chunks, and run the iterations of the inner loops in parallel with a factor of 2 for the outer loop and a factor of 30 for the first inner loop and a factor of 10 for the second inner loop.\"", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes written in C, the following pragma values are used:\n\n1. Treat the following function as a hardware kernel for acceleration: '#pragma ACCEL kernel'\n2. Don't automatically pipeline this loop: '#pragma ACCEL PIPELINE \"off\"'\n3. Process this loop in its original, full form without breaking it into smaller chunks: '#pragma ACCEL TILE FACTOR=1'\n4. Run the iterations of this loop one after the other, not in parallel: '#pragma ACCEL PARALLEL FACTOR=1'\n\nThe comprehensive but very concise natural language instruction to generate these HLS codes would be:\n\"Mark the function as a hardware kernel, turn off auto-pipelining for the outer loop, set the tile factor to 1 for all loops, and run the iterations sequentially instead of in parallel.\"", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{2}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_up = i + 1;\n        int j_up = j + 1;\n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7_0}\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_up][j] - ex[i][j]) - 0.7 * (ey[i][j_up] - ey[i][j]);\n      }\n    }\n  }\n}"}}
{"input": "Process the first loop in parallel with automatic factor determination, turn off automatic loop pipelining, use automatic tiling with factor 1, and process the second loop in parallel with automatic factor determination and reduction.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[410][390],double s[390],double q[410],double p[390],double r[410])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 390; i++) {\n    s[i] = ((double )0);\n    q[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 410; i++) {\n    q[0] += r[i] * A[i][0];\n    s[0] += r[i] * A[i][0];\n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 1; j < 390; j++) {\n      q[j] += r[i] * A[i][j];\n      s[j] += A[i][j] * p[j];\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_mvt(double x[4096],double y[4096],double A[4096][32],double B[4096][32])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 32; i++) {\n    y[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction=y FACTOR=auto{1}\n    for (j = 0; j < 4096; j++) {\n      y[i] += A[j][i] * x[j];\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 4096; i++) {\n    x[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction=x FACTOR=auto{__PARA__L2}\n    for (j = 0; j < 32; j++) {\n      x[i] += B[i][j] * y[j];\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[410][390],double s[390],double q[410],double p[390],double r[410])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PARALLEL FACTOR=auto{118}\n  for (i = 0; i < 390; i++) {\n    s[i] = ((double )0);\n    q[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n  for (i = 0; i < 410; i++) {\n    q[0] += r[i] * A[i][0];\n    s[0] += r[i] * A[i][0];\n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 1; j < 390; j++) {\n      q[j] += r[i] * A[i][j];\n      s[j] += A[i][j] * p[j];\n    }\n  }\n}"}}
{"input": "To compile this C code with the correct HLS pragmas, do the following:\n\n1. For the outer loop, use \"#pragma ACCEL PIPELINE auto\" to automatically pipeline the loop.\n\n2. For the outer loop, use \"#pragma ACCEL TILE FACTOR=auto{1}\" to break it into smaller chunks with automatic factor determination.\n\n3. For the first inner loop, use \"#pragma ACCEL PARALLEL FACTOR=auto{12}\" to run iterations in parallel with an auto-determined factor.\n\n4. For the second inner loop, use \"#pragma ACCEL PARALLEL FACTOR=auto{3}\" to run iterations in parallel with an auto-determined factor.\n\nFinally, annotate the 'kernel_jacobi_1d' function with the \"#pragma ACCEL kernel\" pragma to treat it as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL WORKER FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL WORKER FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes in C, use the following natural language instruction for each specific #pragma value:\n\n- \"Automatically flatten and pipeline this loop\" - for the line `#pragma ACCEL PIPELINE auto{flatten}`.\n- \"Set the tile factor automatically to 1\" - for the line `#pragma ACCEL TILE FACTOR=auto{1}`.\n- \"Automatically parallelize this loop with a factor of 2\" - for the line `#pragma ACCEL PARALLEL FACTOR=auto{2}`.\n- \"Automatically parallelize this loop with a factor of 12\" - for the line `#pragma ACCEL PARALLEL FACTOR=auto{12}`.\n- \"Automatically parallelize this loop with a factor of 1\" - for the line `#pragma ACCEL PARALLEL FACTOR=auto{1}`.\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "**seq.c**: 1 loop transforms to 1 \n\n\n#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#include <math.h>\n#pragma ACCEL kernel\n\nvoid kernel_correlation(double float_n,double data[100][80],double corr[80][80],double mean[80],double stddev[80])\n{\n  int i;\n  int j;\n  int k;\n  double eps = 0.1e-10;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (j = 0; j < 80; j++) {\n    mean[j] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (i = 0; i < 100; i++) {\n      mean[j] += data[i][j];\n    }\n    mean[j] /= float_n;\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n  for (j = 0; j < 80; j++) {\n    stddev[j] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 100; i++) {\n      stddev[j] += pow(data[i][j] - mean[j],(double )2);\n    }\n    stddev[j] /= float_n;\n    stddev[j] = sqrt(stddev[j]);\n/* The following in an inelegant but usual way to handle\n         near-zero std. dev. values, which below would cause a divide by zero.\n         (Application developers responsibility to avoid this condition!) */\n    stddev[j] = (stddev[j] <= eps?1.0 : stddev[j]);\n  }\n/* Center and reduce the column vectors. */\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n  for (i = 0; i < 100; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (j = 0; j < 80; j++) {\n      data[i][j] -= mean[j];\n      data[i][j] /= sqrt(float_n) * stddev[j];\n    }\n  }\n/* Calculate the m * m correlation matrix. */\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n  for (i = 0; i < 80; i++) {\n    corr[i][i] = 1.0;\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L7}\n    for (j = i + 1; j < 80; j++) {\n      corr[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (k = 0; k < 100; k++) {\n        corr[i][j] += data[k][i] * data[k][j];\n      }\n      corr[j][i] = corr[i][j];\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes written in C, use the following natural language instructions:\n\n- For the `kernel_jacobi_1d` function, insert the directive to treat the function as a hardware kernel for acceleration.\n- For the outer loop, automatically pipeline the entire loop in the code without flattening the multi-dimensional access pattern.\n- For the outer loop, use auto{1} factor to tile the loop into smaller chunks with size determined automatically.\n- For the outer loop, use auto{2} factor to parallelize the loop with an auto-determined parallel factor.\n- For the inner loop, use auto{30} factor to parallelize the loop with an auto-determined parallel factor.\n- For the second inner loop, use auto{1} factor to parallelize the loop with an auto-determined parallel factor.\n\nBy implementing these natural language instructions, you can generate the given HLS codes in C with the corresponding #pragma values.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes in C, you need to treat the following function as a hardware kernel for acceleration and use the following #pragma values:\n\n1. Use `#pragma ACCEL PIPELINE auto{flatten}` to automatically pipeline the loop.\n2. Use `#pragma ACCEL TILE FACTOR=auto{1}` to process the loop in its original, full form without breaking it into smaller chunks.\n3. Use `#pragma ACCEL PARALLEL FACTOR=auto{2}` to run the iterations of the loop in parallel with a factor of 2.\n4. Use `#pragma ACCEL PARALLEL FACTOR=auto{12}` for the inner loop to run in parallel with a factor of 12.\n5. Use `#pragma ACCEL PARALLEL FACTOR=auto{1}` for the subsequent loop to run in parallel with a factor of 1.\n\nGiven these instructions and #pragma values, the HLS codes should be generated in C.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_in_j = i * 240 + j;\n        int i_nxt_j = (i + 1) * 240 + j;\n        int i_nxt_j_nxt = (i + 1) * 240 + j + 1;\n        int i_prv_j = i * 240 + j - 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}"}}
{"input": "Process the outer loop in parallel, processing iterations in parallel as much as possible. Pipeline the inner loops to improve throughput. Use a tile factor of 1 to retain the original loop structure. Additionally, treat the function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 30; t++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{31}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes written in C, you need to treat the `kernel_doitgen` function as a hardware kernel for acceleration and apply the following specific #pragma values for optimization:\n\n1. Disable automatic pipelining for the outermost loop:\n   `#pragma ACCEL PIPELINE auto{off}`\n\n2. Process the outermost loop in its original, full form without breaking it into smaller chunks:\n   `#pragma ACCEL TILE FACTOR=auto{1}`\n\n3. Enable automatic loop pipelining with flattening for the middle loop:\n   `#pragma ACCEL PIPELINE auto{flatten}`\n\n4. Process the middle loop in its original, full form without breaking it into smaller chunks:\n   `#pragma ACCEL TILE FACTOR=auto{1}`\n\n5. Disable automatic pipelining for the innermost loop:\n   `#pragma ACCEL PIPELINE auto{off}`\n\n6. Process the innermost loop in its original, full form without breaking it into smaller chunks:\n   `#pragma ACCEL TILE FACTOR=auto{1}`\n\nWith the above #pragma values, the given C code can be optimized for HLS processing.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        double sum_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=sum_tmp FACTOR=auto{1}\n\tfor (s = 0; s < 30; s++) {\n          sum_tmp += A[r][q][s] * C4[s][p];\n        }\n\tsum[p] = sum_tmp;\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        double sum_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=sum_tmp FACTOR=auto{1}\n\tfor (s = 0; s < 30; s++) {\n          sum_tmp += A[r][q][s] * C4[s][p];\n        }\n\tsum[p] = sum_tmp;\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        double sum_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=sum_tmp FACTOR=auto{1}\n\tfor (s = 0; s < 30; s++) {\n          sum_tmp += A[r][q][s] * C4[s][p];\n        }\n\tsum[p] = sum_tmp;\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Perform the following steps to optimize the C code using HLS pragmas:\n- First, mark the function as a hardware kernel for acceleration using '#pragma ACCEL kernel'.\n- Then, parallelize the loop iterating over 's' array by replacing '#pragma ACCEL PARALLEL FACTOR=auto{1}' with '#pragma ACCEL PARALLEL FACTOR=1'.\n- Next, do not automatically pipeline the loop iterating over 's' array by replacing '#pragma ACCEL PIPELINE auto{off}' with '#pragma ACCEL PIPELINE off'.\n- Finally, keep the loop iterating over 'q' array in its original form without breaking it into smaller chunks and process it without parallelization by keeping '#pragma ACCEL TILE FACTOR=auto{1}' and '#pragma ACCEL PARALLEL FACTOR=auto{1}' unchanged.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[410][390],double s[390],double q[410],double p[390],double r[410])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 390; i++) {\n    s[i] = ((double )0);\n    q[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 410; i++) {\n    q[0] += r[i] * A[i][0];\n    s[0] += r[i] * A[i][0];\n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 1; j < 390; j++) {\n      q[j] += r[i] * A[i][j];\n      s[j] += A[i][j] * p[j];\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[410][390],double s[390],double q[410],double p[390],double r[410])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 390; i++) {\n    s[i] = ((double )0);\n    q[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 410; i++) {\n    q[0] += r[i] * A[i][0];\n    s[0] += r[i] * A[i][0];\n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 1; j < 390; j++) {\n      q[j] += r[i] * A[i][j];\n      s[j] += A[i][j] * p[j];\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Process the following function as a hardware kernel for acceleration, and within the loops, turn off automatic pipelining and use a tile factor of 1.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{}\n      \n#pragma ACCEL TILE FACTOR=auto{2}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        double ize = 1.0 / (hz[i][j] + hz[i][j + 1] + hz[i + 1][j] + hz[i + 1][j + 1]);\n        double _zero = 0.0;\n        hz[i][j] = _zero + 2.0 * ize * (hz[i][j] + hz[i][j + 1] + hz[i + 1][j] + hz[i + 1][j + 1]);\n        double  temp = ey[i][j + 1] - ey[i][j];\n        double  ix = ex[i][j + 1] - ex[i][j];\n        double  iy = ey[i + 1][j] - ey[i][j];\n        double  _id = _fict_[i] - ex[i][j] * (ix) - ey[i][j] * (iy);\n        ex[i][j] = _zero + 2.0 * ize * (ex[i][j] + temp * ix);\n        ey[i][j] = _zero + 2.0 * ize * (ey[i][j] + temp * iy);\n        _fict_[i] = _id;\n      }\n    }\n  }\n}"}}
{"input": "To optimize the given C code for HLS acceleration, use the following comprehensive but concise natural language instruction:\n\n\"Set the pipeline directive to manual, do not automatically pipeline the loops, and set the tile factor to 8 for the outermost loop; keep the loops in their original, full form without breaking them into smaller chunks, and process them one after the other without parallelization, treating the function as a hardware kernel for acceleration.\"\n\nThis instruction encompasses the necessary #pragma values and their specific settings for the given HLS code.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1 * i * nx;\n        int j_col = -1 * j * ny;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1*i;\n        int j_row = -1*j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_col][j + 1] - ex[i_col][j] + ey[i + 1][j_row] - ey[i][j_row]);\n      }\n    }\n  }\n}"}}
{"input": "Process the loop for the variable 'i' in parallel, run all the iterations of this loop one after the other, not in parallel, and treat this function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Process the following function as a hardware kernel for acceleration. Automatically pipeline the first loop, use automatic tile factor of 2, and run iterations of the second loop in parallel with reduction operations for variables 'tmp' and 'y'.", "output": "#pragma ACCEL kernel\n\nvoid kernel_atax(int m,int n,double A[116][124],double x[124],double y[124],double tmp[116])\n{\n  int i;\n  int j;\n//#pragma scop\n  for (i = 0; i < 124; i++) \n    y[i] = ((double )0);\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    tmp[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1_0}\n    for (j = 0; j < 124; j++) {\n      tmp[i] += A[i][j] * x[j];\n    }\n    \n#pragma ACCEL PARALLEL reduction=y FACTOR=auto{1_1}\n    for (j = 0; j < 124; j++) {\n      y[j] += A[i][j] * tmp[i];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[410][390],double s[390],double q[410],double p[390],double r[410])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 390; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 410; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 390; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[410][390],double s[390],double q[410],double p[390],double r[410])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 390; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n  for (i = 0; i < 410; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 390; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_mvt(double x[400],double y[400],double u1[400],double u2[400],double v[400],int n)\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 400; i++) {\n    x[i] = 1.0;\n    y[i] = 1.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 400; i++) {\n    \n#pragma ACCEL PARALLEL reduction=u1 FACTOR=auto{__PARA__L50}\n    for (j = 0; j < 400; j++) {\n      u1[i] += v[j] * y[j] / ((u2[j] + 1.0) * (u2[j] + 1.0));\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n  for (i = 0; i < 400; i++) {\n    \n#pragma ACCEL PARALLEL reduction=y FACTOR=auto{__PARA__L36}\n    for (j = 0; j < 400; j++) {\n      y[i] += x[j] * v[j] / ((u2[j] + 1.0) * (u2[j] + 1.0));\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes in C, follow these natural language instructions:\n1. Mark the function as a hardware kernel for acceleration.\n2. Turn off automatic pipeline for the following loop.\n3. Keep the loop in its original form without breaking it into smaller chunks.\n4. Run iterations of the loop in parallel with a factor of 2.\n5. Run the inner loop iterations in parallel with a factor of 30.\n6. Run the inner loop iterations in parallel with a factor of 12.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "7. Turn off automatic parallelization for the following loop.\n8. Turn off automatic parallelization for the following loop.\n9. Turn off automatic parallelization for the following loop.\n10. Turn off automatic parallelization for the following loop.\n11. Turn off automatic parallelization for the following loop.\n12. Turn off automatic parallelization for the following loop.\n13. Turn off automatic parallelization for the following loop.\n14. Turn off automatic parallelization for the following loop.\n15. Turn off automatic parallelization for the following loop.\n16. Turn off automatic parallelization for the following loop.\n17. Turn off automatic parallelization for the following loop.\n18. Turn off automatic parallelization for the following loop.\n19. Turn off automatic parallelization for the following loop.\n20. Turn off automatic parallelization for the following loop.\n21. Turn off automatic parallelization for the following loop.\n22. Turn off automatic parallelization for the following loop.\n23. Turn off automatic parallelization for the following loop.\n24. Turn off automatic parallelization for the following loop.\n25. Turn off automatic parallelization for the following loop.\n26. Turn off automatic parallelization for the following loop.\n27. Turn off automatic parallelization for the following loop.\n28. Turn off automatic parallelization for the following loop.\n29. Turn off automatic parallelization for the following loop.\n30. Turn off automatic parallelization for the following loop.\n31. Turn off automatic parallelization for the following loop.\n32. Turn off automatic parallelization for the following loop.\n33. Turn off automatic parallelization for the following loop.\n34. Turn off automatic parallelization for the following loop.\n35. Turn off automatic parallelization for the following loop.\n36. Turn off automatic parallelization for the following loop.\n37. Turn off automatic parallelization for the following loop.\n38. Turn off automatic parallelization for the following loop.\n39. Turn off automatic parallelization for the following loop.\n40. Turn off automatic parallelization for the following loop.\n41. Turn off automatic parallelization for the following loop.\n42. Turn off automatic parallelization for the following loop.\n43. Turn off automatic parallelization for the following loop.\n44. Turn off automatic parallelization for the following loop.\n45. Turn off automatic parallelization for the following loop.\n46. Turn off automatic parallelization for the following loop.\n47. Turn off automatic parallelization for the following loop.\n48. Turn off automatic parallelization for the following loop.\n49. Turn off automatic parallelization for the following loop.\n50. Turn off automatic parallelization for the following loop.\n51. Turn off automatic parallelization for the following loop.\n52. Turn off automatic parallelization for the following loop.\n53. Turn off automatic parallelization for the following loop.\n54. Turn off automatic parallelization for the following loop.\n55. Turn off automatic parallelization for the following loop.\n56. Turn off automatic parallelization for the following loop.\n57. Turn off automatic parallelization for the following loop.\n58. Turn off automatic parallelization for the following loop.\n59. Turn off automatic parallelization for the following loop.\n60. Turn off automatic parallelization for the following loop.\n61. Turn off automatic parallelization for the following loop.\n62. Turn off automatic parallelization for the following loop.\n63. Turn off automatic parallelization for the following loop.\n64. Turn off automatic parallelization for the following loop.\n65. Turn off automatic parallelization for the following loop.\n66. Turn off automatic parallelization for the following loop.\n67. Turn off automatic parallelization for the following loop.\n68. Turn off automatic parallelization for the following loop.\n69. Turn off automatic parallelization for the following loop.\n70. Turn off automatic parallelization for the following loop.\n71. Turn off automatic parallelization for the following loop.\n72. Turn off automatic parallelization for the following loop.\n73. Turn off automatic parallelization for the following loop.\n74. Turn off automatic parallelization for the following loop.\n75. Turn off automatic parallelization for the following loop.\n76. Turn off automatic parallelization for the following loop.\n77. Turn off automatic parallelization for the following loop.\n78. Turn off automatic parallelization for the following loop.\n79. Turn off automatic parallelization for the following loop.\n80. Turn off automatic parallelization for the following loop.\n81. Turn off automatic parallelization for the following loop.\n82. Turn off automatic parallelization for the following loop.\n83. Turn off automatic parallelization for the following loop.\n84. Turn off automatic parallelization for the following loop.\n85. Turn off automatic parallelization for the following loop.\n86. Turn off automatic parallelization for the following loop.\n87. Turn off automatic parallelization for the following loop.\n88. Turn off automatic parallelization for the following loop.\n89. Turn off automatic parallelization for the following loop.\n90. Turn off automatic parallelization for the following loop.\n91. Turn off automatic parallelization for the following loop.\n92. Turn off automatic parallelization for the following loop.\n93. Turn off automatic parallelization for the following loop.\n94. Turn off automatic parallelization for the following loop.\n95. Turn off automatic parallelization for the following loop.\n96. Turn off automatic parallelization for the following loop.\n97. Turn off automatic parallelization for the following loop.\n98. Turn off automatic parallelization for the following loop.\n99. Turn off automatic parallelization for the following loop.\n100. Turn off automatic parallelization for the following loop.\n #pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1 * i;\n        int j_row = -1 * j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_col + 1][j_row + 1] - ex[i][j_row + 1] - ey[i_col + 1][j][j_row + 1] + ey[i][j][j_row + 1]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{12}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Process the loop with automatic pipelining, use automatic tiling, and run the iterations of the loop in parallel with a reduction clause. Also, treat the following function as a hardware kernel for acceleration.", "output": "\n#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[410][390],double s[390],double q[410],double p[390],double r[410])\n{\n  int i;\n  int j;\n  for (i = 0; i < 390; i++) \n    s[i] = ((double )0);\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 410; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 390; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[410][390],double s[390],double q[410],double p[390],double r[410])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n  for (i = 0; i < 390; i++) {\n    s[i] = ((double )0);\n    q[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n  for (i = 0; i < 410; i++) {\n    q[0] += r[i] * A[i][0];\n    s[0] += r[i] * A[i][0];\n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 1; j < 390; j++) {\n      q[j] += r[i] * A[i][j];\n      s[j] += A[i][j] * p[j];\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes written in C, use the following natural language instruction:\n\n\"Mark the following function as a hardware kernel for acceleration, and for the loops within it:\n1. Disable automatic pipelining.\n2. Process the loops in their original, full form without breaking them into smaller chunks.\n3. Perform pipelining with flattening for the innermost loop.\n4. Use a tile factor of 8 for the innermost loop.\"\n\nTranslate the above natural language instruction to the specific #pragma values as follows:\n```c\n#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{8}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    \n```", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{8}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma endscop\n}", "1": "#pragma endscop\n}", "2": "#pragma endscop\n}"}}
{"input": "Process the following loop sequentially without pipeline optimization: `#pragma ACCEL PIPELINE auto{off}`\nProcess the loop using its original, full form without breaking it into smaller chunks: `#pragma ACCEL TILE FACTOR=auto{1}`\nRun the iterations of this loop in parallel by breaking it into smaller chunks: `#pragma ACCEL TILE FACTOR=auto{4}`\nTreat the following function as a hardware kernel for acceleration: `#pragma ACCEL kernel`", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{}\n      \n#pragma ACCEL TILE FACTOR=auto{4}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}"}}
{"input": "To generate the HLS codes in C, use the following natural language instruction:\n\n\"Optimize hardware pipeline manually instead of automatic, do not tile the loop, and parallelize with a factor of 2 for the outer loop, 30 for the first inner loop, and 10 for the second inner loop. Treat the function as a hardware kernel for acceleration.\"", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 35; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 35; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Process the `kernel_doitgen` function as a hardware kernel for acceleration, and for the loops within, use the following pragma values:\n- For the outer loop over `r`, do not automatically pipeline it (`#pragma ACCEL PIPELINE auto{off}`).\n- For the loop over `r`, break it into smaller chunks with a factor of 2 in tiling (`#pragma ACCEL TILE FACTOR=2`).\n- For the loop over `q`, automatically pipeline it in a flattened manner (`#pragma ACCEL PIPELINE auto{flatten}`), and do not break it into smaller chunks (`#pragma ACCEL TILE FACTOR=1`).\n- For the loop over `p`, do not automatically pipeline it (`#pragma ACCEL PIPELINE auto{off}`), and do not break it into smaller chunks (`#pragma ACCEL TILE FACTOR=1`).", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#include <math.h>\n#pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        double sum_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=sum_tmp FACTOR=auto{1}\n\tfor (s = 0; s < 30; s++) {\n          sum_tmp += A[r][q][s] * C4[s][p];\n        }\n\tsum[p] = sum_tmp;\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "//#pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        double sum_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=sum_tmp FACTOR=auto{1}\n\tfor (s = 0; s < 30; s++) {\n          sum_tmp += A[r][q][s] * C4[s][p];\n        }\n\tsum[p] = sum_tmp;\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "After acceleration, the generated C++ code should be equivalent to the following with no ` #pragma ACCEL kernel` :\n #pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        double sum_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=sum_tmp FACTOR=auto{1}\n\tfor (s = 0; s < 30; s++) {\n          sum_tmp += A[r][q][s] * C4[s][p];\n        }\n\tsum[p] = sum_tmp;\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the provided HLS codes, use the following natural language instructions:\n\n1. Enable automatic pipelining for the loop: `#pragma ACCEL PIPELINE auto`\n\n2. Set the tiling factor automatically to 1 for the loop: `#pragma ACCEL TILE FACTOR=auto{1}`\n\n3. Set the parallelization factor automatically to 2 for the outer loop: `#pragma ACCEL PARALLEL FACTOR=auto{2}`\n\n4. Set the parallelization factor automatically to 30 for the inner loop (first computation loop): `#pragma ACCEL PARALLEL FACTOR=auto{30}`\n\n5. Set the parallelization factor automatically to 10 for the inner loop (second computation loop): `#pragma ACCEL PARALLEL FACTOR=auto{10}`\n\nRemember, in each pragma, the 'auto' specifies that the value should be determined automatically by the hardware.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 2L * j;\n        int _in_i = 2L * i;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction=D FACTOR=auto{10}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes in C, follow these natural language instructions:\n\n1. Treat the following function as a hardware kernel for acceleration\n   ```\n   #pragma ACCEL kernel\n   ```\n\n2. Don't automatically pipeline the outermost loop\n   ```\n   #pragma ACCEL PIPELINE auto{off}\n   ```\n\n3. Process the outermost loop with a factor of 4\n   ```\n   #pragma ACCEL TILE FACTOR=auto{4}\n   ```\n\n4. Automatically pipeline the middle loop with flattening\n   ```\n   #pragma ACCEL PIPELINE auto{flatten}\n   ```\n\n5. Process the middle loop in its original, full form without breaking it into smaller chunks\n   ```\n   #pragma ACCEL TILE FACTOR=auto{1}\n   ```\n\n6. Don't automatically pipeline the innermost loop\n   ```\n   #pragma ACCEL PIPELINE auto{off}\n   ```\n\n7. Process the innermost loop in its original, full form without breaking it into smaller chunks\n   ```\n   #pragma ACCEL TILE FACTOR=auto{1}\n   ```", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "", "1": "", "2": ""}}
{"input": "To generate the given HLS codes in C, for the function `kernel_jacobi_1d`, use the following natural language instructions for the respective #pragma values:\n\n1. \"Automatically pipeline the loops for parallel execution\" - for `#pragma ACCEL PIPELINE auto{flatten}`\n2. \"Divide the loops into smaller units of iteration to be processed in parallel, with the specified automatic factor\" - for `#pragma ACCEL TILE FACTOR=auto{1}`\n3. \"Execute the iterations of the loops in parallel with the specified automatic factor\" - for `#pragma ACCEL PARALLEL FACTOR=auto{2}` (first loop) and `#pragma ACCEL PARALLEL FACTOR=auto{30}` (second loop)\n4. \"Treat the following function as a hardware kernel for acceleration\" - for `#pragma ACCEL kernel`", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Process the following function as a hardware kernel for acceleration. Do not automatically pipeline the first loop. Use a tile factor of 1 for loop tiling. Run the iterations of the second loop one after the other, not in parallel, with reduction of 'tmp' and 'y' using a factor of 1 for both reductions.", "output": "#pragma ACCEL kernel\n\nvoid kernel_atax(int m,int n,double A[116][124],double x[124],double y[124],double tmp[116])\n{\n  int i;\n  int j;\n//#pragma scop\n  for (i = 0; i < 124; i++) \n    y[i] = ((double )0);\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    tmp[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1_0}\n    for (j = 0; j < 124; j++) {\n      tmp[i] += A[i][j] * x[j];\n    }\n    \n#pragma ACCEL PARALLEL reduction=y FACTOR=auto{1_1}\n    for (j = 0; j < 124; j++) {\n      y[j] += A[i][j] * tmp[i];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_atax(double A[340],double x[420],double y[420],double tmp[340])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 420; i++) {\n    tmp[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 340; i++) {\n    tmp[i] = A[i] * x[i];\n  }\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 420; i++) {\n    y[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction=y FACTOR=auto{1}\n    for (j = 0; j < 340; j++) {\n      y[i] += tmp[j] * A[i * 340 + j];\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[410][390],double s[390],double q[410],double p[390],double r[410])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 390; i++) {\n    s[i] = ((double )0);\n    q[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 410; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 390; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_atax(double A[340],double x[420],double y[420],double tmp[340])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 420; i++) {\n    tmp[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 340; i++) {\n    tmp[i] = A[i] * x[i];\n  }\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 420; i++) {\n    y[i] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 340; j++) {\n      y[i] += tmp[j] * A[i * 340 + j];\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes in C, use the following concise natural language instructions for the specific #pragma values:\n\n1. Mark the function as a hardware kernel for acceleration: \n   - \"Treat the following function as a hardware kernel for acceleration\"\n\n2. Pipeline the loop with auto scheduling:\n   - \"Automatically pipeline this loop\"\n\n3. Tile the loop with a factor of 4:\n   - \"Break this loop into smaller chunks with a factor of 4\"\n\n4. Run the iterations one after the other, not in parallel, with automatic scheduling:\n   - \"Automatically process this loop without running iterations in parallel\"\n\n5. Turn off automatic pipelining for the loop:\n   - \"Turn off automatic pipelining for this loop\"\n\n6. Tile the loop with a factor of 1:\n   - \"Break this loop into smaller chunks with a factor of 1\"\n\n7. Run the iterations one after the other, not in parallel, with automatic scheduling:\n   - \"Automatically process this loop without running iterations in parallel\"\n\n8. Pipeline the loop with auto scheduling:\n   - \"Automatically pipeline this loop\"\n\n9. Tile the loop with a factor of 1:\n   - \"Break this loop into smaller chunks with a factor of 1\"\n\n10. Run the iterations one after the other, not in parallel, with automatic scheduling:\n    - \"Automatically process this loop without running iterations in parallel\"\n\n11. Pipeline the loop with a specific identifier (__PIPE__L3) for scheduling:\n    - \"Pipeline this loop with a specific identifier\"\n\n12. Tile the loop with a specific identifier (__TILE__L3) for scheduling:\n    - \"Break this loop into smaller chunks with a specific identifier\"\n\n13. Run the iterations in parallel with a factor of 1:\n    - \"Run the iterations of this loop in parallel with a factor of 1\"\n\nBy implementing these instructions, the HLS codes in C can be generated as described.", "output": "#include <math.h>\n#pragma ACCEL kernel\n\nvoid kernel_correlation(double float_n,double data[100][80],double corr[80][80],double mean[80],double stddev[80])\n{\n  int i;\n  int j;\n  int k;\n  double eps = 0.1;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n  for (j = 0; j < 80; j++) {\n    mean[j] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 100; i++) {\n      mean[j] += data[i][j];\n    }\n    mean[j] /= float_n;\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n  for (j = 0; j < 80; j++) {\n    stddev[j] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 0; i < 100; i++) {\n      stddev[j] += pow(data[i][j] - mean[j],(double )2);\n    }\n    stddev[j] /= float_n;\n    stddev[j] = sqrt(stddev[j]);\n/* The following in an inelegant but usual way to handle\n         near-zero std. dev. values, which below would cause a zero-\n         divide. */\n    stddev[j] = (stddev[j] <= eps?1.0 : stddev[j]);\n  }\n/* Center and reduce the column vectors. */\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (i = 0; i < 100; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (j = 0; j < 80; j++) {\n      data[i][j] -= mean[j];\n      data[i][j] /= sqrt(float_n) * stddev[j];\n    }\n  }\n/* Calculate the m * m correlation matrix. */\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 80 - 1; i++) {\n    corr[i][i] = 1.0;\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L7}\n    for (j = i + 1; j < 80; j++) {\n      corr[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7_0}\n      for (k = 0; k < 100; k++) {\n        corr[i][j] += data[k][i] * data[k][j];\n      }\n      corr[j][i] = corr[i][j];\n    }\n  }\n  corr[80 - 1][80 - 1] = 1.0;\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][80],double C[80][50],double D[40][50])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction=D FACTOR=auto{__PARA__L2}\n      for (k = 0; k < 80; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][80],double C[80][50],double D[40][50])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction=D FACTOR=auto{__PARA__L2}\n      for (k = 0; k < 80; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes, use the following comprehensive but concise natural language instruction:\n\"Mark the following function as a hardware kernel for acceleration, then pipeline the loop automatically, tile the loop with a factor of 8, and run the iterations of the loop in parallel with a parallel factor of 1.0 for reduction variables 'tmp' and 1.1 for reduction variables 'y'.\"\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_atax(int m,int n,double A[116][124],double x[124],double y[124],double tmp[116])\n{\n  int i;\n  int j;\n//#pragma scop\n  for (i = 0; i < 124; i++) \n    y[i] = ((double )0);\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    tmp[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1_0}\n    for (j = 0; j < 124; j++) {\n      tmp[i] += A[i][j] * x[j];\n    }\n    \n#pragma ACCEL PARALLEL reduction=y FACTOR=auto{1_1}\n    for (j = 0; j < 124; j++) {\n      y[j] += A[i][j] * tmp[i];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_gemver(int n,double alpha,double beta,double A[40][50],double u1[40],double v1[40],double u2[50],double v2[50],double w[50],double x[40],double y[40],double z[50])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    double tmp = 0.0;\n    double tmp_x = 0.0;\n    double tmp_y = 0.0;\n    double Ai_j[50];\n    for (j = 0; j < 50; j++) {\n      Ai_j[j] = A[i][j];\n      tmp_x += A[i][j] * x[j];\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 40; j++) {\n      tmp += Ai_j[j] * y[j];\n      tmp_y += Ai_j[j] * u1[j];\n    }\n    z[i] = tmp_x;\n    double Bj = beta * v1[i] + alpha * tmp;\n    y[i] = Bj;\n    double Ci = beta * u2[i] + alpha * tmp_y;\n    for (j = 0; j < 50; j++) {\n      w[j] += A[i][j] * Bj;\n    }\n    x[i] = Ci;\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_gemver(int n,double alpha,double beta,double A[120][120],double u1[120],double v1[120],double u2[120],double v2[120],double w[120],double x[120],double y[120],double z[120])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 120; i++) {\n    for (j = 0; j < 120; j++) {\n      A[i][j] += + u1[i] * v1[j] + u2[i] * v2[j];\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 120; i++) {\n    y[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 120; i++) {\n    x[i] = 0.0;\n    z[i] = 0.0;\n    double tmp = 0.0;\n    for (j = 0; j < 120; j++) {\n      if (i == j) {\n        A[i][j] = 1.0;\n      }\n      y[i] += A[i][j] * w[j];\n      x[i] += A[j][i] * w[j];\n      z[i] += A[i][j] * v1[j];\n      tmp += A[i][j] * u1[j] * v2[i];\n    }\n    y[i] = alpha * y[i] + beta * tmp + u1[i] * x[i] + u2[i] * z[i];\n  }\n}"}}
{"input": "To generate the given HLS codes, you need to treat the function as a hardware kernel for acceleration. Then, don't automatically pipeline the loop, process the loop in its original form without breaking it into smaller chunks, and run the iterations of the loop one after the other, not in parallel. Finally, reduce the loop variables 'tmp' and 'y' in separate parallel processes.", "output": "#pragma ACCEL kernel\n\nvoid kernel_atax(int m,int n,double A[116][124],double x[124],double y[124],double tmp[116])\n{\n  int i;\n  int j;\n//#pragma scop\n  for (i = 0; i < 124; i++) \n    y[i] = ((double )0);\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    tmp[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1_0}\n    for (j = 0; j < 124; j++) {\n      tmp[i] += A[i][j] * x[j];\n    }\n    \n#pragma ACCEL PARALLEL reduction=y FACTOR=auto{1_1}\n    for (j = 0; j < 124; j++) {\n      y[j] += A[i][j] * tmp[i];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_atax(double A[390][410],double x[410],double y[410],double tmp[390])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 410; i++) {\n    tmp[0] = A[0][i] * x[i];\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 410; i++) {\n    y[i] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 390; j++) {\n      y[i] += A[j][i] * tmp[j];\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_atax(double A[390][410],double x[410],double y[410],double tmp[390])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 410; i++) {\n    tmp[0] = A[0][i] * x[i];\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 410; i++) {\n    y[i] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 390; j++) {\n      y[i] += tmp[j] * A[j][i];\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_atax(double A[390][410],double x[410],double y[410],double tmp[390])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 410; i++) {\n    tmp[0] = A[0][i] * x[i];\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 410; i++) {\n    y[i] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 390; j++) {\n      y[i] += tmp[j] * A[j][i];\n    }\n  }\n}"}}
{"input": "Process this loop in its original, full form without breaking it into smaller chunks\nRun the iterations of this loop one after the other, not in parallel\nTreat the following function as a hardware kernel for acceleration", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 0 + 1L * j;\n        int _in_i = 0 + 1L * i;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes in C, use the following natural language instruction:\n\"Designate the following function as a hardware kernel for acceleration. Pipeline the outer loop automatically with flattening. Break the loop into tiles with a factor chosen automatically. Run the iterations of the outer loop in parallel with a factor of 2, followed by running the inner loops in parallel with a factor of 16 and then a factor of 1.\"", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes in C, use the following natural language instruction: \"Treat the following function as a hardware kernel for acceleration, process the loops in their original, full form without breaking them into smaller chunks, don't automatically pipeline the loops, and run the iterations of the loops one after the other, not in parallel.\"", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_up = i + 1;\n        int j_up = j + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_up][j] - ex[i][j]) - 0.7 * (ey[i][j_up] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}"}}
{"input": "Process the function as a hardware kernel for acceleration.\nDisable automatic pipelining for all loops.\nDo not break the loops into smaller chunks.\nSet the tile factor to 1 for all loops.\nEnable automatic pipelining for the innermost loop with a tile factor of 8.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{}\n      \n#pragma ACCEL TILE FACTOR=auto{8}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1*i;\n        int j_row = -1*j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_col][j + 1] - ex[i_col][j] + ey[i + 1][j_row] - ey[i][j_row]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "2": "Configure storage tiling for A and B to have a total of 4 elements.\nConfigure storage tiling for C to have a total of 128 elements.\n #pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes in C, you can use the following comprehensive but concise natural language instruction:\n\n\"Optimize loop iteration processing for acceleration by automatically pipelining it, breaking it into smaller chunks, and running parallel iterations with specific factors. Treat the function as a hardware kernel for acceleration.\"\n\nThis instruction encompasses the use of the following specific #pragma values:\n- '#pragma ACCEL PIPELINE auto{flatten}' for automatically pipelining the loop\n- '#pragma ACCEL TILE FACTOR=auto{1}' for automatically breaking the loop into smaller chunks\n- '#pragma ACCEL PARALLEL FACTOR=auto{2}' to run parallel iterations with a specific factor\n- '#pragma ACCEL kernel' to treat the function as a hardware kernel for acceleration", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -a * p[i][j - 1] - c * u[i - 1][j] + d * p[i][j + 1] + e * v[j][i];\n        q[i][j] = -b * q[i][j - 1] - f * u[i][j - 1] + d * q[i][j + 1] + e * v[j][i];\n      }\n      v[60 - 1][i] = 1.0;\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = u[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -a * p[i][j - 1] - c * u[i - 1][j] + d * p[i][j + 1] + e * v[j][i];\n        q[i][j] = -b * q[i][j - 1] - f * u[i][j - 1] + d * q[i][j + 1] + e * v[j][i];\n      }\n      u[i][60 - 1] = 1.0;\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        double  _val_27 = 0.0;\n        double  _val_28 = 0.0;\n        double  _val_29 = 0.0;\n        double  _val_30 = 0.0;\n        double  _val_31 = 0.0;\n        double  _val_32 = 0.0;\n        double  _val_33 = 0.0;\n        double  _val_34 = 0.0;\n        double  _val_35 = 0.0;\n        double  _val_36 = 0.0;\n        double  _val_37 = 0.0;\n        double  _val_38 = 0.0;\n        double  _val_39 = 0.0;\n        double  _val_40 = 1.0;\n        _val_27 = ex[i][j + 1] - ex[i][j];\n        _val_28 = ey[i + 1][j] - ey[i][j];\n        _val_29 = ex[i + 1][j + 1] - ex[i + 1][j];\n        _val_30 = ex[i + 1][j] - ex[i][j];\n        _val_31 = ey[i][j + 1] - ey[i][j];\n        _val_32 = hz[i][j + 1] - hz[i][j];\n        _val_33 = hz[i + 1][j] - hz[i][j];\n        _val_34 = hz[i + 1][j + 1] - hz[i][j];\n        _val_35 = _val_30 * _val_32;\n        _val_36 = _val_28 * _val_33;\n        _val_37 = _val_27 * _val_36;\n        _val_38 = _val_29 * _val_34;\n        _val_39 = _val_31 * _val_38;\n        _val_40 = _val_35 + _val_39;\n        ey[i][j] = _val_40;\n        hz[i][j] = _val_37;\n      }\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes in C:\n\n1. Invoke hardware acceleration for the following function\n   ```c\n   #pragma ACCEL kernel\n   void kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n   {\n     // code\n   }\n   ```\n\n2. Apply pipeline optimization to the loop\n   ```c\n   #pragma ACCEL PIPELINE auto{flatten}\n   ```\n\n3. Perform tiling with a factor of 1 for loop optimization\n   ```c\n   #pragma ACCEL TILE FACTOR=auto{1}\n   ```\n\n4. Enable loop parallelization with a factor of 2\n   ```c\n   #pragma ACCEL PARALLEL FACTOR=auto{2}\n   ```\n\n5. Parallelize the loop with a factor of 16\n   ```c\n   #pragma ACCEL PARALLEL FACTOR=auto{16}\n   ```\n\n6. Sequentially execute the loop iterations with a factor of 1 for optimization\n   ```c\n   #pragma ACCEL PARALLEL FACTOR=auto{1}\n   ```", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "", "1": "", "2": ""}}
{"input": "To generate the given HLS C codes, follow these natural language instructions:\n\n- Treat the following function as a hardware kernel for acceleration.\n- Don't automatically pipeline the outer loop.\n- Process the loops in their original, full form without breaking them into smaller chunks.\n- Run the iterations of the inner loops one after the other, not in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{8}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L8}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Process the loops in their original, full form without breaking them into smaller chunks. Run the iterations of the loops one after the other, not in parallel. Treat the following function as a hardware kernel for acceleration. Also, don't automatically pipeline the loops.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1;\n        int j_col = -1;\n        double dxy_x = 0.0;\n        double dxy_y = 0.0;\n        double ex_x = 0.0;\n        double ex_y = 0.0;\n        double ey_x = 0.0;\n        double ey_y = 0.0;\n        double hz_x = 0.0;\n        double hz_y = 0.0;\n        double _in_0 = ex[i][j];\n        dxy_x = _in_0 + ex[i][j + 1];\n        dxy_y = ey[i][j] + ey[i + 1][j];\n        ex_x = dxy_x * (hz[i + 1][j] - hz[i][j]) - ey[i][j] * (hz[i + 1][j + 1] - hz[i][j + 1]);\n        ex_y = dxy_y * (hz[i + 1][j] - hz[i][j]) - ex[i][j] * (hz[i + 1][j + 1] - hz[i][j + 1]);\n        _in_0 = ey[i][j];\n        ey_x = _in_0 + ey[i + 1][j];\n        ey_y = dxy_y * (hz[i + 1][j + 1] - hz[i][j + 1]) - ex[i][j + 1] * (hz[i + 1][j + 1] - hz[i][j + 1]);\n        hz_x = dxy_x - ey_x;\n        hz_y = dxy_y - ey_y;\n        dxy_x = hz[i][j] + hz_x;\n        dxy_y = hz[i][j] + hz_y;\n        ex[i][j] = dxy_x;\n        ey[i][j] = dxy_y;\n        hz[i][j] = dxy_x * ey_x - dxy_y * ex_x + 2.0 * (ex_y * ey_x - ex_x * ey_y) + _fict_[i * nx + j];\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        double  _val_1 = 0.0;\n        double  _val_2 = 0.0;\n        double  _val_3 = 0.0;\n        double  _val_4 = 0.0;\n        double  _val_5 = 0.0;\n        double  _val_6 = 0.0;\n        double  _val_7 = 0.0;\n        double  _val_8 = 0.0;\n        double  _val_9 = 0.0;\n        _val_1 = ex[i][j + 1] - ex[i][j];\n        _val_2 = ey[i + 1][j] - ey[i][j];\n        _val_3 = hz[i][j + 1] - hz[i][j];\n        _val_4 = hz[i + 1][j] - hz[i][j];\n        _val_5 = ex[i][j + 1] - ex[i][j];\n        _val_6 = ey[i + 1][j + 1] - ey[i + 1][j];\n        _val_7 = ey[i][j] - ey[i][j + 1];\n        _val_8 = hz[i + 1][j + 1] - hz[i][j + 1];\n        _val_9 = hz[i + 1][j] - hz[i][j];\n        ey[i][j] = _val_9 + _fict_[i * nx + j] + 0.25 * (_val_6 - _val_7);\n        _fict_[i * nx + j] = _val_3 + _fict_[i * nx + j] + 0.25 * (_val_4 - _val_1);\n        ex[i][j] = _val_7 + _fict_[i * nx + j] + 0.25 * (_val_2 - _val_8);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1;\n        int j_col = -1;\n        double dxy_x = 0.5 * (ey[i + 1][j + 1] - ey[i + 1][j - 1]);\n        double dxy_y = 0.5 * (ex[i + 1][j + 1] - ex[i - 1][j + 1]);\n        double dzz = 4.0 * (hz[i][j] - (hz[i][j - 1] + hz[i - 1][j] + hz[i][j + 1] + hz[i + 1][j])) + ex[i][j] * (ex[i][j] - ex[i][j - 1]) + ey[i][j] * (ey[i][j] - ey[i][j - 1]) ;\n        double dzz_x = ex[i][j] * dxy_x;\n        double dzz_y = ey[i][j] * dxy_x;\n        double one_b_ex = ((ex[i][j]) + dzz_x);\n        double one_b_ey = ((ey[i][j]) + dzz_y);\n        double one_b_hz = (hz[i][j] + dzz);\n        ex[i][j] = one_b_ex;\n        ey[i][j] = one_b_ey;\n        hz[i][j] = one_b_hz;\n      }\n    }\n  }\n}"}}
{"input": "Process the following function as a hardware kernel for acceleration, and for the loop nest within, don't automatically pipeline the outermost loop and process it in its original, full form without breaking it into smaller chunks. For the inner loops, automatically pipeline the loops with a factor of 8 for the second loop, and flatten the third loop automatically with a factor of 1.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{8}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}"}}
{"input": "To generate the HLS codes, use the following natural language instructions:\n\n- For the outer loop, \"Don't automatically pipeline this loop\" and \"Process this loop in its original, full form without breaking it into smaller chunks\" should be used to turn off autopipelining and set the tile factor to 1.\n- For the second loop, \"Don't automatically pipeline this loop\" and \"Process this loop in its original, full form without breaking it into smaller chunks\" should be used to turn off autopipelining and set the tile factor to 1.\n- For the innermost loop, \"Automatically pipeline this loop\" and \"Set the tile factor to 8\" should be used to enable autopipelining and set the tile factor to 8.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{}\n      \n#pragma ACCEL TILE FACTOR=auto{8}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Process the loop in its original, full form without breaking it into smaller chunks.  \nRun the iterations of this loop one after the other, not in parallel.  \nTreat the following function as a hardware kernel for acceleration.  \nAutomatically pipeline this loop, flatten the loop body.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1*i;\n        int j_col = j + 1;\n        hz[i_col][j_col] = hz[i_col][j_col] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1*i;\n        int j_col = j + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_col][j] - ex[i][j_col]) - 0.7 * (ey[i][j_col] - ey[i_col][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes in C, follow these concise natural language instructions:\n\n- Treat the following function as a hardware kernel for acceleration\n- Don't automatically pipeline this loop\n- Process this loop in its original, full form without breaking it into smaller chunks\n- Run the iterations of this loop one after the other, not in parallel", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 2 * j;\n        int _in_i = 2 * i;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][_in_j + 1] - ex[i][_in_j] + ey[ _in_i + 1][j] - ey[ _in_i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\n#pragma ACCEL kernel\n\nvoid kernel_adi(int tsteps,int n,double u[60][60],double v[60][60],double p[60][60],double q[60][60])\n{\n  int t;\n  int i;\n  int j;\n  double DX;\n  double DY;\n  double DT;\n  double B1;\n  double B2;\n  double mul1;\n  double mul2;\n  double a;\n  double b;\n  double c;\n  double d;\n  double e;\n  double f;\n//#pragma scop\n  DX = 1.0 / ((double )60);\n  DY = 1.0 / ((double )60);\n  DT = 1.0 / ((double )40);\n  B1 = 2.0;\n  B2 = 1.0;\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n  a = -mul1 / 2.0;\n  b = 1.0 + mul1;\n  c = a;\n  d = -mul2 / 2.0;\n  e = 1.0 + mul2;\n  f = d;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 1; t <= 40; t++) {\n//Column Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      v[0][i] = 1.0;\n      p[i][0] = 0.0;\n      q[i][0] = v[0][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -a * p[i][j - 1] - d * p[j - 1][i] + u[i][j];\n        q[i][j] = -b * q[i][j - 1] - e * q[j - 1][i] + v[i][j];\n      }\n      j = 59;\n      v[i][j] = 1.0;\n      q[i][j] = f / q[i][j - 1];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = j - 1; j >= 1; j--) {\n        q[i][j] = q[i][j] - q[i][j + 1] * c / p[j + 1][i];\n      }\n      q[i][j] = q[i][j] * p[j][i];\n    }\n//Row Sweep\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 59; i++) {\n      u[i][0] = 1.0;\n      p[i][0] = 0.0;\n      u[i][0] = v[i][0];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 59; j++) {\n        p[i][j] = -a * p[i][j - 1] - d * p[j - 1][i] + u[i][j];\n        u[i][j] = b * u[i][j - 1] - e * u[j - 1][i] + v[i][j];\n      }\n      j = 59;\n      u[i][j] = 1.0;\n      u[i][j] = v[i][j] - d * u[j - 1][i];\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = j - 1; j >= 1; j--) {\n        u[i][j] = u[i][j] - f * q[j][i] / p[j][i];\n      }\n      u[i][j] = u[i][j] * p[j][i];\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the HLS code written in C, use the \"pragma\" directives in the following natural language instructions:\n\n1. Mark the following function as a hardware kernel for acceleration:\n   - Use: `#pragma ACCEL kernel`\n\n2. Implement a loop that is pipelined automatically by the HLS tool:\n   - Use: `#pragma ACCEL PIPELINE auto{flatten}`\n\n3. Break the loop into smaller chunks for processing, with the chunk factor determined automatically:\n   - Use: `#pragma ACCEL TILE FACTOR=auto{4}`\n\n4. Run the iterations of this loop one after the other, not in parallel, with parallel factor determined automatically:\n   - Use: `#pragma ACCEL PARALLEL FACTOR=auto{1}`\n\n5. For the inner loop, perform parallel reduction on variable \"tmp\" with the factor determined automatically:\n   - Use: `#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1_0}`\n\n6. For the inner loop, perform parallel reduction on variable \"y\" with the factor determined automatically:\n   - Use: `#pragma ACCEL PARALLEL reduction=y FACTOR=auto{1_1}`", "output": "#pragma ACCEL kernel\n\nvoid kernel_atax(int m,int n,double A[116][124],double x[124],double y[124],double tmp[116])\n{\n  int i;\n  int j;\n//#pragma scop\n  for (i = 0; i < 124; i++) \n    y[i] = ((double )0);\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    tmp[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1_0}\n    for (j = 0; j < 124; j++) {\n      tmp[i] += A[i][j] * x[j];\n    }\n    \n#pragma ACCEL PARALLEL reduction=y FACTOR=auto{1_1}\n    for (j = 0; j < 124; j++) {\n      y[j] += A[i][j] * tmp[i];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "7. For the inner loop, perform parallel reduction on variable \"x\" with the factor determined automatically:\n   - Use: `#pragma ACCEL PARALLEL reduction=x FACTOR=auto{1_2}`\n\n8. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n9. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n10. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n11. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n12. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n13. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n14. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n15. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n16. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n17. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n18. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n19. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n20. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n21. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n22. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n23. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n24. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n25. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n26. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n27. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n28. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n29. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n30. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n31. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n32. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n33. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n34. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n35. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n36. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n37. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n38. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n39. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n40. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n41. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n42. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n43. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n44. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n45. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n46. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n47. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n48. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n49. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n50. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n51. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n52. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n53. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n54. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n55. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n56. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n57. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n58. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n59. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n60. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n61. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n62. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n63. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n64. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n65. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n66. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n67. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n68. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n69. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n70. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n71. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n72. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n73. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n74. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n75. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n76. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n77. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n78. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n79. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n80. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n81. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n82. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n83. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n84. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n85. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n86. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n87. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n88. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n89. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n90. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n91. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n92. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n93. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n94. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n95. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n96. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n97. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n98. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n99. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n100. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n101. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n102. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n103. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n104. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n105. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n106. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n107. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n108. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n109. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n110. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n111. Implement the function using a software pipeline:\n   - Use: `#pragma ACCEL PIPELINE auto{off}`\n\n112. Mark the following function as a kernel:\n   - Use: `#pragma ACCEL kernel`\n\n113. Implement the function using a software pipeline:\n   - Use: `#", "1": "7. For the inner loop, perform parallel reduction on variable \"x\" with the factor determined automatically:\n   - Use: `#pragma ACCEL PARALLEL reduction=x FACTOR=auto{1_2}`\n\n8. Implement the code below in a function called \"kernel_gemver\":\n   \n    #pragma ACCEL kernel\n\nvoid kernel_gemver(int n,double alpha,double beta,double A[40][50],double u1[40],double v1[40],double u2[50],double v2[50],double w[50],double x[40],double y[50],double z[40])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    double tmp = 0.0;\n    double tmp2 = 0.0;\n    \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp += A[i][j] * u1[j];\n      tmp2 += A[i][j] * v1[j];\n    }\n    y[i] = beta * y[i] + tmp;\n    z[i] = beta * z[i] + tmp2;\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    double tmp3 = 0.0;\n    double tmp4 = 0.0;\n    \n#pragma ACCEL PARALLEL reduction=tmp3 FACTOR=auto{1}\n    for (j = 0; j < 40; j++) {\n      tmp3 += A[j][i] * y[j];\n      tmp4 += A[j][i] * z[j];\n    }\n    w[i] = alpha * tmp3 + 1.0 * x[i] + beta * w[i];\n    x[i] = alpha * tmp4 + 1.0 * x[i];\n  }\n}", "2": "7. For the inner loop, perform parallel reduction on variable \"x\" with the factor determined automatically:\n   - Use: `#pragma ACCEL PARALLEL reduction=x FACTOR=auto{1_2}`\n\n8. For the inner loop, perform parallel reduction on variable \"z\" with the factor determined automatically:\n   - Use: `#pragma ACCEL PARALLEL reduction=z FACTOR=auto{1_3}`\n\n#pragma ACCEL kernel\n\nvoid kernel_gemver(int n,double alpha,double beta,double A[40][50],double u1[40],double v1[40],double u2[50],double v2[50],double w[50],double x[40],double y[50],double z[40])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    double tmp = u1[i] * v2[0];\n    A[i][0] = alpha * tmp + A[i][0];\n    x[i] = alpha * tmp + x[i];\n    y[0] = beta * y[0] + z[i];\n  }\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    double tmp = 0.0;\n    v1[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp += A[i][j] * u2[j];\n      v1[i] += A[i][j] * v2[j];\n    }\n    A[i][0] = tmp;\n    y[0] = beta * y[0] + tmp;\n    w[0] = alpha * u2[0] * v1[0] + beta * w[0];\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    double tmp = 0.0;\n    z[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp += A[i][j] * x[j];\n      z[i] += A[i][j] * y[j];\n    }\n    A[i][0] = tmp;\n    w[0] = alpha * tmp + beta * w[0];\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (i = 0; i < 40; i++) {\n    double tmp = u1[i] * v2[0];\n    x[i] = tmp + x[i];\n    y[0] = y[0] + z[i];\n  }\n}"}}
{"input": "To generate the given HLS codes in C, use the following pragma instructions:\n- Treat the following function as a hardware kernel for acceleration: '#pragma ACCEL kernel'\n- Don't automatically pipeline this loop: '#pragma ACCEL PIPELINE auto{off}'\n- Process this loop in its original, full form without breaking it into smaller chunks: '#pragma ACCEL TILE FACTOR=auto{1}'\n- Run the iterations of this loop one after the other, not in parallel: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Automatically pipeline this loop and fully unroll the inner loop: '#pragma ACCEL PIPELINE auto{flatten}' and '#pragma ACCEL TILE FACTOR=auto{4}'", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{4}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_in_j = i * 240 + j;\n        int i_below_j = (i + 1) * 240 + j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = (i * (240 - 1));\n        int j_col = (j * (200 - 1));\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "- Do not automatically distribute this loop: '#pragma ACCEL DISTRIBUTE FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}'\n- Do not automatically parallelize this loop: '#pragma ACCEL PARALLEL"}}
{"input": "Generate HLS codes for the following C code:\n\n'Process the entire loop without automatic pipeline'\n\n'Process the loop in its original, full form without smaller tiling'\n\n'Pipeline the loop without automatic parallelization'\n\n'Treat the function as a hardware kernel for acceleration'", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{}\n      \n#pragma ACCEL TILE FACTOR=auto{2}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1*i;\n        int j_row = -1*j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_col + 1][j_row + 1] - ex[i_col + 1][j_row] - ey[i_col + 1][j_row + 1] + ey[i_col + 1][j_row]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[410][390],double s[390],double q[410],double p[390],double r[410])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 390; i++) {\n    s[i] = ((double )0);\n    q[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 410; i++) {\n    q[0] += r[i] * A[i][0];\n    s[0] += r[i] * A[i][0];\n    _intrinsic_vsev(((double *)q) + 0, 0, 2);\n    _intrinsic_vsw(0, 2, ((double *)s) + 0, 0);\n    double p_i = -1.0 * p[0];\n    double r_i = ((double )0);\n    \n#pragma ACCEL PARALLEL reduction=r_i FACTOR=auto{1}\n    for (j = 0; j < 390; j++) {\n      r_i += s[j] * A[i][j];\n    }\n    q[0] = q[0] - r_i * p_i;\n    _intrinsic_vld(((double *)s) + 0, 0, 2);\n    _intrinsic_vld(((double *)q) + 0, 0, 2);\n    _intrinsic_vadd2(r_i,p_i,0,2);\n    double sum = r_i;\n    r[i] = sum;\n  }\n}"}}
{"input": "To generate the given HLS codes, follow these concise natural language instructions:\n\n1. Mark the function as a hardware kernel for acceleration.\n2. Turn off automatic loop pipelining for the following loop.\n3. Use the original, full form of the loop without breaking it into smaller chunks.\n4. Run the iterations of the loop with a parallel factor of 2.\n5. Run the iterations of the first inner loop with a parallel factor of 3.\n6. Run the iterations of the second inner loop with a parallel factor of 1.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "7. Turn off automatic loop blocking for the following loop.\n8. Use the original, full form of the loop without breaking it into smaller chunks.\n9. Run the iterations of the loop with a parallel factor of 4.\n10. Run the iterations of the first inner loop with a parallel factor of 4.\n11. Run the iterations of the second inner loop with a parallel factor of 4.\n12. Turn off automatic loop fusion for the following loop.\n13. Use the original, full form of the loop without breaking it into smaller chunks.\n14. Run the iterations of the loop with a parallel factor of 2.\n15. Run the iterations of the first inner loop with a parallel factor of 1.\n16. Run the iterations of the second inner loop with a parallel factor of 1.\n#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 2L * j;\n        int _in_i = 2L * i;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}"}}
{"input": "Ensure that the following function is treated as a hardware kernel for acceleration. Also, do not automatically pipeline the outermost loop, and process it in its original, full form without breaking it into smaller chunks. For the innermost loops, pipeline them to a factor of 4 and flatten the loop.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[j];\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[j];\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = (A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i][j + 1] + A[j + 1][i] + A[i + 1][j] + A[j][i]) / 8.0;\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = A[i][j] - 1.0;\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Process the loop in its original, full form without breaking it into smaller chunks.\nRun the iterations of this loop two at a time in parallel.\nAutomatically pipeline this loop and flatten its structure to optimize performance.\nTreat the following function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 0 + 1L * j;\n        int _in_i = 0 + 1L * i;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 0 + 1L * jump;\n        int _in_i = 0 + 1L * tile;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes for the C program, use the following comprehensive but concise natural language instruction set:\n- Use hardware acceleration for the function: 'Treat the following function as a hardware kernel for acceleration'\n- Pipeline the outer loop: 'Automatically pipeline this loop'\n- Process the loop in its original, full form without breaking it into smaller chunks: 'Set the tile factor to 1'\n- Run the iterations of the outer loop in parallel with a factor of 2: 'Set the parallel factor to 2 for the outer loop'\n- Run the inner loops in parallel with a factor of 32 and 10 respectively: 'Set the parallel factor to 32 for the first inner loop and 10 for the second inner loop'", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{10}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction=D FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double B[25][30][40],double C[25][40][50])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n  int t;\n  int u;\n  double temp1;\n  double temp2;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  loop_r:\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    loop_q:\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      loop_p:\n      for (p = 0; p < 30; p++) {\n        loop_s:\n        for (s = 0; s < 30; s++) {\n          temp1 = A[r][q][s] * B[r][s][p];\n          loop_t:\n          for (t = 0; t < 40; t++) {\n            temp2 = temp1 * C[q][t][p];\n            loop_u:\n            for (u = 0; u < 50; u++) {\n              A[r][t][u] += temp2;\n            }\n          }\n        }\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_doit(double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        double sum_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=sum_tmp FACTOR=auto{__PARA__L2}\n\tfor (s = 0; s < 30; s++) {\n          sum_tmp += A[r][q][s] * C4[s][p];\n        }\n\tsum[p] = sum_tmp;\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes, use the following natural language compilation instructions:\n\n1. \"Process this function as a hardware kernel for acceleration\": \n```c\n#pragma ACCEL kernel\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n```\n\n2. \"Don't automatically pipeline this loop\":\n```c\n#pragma ACCEL PIPELINE \"off\"\n```\n\n3. \"Process this loop in its original, full form without breaking it into smaller chunks\":\n```c\n#pragma ACCEL TILE FACTOR=1\n```\n\n4. \"Run the iterations of this loop one after the other, not in parallel\":\n```c\n#pragma ACCEL PARALLEL FACTOR=1\n```", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "5. \"Don't automatically distribute this loop onto multiple processors\":\n```c\n#pragma ACCEL PARALLEL FACTOR=auto{1}\nfor (t = 0; t < 40; t++) {\n  jacobi_1d(tsteps,n,A,B);\n}\n\n```\n\n6. \"Don't automatically distribute this loop onto multiple processors\":\n```c\n#pragma ACCEL PARALLEL FACTOR=auto{2}\nfor (t = 0; t < 40; t++) {\n  jacobi_1d(tsteps,n,B,A);\n}\n\n```", "1": "5. \"Process this loop with Unroll(auto)\":\n```c\n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 30; t++) {\n    #pragma ACCEL PIPELINE auto{__PIPE__L2}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n    #pragma ACCEL PIPELINE auto{__PIPE__L3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n  }\n```", "2": "5. \"Don't automatically distribute this loop\":\n```c\n#pragma ACCEL DISTRIBUTE FACTOR=1\n  for (t = 0; t < 40; t++) {\n    #pragma ACCEL PIPELINE auto{off}\n    #pragma ACCEL TILE FACTOR=auto{1}\n//#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n    #pragma ACCEL PIPELINE auto{off}\n    #pragma ACCEL TILE FACTOR=auto{1}\n//#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n  }\n```"}}
{"input": "To generate the given HLS codes for the C function 'kernel_doitgen', follow these natural language instructions:\n\n1. Mark the entire function as a hardware kernel for acceleration.\n2. Don't automatically pipeline the outermost loop.\n3. Process the outermost loop in its original, full form without breaking it into smaller chunks.\n4. Don't automatically pipeline the middle loop.\n5. Process the middle loop in its original, full form without breaking it into smaller chunks.\n6. Automatically pipeline the innermost loop.\n7. Break the innermost loop into smaller chunks with a tile factor of 4.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{}\n      \n#pragma ACCEL TILE FACTOR=auto{4}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double B[25][30],double D[20][30],double E[25][20])\n{\n  int r;\n  int q;\n  int p;\n  int j;\n  int k;\n  int i;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  loop_r:\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    loop_q:\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      loop_p:\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = ((double )0);\n      }\n    }\n    loop_j:\n    for (j = 0; j < 30; j++) {\n      loop_k:\n      for (k = 0; k < 20; k++) {\n        double Bjk = B[r][j] * D[k][j];\n\t\t\t\tloop_i:\n        for (i = 0; i < 30; i++) {\n          A[r][k][i] += Bjk * E[q][i];\n        }\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  loop_j_1:\n  for (j = 0; j < 30; j++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    loop_k_1:\n    for (k = 0; k < 30; k++) {\n      C4[j][k] = ((double )0);\n      \n#pragma ACCEL PARALLEL reduction=C4 FACTOR=auto{__PARA__L4}\n      loop_r_1:\n      for (r = 0; r < 25; r++) {\n        loop_q_1:\n        for (q = 0; q < 20; q++) {\n          C4[j][k] += A[r][q][k] * D[q][r];\n        }\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        double sum_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=sum_tmp FACTOR=auto{__PARA__L3}\n\tfor (s = 0; s < 30; s++) {\n          sum_tmp += A[r][q][s] * C4[s][p];\n        }\n\tsum[p] = sum_tmp;\n\tdouble A_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=A_tmp FACTOR=auto{__PARA__L4}\n\tfor (s = 0; s < 30; s++) {\n          A_tmp += A[r][q][s] * sum[s];\n        }\n\tA[r][q][0] = A_tmp;\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30],double B[25][20][30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n      for (p = 0; p < 30; p++) {\n        double sum = A[r][q][p];\n#pragma ACCEL PARALLEL reduction=sum FACTOR=auto{__PARA__L4}\n\tfor (s = 0; s < 30; s++) {\n          sum += A[r][q][s] * C4[s][p];\n        }\n        B[r][q][p] = sum;\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes in C, use the following pragma values:\n\n1. For the outermost loop, do not automatically pipeline:\n   - Use `#pragma ACCEL PIPELINE auto{off}`\n\n2. For the outermost loop, process it in its original, full form without breaking it into smaller chunks:\n   - Use `#pragma ACCEL TILE FACTOR=auto{1}`\n\n3. For the middle loop, do not automatically pipeline:\n   - Use `#pragma ACCEL PIPELINE auto{off}`\n\n4. For the middle loop, process it in its original, full form without breaking it into smaller chunks:\n   - Use `#pragma ACCEL TILE FACTOR=auto{1}`\n\n5. For the innermost loop, automatically pipeline:\n   - Use `#pragma ACCEL PIPELINE auto{}`\n\n6. For the innermost loop, process it with a factor of 4:\n   - Use `#pragma ACCEL TILE FACTOR=auto{4}`\n\nRemember to also use `#pragma ACCEL kernel` to treat the given function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{}\n      \n#pragma ACCEL TILE FACTOR=auto{4}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "", "1": "", "2": ""}}
{"input": "To generate the given HLS code in C:\n\n\"Declare the following function as a hardware kernel for acceleration, then for the loop within the function:\n  - Implement automatic pipelining\n  - Use the original loop form without breaking it into smaller chunks, and\n  - Run the iterations of the first inner loop in parallel, and then the iterations of the second inner loop in parallel with a factor of 3, followed by a factor of 16.\"\n\nThe corresponding #pragma values to use are:\n- Hardware kernel declaration: #pragma ACCEL kernel\n- Pipelining: #pragma ACCEL PIPELINE auto{}\n- Loop full form: #pragma ACCEL TILE FACTOR=auto{1}\n- Inner loop parallelization: \n  - First inner loop: #pragma ACCEL PARALLEL FACTOR=auto{16}\n  - Second inner loop: #pragma ACCEL PARALLEL FACTOR=auto{3}", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}"}}
{"input": "To generate the specific HLS codes in C, you need to follow these natural language instructions:\n\n1. Treat the following function as a hardware kernel for acceleration.\n2. Don't automatically pipeline the outermost loop.\n3. Process the outermost loop in its original, full form without breaking it into smaller chunks.\n4. Don't automatically pipeline the mid-level loop.\n5. Process the mid-level loop in its original, full form without breaking it into smaller chunks.\n6. Automatically pipeline the innermost loop with flattening optimization.\n7. Break the innermost loop into smaller chunks with a tile factor of 2 for optimization.\n\nBy following these instructions, you can generate the given HLS codes for the C program.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{2}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{1}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes in C, use the following natural language instruction:\n\n\"For the kernel function 'kernel_jacobi_1d' with parameters 'tsteps', 'n', 'A[120]', and 'B[120]', first apply automatic loop pipelining. Then, tile the loops with an automatic factor of 1, and process the loops in parallel with an automatic factor of 2. Inside the outer loop, parallelize the loop iterations with a factor of 16. Followed by that, parallelize the loop iterations with a factor of 3. End by treating the function as a hardware kernel for acceleration.\"", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To process the given C code using HLS pragma values, follow the following comprehensive but very concise natural language instruction for each pragma:\n\n1. For the loop pipeline, use `Don't automatically pipeline this loop` to describe `#pragma ACCEL PIPELINE auto{off}`.\n2. For the loop tiling, use `Process this loop with its original, full form without breaking it into smaller chunks` to describe `#pragma ACCEL TILE FACTOR=auto{1}`.\n3. For the loop parallelization, use `Run the iterations of this loop one after the other, not in parallel` to describe `#pragma ACCEL PARALLEL FACTOR=auto{2}`.\n4. Treat the following function as a hardware kernel for acceleration by using `Treat the following function as a hardware kernel for acceleration` to describe `#pragma ACCEL kernel`.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        z_pe[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n      for (j = 0; j < 240 - 1; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (z_pe[i][j] - z_se[i][j + 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n      for (j = 0; j < 240 - 1; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (z_se[i + 1][j] - z_pe[i][j]);\n      }\n    }\n  }\n}"}}
{"input": "To generate the HLS codes:\n1. Designate the following function as a hardware kernel for acceleration using the directive '#pragma ACCEL kernel'.\n2. Don't automatically pipeline the outer loop using '#pragma ACCEL PIPELINE \"off\"'.\n3. Process the outer loop in its full form without breaking it into smaller chunks using '#pragma ACCEL TILE FACTOR=1'.\n4.  Don't automatically pipeline the middle loop using '#pragma ACCEL PIPELINE \"off\"'.\n5. Process the middle loop in chunks of size 2 using '#pragma ACCEL TILE FACTOR=2'.\n6. Flatten the inner loop automatically using '#pragma ACCEL PIPELINE auto{flatten}'.\n7. Process the inner loop in its full form without breaking it into smaller chunks using '#pragma ACCEL TILE FACTOR=1'.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{2}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL WORKER FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes in C, use the following natural language instruction:\n\n\"Designate the following function as a hardware kernel for acceleration, and within the function, apply automatic loop pipelining, tile factor and parallelization for optimization.\"", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1*i;\n        int j_col = j + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_col][j] - ex[i][j_col]) - 0.7 * (ey[i][j_col] - ey[i_col][j]);\n      }\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes in C for hardware acceleration, use the following comprehensive but concise natural language instruction:\n\n\"Declare the following function as a hardware kernel for acceleration and apply specific optimizations to the loops: turn off automatic pipelining, set the tile factor to 1 for original full processing, and parallelize the loops with specific factors of 2, 32, and 12.\"\n\nThis instruction covers the key pragma values to use:\n\n- '#pragma ACCEL kernel' for hardware acceleration\n- '#pragma ACCEL PIPELINE auto{off}' for turning off automatic pipelining\n- '#pragma ACCEL TILE FACTOR=auto{1}' for setting the tile factor to 1\n- '#pragma ACCEL PARALLEL FACTOR=auto{2}' for parallelizing the loop with a factor of 2\n- '#pragma ACCEL PARALLEL FACTOR=auto{32}' for parallelizing the loop with a factor of 32\n- '#pragma ACCEL PARALLEL FACTOR=auto{12}' for parallelizing the loop with a factor of 12", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i % 100);\n        int j_col = 2L * (j % 120);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_up = i + 1;\n        int j_up = j + 1;\n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7_0}\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_up][j] - ex[i][j]) - 0.7 * (ey[i][j_up] - ey[i][j]);\n      }\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes in C, use the following natural language instructions for the #pragma values:\n\n1. Apply automatic pipelining to the loop: \n   Use '#pragma ACCEL PIPELINE auto{}' to automatically pipeline the loop.\n   \n2. Set the tiling factor for the loop to its automatic value:\n   Use '#pragma ACCEL TILE FACTOR=auto{1}' to set the tiling factor automatically.\n   \n3. Set the parallelization factor for the first loop to its automatic value:\n   Use '#pragma ACCEL PARALLEL FACTOR=auto{2}' to parallelize the loop automatically.\n\n4. Set a specific parallelization factor for the inner loop to its automatic value:\n   Use '#pragma ACCEL PARALLEL FACTOR=auto{32}' to parallelize the inner loop with the specified factor.\n\n5. Set a different parallelization factor for the subsequent inner loop to its automatic value:\n   Use '#pragma ACCEL PARALLEL FACTOR=auto{12}' to parallelize the second inner loop with the specified factor.\n\nBy following these instructions, you can generate the given HLS codes in C with the appropriate #pragma values.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}"}}
{"input": "To auto pipeline the loop, use `#pragma ACCEL PIPELINE auto`  \nTo auto tile the loop with factor 1, use `#pragma ACCEL TILE FACTOR=auto{1}`  \nTo auto parallelize the loop with factor 2, use `#pragma ACCEL PARALLEL FACTOR=auto{2}`  \nTo auto parallelize the inner loop with factor 32, use `#pragma ACCEL PARALLEL FACTOR=auto{32}`  \nTo auto parallelize the inner loop with factor 12, use `#pragma ACCEL PARALLEL FACTOR=auto{12}`", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L2}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L3}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L4}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L5}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__Para__L6}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _row = 2 * i *240 + j;\n        int _col = 2 * (j + 1) *200 + i;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[j + 1][i] - ey[j][i]);\n      }\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes in C, follow these concise natural language instructions:\n1. Treat the following function as a hardware kernel for acceleration.\n2. Don't automatically pipeline this loop.\n3. Process this loop in its original, full form without breaking it into smaller chunks.\n4. Run the iterations of this loop in parallel with a factor of 2.\n5. Run the iterations of this loop in parallel with a factor of 4.\n6. Run the iterations of this loop in parallel with a factor of 8.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To automatically pipeline the loop, set the pragma value to '#pragma ACCEL PIPELINE auto{}'. To process the loop in its original, full form without breaking it into smaller chunks, set the pragma value to '#pragma ACCEL TILE FACTOR=auto{1}'. To run the iterations of the loop one after the other, not in parallel, set the pragma value to '#pragma ACCEL PARALLEL FACTOR=auto{2}'.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": ".pragma ACCEL PIPELINE auto{}\n.pragma ACCEL TILE FACTOR=auto{1}\n.pragma ACCEL PARALLEL FACTOR=auto{2}\n #pragma ACCEL PARALLEL FACTOR=auto{1}\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}"}}
{"input": "Process the following function as a hardware kernel for acceleration. Code the loops for r, q, and p to be pipelined without using automatic pipeline. Use a tile factor of 1 for each loop.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{2}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L4}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        double  _tmp_1 = 0.0;\n        double  _tmp_2 = 0.0;\n        double  _tmp_3 = 0.0;\n        double  _tmp_4 = 0.0;\n        double  _tmp_5 = 0.0;\n        double  _tmp_6 = 0.0;\n        double  _tmp_7 = 0.0;\n        double  _tmp_8 = 0.0;\n        double  _tmp_9 = 0.0;\n        _tmp_1 = ex[i][j + 1] - ex[i][j];\n        _tmp_2 = ey[i + 1][j] - ey[i][j];\n        _tmp_3 = hz[i + 1][j] - hz[i][j];\n        _tmp_4 = ex[i + 1][j + 1] - ex[i + 1][j];\n        _tmp_5 = ey[i + 1][j + 1] - ey[i + 1][j];\n        _tmp_6 = hz[i + 1][j + 1] - hz[i + 1][j];\n        _tmp_7 = ex[i][j] - ex[i][j - 1];\n        _tmp_8 = ey[i][j] - ey[i - 1][j];\n        _tmp_9 = hz[i][j] - hz[i - 1][j];\n        hz[i][j] = hz[i][j] + 0.7 * ((_tmp_4 - _tmp_1) + (_tmp_7 - _tmp_2) + (_tmp_8 - _tmp_3) - (_tmp_5 - _tmp_6));\n        ey[i][j] = ey[i][j] + 0.7 * ((_tmp_3 - _tmp_8) + (_tmp_5 - _tmp_9));\n        ex[i][j] = ex[i][j] + 0.7 * ((_tmp_1 - _tmp_4) + (_tmp_2 - _tmp_7));\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        double  delta_e = (ex[i][j + 1] - ex[i][j]) + (ey[i + 1][j] - ey[i][j]);\n        double  delta_h = hz[i][j + 1] - hz[i][j];\n        double  D = delta_e - delta_h;\n        hz[i][j] += 0.7 * D;\n      }\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes written in C:\nUse '#pragma ACCEL kernel' to designate the following function as a hardware kernel for acceleration.\n\nUse '#pragma ACCEL PIPELINE auto{}' to enable automatic pipeline scheduling for the loop.\n\nUse '#pragma ACCEL TILE FACTOR=auto{1}' to process the loop in its original, full form without breaking it into smaller chunks.\n\nUse '#pragma ACCEL PARALLEL FACTOR=auto{2}' to run iterations of the loop in parallel, with a parallel factor of 2.\n\nUse '#pragma ACCEL PARALLEL FACTOR=auto{32}' to run the inner loop iterations in parallel, with a parallel factor of 32.\n\nUse '#pragma ACCEL PARALLEL FACTOR=auto{12}' to run iterations of the inner loop in parallel, with a parallel factor of 12.\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Transform the following function into a hardware kernel for acceleration, and apply parallelization to the outer and inner loops. Also, pipeline the loop for better performance.\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = (i * 240) + j;\n        int i_row = ((i + 1) * 240) + j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_row][j + 1] - ex[i_row][j] + ey[i][j + 1] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        double  _vala = 0.0;\n        double  _valb = 0.0;\n        double  _valc = 0.0;\n        double  _vald = 0.0;\n        double  _vale = 0.0;\n        double  _valf = 0.0;\n        double  _valg = 0.0;\n        double  _valh = 0.0;\n        _vala = ex[i][j];\n        _valb = ey[i][j];\n        _valc = hz[i][j];\n        _vald = ex[i][j + 1];\n        _vale = ey[i][j + 1];\n        _valf = hz[i][j + 1];\n        _valg = ex[i + 1][j];\n        _valh = ey[i + 1][j];\n        hz[i][j] = _valc + 0.25 * (sqr(sin(_vala)) * (_valb - _valh) + sqr(sin(_valb)) * (_vala - _valg) + sqr(sin(_valc)) * (_valh - _vald) + sqr(sin(_vald)) * (_valg - _vala) + sqr(sin(_vale)) * (_valb - _valf) + sqr(sin(_valf)) * (_vale - _valb) + sqr(sin(_valg)) * (_vald - _valc) + sqr(sin(_valh)) * (_valc - _vald));\n        ey[i][j] = _valb + 0.25 * (sqr(sin(_vala)) * (hz[i][j] - _vald) + sqr(sin(_valb)) * (hz[i][j + 1] - _vale) + sqr(sin(_valc)) * (hz[i + 1][j] - _valf) + sqr(sin(_vald)) * (hz[i][j] - _valg) + sqr(sin(_vale)) * (hz[i][j + 1] - _vala) + sqr(sin(_valf)) * (hz[i + 1][j + 1] - _valb) + sqr(sin(_valg)) * (hz[i + 1][j] - _valc) + sqr(sin(_valh)) * (hz[i + 1][j + 1] - _vald));\n        ex[i][j] = _vala + 0.25 * (sqr(sin(_vala)) * (hz[i][j + 1] - _valf) + sqr(sin(_valb)) * (hz[i + 1][j + 1] - _valg) + sqr(sin(_valc)) * (hz[i + 1][j] - _valh) + sqr(sin(_vald)) * (hz[i][j] - _vala) + sqr(sin(_vale)) * (hz[i + 1][j + 1] - _valb) + sqr(sin(_valf)) * (hz[i][j + 1] - _vale) + sqr(sin(_valg)) * (hz[i + 1][j] - _valc) + sqr(sin(_valh)) * (hz[i + 1][j + 1] - _vald));\n      }\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes in C, you need to apply the following #pragma values:\n\n1. For the outermost loop:\n   - Use `#pragma ACCEL PIPELINE \"off\"` to prevent automatic pipelining.\n\n2. For the nested loops:\n   - Use `#pragma ACCEL TILE FACTOR=1` to process the loops in their original, full form without breaking them into smaller chunks.\n\n3. Inside the innermost loop:\n   - Use `#pragma ACCEL PIPELINE \"off\"` to disable automatic pipelining.\n\nCombine these pragma directives with the function declaration `#pragma ACCEL kernel` to treat the function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}"}}
{"input": "Process the following loops in their original, full form without breaking them into smaller chunks and automatically pipeline each loop. Treat the 'kernel_doitgen' function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        double sum_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=sum_tmp FACTOR=auto{__PARA__L3}\n\tfor (s = 0; s < 30; s++) {\n          sum_tmp += A[r][q][s] * C4[s][p];\n        }\n\tsum[p] = sum_tmp;\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        double sum_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=sum_tmp FACTOR=auto{__PARA__L3}\n\tfor (s = 0; s < 30; s++) {\n          sum_tmp += A[r][q][s] * C4[s][p];\n        }\n\tsum[p] = sum_tmp;\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        double sum = ((double )0);\n#pragma ACCEL PARALLEL reduction=sum FACTOR=auto{__PARA__L3}\n\tfor (s = 0; s < 30; s++) {\n          sum += A[r][q][s] * C4[s][p];\n        }\n\tA[r][q][p] = sum;\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Apply pipeline optimization to the outermost loop, and enable tiling with a factor of 2 for parallelism. Disable pipeline optimization and set tiling factor to 1 for the inner loops to maintain the original, unbroken form. Additionally, mark the following function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][80],double C[80][50],double D[40][50])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      for (k = 0; k < 70; k++) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 50; j++) {\n      D[i][j] *= beta;\n      for (k = 0; k < 80; k++) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{80}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes:\n\n1. Treat the following function `kernel_jacobi_1d` as a hardware kernel for acceleration - Use `#pragma ACCEL kernel` before the function declaration.\n\n2. Don't automatically pipeline the loop - Use `#pragma ACCEL PIPELINE \"off\"` before the loop to disable automatic pipelining.\n\n3. Process this loop in its original, full form without breaking it into smaller chunks - Use `#pragma ACCEL TILE FACTOR=1` before the loop to set the tile factor to 1.\n\n4. Run the iterations of this loop one after the other, not in parallel - Use `#pragma ACCEL PARALLEL FACTOR=1` before the loop to set the parallel factor to 1.\n\nThese instructions will help you generate the given HLS codes written in C.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{15}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Process the functions 'kernel_doitgen' as hardware kernels for acceleration. For the loops in the function, ensure they are not automatically pipelined and are processed in their original, full form without breaking them into smaller chunks. Additionally, ensure that the iterations of the loops are not run in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        double sum_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=sum_tmp FACTOR=auto{__PARA__L3}\n\tfor (s = 0; s < 30; s++) {\n          sum_tmp += A[r][q][s] * C4[s][p];\n        }\n\tsum[p] = sum_tmp;\n        A[r][q][p] = sum_tmp;\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        double sum_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=sum_tmp FACTOR=auto{__PARA__L3}\n\tfor (s = 0; s < 30; s++) {\n          sum_tmp += A[r][q][s] * C4[s][p];\n        }\n\tsum[p] = sum_tmp;\n\tdouble A_tmp = A[r][q][p];\n\tA[r][q][p] = A_tmp * C4[p][p];\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        double sum_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=sum_tmp FACTOR=auto{__PARA__L3}\n\tfor (s = 0; s < 30; s++) {\n          sum_tmp += A[r][q][s] * C4[s][p];\n        }\n\tsum[p] = sum_tmp;\n\tdouble A_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=A_tmp FACTOR=auto{__PARA__L4}\n\tfor (s = 0; s < 30; s++) {\n          A_tmp += A[r][q][s] * sum[s];\n        }\n\tA[r][q][0] = A_tmp;\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Apply automatic pipeline directive to the loop\nApply automatic tiling directive to the loop with a factor of 1\nApply automatic parallelization directive to the loop with a factor of 2\nApply automatic parallelization directive to the inner loop with a factor of 4\nApply automatic parallelization directive to the inner loop with a factor of 8", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL PIPELINE auto{__PIPE__L3}\n \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 1; i <= 32; i++) {\n     tmp = in[i] + 1.0;\n     out[i] = tmp * tmp;\n     a[i] = a[i] * b[i];\n  }\n//Matrix multiplication\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n  for (i = 1; i <= 32; i++) {\n     y[i] = 0.0;\n     for (j = 1; j <= 32;j++) {\n       y[i] = y[i] + a[j] * b[i * j];\n     }\n  }\n}\n \nint main(int argc,char**argv) {\n  double out[32];\n  double y[32];\n  double a[32];\n  double b[32];\n  double in[32];\n  double tmp;\n  int i;\n  int j;\n  \n#pragma ACCEL kernel\n  kernel_gemm(out,y,a,b,in,tmp,i,j,142);\n  for (i = 0; i < 32; i++) {\n    a[i] = ((double )1.0);\n    b[i] = ((double )1.0);\n    in[i] = ((double )1.0);\n    tmp = 0.0;\n    y[i] = 0.0;\n    out[i] = 0.0;\n  }\n  for (i = 0; i < 32; i++) {\n    for (j = 0; j < 32; j++) {\n      a[i] *= b[j];\n      tmp += a[j] * b[i];\n    }\n    y[i] = a[i] + tmp;\n    out[i] = in[i] * y[i];\n  }\n  for (i = 0; i < 32; i++) {\n    if (out[i] - 142.9827 != 0.0) {\n      printf(\"Mistake in libkernel: \");\n      printf(\"out[i]=%f\",out[i]);\n      printf(\" instead of \");\n      printf(\"142.9827\");\n      printf(\"\\n\");\n      return 0;\n    }\n  }\n  return 0;\n}", "1": "#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (j = 1; j <= n; j++) {\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{4}\n    for (i = 1; i <= n - 1; i++) {\n      y[i] += b[i] * y[j];\n    }\n  }\n}", "2": "#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (j = 1; j <= n; j++) {\n    \n#pragma ACCEL PARALLEL reduction=A FACTOR=auto{__PARA__L3}\n    for (i = 1; i <= n - 1; i++) {\n      A[i][j] = A[i][j] - A[i][1] * A[1][j];\n    }\n  }\n}"}}
{"input": "To accelerate the 'kernel_jacobi_1d' function, use the following comprehensive but very concise natural language instruction:\n\n\"Automatically pipeline the loop, break it into smaller chunks, and run iterations in parallel with specific factors.\"\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L10}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L11}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L12}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L13}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L14}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L15}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L16}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L17}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L18}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L19}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L20}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L21}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L22}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L23}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L24}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L25}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L26}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L27}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L28}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L29}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L30}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L31}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L32}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L33}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L34}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L35}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L36}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L37}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L38}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L39}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L40}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L41}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L42}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L43}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L44}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L45}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L46}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L47}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L48}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L49}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L50}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L51}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L52}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L53}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L54}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L55}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L56}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L57}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L58}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L59}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L60}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L61}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L62}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L63}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L64}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L65}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L66}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L67}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L68}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L69}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L70}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L71}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L72}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L73}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L74}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L75}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L76}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L77}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L78}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L79}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L80}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L81}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L82}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L83}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L84}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L85}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L86}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L87}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L88}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L89}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L90}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L91}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L92}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L93}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L94}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L95}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L96}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L97}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L98}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L99}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L100}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L101}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L102}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L103}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L104}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L105}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L106}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L107}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L108}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L109}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L110}\n  \n#pragma ACCEL PARALLEL FACTOR=auto", "1": "#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L10}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L11}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L12}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L13}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L14}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L15}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L16}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L17}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L18}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L19}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L20}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L21}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L22}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L23}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L24}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L25}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L26}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L27}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L28}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L29}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L30}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L31}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L32}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L33}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L34}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L35}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L36}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L37}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L38}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L39}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L40}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L41}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L42}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L43}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L44}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L45}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L46}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L47}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L48}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L49}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L50}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L51}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L52}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L53}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L54}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L55}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L56}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L57}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L58}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L59}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L60}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L61}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L62}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L63}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L64}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L65}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L66}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L67}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L68}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L69}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L70}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L71}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L72}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L73}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L74}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L75}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L76}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L77}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L78}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L79}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L80}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L81}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L82}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L83}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L84}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L85}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L86}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L87}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L88}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L89}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L90}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L91}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L92}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L93}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L94}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L95}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L96}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L97}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L98}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L99}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L100}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L101}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L102}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L103}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L104}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L105}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L106}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L107}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L108}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L109}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L110}\n  \n#pragma ACCEL PARALLEL FACTOR=auto", "2": "#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L10}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L11}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L12}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L13}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L14}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L15}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L16}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L17}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L18}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L19}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L20}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L21}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L22}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L23}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L24}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L25}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L26}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L27}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L28}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L29}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L30}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L31}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L32}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L33}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L34}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L35}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L36}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L37}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L38}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L39}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L40}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L41}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L42}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L43}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L44}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L45}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L46}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L47}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L48}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L49}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L50}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L51}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L52}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L53}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L54}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L55}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L56}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L57}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L58}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L59}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L60}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L61}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L62}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L63}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L64}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L65}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L66}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L67}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L68}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L69}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L70}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L71}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L72}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L73}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L74}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L75}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L76}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L77}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L78}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L79}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L80}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L81}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L82}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L83}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L84}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L85}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L86}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L87}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L88}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L89}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L90}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L91}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L92}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L93}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L94}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L95}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L96}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L97}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L98}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L99}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L100}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L101}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L102}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L103}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L104}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L105}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L106}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L107}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L108}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L109}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L110}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{"}}
{"input": "To generate the given HLS codes in C, you should use the following concise natural language instructions for the specific #pragma values:\n\n1. \"Process this loop in its original, full form without breaking it into smaller chunks and don't automatically pipeline it\" to describe `#pragma ACCEL PIPELINE off`\n2. \"Break this loop into smaller chunks of the same size for optimization\" to describe `#pragma ACCEL TILE FACTOR=1`\n3. \"Run the iterations of this loop in parallel with a factor of 2\" to describe `#pragma ACCEL PARALLEL FACTOR=2`\n4. \"Treat the following function as a hardware kernel for acceleration\" to describe `#pragma ACCEL kernel`\n\nBy using these natural language instructions, you can generate the HLS codes written in C as provided.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 38; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        double delta_x = (double )(ex[i][j + 1] - ex[i][j]);\n        double  delta_y = (double )(ey[i + 1][j] - ey[i][j]);\n        double  delta_z = (double )(hz[i][j + 1] - hz[i][j]);\n        double   si = 1.0 / (1.0 + delta_x * delta_x);\n        double   sj = 1.0 / (1.0 + delta_y * delta_y);\n        double   sk = 1.0 / (1.0 + delta_z * delta_z);\n        double  val = si * sj * sk * (hz[i][j] - (delta_x * ((ey[i][j + 1] - ey[i][j]) + (delta_y * (ex[i + 1][j] - ex[i][j])))) - delta_z * (ex[i][j] - ex[i][j + 1]));\n        double  ex_x = si * sj * ( ey[i][j + 1] - ey[i][j] - delta_x * (val - ex[i][j]));\n        double  ey_y = sj * sk * ( ex[i + 1][j] - ex[i][j] - delta_y * (val - ey[i][j]));\n        double  hz_z = sk * si * ( ex[i][j] - ex[i][j + 1] - delta_z * (val - hz[i][j]));\n        ex[i][j] = ex_x;\n        ey[i][j] = ey_y;\n        hz[i][j] = hz_z;\n      }\n    }\n  }\n}"}}
{"input": "To generate the provided HLS codes in C, use the following natural language instructions for specific #pragma values:\n\nEnsure this function is treated as a hardware kernel for acceleration:\n```c\n#pragma ACCEL kernel\n```\n\nDon't automatically pipeline the outermost loop:\n```c\n#pragma ACCEL PIPELINE \"off\"\n```\n\nProcess the loops in their original, full form without breaking them into smaller chunks:\n```c\n#pragma ACCEL TILE FACTOR=1\n```\n\nRun the iterations of the inner loop one after the other, not in parallel:\n```c\n#pragma ACCEL PARALLEL FACTOR=1\n```", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{}\n      \n#pragma ACCEL TILE FACTOR=auto{4}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "Ensure this function is treated as a hardware kernel for acceleration:\n#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction=D FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "### Instruction: \nOptimize the loop to run efficiently for hardware acceleration, and attempt automatic strategies for pipelining, tiling, and parallelization.\n\n### Pragma Values:\n- `#pragma ACCEL PIPELINE auto{off}`: Don't automatically pipeline this loop\n- `#pragma ACCEL TILE FACTOR=auto{1}`: Process this loop in its original, full form without breaking it into smaller chunks\n- `#pragma ACCEL PARALLEL FACTOR=auto{2}`: Run the iterations of this loop in parallel with factor 2\n- `#pragma ACCEL PARALLEL FACTOR=auto{3}`: Run the inner loop iterations in parallel with factor 3\n- `#pragma ACCEL PARALLEL FACTOR=auto{12}`: Run the outer loop iterations in parallel with factor 12\n- `#pragma ACCEL kernel`: Treat the following function as a hardware kernel for acceleration", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "", "1": "", "2": ""}}
{"input": "Process the loops in their original, full form without breaking them into smaller chunks, and do not automatically pipeline the loops. Treat the function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{2}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2_0}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[j];\n    }\n    \n#pragma ACCEL PIPELINE auto{off_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1_1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2_1}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2_1_0}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1_2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2_2}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2_2_0}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1_3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2_3}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2_3_0}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _row = i * 240 + j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}"}}
{"input": "Process both loops in their original, full form without breaking them into smaller chunks; run the iterations of the loops in parallel with a factor of 2; pipeline both loops automatically.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[410][390],double s[390],double q[410],double p[390],double r[410])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 390; i++) {\n    s[i] = ((double )0);\n    q[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 410; i++) {\n    q[0] += r[i] * A[i][0];\n    s[0] += r[i] * A[i][0];\n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 1; j < 390; j++) {\n      q[j] += r[i] * A[i][j];\n      s[j] += A[i][j] * p[j];\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes, follow these concise natural language instructions:\n- Optimize the loop using automatic pipelining.\n- Split the loop into smaller chunks with a factor of 1.\n- Parallelize the loop with a factor of 2.\n- Further parallelize the inner loop with a factor of 4.\n- Further parallelize the loop with a factor of 8.\n\nThis will result in the same HLS codes in C using #pragma directives.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{_1}\n    \n#pragma ACCEL TILE FACTOR=auto{_1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{_2}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{_3}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_4}\n    \n#pragma ACCEL TILE FACTOR=auto{_4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{_5}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{_6}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_7}\n    \n#pragma ACCEL TILE FACTOR=auto{_7}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{_8}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{_9}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{_1}\n    \n#pragma ACCEL TILE FACTOR=auto{_1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{_2}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{_3}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_4}\n    \n#pragma ACCEL TILE FACTOR=auto{_4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{_5}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{_6}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{_7}\n    \n#pragma ACCEL TILE FACTOR=auto{_7}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{_8}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{_9}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes in C:\n\n1. Treat the following function as a hardware kernel for acceleration.\n2. Don't automatically pipeline this loop.\n3. Process this loop in its original, full form without breaking it into smaller chunks.\n4. Run the iterations of this loop one after the other, not in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_gesummv(double alpha,double beta,double A[250][250],double B[250][250],double tmp[250],double x[250],double y[250])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 250; i++) {\n    tmp[i] = 0.0;\n    y[i] = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 250; j++) {\n      tmp[i] += A[i][j] * x[j];\n      y[i] += B[i][j] * x[j];\n    }\n    y[i] = alpha * tmp[i] + beta * y[i];\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[410][390],double s[390],double q[410],double p[390],double r[410])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PARALLEL FACTOR=auto{26472144}\n  for (i = 0; i < 390; i++) {\n    s[i] = ((double )0);\n    q[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 410; i++) {\n    q[0] += r[i] * A[i][0];\n    s[0] += r[i] * A[i][0];\n/* Multiply Q<j> by A<i,j> in A */\n    \n#pragma ACCEL PARALLEL FACTOR=auto{256}\n    for (j = 0; j < 390; j++) {\n      q[j] = q[j] * A[i][0] + r[i] * A[i][j];\n      s[j] = s[j] * A[i][0] + p[i] * A[i][j];\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes in C, follow the natural language instruction:\n\n\"For the function `kernel_doitgen`, mark it as a hardware kernel for acceleration by treating it as such.\"\nUse the following #pragma values:\n1. `#pragma ACCEL kernel` - Treat the following function as a hardware kernel for acceleration.\n\nThis will correctly generate the provided HLS codes in C.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{8}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "", "1": "", "2": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int ni,int nj,int nk,int nl,double A[40][50],double B[40][50],double C[50][60],double D[40][60],double product[40][50])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      A[i][j] = ((double )0);\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 60; j++) {\n      B[i][j] = ((double )0);\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 60; j++) {\n      C[i][j] = ((double )0);\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 60; j++) {\n      D[i][j] = ((double )0);\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 50; k++) {\n        A[i][k] += B[i][j] * C[k][j];\n        D[i][j] += A[i][k] * C[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 50; j++) {\n      product[i][j] = A[i][j] * D[i][j];\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Optimize nested loops for FPGA acceleration by automatically parallelizing and pipelining the outer and inner loops. Use the specified array reduction factor for parallelism. Apply tiling to the loops with a factor of 1 to maintain the original loop structure. Treat the \"kernel_big\" function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][70],double F[40][70],double C[70][80],double D[80][90],double G[40][90])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n      for (k = 0; k < 50; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_big(double A[250][250],double C4[250][250],double sum[250])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (i = 0; i < 250; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    for (j = 0; j < 250; j++) {\n      double tmp = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{__PARA__L5}\n      for (k = 0; k < 250; k++) {\n        tmp += A[i][k] * C4[k][j];\n      }\n      sum[i] = tmp;\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_big(int tsteps,int n,double u[60][60],double v[60][60],double w[60][60],double x[60][60],double y[60][60],double z[60][60])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{112}\n  for (t = 1; t <= 390; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 59; j++) {\n        u[i][j] = ((double )0);\n        v[i][j] = ((double )0);\n        w[i][j] = ((double )0);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (i = 1; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 1; j < 59; j++) {\n        double DU_J = 0.0;\n        double DV_I = 0.0;\n        double DW_I = 0.0;\n        double _in_0 = 0.0;\n        double _in_1 = 0.0;\n        double _in_2 = 0.0;\n        double _in_3 = 0.0;\n        double _in_4 = 0.0;\n        double _in_5 = 0.0;\n        double _in_6 = 0.0;\n        double _in_7 = 0.0;\n        double _in_8 = 0.0;\n        double _in_9 = 0.0;\n        double _in_10 = 0.0;\n        double _in_35 = u[i][j];\n        u[i][j] = _in_35 + _in_35;\n        _in_0 = u[i][j - 1];\n        DU_J = _in_0 + _in_0;\n        _in_1 = v[i - 1][j] ;\n        DV_I = _in_1 + _in_1;\n        _in_2 = w[i][j + 1];\n        DW_I = _in_2 + _in_2;\n        _in_3 = u[i][j + 1];\n        x[i][j] = _in_3 + _in_3;\n        _in_4 = v[i + 1][j] ;\n        y[i][j] = _in_4 + _in_4;\n        _in_5 = w[i + 1][j] ;\n        z[i][j] = _in_5 + _in_5;\n        _in_6 = DU_J * x[i][j];\n        _in_7 = DV_I * y[i][j];\n        _in_8 = DW_I * z[i][j];\n        _in_9 = DU_J * y[i][j];\n        _in_10 = DV_I * z[i][j];\n        u[i][j] = _in_6 - _in_9;\n        v[i][j] = _in_7 - _in_10;\n        w[i][j] = _in_8 - _in_10;\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 1; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 59; j++) {\n        x[i][j] -= 0.5 * (u[i][j] - u[i][j - 1]);\n        y[i][j] -= 0.5 * (v[i][j] - v[i - 1][j]);\n        z[i][j] -= 0.5 * (w[i][j] - w[i][j + 1]);\n      }\n    }\n  }\n}"}}
{"input": "To generate the given C code with HLS pragma directives::\n1. Mark the function as a hardware kernel for acceleration: Use `#pragma ACCEL kernel` before the function definition.\n2. Turn off automatic pipeline for the outer loop: Use `#pragma ACCEL PIPELINE auto{off}` before the outer loop.\n3. Set the tile factor to 1 for the outer loop: Use `#pragma ACCEL TILE FACTOR=auto{1}` before the outer loop.\n4. Turn off automatic pipeline for the inner loops: Use `#pragma ACCEL PIPELINE auto{off}` before the inner loops.\n5. Set the tile factor to 1 for the inner loops: Use `#pragma ACCEL TILE FACTOR=auto{1}` before the inner loops.\n\nThese directives will configure the hardware design for the given C code and control the pipelining and tiling behavior for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Process the `doitgen` function as a hardware kernel for acceleration. \nFor the outer loop with loop variable `r`, do not automatically pipeline and process in its original, full form without breaking it into smaller chunks. For the inner loop with loop variable `q`, automatically pipeline and process in smaller chunks with factor of 8. And for the innermost loop with loop variable `p`, automatically pipeline with flattening and process in its original form without breaking it into smaller chunks.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{8}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[25][20][30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = ((double )0);\n      }\n    }\n    for (p = 0; p < 30; p++) {\n      A[r][14][p] = 4.0;\n    }\n    for (q = 0; q < 20; q++) {\n      A[r][q][14] = 4.0;\n    }\n    for (s = 0; s < 1; s++) {\n      for (q = 0; q < 20; q++) {\n        for (p = 0; p < 30; p++) {\n          A[r][q][p] += ((double )(((int )(((double )10.0) * \n                                         sin(((double )(s + 1) * \n                                              p / 30.0))))) * C4[r][q][p]);\n        }\n      }\n    }\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n      for (p = 0; p < 30; p++) {\n        C4[r][q][p] = A[r][q][p];\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Process this loop in its original, full form without breaking it into smaller chunks: #pragma ACCEL TILE FACTOR=1\n\nRun the iterations of this loop one after the other, not in parallel: #pragma ACCEL PARALLEL FACTOR=1\n\nDon't automatically pipeline this loop: #pragma ACCEL PIPELINE \"off\"\n\nTreat the following function as a hardware kernel for acceleration: #pragma ACCEL kernel", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "void kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 2L * j;\n        int _in_i = 2L * i;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "void kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1 * i + 240 - 1;\n        int j_col = -1 * j + 240 - 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL PARAMETER TRI_A = 120\n#pragma ACCEL PARAMETER TRI_B = 120\n#pragma ACCEL PARAMETER TRI_C = 140\n\nvoid kernel_gemm(double alpha,double beta,double C[140][140],double A[140][120],double B[140][120])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//SIDE = 'L'\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is MxK\n//B is KxN\n//C is MxN\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 140; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 140; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 120; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 140; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}"}}
{"input": "Process the loop of the function 'kernel_jacobi_1d' in its original, full form without breaking it into smaller chunks. Automatically pipeline this loop. Run the iterations of this loop in parallel with a factor of 2. Then run the inner loop iterations of this loop in parallel with a factor of 8. Finally, run the inner loop iterations of this loop one after the other, not in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 30; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 30; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 30; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes in C, use the following natural language instructions for the specific #pragma values:\n\n1. Don't automatically pipeline the loop: '#pragma ACCEL PIPELINE auto{off}'\n2. Process this loop in its original, full form without breaking it into smaller chunks: '#pragma ACCEL TILE FACTOR=auto{1}'\n3. Run the iterations of this loop one after the other, not in parallel: '#pragma ACCEL PARALLEL FACTOR=auto{2}'\n4. Treat the following function as a hardware kernel for acceleration: '#pragma ACCEL kernel'", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{32}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#define NR_END 1\n#define FREE_ARG char*\n\n#define NI 64\n#define NJ 64\n#define NK 64\n#define NL 64\n#define NT 4\n#define REAL double\n\nvoid kernel_dpbsp(int tsteps,int n,REAL A[40][50][60][50],REAL B[40][50][60][50],REAL F[40][60][50][50],REAL J[40][50][50][50],REAL D[60][50][50],REAL C[60][50][50])\n{\n  int t;\n  int i;\n  int j;\n  int k;\n  int l;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (i = 0; i <= 39; i++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n      for (j = 0; j <= 29; j++) {\n        for (k = 0; k <= 29; k++) {\n          A[i][j][k][l] = 0.0;\n        }\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (t = 0; t <= 38; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    for (i = 0; i <= 39; i++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n      for (j = 0; j <= 29; j++) {\n        for (k = 0; k <= 29; k++) {\n          for (l = 0; l <= 29; l++) {\n            A[i][j][k][l] = (REAL )(((long )j) * ((long )k) * ((long )l));\n          }\n        }\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n    for (i = 0; i <= 39; i++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n      for (j = 0; j <= 29; j++) {\n        for (k = 0; k <= 29; k++) {\n          for (l = 0; l <= 29; l++) {\n            F[i][j][k][l] = 0.0;\n          }\n        }\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L7}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L7}\n    for (i = 0; i <= 39; i++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L8}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L8}\n      for (j = 0; j <= 29; j++) {\n        for (k = 0; k <= 29; k++) {\n          for (l = 0; l <= 29; l++) {\n            J[i][j][k][l] = 0.0;\n          }\n        }\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L9}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L9}\n    for (i = 0; i <= 59; i++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L10}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L10}\n      for (j = 0; j <= 49; j++) {\n        for (k = 0; k <= 49; k++) {\n          D[i][j][k] = 0.0;\n        }\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L11}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L11}\n    for (i = 0; i <= 59; i++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L12}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L12}\n      for (j = 0; j <= 49; j++) {\n        for (k = 0; k <= 49; k++) {\n          C[i][j][k] = 0.0;\n        }\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L13}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L13}\n    for (t = 0; t <= 37; t++) {\n      \n      for (i = 0; i <= 39; i++) {\n        for (j = 0; j <= 29; j++) {\n          for (k = 0; k <= 29; k++) {\n            for (l = 0; l <= 29; l++) {\n              F[i][j][k][l] += A[i][j][k][l] * B[i][j][k][l];\n            }\n          }\n        }\n      }\n      \n      for (i = 0; i <= 39; i++) {\n        for (j = 0; j <= 29; j++) {\n          for (k = 0; k <= 29; k++) {\n            for (l = 0; l <= 29; l++) {\n              J[i][j][k][l] = F[i][j][k][l] - J[i][j][k][l];\n            }\n          }\n        }\n      }\n      \n      for (i = 0; i <= 59; i++) {\n        for (j = 0; j <= 49; j++) {\n          for (k = 0; k <= 49; k++) {\n            double _in_8 = (double )(60.0 * 50.0 * 40.0);\n            double _in_9 = (double )(j * k * l);\n            double _in_10 = J[i][j][k][l];\n            D[i][j][k] += _in_8 * _in_9 * _in_10;\n          }\n        }\n      }\n      \n      for (i = 0; i <= 59; i++) {\n        for (j = 0; j <= 49; j++) {\n          for (k = 0; k <= 49; k++) {\n            double _in_11 = D[i][j][k];\n            C[i][j][k] += _in_11;\n          }\n        }\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L14}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L14}\n    for (i = 0; i <= 39; i++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L15}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L15}\n      for (j = 0; j <= 29; j++) {\n        for (k = 0; k <= 29; k++) {\n          for (l = 0; l <= 29; l++) {\n            F[i][j][k][l] = C[i][j][k] + J[i][j][k][l];\n          }\n        }\n      }\n    }\n    \n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes, use the following pragma values:\n\n1.  Treat the following function as a hardware kernel for acceleration.\n```c\n#pragma ACCEL kernel\n```\n\n2.  Don't automatically pipeline this loop.\n```c\n#pragma ACCEL PIPELINE \"off\"\n```\n\n3.  Process this loop in its original, full form without breaking it into smaller chunks.\n```c\n#pragma ACCEL TILE FACTOR=1\n```\n\n4.  Run the iterations of this loop one after the other, not in parallel.\n```c\n#pragma ACCEL PARALLEL FACTOR=1\n```", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{8}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "", "1": "", "2": "#pragma ACCEL THREADS FACTOR=auto{1}\n \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n void kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{7}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction=D FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes written in C, use the following concise natural language instruction:\n\n\"Optimize the loop iterations for pipelining, tiling with a factor of 1, and parallelizing with factors of 2, 5, and 8, respectively. Treat the function as a hardware kernel for acceleration.\"\n\nThis instruction captures the process of the codes and specifies the appropriate #pragma values to use.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i - 1) + 1;\n        int j_col = 2L * (j - 1) + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_col][j_col + 1] - ex[i_col][j_col] + ey[i_col + 1][j_col] - ey[i_col][j_col]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := E */\n  for (i = 0; i < 40; i++) {\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n    }\n  }\n  \n/* F := F */\n  for (i = 0; i < 50; i++) {\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n    }\n  }\n  \n/* G := G */\n  for (i = 0; i < 40; i++) {\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n    }\n  }\n  \n/* K := A*B */\n  for (i = 0; i < 40; i++) {\n    for (j = 0; j < 50; j++) {\n      for (k = 0; k < 60; k++) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n/* L := C*D */\n  for (i = 0; i < 50; i++) {\n    for (j = 0; j < 70; j++) {\n      for (k = 0; k < 80; k++) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n  \n/* G := E*F + G */\n  for (i = 0; i < 40; i++) {\n    for (j = 0; j < 70; j++) {\n      for (k = 0; k < 50; k++) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_low = 2*i;\n        int i_high = 2*i + 2;\n        int j_low = 2*j;\n        int j_high = 2*j + 2;\n        double update = ((ey[i_low][j_high] - ey[i_low][j_low]) - (ex[i_high][j_low] - ex[i_low][j_low])) - ey[i][j];\n        double z_ij = hz[i][j] + 0.7 * update;\n        hz[i][j] = z_ij;\n        ey[i][j] = z_ij - update + ex[i][j];\n        ex[i][j] = z_ij - update + ey[i][j];\n      }\n    }\n  }\n}"}}
{"input": "Parallelize the outer loop with a factor chosen automatically. Pipeline the loops using flattening. Tile the loops with a factor chosen automatically. Parallelize the outer and inner loops with a factor chosen automatically and perform reduction on inner loop. Treat the function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[124][116],double s[116],double q[124],double p[116],double r[124])\n{\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 116; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{80}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 124; i++) {\n    q[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n    for (j = 0; j < 116; j++) {\n      s[j] += r[i] * A[i][j];\n      q[i] += A[i][j] * p[j];\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      double Bji = B[i][j];\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1}\n      for (k = 0; k < 70; k++) {\n        tmp[i][j] += A[i][k] * Bji * C[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      double sum = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=sum FACTOR=auto{1}\n      for (k = 0; k < 50; k++) {\n        sum += D[i][k] * C[k][j];\n      }\n      D[i][j] = sum;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      D[i][j] = alpha * tmp[i][j] + beta * D[i][j];\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][80],double C[80][90],double D[40][90])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 90; j++) {\n      D[i][j] *= beta;\n      for (k = 0; k < 80; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Process the following function as a hardware kernel for acceleration and apply the following pragma values:\n1. For the outer loop of 'r', turn off automatic pipelining and maintain the loop in its original, full form without breaking it into smaller chunks.\n2. For the inner loop of 'q', also turn off automatic pipelining and maintain the loop in its original, full form without breaking it into smaller chunks.\n3. For the most inner loop of 'p', again turn off automatic pipelining and maintain the loop in its original, full form without breaking it into smaller chunks.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes in C, use the following comprehensive but concise natural language instruction:\n\n\"Convert the function to a hardware kernel for acceleration and apply automatic pipeline, tile factor, and parallel factor optimizations based on the compiler's decision.\"\n\nThis instruction covers the specific pragmas like \"#pragma ACCEL kernel\", \"#pragma ACCEL PIPELINE auto{}\", \"#pragma ACCEL TILE FACTOR=auto{1}\", and \"#pragma ACCEL PARALLEL FACTOR=auto{}\" and sets the compiler to make automatic decisions for pipeline, tiling, and parallelization factors.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120])\n{\n  int t;\n  int i;\n  double B[120];\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_low = i - 1;\n        int i_high = i + 1;\n        int j_low = j - 1;\n        int j_high = j + 1;\n        double out_0 = ((ex[i][j] - ex[i_low][j]) + (ey[i][j] - ey[i][j_low])) / ((double )2);\n        double out_1 = ((ey[i][j] - ey[i_low][j]) + (hz[i][j] - hz[i_low][j_low])) / ((double )2);\n        double out_2 = ((hz[i][j] - hz[i_low][j]) + (ex[i][j_low] - ex[i_low][j_low])) / ((double )2);\n        double _fict_buf = 0.0;\n        ey[i_low][j] = out_0;\n        ex[i][j_low] = out_1;\n        hz[i_low][j_low] = out_2;\n        ey[i][j] = _fict_buf;\n      }\n    }\n  }\n}"}}
{"input": "Process this loop in its original, full form without breaking it into smaller chunks; don't automatically pipeline this loop; run the iterations of this loop one after the other, not in parallel; treat the following function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes, use the following natural language instruction:\n\n\"Designate the following function as a hardware kernel for acceleration, then automatically pipeline the outer loop, tile the loops with a factor of 1, and parallelize the outer loop with a factor of 2 and the inner loops with factors of 6 and 5 respectively.\"\n\nI hope this helps!", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "", "1": "", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes in C:\n\n- Enhance parallelism by automatically pipelining this loop using '#pragma ACCEL PIPELINE auto{}'\n- Process this loop with its original, full form without breaking it into smaller chunks using '#pragma ACCEL TILE FACTOR=auto{1}'\n- Run the iterations of this loop in parallel with a factor automatically determined using '#pragma ACCEL PARALLEL FACTOR=auto{2}'\n- Further maximize parallelism by automatically determining the parallel factor of 5 for the inner loop using '#pragma ACCEL PARALLEL FACTOR=auto{5}'\n- Finally, achieve higher parallelism with an automatic parallel factor of 8 for the second inner loop using '#pragma ACCEL PARALLEL FACTOR=auto{8}'\n\nEnsure these pragmas are placed appropriately in the code to achieve the specified hardware acceleration behavior.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{5}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes written in C, use the following natural language instructions for the specific #pragma values:\n\n1. 'Treat the following function as a hardware kernel for acceleration'\n   Use: `#pragma ACCEL kernel`\n\n2. 'Don't automatically pipeline this loop'\n   Use: `#pragma ACCEL PIPELINE \"off\"`\n\n3. 'Process this loop in its original, full form without breaking it into smaller chunks'\n   Use: `#pragma ACCEL TILE FACTOR=1`\n\n4. 'Run the iterations of this loop one after the other, not in parallel'\n   Use: `#pragma ACCEL PARALLEL FACTOR=1`", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}`\n\nint kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "5. 'This is a kernel from PARBOIL'\n   Use: `#pragma ACCEL kernel`\n\n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 38; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{120}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "2": "5. 'Move the following code out of the loop'\n   Use: `#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}`\n\nint kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes in C, use the following natural language instructions for the specific #pragma values:\n\n1. \"Treat the following function as a hardware kernel for acceleration\" - Use `#pragma ACCEL kernel` to indicate that the function should be treated as a hardware kernel for acceleration.\n\n2. \"Don't automatically pipeline this loop\" - Use `#pragma ACCEL PIPELINE \"off\"` to turn off automatic pipelining for the loop.\n\n3. \"Process this loop in its original, full form without breaking it into smaller chunks\" - Use `#pragma ACCEL TILE FACTOR=1` to set the tiling factor to 1, indicating that the loop should not be broken into smaller chunks.\n\n4. \"Run the iterations of this loop one after the other, not in parallel\" - Use `#pragma ACCEL PARALLEL FACTOR=1` to specify that the loop iterations should not be run in parallel and should instead be executed one after the other.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{}\n      \n#pragma ACCEL TILE FACTOR=auto{8}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL PARALLEL FACTOR=auto{16}` to parallelize this loop.\n  \n#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction=D FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "5. \"Map A => B\" - Use `#pragma ACCEL kernel FACTOR=auto{__PARA__L1}` to autoparallelize this kernel.\n  \n#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[200][220],double A[200][200],double B[200][220])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 200; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 220; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 200; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 220; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "2": "5. \"Unroll this loop by a factor of 16\" - Use `#pragma ACCEL PIPELINE auto{off} UNROLL auto{16}` to specify that the pipeline of this loop should be flushed and the loop should be unrolled by a factor of 16.\n\n6. \"Automatic cache\" - Use `#pragma ACCEL PIPELINE auto{off} AUTO_EXPOSE_CACHE` to enable the automatic exposure of a cache for the pipeline.\n\n#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}"}}
{"input": "Process this function as a hardware kernel for acceleration. Pipeline the outer loop with offloading disabled. Use an automatic tiling factor of 2 for the outer loop. Pipeline the middle loop with flattening enabled and use an automatic tiling factor of 1 for the middle and inner loops.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < 240 - 1; j++) {\n        int _array_idx = i * 240 + j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_in_j;\n        int i_min_j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}"}}
{"input": "Process the nested loops in their original, full form without breaking them into smaller chunks, and treat the function as a hardware kernel for acceleration. Additionally, don't automatically pipeline the loops and use a tile factor of 1 for each loop.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[j];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_0}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{off_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1_1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_1}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1_1_0}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1_2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_2}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1_2_0}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1_3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_3}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1_3_0}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _row = i * 240 + j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}"}}
{"input": "Process the following function as a hardware kernel for acceleration, and don't automatically pipeline the outermost loop; process the outermost loop in its original, full form without breaking it into smaller chunks; process the inner loops with a tile factor of 1, and turn off automatic pipelining for the inner loops.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{8}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_0}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[j];\n    }\n    \n#pragma ACCEL PIPELINE auto{off_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1_1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_1}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1_1_0}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1_2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_2}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1_2_0}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1_3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_3}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1_3_0}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[j];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Process the three nested loops in function 'kernel_doitgen' in the original, full form without breaking them into smaller chunks. Ensure that the loops are not automatically pipelined and that they are not treated as flattened. Set the tile factor as 1 for the outer two loops and 8 for the inner loop to optimize for hardware acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{8}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][25])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        double sum = ((double )0);\n#pragma ACCEL PARALLEL reduction=sum FACTOR=auto{__PARA__L3}\n\tfor (s = 0; s < 30; s++) {\n          sum += A[r][q][s] * C4[s][p];\n        }\n\tA[r][q][p] = sum;\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int A[25][20][30],int B[25][20][30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        B[r][q][p] = A[r][q][p];\n      }\n    }\n    for (p = 0; p < 30; p++) {\n      for (s = 0; s < 16; s++) {\n        int _in_val = A[r][s][p];\n        B[r][s][p] = _in_val;\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][25])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = ((double )0);\n      }\n    }\n    for (p = 0; p < 30; p++) {\n      A[r][14][p] = 1.0;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n      for (p = 0; p < 30; p++) {\n        for (s = 0; s < 16; s++) {\n          A[r][q][p] += C4[p][s + 0] * A[r][s + 0][q] + C4[p][s + 1] * A[r][s + 1][q] + C4[p][s + 2] * A[r][s + 2][q] + C4[p][s + 3] * A[r][s + 3][q] + C4[p][s + 4] * A[r][s + 4][q];\n        }\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes in C, you should use the following comprehensive but concise natural language instructions for the #pragma values:\n\n1. Don't automatically pipeline this loop.\n2. Process this loop in its original, full form without breaking it into smaller chunks.\n3. Run the iterations of this loop two at a time in parallel.\n4. Treat the following function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L8}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}"}}
{"input": "Process the loops with automatic pipeline and tiling, and use the default tile factor for the tiling.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{}\n      \n#pragma ACCEL TILE FACTOR=auto{4}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n    for (j = 0; j < 70; j++) {\n      double tmp = A[i][0] * B[0][j];\n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (k = 1; k < 80; k++) {\n        tmp += A[i][k] * B[k][j];\n      }\n      C[i][j] += alpha * tmp;\n    }\n  }\n}", "1": "#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (i = 16; i < 96; i++) {\n    dm2[i] = 0.0;\n    \n#pragma ACCEL PARALLEL reduction FACTOR=auto{__PARA__L4}\n    for (j = 16; j < 96; j++) {\n      dm2[i] += dm1[j] * b[i * j];\n    }\n  }\n}", "2": "#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (j = 16; j < 96; j++) {\n    tmp = 0.0;\n    dum = 0.0;\n    for (i = 1; i < 80; i++) {\n      tmp += A[i][j];\n      dum += A[i][j] * B[i][j];\n    }\n    for (i = 1; i < 80; i++) {\n      A[i][j] = A[i][j] - tmp / 80.0;\n      B[i][j] = B[i][j] - A[i][j] * dum / tmp;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n  for (i = 1; i < 80; i++) {\n    y[i] = 0.0;\n  }\n  \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n  for (j = 16; j < 96; j++) {\n    sum = 0.0;\n#pragma ACCEL PARALLEL reduction=sum FACTOR=auto{__PARA__L4}\n    for (i = 1; i < 80; i++) {\n      sum += A[i][j] * y[i];\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    y[j] = sum;\n  }\n}"}}
{"input": "Process the following function as a hardware kernel for acceleration and apply the following pragma values: Do not automatically pipeline the loops using pragma ACCEL PIPELINE auto{off}, and process the loops without breaking them into smaller chunks using pragma ACCEL TILE FACTOR=2, and for each loop, turn off automatic pipelining with pragma ACCEL PIPELINE auto{off} and use pragma ACCEL TILE FACTOR=1 to process the iterations in their original, full form without breaking them into smaller chunks.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes in C, use these natural language instructions:\n\n1. Treat the following function as a hardware kernel for acceleration.\n2. Don't automatically pipeline this loop.\n3. Process this loop in its original, full form without breaking it into smaller chunks.\n4. Run the iterations of this loop one after the other, not in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{2}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_gemver(int n,double alpha,double beta,double A[120][120],double u1[120],double v1[120],double u2[120],double v2[120],double w[120],double x[120],double y[120],double z[120])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 120; i++) {\n    x[i] = 0.0;\n    y[i] = 0.0;\n    z[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 120; i++) {\n    double tmp1 = 0.0;\n    double tmp2 = 0.0;\n    double uu = 0.0;\n    double vv = 0.0;\n    double ww = 0.0;\n    double uv = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 120; j++) {\n      tmp1 = A[i][j] * u1[j];\n      tmp2 = A[i][j] * v1[j];\n      uu += u1[j] * tmp1;\n      vv += v1[j] * tmp2;\n      uv += u1[j] * tmp2;\n      ww += w[j] * A[i][j];\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (j = 0; j < 120; j++) {\n      x[i] += v2[j] * tmp2;\n      y[i] += u2[j] * tmp1;\n      z[i] += (A[i][j] * ((u1[j] * v1[j]) + (w[j] * uv + uu * vv \n                                              + ww))) - x[i] - y[i];\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes in C, use the following natural language instructions for the specific #pragma values:\n- For the top-level kernel function: 'Treat the following function as a hardware kernel for acceleration'\n- For the outermost loop over 'r': 'Don't automatically pipeline this loop' and 'Process this loop in its original, full form without breaking it into smaller chunks'\n- For the loop over 'q' inside the 'r' loop: 'Don't automatically pipeline this loop' and 'Process this loop in its original, full form without breaking it into smaller chunks'\n- For the innermost loop over 'p' inside the 'q' loop: 'Don't automatically pipeline this loop' and 'Process this loop in its original, full form without breaking it into smaller chunks'\n\nThese natural language instructions map to the following specific #pragma values in the C code:\n- '#pragma ACCEL kernel' for the top-level kernel function\n- '#pragma ACCEL PIPELINE \"off\"' for the outermost loop over 'r'\n- '#pragma ACCEL TILE FACTOR=1' for the outermost loop over 'r'\n- '#pragma ACCEL PIPELINE \"off\"' for the loop over 'q' inside the 'r' loop\n- '#pragma ACCEL TILE FACTOR=1' for the loop over 'q' inside the 'r' loop\n- '#pragma ACCEL PIPELINE \"off\"' for the loop over 'p' inside the 'q' loop\n- '#pragma ACCEL TILE FACTOR=1' for the loop over 'p' inside the 'q' loop", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "- '#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}' for the loop over 'p' inside the 'q' loop\n- '#pragma ACCEL PIPELINE auto{__PIPE__L3}' for the loop over 'r'\n- '#pragma ACCEL TILE FACTOR=auto{__TILE__L3}' for the loop over 'r'\n- '#pragma ACCEL PIPELINE auto{__PIPE__L4}' for the loop over 'q'\n- '#pragma ACCEL TILE FACTOR=auto{__TILE__L4}' for the loop over 'q'\n\n\n #pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] -= 0.5 * (A[i][j] - A[i][j - 1]);\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "- '#pragma ACCEL PIPELINE auto{__PIPE__L3}' for the loop over 'r'\n- '#pragma ACCEL TILE FACTOR=auto{__TILE__L3}' for the loop over 'r'\n- '#pragma ACCEL PIPELINE auto{__PIPE__L2}' for the loop over 'q'\n- '#pragma ACCEL TILE FACTOR=auto{__TILE__L2}' for the loop over 'q'\n- '#pragma ACCEL PIPELINE auto{__PIPE__L1}' for the loop over 'p'\n- '#pragma ACCEL TILE FACTOR=auto{__TILE__L1}' for the loop over 'p'\n\n\n #pragma ACCEL kernel\n\nvoid kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; k++) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n      for (k = 0; k < 80; k++) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (k = 0; k < 50; k++) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "- '#pragma ACCEL PIPELINE auto{__PIPE__L3}' for the loop over 'r' inside the 'kernel_seidel_2d' function\n- '#pragma ACCEL TILE FACTOR=auto{__TILE__L3}' for the loop over 'r' inside the 'kernel_seidel_2d' function\n- '#pragma ACCEL PIPELINE auto{__PIPE__L2}' for the loop over 'q' inside the 'kernel_seidel_2d' function\n- '#pragma ACCEL TILE FACTOR=auto{__TILE__L2}' for the loop over 'q' inside the 'kernel_seidel_2d' function\n- '#pragma ACCEL PIPELINE auto{__PIPE__L1}' for the loop over 'p' inside the 'kernel_seidel_2d' function\n- '#pragma ACCEL TILE FACTOR=auto{__TILE__L1}' for the loop over 'p' inside the 'kernel_seidel_2d' function\n\n\n #pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int p;\n  int q;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 32; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (p = 1; p < 120 - 1; p++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (q = 1; q < 120 - 1; q++) {\n        A[p][q] = (A[p][q - 1] + A[p][q + 1] + A[p - 1][q] + A[p + 1][q] ) / 4.0;\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (p = 1; p < 120 - 1; p++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (q = 1; q < 120 - 1; q++) {\n        A[p][q] = (A[p][q - 1] + A[p][q + 1] + A[p - 1][q] + A[p + 1][q] ) / 4.0;\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes in C, you should use the following natural language instructions for the #pragma values:\n\n1. Enable automatic pipelining for the loop: '#pragma ACCEL PIPELINE auto{flatten}'\n2. Specify the tiling factor automatically for the loop: '#pragma ACCEL TILE FACTOR=auto{1}'\n3. Set the parallelization factor automatically for the loop: '#pragma ACCEL PARALLEL FACTOR=auto{2}'\n4. Set the parallelization factor automatically for the inner loop: '#pragma ACCEL PARALLEL FACTOR=auto{6}' (inside the outer loop)\n5. Set the parallelization factor automatically for the inner loop: '#pragma ACCEL PARALLEL FACTOR=auto{1}' (inside the outer loop)\n\nBy following these instructions, you can effectively incorporate hardware acceleration into the C codes using the specified HLS #pragma values.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "", "1": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes in C, follow these natural language instructions:\n- Mark the following function as a hardware kernel for acceleration: `#pragma ACCEL kernel`\n- Don't automatically pipeline any of the loops: `#pragma ACCEL PIPELINE \"off\"`\n- Process each loop in its original, full form without breaking it into smaller chunks: `#pragma ACCEL TILE FACTOR=1`\n- Run the iterations of each loop one after the other, not in parallel: `#pragma ACCEL PARALLEL FACTOR=1`", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _row = i * 240 + j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 2*(j + 1) - 1 - 0;\n        int _in_i = 2*(i + 1) - 1 - 0;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL device`\nlong long kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[40][50],double A[40][60],double B[60][50],double F[50][70],double C[50][80],double D[80][70],double G[40][70])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* E := A*B */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      E[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 60; ++k) {\n        E[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n/* F := C*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 50; i++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      F[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n      for (k = 0; k < 80; ++k) {\n        F[i][j] += C[i][k] * D[k][j];\n      }\n    }\n  }\n/* G := E*F */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      G[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 50; ++k) {\n        G[i][j] += E[i][k] * F[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Process the loops with automatic pipelining and tiling. Also, use automatic flattening for the innermost loop to maximize parallelism. Treat the function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{2}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 0 + 1L * (- 1L) + ((int ) j);\n        int _in_i = 0 + 1L * (- 1L) + ((int ) i);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 0 + 1L * (- 1L) + (j + 0L);\n        int _in_i = 0 + 1L * (- 1L) + (i + 0L);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}"}}
{"input": "'Automatically pipeline the loops' \nfor '#pragma ACCEL PIPELINE auto{}'\n\n'Use automatic tiling factor for the loop' \nfor '#pragma ACCEL TILE FACTOR=auto{1}'\n\n'Automatically parallelize the loop with maximum factor of 2' \nfor '#pragma ACCEL PARALLEL FACTOR=auto{2}'\n\n'Automatically parallelize the inner loop with factor 8'\nfor 'pragma ACCEL PARALLEL FACTOR=auto{8}'\n\n'Automatically parallelize the inner loop with factor 6'\nfor 'pragma ACCEL PARALLEL FACTOR=auto{6}'\n\n'Treat the following function as a hardware kernel for acceleration' \nfor '#pragma ACCEL kernel'", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "void kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "void kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{8}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]);\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "void kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes, use the following natural language instructions:\n\n\"Designate the following function as a hardware kernel for acceleration\"\n\n\"Automatically pipeline this loop, flattening the loop hierarchy\"\n\n\"Break this loop into smaller chunks with a factor of 8 for better acceleration\"\n\n\"Run the iterations of this loop in parallel, with a factor of 2\"\n\n\"Run the iterations of this inner loop in parallel, with a factor of 8\"\n\n\"Run the iterations of this loop one after the other, not in parallel\"", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (j = 0; j < 70; j++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (k = 0; k < 80; ++k) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_up = i + 1;\n        int j_up = j + 1;\n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7_0}\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_up][j] - ex[i][j]) - 0.7 * (ey[i][j_up] - ey[i][j]);\n      }\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes in C, you should use the following concise but comprehensive natural language instruction:\n\n\"Designate the following function as a hardware kernel for acceleration, pipeline the loop automatically, set the tile factor to 1 automatically, and parallelize the loops with factors of 2, 8, and 12 automatically.\"\n\nThis instruction encompasses the specific #pragma values and their configurations needed to generate the provided HLS codes in C.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 2 * j;\n        int _in_i = 2 * i;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][_in_j + 1] - ex[i][_in_j] + ey[i][_in_i + 1] - ey[i][_in_i]);\n      }\n    }\n  }\n}"}}
{"input": "Apply full pipeline off and tile factor of 1 to the outer and inner loops of the 'kernel_doitgen' function.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{}\n      \n#pragma ACCEL TILE FACTOR=auto{2}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][24])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = ((double )(r * q * p));\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    for (q = 0; q < 24; q++) {\n      C4[r][q] = 0.0;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    for (p = 0; p < 30; p++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n      for (s = 0; s < 20; s++) {\n        for (q = 0; q < 24; q++) {\n          C4[p][q] += A[r][s][p] * A[r][s][q];\n        }\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][25])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        double sum = ((double )0);\n#pragma ACCEL PARALLEL reduction=sum FACTOR=auto{__PARA__L3}\n\tfor (s = 0; s < 25; s++) {\n          sum += A[s][q][p] * C4[s][r];\n        }\n\tA[r][q][p] = sum;\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][24])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = ((double )(r * q * p));\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    for (q = 0; q < 24; q++) {\n      C4[r][q] = 0.0;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    for (p = 0; p < 30; p++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L5}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L5}\n      for (q = 0; q < 24; q++) {\n        for (r = 0; r < 25; r++) {\n          C4[p][q] += A[r][q][p];\n        }\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Process the loops with automatic pipelining and tiling with a factor of 1, and flatten the inner loop with a tiling factor of 4. Treat the function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{4}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 240;\n        int _in_i = 200;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}"}}
{"input": "\"Perform loop pipelining and do not automatically parallelize the loops; tile the loops with a factor of 1 for r, q, and p loops; and treat the function as a hardware kernel for acceleration.\"", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{4}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "inline void kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_0}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{off_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1_1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_1}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1_1_0}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1_2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_2}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1_2_0}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1_3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1_3}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1_3_0}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _row = i * 240 + j;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "inline void kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}"}}
{"input": "1. Ensure that the loop is automatically pipelined: `#pragma ACCEL PIPELINE auto{flatten}`\n\n2. Break the loop into smaller chunks with automatic tile factor calculation: `#pragma ACCEL TILE FACTOR=auto{1}`\n\n3. Parallelize the loop with automatic factor calculation: `#pragma ACCEL PARALLEL FACTOR=auto{3}`\n\n4. Run the iterations of this loop one after the other, not in parallel: `#pragma ACCEL PARALLEL FACTOR=auto{1}`\n\nEnsure that the following function is treated as a hardware kernel for acceleration: `#pragma ACCEL kernel`", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Process the loops with tiling, automatically determining the factor for tiling. Pipeline the outer loop and the innermost loops, with automatic determination of pipeline scheduling. Use flatten pipeline for the innermost loop to optimize for vectorization. This function is a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L8}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Process the loops in this function in parallel and pipeline the innermost loop. Use auto scheduling for both tiling and pipelining.\nUse \"#pragma ACCEL PIPELINE auto{}\" for pipelining,\nand \"#pragma ACCEL TILE FACTOR=auto{8}\" for the outer loop,\n\"#pragma ACCEL TILE FACTOR=auto{1}\" for the middle loop,\nand \"#pragma ACCEL TILE FACTOR=auto{1}\" for the innermost loop.\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{8}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L6}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L6}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L8}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L8}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L8}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L9}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{16}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}"}}
{"input": "Process the loops in their original, full form without breaking them into smaller chunks, and do not automatically pipeline the loops. Treat the following function as a hardware kernel for acceleration.\n```c\n#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr, int nq, int np, double A[25][20][30], double C4[30][30], double sum[30]) {\n  int r;\n  int q;\n  int p;\n  int s;\n  \n  #pragma ACCEL PIPELINE auto{off}\n  #pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    #pragma ACCEL PIPELINE auto{off}\n    #pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      #pragma ACCEL PIPELINE auto{off}\n      #pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n}\n```", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes in C:\n1. Mark the following function as a hardware kernel for acceleration: `#pragma ACCEL kernel`\n2. Don't automatically pipeline the outer loop: `#pragma ACCEL PIPELINE \"off\"`\n3. Process the outer loop in its original, full form without breaking it into smaller chunks: `#pragma ACCEL TILE FACTOR=1`\n4. Run the iterations of the outer loop one after the other, not in parallel: `#pragma ACCEL PARALLEL FACTOR=1`", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "5. Don't automatically parallelize the inner loop: `#pragma ACCEL PIPELINE auto{__PIPE__L3} FACTOR=auto{__FACTOR__L3} {__PARA__L3}`\n6. Don't automatically parallelize the parallelize for loop: `#pragma ACCEL PIPELINE auto{__PIPE__L2} FACTOR=auto{__FACTOR__L2} {__PARA__L2}`\n7. Don't automatically parallelize the parallelize for loop: `#pragma ACCEL PIPELINE auto{__PIPE__L1} FACTOR=auto{__FACTOR__L1} {__PARA__L1}`\n//#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_up = i + 1;\n        int j_up = j + 1;\n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7_0}\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_up][j] - ex[i][j]) - 0.7 * (ey[i][j_up] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "5. Do not automatically flatten the inner loop: `#pragma ACCEL PIPELINE auto{off}`\n6. Do not automatically unroll the inner loop: `#pragma ACCEL PIPELINE auto{off}`\n7. Do not partition the inner loop: `#pragma ACCEL PIPELINE auto{__PIPE__L2}`\n8. Do not automatically parallelize the inner loop: `#pragma ACCEL PARALLEL FACTOR=auto{1}`\n  \n#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "5. Mark the following loop as a parallelized one: \n   \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n   \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n   for (j = 16; j < 40; j++) {\n      e = b[j] - sum;\n      d = e * f;\n      c = g * d;\n      h = a[j] + c;\n      b[j] = b[j] + e;\n      a[j - 16] = a[j - 16] + f * d;\n      a[j] = h;\n      sum = a[j];\n   }"}}
{"input": "Process the loops with automatic pipeline optimization, and keep the original loop structure without breaking it into smaller chunks.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 0 + 1L * 2L * 7L;\n        int _in_i = 0 + 1L * 2L * 7L;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}"}}
{"input": "To optimize the following C code for hardware acceleration, use the following comprehensive but concise natural language instructions for the specific #pragma values:\n\n1. Enable automatic pipeline optimization for loops: Use '#pragma ACCEL PIPELINE auto{flatten}' to automatically optimize loop pipelining.\n\n2. Keep the original loop structure intact without breaking it into smaller chunks: Use '#pragma ACCEL TILE FACTOR=auto{1}' to maintain the original loop structure.\n\n3. Run loop iterations in parallel, with a factor of 3: Use '#pragma ACCEL PARALLEL FACTOR=auto{3}' to parallelize the loop iterations with a factor of 3.\n\n4. Treat the following function as a hardware kernel for acceleration: Use '#pragma ACCEL kernel' to specify the function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{20}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = 2L * (i / 240.0);\n        int j_col = 2L * (j / 240.0);\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}"}}
{"input": "Process the following function as a hardware kernel for acceleration.\n\nProcess the loop without automatic pipelining.\n\nBreak the loop into smaller chunks of size 1 for tiling.\n\nRun the iterations of the loop in parallel, dividing into 2 parallel tasks for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_heat_3d(int tsteps,int n,double A[60][60],double B[60][60])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 1; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    for (i = 1; i < 59; i++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n      for (j = 1; j < 59; j++) {\n        A[i][j] = 0.2 * (A[i - 1][j] + A[i + 1][j] + A[i][j - 1] + A[i][j + 1] + A[i][j]) + 0.6 * A[i][j];\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    for (i = 1; i < 59; i++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n      for (j = 1; j < 59; j++) {\n        B[i][j] = 0.2 * (B[i - 1][j] + B[i + 1][j] + B[i][j - 1] + B[i][j + 1] + B[i][j]) + 0.6 * B[i][j];\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "sum = 0.0;\n  float tmp = 0.0;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 4000; t++) {\n    \n#pragma ACCEL PARALLEL reduction=sum FACTOR=auto{1}\n    for (i = 0; i < 200; i++) {\n      tmp = data[t * 200 + i];\n      sum = sum + tmp;\n    }\n  }\n//  printf(\"sum: %f\\n\",sum);\n\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_bicg(int m,int n,double A[410][390],double s[390],double q[410],double p[390],double r[410])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 390; i++) {\n    s[i] = ((double )0);\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (i = 0; i < 410; i++) {\n    q[i] = 0.0;\n    p[i] = 0.0;\n    r[i] = 0.0;\n    for (j = 0; j < 390; j++) {\n      s[j] += r[i] * A[i * 390 + j];\n      q[i] += A[i * 390 + j] * A[i * 390 + j];\n      p[i] += A[i * 390 + j] * j;\n    }\n  }\n}"}}
{"input": "Process the loop in its original, full form without breaking it into smaller chunks. \n\nDon't automatically pipeline this loop.\n\nRun the iterations of this loop one after the other, not in parallel.\n\nTreat the following function as a hardware kernel for acceleration.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//SIDE = 'L'\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{6}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To generate the given HLS codes written in C, use the following natural language instruction:\n\n\"For the function `kernel_doitgen`, treat it as a hardware kernel for acceleration. Then, automatically pipeline the loops, and apply tiling factor 4 for the outermost loop and tiling factor 1 for the inner loops. Additionally, use flattening for the innermost loop to pipeline it.\"", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{flatten}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{flatten}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{off}\n      for (s = 0; s < 30; s++) {\n        sum[s] = 0.0;\n      }\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n      for (p = 0; p < 25; p++) {\n        \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n        for (s = 0; s < 30; s++) {\n          sum[s] += A[p][q][s] * A[r][q][s];\n        }\n      }\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n      for (s = 0; s < 30; s++) {\n        C4[r][s] = sum[s];\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n      \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n      for (p = 0; p < 30; p++) {\n        double sum_tmp = 0.0;\n#pragma ACCEL PARALLEL reduction=sum_tmp FACTOR=auto{__PARA__L4}\n\tfor (s = 0; s < 30; s++) {\n          sum_tmp += A[r][q][s] * C4[s][p];\n        }\n\tsum[p] = sum_tmp;\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int tsteps,int n,double A[120][120],double C4[120][120],double sum[120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{4}\n  for (t = 0; t <= 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (i = 0; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL reduction=sum FACTOR=auto{__PARA__L2}\n      for (j = 0; j <= 118; j++) {\n        if (i == j) {\n          sum[i] = 0.0;\n        }\n        else {\n          double _tmp_tmp = A[i][j];\n          sum[i] += _tmp_tmp * C4[j][t];\n        }\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    for (i = 0; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n      for (j = 0; j <= 118; j++) {\n        double _tmp_sum = sum[j];\n        A[i][j] = A[i][j] + _tmp_sum;\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Process the following function as a hardware kernel for acceleration. Automatically pipeline the outer loop. Use an automatic tile factor for the loop, and parallelize the loop with a factor of 4. Within the outer loop, parallelize the inner loops with a factor of 8 and 1 respectively.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_2d(int tsteps,int n,double A[90][90],double B[90][90])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{__PIPE__L0}\n  \n#pragma ACCEL TILE FACTOR=auto{__TILE__L0}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 39; t++) {\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L1}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n      for (j = 1; j < 89; j++) {\n        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 89; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n      for (j = 1; j < 89; j++) {\n        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Process the loops in their original, full form without breaking them into smaller chunks and automatically pipeline each loop. Also, treat the following function as a hardware kernel for acceleration.\n", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{flatten}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_gemm(int ni,int nj,int nk,double alpha,double beta,double C[60][70],double A[60][80],double B[80][70])\n{\n  int i;\n  int j;\n  int k;\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 60; i++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 70; j++) {\n      C[i][j] *= beta;\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n    for (k = 0; k < 80; k++) {\n      \n#pragma ACCEL PARALLEL reduction=C FACTOR=auto{__PARA__L3}\n      for (j = 0; j < 70; j++) {\n        C[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{64}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int i_col = -1*i;\n        int j_col = j + 1;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i_col][j] - ex[i][j_col]) - 0.7 * (ey[i][j_col] - ey[i_col][j]);\n      }\n    }\n  }\n}"}}
{"input": "To generate the given HLS codes in C:\nSpecify the following pragma values for the related loops and functions:\n- Use the '#pragma ACCEL kernel' for the function 'kernel_jacobi_1d'\n- Implement automatic pipeline for the outer loops using '#pragma ACCEL PIPELINE auto{}'\n- Set the tile factor to 'auto{1}' for loop blocking using '#pragma ACCEL TILE FACTOR=auto{1}'\n- Apply automatic parallelization with a factor of 'auto{2}' for the outer loop using '#pragma ACCEL PARALLEL FACTOR=auto{2}'\n- Apply automatic parallelization with a factor of 'auto{30}' and 'auto{12}' for the inner loops using '#pragma ACCEL PARALLEL FACTOR=auto{30}' and '#pragma ACCEL PARALLEL FACTOR=auto{12}' respectively", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L0}'\n \n#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[200],double B[200])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{30}\n    for (i = 1; i < 200 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{12}\n    for (i = 1; i < 200 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "To optimize the HLS code:\n\n\"Apply automatic pipeline directives to the loop\"\n```c\n#pragma ACCEL PIPELINE auto\n```\n\n\"Automatically determine the tiling factor for the loop\"\n```c\n#pragma ACCEL TILE FACTOR=auto{1}\n```\n\n\"Automatically determine the parallelization factor for the loop, allowing up to 3 parallel instances\"\n```c\n#pragma ACCEL PARALLEL FACTOR=auto{3}\n```\n\n\"Automatically determine the parallelization factor for the inner loop, allowing up to 10 parallel instances\"\n```c\n#pragma ACCEL PARALLEL FACTOR=auto{10}\n```\n\n\"Automatically determine the parallelization factor for the inner loop, allowing up to 32 parallel instances\"\n```c\n#pragma ACCEL PARALLEL FACTOR=auto{32}\n```", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{32}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{3}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{10}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        int _in_j = 2 * j;\n        int _in_i = 2 * i;\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][_in_j + 1] - ex[i][_in_j] + ey[ _in_i + 1][j] - ey[ _in_i][j]);\n      }\n    }\n  }\n}", "2": ""}}
{"input": "To generate the given HLS codes in C:\n1. Use '#pragma ACCEL kernel' to designate the function as a hardware kernel for acceleration.\n2. Use '#pragma ACCEL PIPELINE auto{off}' to disable automatic pipelining for the loop.\n3. Use '#pragma ACCEL TILE FACTOR=auto{1}' to process the loop in its original, full form without breaking it into smaller chunks.\n4. Use '#pragma ACCEL PARALLEL FACTOR=auto{4}' to run the iterations of the loop in parallel with a factor of 4.\n5. Use '#pragma ACCEL PARALLEL FACTOR=auto{1}' to run the iterations of the inner loops one after the other, not in parallel.", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < ny; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < ny; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < nx; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < ny; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < nx - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < ny - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[200][240],double ey[200][240],double hz[200][240],double _fict_[100])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (t = 0; t < 100; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 240; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 240; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 200; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 240; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 200 - 1; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 240 - 1; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction = tmp FACTOR=auto{70}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{4}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction = D FACTOR=auto{50}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}"}}
{"input": "Use the following natural language instruction to generate the given HLS codes in C:\n\"Convert the following function into a hardware kernel for acceleration and use specific pragma directives to control loop optimization: turn off automatic pipeline, set the tiling factor to 1, and activate parallelization with a factor of 8 for the outer loop and 1 for the inner loops.\"", "output": "#pragma ACCEL kernel\n\nvoid kernel_jacobi_1d(int tsteps,int n,double A[120],double B[120])\n{\n  int t;\n  int i;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);\n    }\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i < 120 - 1; i++) {\n      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8_0}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[t];\n    }\n    \n#pragma ACCEL PIPELINE auto{off_1}\n    \n#pragma ACCEL TILE FACTOR=auto{1_1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8_1}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8_1_0}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_2}\n    \n#pragma ACCEL TILE FACTOR=auto{1_2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8_2}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8_2_0}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{off_3}\n    \n#pragma ACCEL TILE FACTOR=auto{1_3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8_3}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{8_3_0}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n//#pragma endscop\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction=D FACTOR=auto{16}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_gemver(int n,double alpha,double beta,double A[120][120],double u1[120],double v1[120],double u2[120],double v2[120],double w[120],double x[120],double y[120],double z[120])\n{\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 120; i++) {\n    x[i] = 0.0;\n    y[i] = 0.0;\n    z[i] = 0.0;\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{8}\n  for (i = 0; i < 120; i++) {\n    double tmp1 = 0.0;\n    double tmp2 = 0.0;\n    double uu = 0.0;\n    double vv = 0.0;\n    double ww = 0.0;\n    double xx = 0.0;\n    double yy = 0.0;\n    double zz = 0.0;\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 120; j++) {\n      tmp1 = A[i][j] * u1[j];\n      tmp2 = A[i][j] * v1[j];\n      uu += A[i][j] * u1[j] * v1[j];\n      vv += A[i][j] * u1[j] * v1[j];\n      ww += A[i][j] * v1[j] * v1[j];\n      xx += A[i][j] * x[j];\n      yy += A[i][j] * y[j];\n      zz += A[i][j] * z[j];\n    }\n    x[i] = alpha * ((x[i]) + (((-1.0) * yy) + tmp1)) + ((1.0) * zz);\n    y[i] = alpha * ((y[i]) + (xx + tmp2 + uu)) + beta * ((y[i]) + (zz));\n    z[i] = alpha * (zz + vv) + beta * (z[i]);\n  }\n}"}}
{"input": "Process the outermost loops in their full form, without breaking them into smaller chunks, and then run the iterations of these loops one after the other, not in parallel. For the innermost loops, automatically pipeline them and process them in their original, full form without breaking them into smaller chunks.", "output": "#pragma ACCEL kernel\n\nvoid kernel_doitgen(int nr,int nq,int np,double A[25][20][30],double C4[30][30],double sum[30])\n{\n  int r;\n  int q;\n  int p;\n  int s;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  for (r = 0; r < 25; r++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    for (q = 0; q < 20; q++) {\n      \n#pragma ACCEL PIPELINE auto{}\n      \n#pragma ACCEL TILE FACTOR=auto{1}\n      for (p = 0; p < 30; p++) {\n        sum[p] = 0.0;\n        for (s = 0; s < 30; s++) {\n          sum[p] += A[r][q][s] * C4[s][p];\n        }\n      }\n      for (p = 0; p < 30; p++) {\n        A[r][q][p] = sum[p];\n      }\n    }\n  }\n//#pragma endscop\n}\n", "predicted": {"0": "#pragma ACCEL kernel\n\nvoid kernel_fdtd_2d(int tmax,int nx,int ny,double ex[60][80],double ey[60][80],double hz[60][80],double _fict_[40])\n{\n  int t;\n  int i;\n  int j;\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (t = 0; t < 40; t++) {\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 80; j++) {\n      ey[0][j] = _fict_[j];\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L2}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L2}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{60}\n    for (i = 1; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L5}\n      for (j = 0; j < 80; j++) {\n        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L3}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L3}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L3}\n    for (i = 0; i < 60; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L6}\n      for (j = 1; j < 80; j++) {\n        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n      }\n    }\n    \n#pragma ACCEL PIPELINE auto{__PIPE__L4}\n    \n#pragma ACCEL TILE FACTOR=auto{__TILE__L4}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L4}\n    for (i = 0; i < 59; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L7}\n      for (j = 0; j < 79; j++) {\n        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n      }\n    }\n  }\n}", "1": "#pragma ACCEL kernel\n\nvoid kernel_seidel_2d(int tsteps,int n,double A[120][120])\n{\n  int t;\n  int i;\n  int j;\n//#pragma scop\n  \n#pragma ACCEL PIPELINE auto{}\n  \n#pragma ACCEL TILE FACTOR=auto{2}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n  for (t = 0; t < 30; t++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (i = 1; i <= 118; i++) {\n      \n#pragma ACCEL PARALLEL FACTOR=auto{__PARA__L2}\n      for (j = 1; j <= 118; j++) {\n        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;\n      }\n    }\n  }\n//#pragma endscop\n}", "2": "#pragma ACCEL kernel\n\nvoid kernel_2mm(int ni,int nj,int nk,int nl,double alpha,double beta,double tmp[40][50],double A[40][70],double B[70][50],double C[50][80],double D[40][80])\n{\n  int i;\n  int j;\n  int k;\n//#pragma scop\n/* D := alpha*A*B*C + beta*D */\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n    for (j = 0; j < 50; j++) {\n      tmp[i][j] = 0.0;\n      \n#pragma ACCEL PARALLEL reduction=tmp FACTOR=auto{1}\n      for (k = 0; k < 70; ++k) {\n        tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n    }\n  }\n  \n#pragma ACCEL PIPELINE auto{off}\n  \n#pragma ACCEL TILE FACTOR=auto{1}\n  \n#pragma ACCEL PARALLEL FACTOR=auto{1}\n  for (i = 0; i < 40; i++) {\n    \n#pragma ACCEL PIPELINE auto{off}\n    \n#pragma ACCEL TILE FACTOR=auto{1}\n    \n#pragma ACCEL PARALLEL FACTOR=auto{2}\n    for (j = 0; j < 80; j++) {\n      D[i][j] *= beta;\n      \n#pragma ACCEL PARALLEL reduction=D FACTOR=auto{32}\n      for (k = 0; k < 50; ++k) {\n        D[i][j] += tmp[i][k] * C[k][j];\n      }\n    }\n  }\n//#pragma endscop\n}"}}
